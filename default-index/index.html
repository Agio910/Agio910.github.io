<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog of AgioPan">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Blog of AgioPan">
<meta property="og:description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="AgioPan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog of AgioPan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of AgioPan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（6）- 递归、归并排序与归并分治</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-06 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-06T08:42:46+08:00">2025-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-07 10:09:27" itemprop="dateModified" datetime="2025-08-07T10:09:27+08:00">2025-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a>  </p>
<p>记录的是class020→class022，包括了递归的本质理解、Master公式的应用、归并排序的递归与非递归实现，以及归并分治思想在解决小和问题和翻转对问题中的应用。</p>
<h1 id="020【必备】递归和Master公式"><a href="#020【必备】递归和Master公式" class="headerlink" title="020【必备】递归和Master公式"></a>020【必备】递归和Master公式</h1><h2 id="递归的本质理解"><a href="#递归的本质理解" class="headerlink" title="递归的本质理解"></a>递归的本质理解</h2><h3 id="思想层面的递归"><a href="#思想层面的递归" class="headerlink" title="思想层面的递归"></a>思想层面的递归</h3><p>递归不是玄学，它是一种**”大事化小”**的思维方式。对于新手来说，<strong>画调用图</strong>是理解递归的关键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;给定一个数组，在arr[l...r]范围上，返回最大值&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> f(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arr, l, r</span>):</span><br><span class="line">    <span class="comment"># arr[l...r] 范围上的最大值</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="comment"># 递归基：当左右下标相等时，区间只有一个数，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[l]</span><br><span class="line">    m = (l + r) // <span class="number">2</span>  <span class="comment"># 找到中点</span></span><br><span class="line">    lmax = f(arr, l, m)        <span class="comment"># 递归求左半部分最大值</span></span><br><span class="line">    rmax = f(arr, m + <span class="number">1</span>, r)    <span class="comment"># 递归求右半部分最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(lmax, rmax)     <span class="comment"># 返回左右部分的最大值</span></span><br></pre></td></tr></table></figure>

<p><strong>递归的三个关键点</strong>：</p>
<ol>
<li><strong>明确递归要干什么</strong>：这里是”返回 arr[l…r] 的最大值”</li>
<li><strong>找递归的终止条件</strong>：这里是”l &#x3D;&#x3D; r”，即区间只有一个数  </li>
<li><strong>思考如何缩小规模</strong>：这里是分别递归处理左区间和右区间</li>
</ol>
<h3 id="实际层面的递归"><a href="#实际层面的递归" class="headerlink" title="实际层面的递归"></a>实际层面的递归</h3><p>递归底层利用<strong>系统栈</strong>来实现：</p>
<ul>
<li>当函数调用发生时，系统会将函数的状态（参数、局部变量、返回地址）压入栈中</li>
<li>当函数返回时，系统从栈中弹出状态，恢复到调用点继续执行</li>
<li>这个过程是<strong>可视化的</strong>，所以所有递归函数都可以改成非递归</li>
</ul>
<p><strong>递归改非递归的必要性</strong>：</p>
<ul>
<li><strong>工程实践</strong>：几乎一定要改，除非确定递归深度不会太大</li>
<li><strong>算法竞赛</strong>：能通过就不改，时间紧迫时优先保证正确性</li>
</ul>
<p><strong>形象比喻</strong>：</p>
<ul>
<li><strong>迭代</strong>像是擂台赛：一个个来，逐步解决</li>
<li><strong>递归</strong>像是季后赛：分组对战，逐层淘汰<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%AD%A5.png" alt="递归过程分步"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E9%80%92%E5%BD%92%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="递归时的数据结构"></li>
</ul>
<h2 id="Master公式详解"><a href="#Master公式详解" class="headerlink" title="Master公式详解"></a>Master公式详解</h2><p>Master公式用于分析<strong>分治算法</strong>的时间复杂度，适用于所有子问题规模相同的递归。</p>
<h3 id="公式形式"><a href="#公式形式" class="headerlink" title="公式形式"></a>公式形式</h3><p>$$T(n) &#x3D; a \times T(\frac{n}{b}) + O(n^c)$$</p>
<p>其中：</p>
<ul>
<li><strong>a</strong>：子问题被调用的次数</li>
<li><strong>b</strong>：子问题规模（数据量变为原来的1&#x2F;b）  </li>
<li><strong>c</strong>：除去子问题之外的时间复杂度指数</li>
</ul>
<h3 id="判断标准"><a href="#判断标准" class="headerlink" title="判断标准"></a>判断标准</h3><p>设 $\log_b(a) &#x3D; d$，则：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$d &lt; c$</td>
<td>$O(n^c)$</td>
<td>合并工作量占主导</td>
</tr>
<tr>
<td>$d &gt; c$</td>
<td>$O(n^d)$</td>
<td>递归调用占主导</td>
</tr>
<tr>
<td>$d &#x3D; c$</td>
<td>$O(n^c \log n)$</td>
<td>两者平衡</td>
</tr>
</tbody></table>
<h3 id="经典例子分析"><a href="#经典例子分析" class="headerlink" title="经典例子分析"></a>经典例子分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序：T(n) = 2*T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"># a=2, b=2, c=1</span></span><br><span class="line"><span class="comment"># log₂(2) = 1 = c，所以复杂度为 O(n*logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找：T(n) = 1*T(n/2) + O(1)  </span></span><br><span class="line"><span class="comment"># a=1, b=2, c=0</span></span><br><span class="line"><span class="comment"># log₂(1) = 0 = c，所以复杂度为 O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速排序最好情况：T(n) = 2*T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"># 结果同归并排序：O(n*logn)</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>对于 $T(n) &#x3D; 2 \times T(\frac{n}{2}) + O(n \log n)$：</p>
<ul>
<li>这不符合标准Master公式形式，结果是 $O(n \times (\log n)^2)$，需要特殊记忆，证明过程较复杂，这种递归式常见于“分治 + 合并时需要二分&#x2F;复杂统计”的问题，比如“翻转对”、“区间对统计”，主定理告知其复杂度为 $O(n \log^2 n)$</li>
</ul>
<h1 id="021【必备】归并排序"><a href="#021【必备】归并排序" class="headerlink" title="021【必备】归并排序"></a>021【必备】归并排序</h1><h2 id="归并排序原理"><a href="#归并排序原理" class="headerlink" title="归并排序原理"></a>归并排序原理</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li><strong>左部分排好序、右部分排好序</strong></li>
<li><strong>利用merge过程让左右整体有序</strong></li>
<li><strong>merge过程</strong>：谁小拷贝谁，直到左右两部分数字耗尽，拷贝回原数组</li>
</ol>
<h3 id="为什么归并排序比O-n²-排序快？"><a href="#为什么归并排序比O-n²-排序快？" class="headerlink" title="为什么归并排序比O(n²)排序快？"></a>为什么归并排序比O(n²)排序快？</h3><p><strong>比较行为没有浪费！</strong></p>
<p>对比三种原始排序（选择、冒泡、插入）：</p>
<ul>
<li>每次1到N-1次比较只能确定一个位置</li>
<li>大量比较工作被浪费，效率低下</li>
</ul>
<p>归并排序中：</p>
<ul>
<li>每次比较都有意义，用于合并两个有序序列</li>
<li>比较结果被充分利用，没有浪费</li>
<li>系统栈不会太深</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%88%E4%B8%8D%E4%BC%9A%E6%B7%B1.png" alt="归并排序的栈不会深"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%88%E4%B8%8D%E4%BC%9A%E6%B7%B12.png" alt="归并排序的栈不会深2"></p>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN      <span class="comment"># 原数组</span></span><br><span class="line">help_arr = [<span class="number">0</span>] * MAXN <span class="comment"># 辅助数组</span></span><br><span class="line">n = <span class="number">0</span>                 <span class="comment"># 数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort1</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序递归版</span></span><br><span class="line"><span class="string">    T(n) = 2 * T(n/2) + O(n)</span></span><br><span class="line"><span class="string">    根据master公式，时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    空间复杂度O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:  <span class="comment"># 递归终止条件：只剩一个元素</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    mergeSort1(l, m)      <span class="comment"># 递归排序左半部分</span></span><br><span class="line">    mergeSort1(m + <span class="number">1</span>, r)  <span class="comment"># 递归排序右半部分</span></span><br><span class="line">    merge(l, m, r)        <span class="comment"># 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个有序区间 arr[l...m] 和 arr[m+1...r]</span></span><br><span class="line"><span class="string">    时间复杂度O(n)，其中n = r - l + 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = l      <span class="comment"># help数组写指针</span></span><br><span class="line">    a = l      <span class="comment"># 左侧起始指针</span></span><br><span class="line">    b = m + <span class="number">1</span>  <span class="comment"># 右侧起始指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双指针合并过程</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b] </span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 写回原数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[i] = help_arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序非递归版</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)：外层循环O(logn)，内层归并O(n)</span></span><br><span class="line"><span class="string">    空间复杂度O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    step = <span class="number">1</span>  <span class="comment"># 步长初始化为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> step &lt; n:  <span class="comment"># 外层控制步长，共O(logn)次</span></span><br><span class="line">        l = <span class="number">0</span>  <span class="comment"># 每轮从左端开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt; n:  <span class="comment"># 内层处理每一组</span></span><br><span class="line">            m = l + step - <span class="number">1</span>      <span class="comment"># 计算中点</span></span><br><span class="line">            <span class="keyword">if</span> m + <span class="number">1</span> &gt;= n:        <span class="comment"># 右半部分越界，跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            r = <span class="built_in">min</span>(l + (step &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, n - <span class="number">1</span>)  <span class="comment"># 计算右边界</span></span><br><span class="line">            merge(l, m, r)        <span class="comment"># 合并</span></span><br><span class="line">            l = r + <span class="number">1</span>             <span class="comment"># 移动到下一组</span></span><br><span class="line">            </span><br><span class="line">        step &lt;&lt;= <span class="number">1</span>  <span class="comment"># 步长翻倍</span></span><br></pre></td></tr></table></figure>

<h3 id="非递归实现的核心思路"><a href="#非递归实现的核心思路" class="headerlink" title="非递归实现的核心思路"></a>非递归实现的核心思路</h3><ol>
<li><strong>step表示每次要合并的有序段长度</strong>，初始为1（每个元素自己是有序段）</li>
<li><strong>每一轮成对合并</strong>长度为step的有序段，合并成长度为2*step的有序段</li>
<li><strong>下一轮step翻倍</strong>，继续两两合并</li>
<li><strong>重复直到step &gt;&#x3D; n</strong>，整个数组有序</li>
</ol>
<p><strong>过程示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数组: [3, 8, 7, 6, 4, 5, 1, 2]</span><br><span class="line"></span><br><span class="line">step=1: [3,8] [6,7] [4,5] [1,2] → [3,8,6,7,4,5,1,2]</span><br><span class="line">step=2: [3,6,7,8] [1,2,4,5] → [3,6,7,8,1,2,4,5] </span><br><span class="line">step=4: [1,2,3,4,5,6,7,8] → [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure>

<h2 id="merge过程详解"><a href="#merge过程详解" class="headerlink" title="merge过程详解"></a>merge过程详解</h2><h3 id="双指针合并策略"><a href="#双指针合并策略" class="headerlink" title="双指针合并策略"></a>双指针合并策略</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并过程详解：</span></span><br><span class="line"><span class="string">    1. 双指针扫描：a指向左部分，b指向右部分</span></span><br><span class="line"><span class="string">    2. 比较合并：较小值写入help_arr，对应指针右移</span></span><br><span class="line"><span class="string">    3. 剩余处理：一边扫完后，另一边直接复制</span></span><br><span class="line"><span class="string">    4. 写回原数组：完成排序合并</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = l      <span class="comment"># help_arr写入位置</span></span><br><span class="line">    a = l      <span class="comment"># 左部分起点</span></span><br><span class="line">    b = m + <span class="number">1</span>  <span class="comment"># 右部分起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 两两比较，选择较小值</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余元素（必有一边先结束）</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-log-n"><a href="#时间复杂度：O-n-log-n" class="headerlink" title="时间复杂度：O(n log n)"></a>时间复杂度：O(n log n)</h3><ul>
<li><strong>递归层数</strong>：log₂(n)层，每次将问题规模减半</li>
<li><strong>每层工作量</strong>：O(n)，所有元素都要参与一次合并</li>
<li><strong>总复杂度</strong>：O(n) × O(log n) &#x3D; O(n log n)</li>
</ul>
<h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O(n)"></a>空间复杂度：O(n)</h3><ul>
<li><strong>辅助数组</strong>：需要与原数组等长的help_arr</li>
<li><strong>递归栈</strong>：最大深度O(log n)，但主要空间开销是辅助数组</li>
<li><strong>原地归并</strong>：理论上可以做到O(1)空间，但时间复杂度会退化到O(n²)</li>
</ul>
<h1 id="022【必备】归并分治"><a href="#022【必备】归并分治" class="headerlink" title="022【必备】归并分治"></a>022【必备】归并分治</h1><h2 id="归并分治的核心思想"><a href="#归并分治的核心思想" class="headerlink" title="归并分治的核心思想"></a>归并分治的核心思想</h2><p>归并分治是在归并排序基础上的拓展，用来解决更复杂的问题。</p>
<h3 id="应用条件判断"><a href="#应用条件判断" class="headerlink" title="应用条件判断"></a>应用条件判断</h3><p>一个问题能用归并分治解决，需要满足：</p>
<ol>
<li><strong>大范围答案 &#x3D; 左部分答案 + 右部分答案 + 跨越左右产生的答案</strong></li>
<li><strong>计算”跨越左右产生的答案”时，左右各自有序能带来计算便利性</strong></li>
<li><strong>如果以上两点成立，该问题很可能被归并分治解决</strong></li>
</ol>
<p><strong>求解过程</strong>：在归并排序过程中加入统计逻辑，利用左右有序的特性获得计算便利性。</p>
<h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定数组arr，对于每个位置i，求出其左边所有小于等于arr[i]的数的累加和，所有位置的累加和即为数组的”小和”。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组: [1, 3, 5, 2, 4, 6]</span><br><span class="line"></span><br><span class="line">位置0(1): 左边小于等于1的数 → 0</span><br><span class="line">位置1(3): 左边小于等于3的数 → 1  </span><br><span class="line">位置2(5): 左边小于等于5的数 → 1+3 = 4</span><br><span class="line">位置3(2): 左边小于等于2的数 → 1</span><br><span class="line">位置4(4): 左边小于等于4的数 → 1+3+2 = 6</span><br><span class="line">位置5(6): 左边小于等于6的数 → 1+3+5+2+4 = 15</span><br><span class="line"></span><br><span class="line">小和 = 0+1+4+1+6+15 = 27</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class22-%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/%E5%88%86%E6%B2%BB%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8.png" alt="分治指针滑动"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class22-%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%E6%8B%86%E5%88%86%E6%88%90%E5%AD%90%E9%97%AE%E9%A2%98.png" alt="小和问题拆分成子问题"></p>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469">https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469</a></p>
<h3 id="归并分治解法"><a href="#归并分治解法" class="headerlink" title="归并分治解法"></a>归并分治解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">smallSum</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回arr[l...r]范围上小和的累加和，同时让arr[l..r]变有序</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 递归统计左右部分和跨区部分的小和</span></span><br><span class="line">    <span class="keyword">return</span> smallSum(l, m) + smallSum(m + <span class="number">1</span>, r) + merge(l, m, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    统计跨左右产生的小和，同时完成合并</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span>        <span class="comment"># 累计小和</span></span><br><span class="line">    i = l          <span class="comment"># 左侧指针</span></span><br><span class="line">    sum_left = <span class="number">0</span>   <span class="comment"># 累计左侧小于等于当前右侧元素的和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计跨区贡献：对每个右侧元素，统计左侧贡献</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 左侧所有 &lt;= arr[j] 的元素都对arr[j]有贡献</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= m <span class="keyword">and</span> arr[i] &lt;= arr[j]:</span><br><span class="line">            sum_left += arr[i]  <span class="comment"># 累加左侧贡献</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans += sum_left  <span class="comment"># arr[j]的左侧贡献总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常归并过程</span></span><br><span class="line">    i = l</span><br><span class="line">    a = l</span><br><span class="line">    b = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法关键思路"><a href="#算法关键思路" class="headerlink" title="算法关键思路"></a>算法关键思路</h3><p><strong>为什么要在merge过程中统计？</strong></p>
<ol>
<li><strong>左右有序的便利性</strong>：因为左右都有序，可以用双指针线性扫描</li>
<li><strong>避免重复计算</strong>：每个跨区的小和贡献只需要计算一次</li>
<li><strong>时间复杂度优势</strong>：总体保持O(n log n)，而暴力解法是O(n²)</li>
</ol>
<p><strong>核心技巧</strong>：</p>
<ul>
<li>对于右半部分的每个元素arr[j]，左半部分所有 ≤ arr[j] 的元素都会对小和产生贡献</li>
<li>由于左半部分有序，可以用指针i从左向右扫描，累加贡献值</li>
<li>指针i只会前进不会后退，总的扫描时间为O(n)</li>
</ul>
<h2 id="翻转对问题"><a href="#翻转对问题" class="headerlink" title="翻转对问题"></a>翻转对问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定数组nums，如果i&lt;j且nums[i]&gt;2*nums[j]，我们就将(i,j)称作一个重要翻转对。求数组中翻转对的总数量。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组: [1,3,2,3,1]</span><br><span class="line">翻转对: (1,4)→3&gt;2*1, (3,4)→3&gt;2*1</span><br><span class="line">答案: 2</span><br></pre></td></tr></table></figure>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-pairs/">https://leetcode.cn/problems/reverse-pairs/</a></p>
<h3 id="归并分治解法-1"><a href="#归并分治解法-1" class="headerlink" title="归并分治解法"></a>归并分治解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计翻转对的主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> counts(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counts</span>(<span class="params">arr, l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    统计l...r范围上翻转对的数量，同时让l...r范围变有序</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 递归统计左右两边和跨区部分的翻转对数量</span></span><br><span class="line">    <span class="keyword">return</span> counts(arr, l, m) + counts(arr, m + <span class="number">1</span>, r) + merge(arr, l, m, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计跨区翻转对并完成合并&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 翻转对计数</span></span><br><span class="line">    j = m + <span class="number">1</span>  <span class="comment"># 右边数组起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计跨区翻转对</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, m + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 找到右侧第一个不满足 arr[i] &gt; 2*arr[j] 的位置</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= r <span class="keyword">and</span> arr[i] &gt; <span class="number">2</span> * arr[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当前i能形成的翻转对数量 = j - (m+1)</span></span><br><span class="line">        ans += j - m - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常merge过程（与归并排序相同）</span></span><br><span class="line">    i = l</span><br><span class="line">    a = l</span><br><span class="line">    b = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法关键思路-1"><a href="#算法关键思路-1" class="headerlink" title="算法关键思路"></a>算法关键思路</h3><p><strong>统计策略</strong>：</p>
<ol>
<li><strong>利用左右部分独立有序</strong>：对于左半部分的每个元素arr[i]，在右半部分找到满足arr[i] &gt; 2*arr[j]的所有j</li>
<li><strong>指针单向移动</strong>：左右部分都是有序的，指针j只需要前进，不需要回退  </li>
<li><strong>计数技巧</strong>：当找到第一个不满足条件的j时，说明j前面的所有元素都满足条件</li>
</ol>
<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>每个元素只会被访问一次，总的统计时间：O(n)，符合归并分治的要求</li>
</ul>
<h2 id="归并分治总结"><a href="#归并分治总结" class="headerlink" title="归并分治总结"></a>归并分治总结</h2><h3 id="适用问题特征"><a href="#适用问题特征" class="headerlink" title="适用问题特征"></a>适用问题特征</h3><ol>
<li><strong>可分解性</strong>：问题可以分解为左部分 + 右部分 + 跨区部分</li>
<li><strong>有序性便利</strong>：跨区部分的计算在左右有序时能够优化</li>
<li><strong>线性合并</strong>：跨区计算的时间复杂度为O(n)</li>
</ol>
<h3 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide_conquer</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> base_case</span><br><span class="line">    </span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    left_ans = divide_conquer(l, m)</span><br><span class="line">    right_ans = divide_conquer(m + <span class="number">1</span>, r)</span><br><span class="line">    cross_ans = merge_and_count(l, m, r)  <span class="comment"># 关键：统计跨区答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left_ans + right_ans + cross_ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_and_count</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="comment"># 1. 利用左右有序性，统计跨区答案</span></span><br><span class="line">    cross_count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># ... 统计逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 正常的归并排序merge过程</span></span><br><span class="line">    <span class="comment"># ... 合并逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cross_count</span><br></pre></td></tr></table></figure>

<h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h3><ol>
<li><strong>小和问题</strong>：统计左侧小于等于当前元素的累加和</li>
<li><strong>翻转对问题</strong>：统计满足特定大小关系的数对</li>
<li><strong>最近点对问题</strong>：二维空间中最近两点距离（高难度）</li>
<li><strong>逆序对问题</strong>：统计数组中的逆序对数量</li>
</ol>
<h3 id="与其他算法的关系"><a href="#与其他算法的关系" class="headerlink" title="与其他算法的关系"></a>与其他算法的关系</h3><ul>
<li><strong>线段树</strong>：也可以解决类似问题，但常数因子可能更大</li>
<li><strong>树状数组</strong>：适合在线查询修改，离线场景下归并分治更简洁</li>
<li><strong>分块算法</strong>：另一种分治思想，将在后续课程中介绍</li>
</ul>
<p>归并分治是一种优雅而强大的算法思想，它将复杂问题通过分治和有序性的结合，优雅地降低了时间复杂度。掌握这种思想对于解决许多看似困难的问题都有很大帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（5）- 算法笔试中处理输入和输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-05 08:42:46 / Modified: 16:37:24" itemprop="dateCreated datePublished" datetime="2025-08-05T08:42:46+08:00">2025-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>是class019的内容，本笔记重点介绍Python在算法竞赛和笔试中的高效输入输出处理技巧，包含子矩阵最大累加和问题的完整实现，以及与Java的性能对比分析。</p>
<h1 id="019【必备】算法笔试中处理输入和输出"><a href="#019【必备】算法笔试中处理输入和输出" class="headerlink" title="019【必备】算法笔试中处理输入和输出"></a>019【必备】算法笔试中处理输入和输出</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在算法竞赛和大厂笔试中，输入输出的处理效率往往是程序性能的关键瓶颈。Python虽然在执行速度上不如C++和Java，但通过合理的IO优化技巧，同样可以在大多数场景下取得良好的性能表现。</p>
<h3 id="Python-vs-Java-IO性能对比"><a href="#Python-vs-Java-IO性能对比" class="headerlink" title="Python vs Java IO性能对比"></a>Python vs Java IO性能对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Python</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认IO</strong></td>
<td><code>input()</code>、<code>print()</code> 较慢</td>
<td><code>Scanner</code>、<code>System.out</code> 较慢</td>
</tr>
<tr>
<td><strong>高效IO</strong></td>
<td><code>sys.stdin.read()</code>、批量输出</td>
<td><code>BufferedReader</code>、<code>PrintWriter</code></td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>自动垃圾回收，相对简单</td>
<td>需要考虑静态空间分配</td>
</tr>
<tr>
<td><strong>大整数</strong></td>
<td>原生支持任意精度</td>
<td>需要<code>BigInteger</code>类</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>语法简洁，容易上手</td>
<td>类型安全，但代码较长</td>
</tr>
</tbody></table>
<h2 id="Python编程风格选择"><a href="#Python编程风格选择" class="headerlink" title="Python编程风格选择"></a>Python编程风格选择</h2><h3 id="填函数风格（OJ平台推荐）"><a href="#填函数风格（OJ平台推荐）" class="headerlink" title="填函数风格（OJ平台推荐）"></a>填函数风格（OJ平台推荐）</h3><p>适用于LeetCode、牛客网等在线判题平台，平台会自动处理输入输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfSubMatrix</span>(<span class="params">self, mat, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        只需实现核心算法逻辑</span></span><br><span class="line"><span class="string">        平台自动调用并验证结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.maxSumSubmatrix(mat, n, n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubmatrix</span>(<span class="params">self, mat, rows, cols</span>):</span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            arr = [<span class="number">0</span>] * cols  <span class="comment"># 辅助数组</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, rows):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                    arr[k] += mat[j][k]</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, <span class="variable language_">self</span>.maxSumSubarray(arr))</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubarray</span>(<span class="params">self, arr</span>):</span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            cur += num</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, cur)</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, <span class="number">0</span>)  <span class="comment"># 负数时重置为0</span></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<h3 id="ACM风格（竞赛笔试推荐）"><a href="#ACM风格（竞赛笔试推荐）" class="headerlink" title="ACM风格（竞赛笔试推荐）"></a>ACM风格（竞赛笔试推荐）</h3><p>适用于ACM竞赛、大厂笔试等需要自己处理输入输出的场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    完整的输入输出处理</span></span><br><span class="line"><span class="string">    需要自己解析数据格式</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines = sys.stdin.read().split()</span><br><span class="line">    ptr = <span class="number">0</span></span><br><span class="line">    output = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ptr &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">        n = <span class="built_in">int</span>(lines[ptr])</span><br><span class="line">        ptr += <span class="number">1</span></span><br><span class="line">        m = <span class="built_in">int</span>(lines[ptr])</span><br><span class="line">        ptr += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建矩阵</span></span><br><span class="line">        mat = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            row = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                row.append(<span class="built_in">int</span>(lines[ptr]))</span><br><span class="line">                ptr += <span class="number">1</span></span><br><span class="line">            mat.append(row)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算结果</span></span><br><span class="line">        result = maxSumSubmatrix(mat, n, m)</span><br><span class="line">        output.append(<span class="built_in">str</span>(result))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量输出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(output))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="高效输入输出技巧"><a href="#高效输入输出技巧" class="headerlink" title="高效输入输出技巧"></a>高效输入输出技巧</h2><h3 id="输入优化策略"><a href="#输入优化策略" class="headerlink" title="输入优化策略"></a>输入优化策略</h3><h4 id="推荐：一次性读取大数据"><a href="#推荐：一次性读取大数据" class="headerlink" title="推荐：一次性读取大数据"></a>推荐：一次性读取大数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最高效：适用于已知数据量的场景</span></span><br><span class="line">lines = sys.stdin.read().split()</span><br><span class="line">ptr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐个解析数据</span></span><br><span class="line"><span class="keyword">while</span> ptr &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">    n = <span class="built_in">int</span>(lines[ptr])</span><br><span class="line">    ptr += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 处理数据...</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li>IO次数最少，效率最高</li>
<li>相当于Java的<code>BufferedReader</code>一次性读取</li>
<li>适合大数据量场景</li>
</ul>
<h4 id="可选：按行读取"><a href="#可选：按行读取" class="headerlink" title="可选：按行读取"></a>可选：按行读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用：需要按行处理不同格式数据</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    parts = line.strip().split()</span><br><span class="line">    total = <span class="built_in">sum</span>(<span class="built_in">int</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> parts)</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>每行数据格式不同</li>
<li>无法提前确定数据量</li>
<li>相当于Java的逐行<code>readLine()</code></li>
</ul>
<h4 id="不推荐：频繁调用input"><a href="#不推荐：频繁调用input" class="headerlink" title="不推荐：频繁调用input()"></a>不推荐：频繁调用input()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 效率低：类似Java的Scanner</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 大数据时很慢</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 每次都要系统调用</span></span><br></pre></td></tr></table></figure>

<h3 id="输出优化策略"><a href="#输出优化策略" class="headerlink" title="输出优化策略"></a>输出优化策略</h3><h4 id="推荐：批量输出"><a href="#推荐：批量输出" class="headerlink" title="推荐：批量输出"></a>推荐：批量输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 收集所有结果，最后一次性输出</span></span><br><span class="line">output = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    result = solve(data[i])</span><br><span class="line">    output.append(<span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(output))  <span class="comment"># 一次性输出</span></span><br></pre></td></tr></table></figure>

<h4 id="不推荐：频繁print"><a href="#不推荐：频繁print" class="headerlink" title="不推荐：频繁print()"></a>不推荐：频繁print()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次print都会刷新缓冲区，效率低</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">print</span>(solve(data[i]))  <span class="comment"># 大数据时很慢</span></span><br></pre></td></tr></table></figure>

<h3 id="内存优化：静态空间vs动态空间"><a href="#内存优化：静态空间vs动态空间" class="headerlink" title="内存优化：静态空间vs动态空间"></a>内存优化：静态空间vs动态空间</h3><h4 id="推荐：静态空间分配"><a href="#推荐：静态空间分配" class="headerlink" title="推荐：静态空间分配"></a>推荐：静态空间分配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局预分配，避免频繁内存分配</span></span><br><span class="line">MAXN = <span class="number">201</span></span><br><span class="line">MAXM = <span class="number">201</span></span><br><span class="line">mat = [[<span class="number">0</span>] * MAXM <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]  <span class="comment"># 静态矩阵</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXM  <span class="comment"># 静态辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    <span class="comment"># 复用已分配的空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            mat[i][j] = read_next_int()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用前先清空</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        arr[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="不推荐：频繁动态分配"><a href="#不推荐：频繁动态分配" class="headerlink" title="不推荐：频繁动态分配"></a>不推荐：频繁动态分配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="comment"># 每次都重新分配内存</span></span><br><span class="line">    mat = []  <span class="comment"># 动态创建</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        row = []  <span class="comment"># 每行都新建</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            row.append(read_next_int())</span><br><span class="line">        mat.append(row)</span><br></pre></td></tr></table></figure>

<h2 id="子矩阵最大累加和问题详解"><a href="#子矩阵最大累加和问题详解" class="headerlink" title="子矩阵最大累加和问题详解"></a>子矩阵最大累加和问题详解</h2><h3 id="问题描述与算法思路"><a href="#问题描述与算法思路" class="headerlink" title="问题描述与算法思路"></a>问题描述与算法思路</h3><p><strong>问题</strong>：给定包含正数、负数、零的矩阵，求累加和最大的子矩阵。</p>
<p><strong>核心思想</strong>：将二维问题转化为一维最大子数组和问题</p>
<ol>
<li>枚举子矩阵的上下边界（第i行到第j行）</li>
<li>将每列在这个范围内的元素累加，得到一维数组</li>
<li>对一维数组使用Kadane算法求最大子数组和</li>
</ol>
<h3 id="完整实现（填函数风格）"><a href="#完整实现（填函数风格）" class="headerlink" title="完整实现（填函数风格）"></a>完整实现（填函数风格）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_FillFunction</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfSubMatrix</span>(<span class="params">self, mat, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;主方法，求n×n矩阵的最大子矩阵和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.maxSumSubmatrix(mat, n, n)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubmatrix</span>(<span class="params">mat, n, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;求子矩阵的最大累加和&quot;&quot;&quot;</span></span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举上边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            arr = [<span class="number">0</span>] * m  <span class="comment"># 辅助数组，每次重置</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举下边界（从i到n-1）</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="comment"># 将第j行累加到辅助数组</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    arr[k] += mat[j][k]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 求当前辅助数组的最大子数组和</span></span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, Code01_FillFunction.maxSumSubarray(arr, m))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubarray</span>(<span class="params">arr, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Kadane算法求最大子数组和&quot;&quot;&quot;</span></span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            cur += arr[i]</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, cur)</span><br><span class="line">            cur = <span class="number">0</span> <span class="keyword">if</span> cur &lt; <span class="number">0</span> <span class="keyword">else</span> cur  <span class="comment"># 负数时重置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<p><strong>算法复杂度</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n² × m)</li>
<li><strong>空间复杂度</strong>：O(m)</li>
</ul>
<h3 id="ACM风格实现（静态空间优化）"><a href="#ACM风格实现（静态空间优化）" class="headerlink" title="ACM风格实现（静态空间优化）"></a>ACM风格实现（静态空间优化）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态空间分配，避免频繁内存分配</span></span><br><span class="line">MAXN = <span class="number">201</span></span><br><span class="line">MAXM = <span class="number">201</span></span><br><span class="line">mat = [[<span class="number">0</span>] * MAXM <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line">arr = [<span class="number">0</span>] * MAXM</span><br><span class="line">n = m = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    tokens = sys.stdin.read().split()</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    output = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(tokens):</span><br><span class="line">        n = <span class="built_in">int</span>(tokens[idx])</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        m = <span class="built_in">int</span>(tokens[idx])</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 读取矩阵数据到静态空间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                mat[i][j] = <span class="built_in">int</span>(tokens[idx])</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算结果并收集输出</span></span><br><span class="line">        output.append(<span class="built_in">str</span>(maxSumSubmatrix()))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量输出所有结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(output))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxSumSubmatrix</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用静态空间的子矩阵最大和算法&quot;&quot;&quot;</span></span><br><span class="line">    max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 清空辅助数组（复用静态空间）</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            arr[x] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="comment"># 累加第j行到辅助数组</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                arr[k] += mat[j][k]</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, maxSumSubarray())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxSumSubarray</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一维最大子数组和&quot;&quot;&quot;</span></span><br><span class="line">    max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        cur += arr[i]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, cur)</span><br><span class="line">        cur = <span class="number">0</span> <span class="keyword">if</span> cur &lt; <span class="number">0</span> <span class="keyword">else</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以矩阵为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[-90, 48, 78],</span><br><span class="line"> [ 64,-40, 64], </span><br><span class="line"> [-81, -7, 66]]</span><br></pre></td></tr></table></figure>

<p><strong>枚举过程</strong>：</p>
<ol>
<li><strong>i&#x3D;0, j&#x3D;0</strong>（第0行）：arr&#x3D;[-90, 48, 78] → 最大子数组和&#x3D;126</li>
<li><strong>i&#x3D;0, j&#x3D;1</strong>（第0-1行）：arr&#x3D;[-26, 8, 142] → 最大子数组和&#x3D;150  </li>
<li><strong>i&#x3D;0, j&#x3D;2</strong>（第0-2行）：arr&#x3D;[-107, 1, 208] → 最大子数组和&#x3D;209</li>
<li><strong>i&#x3D;1, j&#x3D;1</strong>（第1行）：arr&#x3D;[64, -40, 64] → 最大子数组和&#x3D;88</li>
<li><strong>i&#x3D;1, j&#x3D;2</strong>（第1-2行）：arr&#x3D;[-17, -47, 130] → 最大子数组和&#x3D;130</li>
<li><strong>i&#x3D;2, j&#x3D;2</strong>（第2行）：arr&#x3D;[-81, -7, 66] → 最大子数组和&#x3D;66</li>
</ol>
<p><strong>最终结果</strong>：209（来自第0-2行，第2-2列的子矩阵）</p>
<h2 id="Python高级IO优化"><a href="#Python高级IO优化" class="headerlink" title="Python高级IO优化"></a>Python高级IO优化</h2><h3 id="FastReader快读类"><a href="#FastReader快读类" class="headerlink" title="FastReader快读类"></a>FastReader快读类</h3><p>FastReader 是一个极致追求输入速度的工具，适用于数据量极大的算法竞赛场景。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>极速读取输入，尤其是大量数字（如百万级数据）。</li>
<li>通过 <strong>一次性读取大块数据（8KB）</strong> 到内存，减少系统I&#x2F;O调用次数。</li>
<li>按字节处理并手动解析数字，比标准 input() 或 sys.stdin.readline() 更快。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>缓冲区：用 self.buffer 存储从输入流一次性读取的大块数据。</li>
<li>按字节解析：用 readByte 方法逐字节读取，跳过非数字字符，自己实现整数解析（包括负数）。</li>
<li>高效：只处理数字和符号，省略 split、strip 等高层方法，极致优化输入。</li>
</ul>
<p><strong>典型用法</strong><br>适合极端大数据输入、对时间卡得很紧的OJ平台。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastReader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file=sys.stdin</span>):</span><br><span class="line">        <span class="variable language_">self</span>.file = file</span><br><span class="line">        <span class="variable language_">self</span>.buffer = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;一次性读取8KB数据到缓冲区&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer = <span class="variable language_">self</span>.file.read(<span class="number">8192</span>)</span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readByte</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个字节&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.idx &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.buffer):</span><br><span class="line">            <span class="variable language_">self</span>._read()</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buffer == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        byte = <span class="variable language_">self</span>.buffer[<span class="variable language_">self</span>.idx]</span><br><span class="line">        <span class="variable language_">self</span>.idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(byte)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readInt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;快速读取整数&quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        minus = <span class="literal">False</span></span><br><span class="line">        b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 跳过非数字字符</span></span><br><span class="line">        <span class="keyword">while</span> b != -<span class="number">1</span> <span class="keyword">and</span> (b &lt; <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> b &gt; <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">and</span> b != <span class="built_in">ord</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> b == <span class="built_in">ord</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            minus = <span class="literal">True</span></span><br><span class="line">            b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 读取数字</span></span><br><span class="line">        <span class="keyword">while</span> b != -<span class="number">1</span> <span class="keyword">and</span> (<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) &lt;= b &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>)):</span><br><span class="line">            num = num * <span class="number">10</span> + (b - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -num <span class="keyword">if</span> minus <span class="keyword">else</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readLong</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取长整数（Python中与int相同）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.readInt()</span><br></pre></td></tr></table></figure>

<h3 id="FastWriter快写类"><a href="#FastWriter快写类" class="headerlink" title="FastWriter快写类"></a>FastWriter快写类</h3><p>FastWriter 是一个高效输出工具，适用于需要频繁输出、输出量大的场合。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>减少输出次数：把所有输出内容先缓存在内存里，最后统一输出，减少系统调用。</li>
<li>链式调用和兼容Java风格，用起来很方便。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>缓冲区：所有待输出内容先存入 self.buffer 列表。</li>
<li>批量输出：调用 flush() 时，一次性将所有内容写入输出流。</li>
<li>兼容性：支持 write（写字符串）、writeln&#x2F;println（写一行），用法灵活。</li>
</ul>
<p><strong>典型用法</strong></p>
<p>适合数据量大、频繁输出的算法题&#x2F;竞赛场景，防止 print() 太慢导致超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastWriter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file=sys.stdout</span>):</span><br><span class="line">        <span class="variable language_">self</span>.file = file</span><br><span class="line">        <span class="variable language_">self</span>.buffer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;写入字符串到缓冲区&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer.append(<span class="built_in">str</span>(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># 支持链式调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeln</span>(<span class="params">self, s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;写入一行&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer.append(<span class="built_in">str</span>(s) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">println</span>(<span class="params">self, s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;兼容Java习惯的方法名&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.writeln(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flush</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;刷新缓冲区，实际写入文件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buffer:</span><br><span class="line">            <span class="variable language_">self</span>.file.write(<span class="string">&quot;&quot;</span>.join(<span class="variable language_">self</span>.buffer))</span><br><span class="line">            <span class="variable language_">self</span>.file.flush()</span><br><span class="line">            <span class="variable language_">self</span>.buffer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;关闭写入器&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.flush()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.file != sys.stdout:</span><br><span class="line">            <span class="variable language_">self</span>.file.close()</span><br></pre></td></tr></table></figure>

<h3 id="Kattio类（Python版）"><a href="#Kattio类（Python版）" class="headerlink" title="Kattio类（Python版）"></a>Kattio类（Python版）</h3><p>Kattio 类是一个高效的输入输出（I&#x2F;O）工具类，最初流行于 Java 的竞赛编程圈。它的 Python 版本（如你上面给出的代码）主要是用来简化和加快处理标准输入输出，尤其适合数据量较大、输入格式“特殊”或需要频繁读取单个数据的场景，比如各类算法竞赛、OJ（Online Judge）平台等。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>高效读取输入：普通的 input() 在数据量大时会变慢，Kattio 通过缓冲和一次性读取一行数据，提升了读取效率。</li>
<li>简化输入格式处理：常见的输入格式如多行多列、混合类型（int、float、str）都能方便读取，不用每次都写 split、map 一大堆。</li>
<li>输出简便：带有封装的 println 方法，输出不再需要手动 print(…, file&#x3D;…)。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>维护一个缓冲区（self.buffer），每次读取一整行并分割成单词。</li>
<li>提供 next() 方法按顺序读取下一个字符串，nextInt() 读取下一个整数，nextDouble() 读取下一个浮点数等。</li>
<li>适配输入和输出流（默认为标准输入输出，但也可以重定向到文件），并提供 close 方法在需要时关闭流。</li>
</ul>
<p>参考Java版Kattio的Python实现，处理特殊输入格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kattio</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    高效IO类，适用于特殊格式输入</span></span><br><span class="line"><span class="string">    效率略低于FastReader，但兼容性更好</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_stream=sys.stdin, output_stream=sys.stdout</span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">input</span> = input_stream</span><br><span class="line">        <span class="variable language_">self</span>.output = output_stream</span><br><span class="line">        <span class="variable language_">self</span>.buffer = []</span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fill_buffer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;填充缓冲区&quot;&quot;&quot;</span></span><br><span class="line">        line = <span class="variable language_">self</span>.<span class="built_in">input</span>.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer = line.strip().split()</span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个字符串&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.idx &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.buffer):</span><br><span class="line">            <span class="variable language_">self</span>._fill_buffer()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.buffer:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        result = <span class="variable language_">self</span>.buffer[<span class="variable language_">self</span>.idx]</span><br><span class="line">        <span class="variable language_">self</span>.idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextInt</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个整数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="variable language_">self</span>.<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextLong</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个长整数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="variable language_">self</span>.<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextDouble</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个浮点数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(<span class="variable language_">self</span>.<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">println</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;输出一行&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(s, file=<span class="variable language_">self</span>.output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;关闭IO流&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.<span class="built_in">input</span> != sys.stdin:</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">input</span>.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.output != sys.stdout:</span><br><span class="line">            <span class="variable language_">self</span>.output.close()</span><br></pre></td></tr></table></figure>

<h2 id="Python常用数据结构快速参考"><a href="#Python常用数据结构快速参考" class="headerlink" title="Python常用数据结构快速参考"></a>Python常用数据结构快速参考</h2><h3 id="基础容器操作"><a href="#基础容器操作" class="headerlink" title="基础容器操作"></a>基础容器操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表（动态数组）</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.append(<span class="number">4</span>)              <span class="comment"># O(1) 尾部添加</span></span><br><span class="line">arr.insert(<span class="number">0</span>, <span class="number">0</span>)           <span class="comment"># O(n) 头部插入</span></span><br><span class="line">arr.pop()                  <span class="comment"># O(1) 尾部删除</span></span><br><span class="line">arr.pop(<span class="number">0</span>)                 <span class="comment"># O(n) 头部删除</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])              <span class="comment"># O(1) 随机访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双端队列（可当栈或队列）</span></span><br><span class="line">dq = deque()</span><br><span class="line">dq.append(<span class="number">1</span>)               <span class="comment"># 队尾入队</span></span><br><span class="line">dq.appendleft(<span class="number">2</span>)           <span class="comment"># 队首入队</span></span><br><span class="line">dq.pop()                   <span class="comment"># 队尾出队</span></span><br><span class="line">dq.popleft()               <span class="comment"># 队首出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)             <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)             <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">print</span>(s1 - s2)             <span class="comment"># 差集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典操作</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)       <span class="comment"># 默认值为0</span></span><br><span class="line">d[<span class="string">&quot;key&quot;</span>] += <span class="number">1</span>              <span class="comment"># 自动初始化并自增</span></span><br></pre></td></tr></table></figure>

<h3 id="排序与查找"><a href="#排序与查找" class="headerlink" title="排序与查找"></a>排序与查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">arr.sort()                           <span class="comment"># 原地升序排序</span></span><br><span class="line">arr.sort(reverse=<span class="literal">True</span>)               <span class="comment"># 原地降序排序</span></span><br><span class="line">sorted_arr = <span class="built_in">sorted</span>(arr)             <span class="comment"># 返回新的排序数组</span></span><br><span class="line">custom_sorted = <span class="built_in">sorted</span>(arr, key=<span class="keyword">lambda</span> x: -x)  <span class="comment"># 自定义排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>]  <span class="comment"># 必须有序</span></span><br><span class="line">idx = bisect.bisect_left(arr, <span class="number">4</span>)     <span class="comment"># 查找插入位置</span></span><br><span class="line">idx = bisect.bisect_right(arr, <span class="number">4</span>)    <span class="comment"># 查找插入位置（右侧）</span></span><br></pre></td></tr></table></figure>

<h3 id="大整数与高精度"><a href="#大整数与高精度" class="headerlink" title="大整数与高精度"></a>大整数与高精度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python原生支持任意精度整数</span></span><br><span class="line">big_num = <span class="number">10</span>**<span class="number">100</span>                    <span class="comment"># 10的100次方</span></span><br><span class="line">result = big_num * big_num           <span class="comment"># 自动处理大整数运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高精度除法</span></span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line">decimal.getcontext().prec = <span class="number">50</span>       <span class="comment"># 设置精度</span></span><br><span class="line">a = decimal.Decimal(<span class="string">&#x27;1&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实战技巧与注意事项"><a href="#实战技巧与注意事项" class="headerlink" title="实战技巧与注意事项"></a>实战技巧与注意事项</h2><h3 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 避免在循环中重复计算</span></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):  <span class="comment"># 每次都计算len(arr)</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法  </span></span><br><span class="line">arr_len = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(arr_len):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用局部变量访问全局数据</span></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        result += global_data[i]  <span class="comment"># 每次都查找全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    local_data = global_data  <span class="comment"># 本地化全局变量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        result += local_data[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 字符串拼接优化</span></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s += <span class="built_in">str</span>(i)  <span class="comment"># 每次都创建新字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">parts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    parts.append(<span class="built_in">str</span>(i))</span><br><span class="line">s = <span class="string">&quot;&quot;</span>.join(parts)</span><br></pre></td></tr></table></figure>

<h3 id="常见陷阱与解决方案"><a href="#常见陷阱与解决方案" class="headerlink" title="常见陷阱与解决方案"></a>常见陷阱与解决方案</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 递归深度限制</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10000</span>)  <span class="comment"># 设置递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 浮点数精度问题</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_equal</span>(<span class="params">a, b, eps=<span class="number">1e-9</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt; eps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 列表初始化陷阱</span></span><br><span class="line"><span class="comment"># 错误：所有行共享同一个列表</span></span><br><span class="line">matrix = [[<span class="number">0</span>] * m] * n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：每行都是独立的列表</span></span><br><span class="line">matrix = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 字典默认值</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># 使用defaultdict避免KeyError</span></span><br><span class="line">count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">count[key] += <span class="number">1</span>  <span class="comment"># 自动初始化为0</span></span><br></pre></td></tr></table></figure>

<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件编译式调试</span></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_print</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;DEBUG:&quot;</span>, *args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入输出重定向（本地测试）</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    sys.stdin = <span class="built_in">open</span>(<span class="string">&#x27;input.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    sys.stdout = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时器</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="comment"># ... 算法代码 ...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;执行时间: <span class="subst">&#123;time.time() - start_time:<span class="number">.3</span>f&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（4）- 二叉树相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-04 14:42:46" itemprop="dateCreated datePublished" datetime="2025-08-04T14:42:46+08:00">2025-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:01:37" itemprop="dateModified" datetime="2025-08-05T16:01:37+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了二叉树的基础概念、三种遍历方式的递归实现和非递归实现，涵盖了先序、中序、后序遍历的原理与代码实现，包括了class017 -&gt; class018的内容</p>
<h1 id="017【入门】二叉树及其三种序的递归实现"><a href="#017【入门】二叉树及其三种序的递归实现" class="headerlink" title="017【入门】二叉树及其三种序的递归实现"></a>017【入门】二叉树及其三种序的递归实现</h1><h2 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h2><p>二叉树是一种重要的树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树是许多高级数据结构和算法的基础。</p>
<h3 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = v         <span class="comment"># 节点的值</span></span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span>     <span class="comment"># 左子节点</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span>    <span class="comment"># 右子节点</span></span><br></pre></td></tr></table></figure>

<h3 id="递归序的概念"><a href="#递归序的概念" class="headerlink" title="递归序的概念"></a>递归序的概念</h3><p>递归序是理解二叉树遍历的关键概念。对于任意二叉树节点，递归过程会经过该节点三次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 第1次到达该节点 - 刚进入该节点</span></span><br><span class="line">    f(head.left)   <span class="comment"># 递归处理左子树</span></span><br><span class="line">    <span class="comment"># 第2次到达该节点 - 左子树处理完毕</span></span><br><span class="line">    f(head.right)  <span class="comment"># 递归处理右子树</span></span><br><span class="line">    <span class="comment"># 第3次到达该节点 - 右子树处理完毕</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/f%E5%87%BD%E6%95%B0.png" alt="f函数"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E7%90%86%E8%A7%A3f%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%80%92%E5%BD%92%E5%BA%8F.png" alt="理解f函数"></p>
<p>根据在这三个时机中选择处理节点的时机不同，就形成了三种不同的遍历方式。</p>
<h2 id="二叉树的三种递归遍历"><a href="#二叉树的三种递归遍历" class="headerlink" title="二叉树的三种递归遍历"></a>二叉树的三种递归遍历</h2><h3 id="先序遍历（Pre-order-Traversal）"><a href="#先序遍历（Pre-order-Traversal）" class="headerlink" title="先序遍历（Pre-order Traversal）"></a>先序遍历（Pre-order Traversal）</h3><p>先序遍历的顺序是：<strong>根节点 → 左子树 → 右子树</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    先序遍历：在第1次到达节点时处理</span></span><br><span class="line"><span class="string">    应用场景：复制二叉树、表达式树求值、目录树打印</span></span><br><span class="line"><span class="string">    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 先处理当前节点</span></span><br><span class="line">    BinaryTreeTraversalRecursion.preOrder(head.left)   <span class="comment"># 再遍历左子树</span></span><br><span class="line">    BinaryTreeTraversalRecursion.preOrder(head.right)  <span class="comment"># 最后遍历右子树</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E5%85%88%E5%BA%8F.png" alt="先序"></p>
<h3 id="中序遍历（In-order-Traversal）"><a href="#中序遍历（In-order-Traversal）" class="headerlink" title="中序遍历（In-order Traversal）"></a>中序遍历（In-order Traversal）</h3><p>中序遍历的顺序是：<strong>左子树 → 根节点 → 右子树</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历：在第2次到达节点时处理</span></span><br><span class="line"><span class="string">    应用场景：二叉搜索树排序（得到有序序列）、表达式树转中缀表达式</span></span><br><span class="line"><span class="string">    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    BinaryTreeTraversalRecursion.inOrder(head.left)   <span class="comment"># 先遍历左子树</span></span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 再处理当前节点</span></span><br><span class="line">    BinaryTreeTraversalRecursion.inOrder(head.right)  <span class="comment"># 最后遍历右子树</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E4%B8%AD%E5%BA%8F.png" alt="中序"></p>
<h3 id="后序遍历（Post-order-Traversal）"><a href="#后序遍历（Post-order-Traversal）" class="headerlink" title="后序遍历（Post-order Traversal）"></a>后序遍历（Post-order Traversal）</h3><p>后序遍历的顺序是：<strong>左子树 → 右子树 → 根节点</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历：在第3次到达节点时处理</span></span><br><span class="line"><span class="string">    应用场景：计算目录大小、删除二叉树、表达式树计算</span></span><br><span class="line"><span class="string">    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    BinaryTreeTraversalRecursion.posOrder(head.left)   <span class="comment"># 先遍历左子树</span></span><br><span class="line">    BinaryTreeTraversalRecursion.posOrder(head.right)  <span class="comment"># 再遍历右子树</span></span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 最后处理当前节点</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E5%90%8E%E5%BA%8F.png" alt="后序"></p>
<h2 id="递归遍历的示例执行"><a href="#递归遍历的示例执行" class="headerlink" title="递归遍历的示例执行"></a>递归遍历的示例执行</h2><p>以下面的二叉树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \ / \</span><br><span class="line">4  5 6  7</span><br></pre></td></tr></table></figure>

<h3 id="执行结果对比"><a href="#执行结果对比" class="headerlink" title="执行结果对比"></a>执行结果对比</h3><ul>
<li><strong>先序遍历结果</strong>：1 2 4 5 3 6 7</li>
<li><strong>中序遍历结果</strong>：4 2 5 1 6 3 7  </li>
<li><strong>后序遍历结果</strong>：4 5 2 6 7 3 1</li>
</ul>
<h3 id="递归调用过程分析"><a href="#递归调用过程分析" class="headerlink" title="递归调用过程分析"></a>递归调用过程分析</h3><p>以先序遍历为例，递归调用的过程：</p>
<ol>
<li>访问节点1，打印1</li>
<li>递归进入左子树（节点2）<ul>
<li>访问节点2，打印2</li>
<li>递归进入左子树（节点4）<ul>
<li>访问节点4，打印4</li>
<li>左右子树为空，返回</li>
</ul>
</li>
<li>递归进入右子树（节点5）<ul>
<li>访问节点5，打印5</li>
<li>左右子树为空，返回</li>
</ul>
</li>
</ul>
</li>
<li>递归进入右子树（节点3）<ul>
<li>类似过程…</li>
</ul>
</li>
</ol>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>所有递归遍历算法的时间复杂度都是 <strong>O(n)</strong>，其中n是二叉树的节点数。每个节点都会被访问恰好一次。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>额外空间复杂度：O(h)</strong>，其中h是树的高度。</p>
<ul>
<li><strong>最好情况</strong>（完全平衡的二叉树）：h &#x3D; ⌊log₂n⌋，空间复杂度为O(log n)</li>
<li><strong>最坏情况</strong>（完全不平衡的树，退化为链表）：h &#x3D; n，空间复杂度为O(n)</li>
<li><strong>平均情况</strong>：对于随机二叉树，h &#x3D; O(log n)</li>
</ul>
<p>空间消耗主要来自递归调用栈，栈的最大深度等于树的高度。</p>
<h2 id="三种遍历方式的应用场景"><a href="#三种遍历方式的应用场景" class="headerlink" title="三种遍历方式的应用场景"></a>三种遍历方式的应用场景</h2><h3 id="先序遍历的典型应用"><a href="#先序遍历的典型应用" class="headerlink" title="先序遍历的典型应用"></a>先序遍历的典型应用</h3><ol>
<li><strong>复制二叉树</strong>：先创建根节点，再递归复制左右子树</li>
<li><strong>表达式树求值</strong>：先处理操作符，再处理操作数</li>
<li><strong>目录树打印</strong>：先打印目录名，再打印子目录内容</li>
<li><strong>序列化二叉树</strong>：将树结构转换为字符串格式</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制二叉树示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyTree</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 先创建新节点（先序特点）</span></span><br><span class="line">    newNode = TreeNode(root.val)</span><br><span class="line">    newNode.left = copyTree(root.left)    <span class="comment"># 递归复制左子树</span></span><br><span class="line">    newNode.right = copyTree(root.right)  <span class="comment"># 递归复制右子树</span></span><br><span class="line">    <span class="keyword">return</span> newNode</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历的典型应用"><a href="#中序遍历的典型应用" class="headerlink" title="中序遍历的典型应用"></a>中序遍历的典型应用</h3><ol>
<li><strong>二叉搜索树排序</strong>：中序遍历BST得到有序序列</li>
<li><strong>表达式树转中缀表达式</strong>：按照运算符优先级添加括号</li>
<li><strong>验证二叉搜索树</strong>：检查中序遍历结果是否为递增序列</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证二叉搜索树示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node, values</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        inorder(node.left, values)</span><br><span class="line">        values.append(node.val)  <span class="comment"># 中序收集值</span></span><br><span class="line">        inorder(node.right, values)</span><br><span class="line">    </span><br><span class="line">    values = []</span><br><span class="line">    inorder(root, values)</span><br><span class="line">    <span class="comment"># 检查是否严格递增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(values[i] &lt; values[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历的典型应用"><a href="#后序遍历的典型应用" class="headerlink" title="后序遍历的典型应用"></a>后序遍历的典型应用</h3><ol>
<li><strong>计算目录大小</strong>：先计算子目录大小，再计算当前目录</li>
<li><strong>删除二叉树</strong>：先删除子节点，再删除父节点</li>
<li><strong>表达式树计算</strong>：先计算子表达式，再计算根表达式</li>
<li><strong>计算树的高度</strong>：先计算子树高度，再计算当前树高度</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算二叉树高度示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 先计算左右子树高度（后序特点）</span></span><br><span class="line">    leftHeight = maxDepth(root.left)</span><br><span class="line">    rightHeight = maxDepth(root.right)</span><br><span class="line">    <span class="comment"># 再计算当前树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方式选择指南"><a href="#遍历方式选择指南" class="headerlink" title="遍历方式选择指南"></a>遍历方式选择指南</h2><table>
<thead>
<tr>
<th>需求场景</th>
<th>推荐遍历方式</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>复制&#x2F;构建树结构</td>
<td>先序遍历</td>
<td>需要先创建根节点</td>
</tr>
<tr>
<td>获取有序数据</td>
<td>中序遍历</td>
<td>BST的中序遍历有序</td>
</tr>
<tr>
<td>释放&#x2F;计算资源</td>
<td>后序遍历</td>
<td>需要先处理子节点</td>
</tr>
<tr>
<td>树的序列化</td>
<td>先序遍历</td>
<td>便于重建树结构</td>
</tr>
<tr>
<td>表达式求值</td>
<td>后序遍历</td>
<td>需要先计算子表达式</td>
</tr>
</tbody></table>
<h2 id="递归实现的优缺点"><a href="#递归实现的优缺点" class="headerlink" title="递归实现的优缺点"></a>递归实现的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>代码简洁</strong>：逻辑清晰，易于理解和实现</li>
<li><strong>自然表达</strong>：完美匹配树的递归定义</li>
<li><strong>易于扩展</strong>：容易添加额外的处理逻辑</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>栈溢出风险</strong>：深度递归可能导致栈溢出</li>
<li><strong>性能开销</strong>：函数调用的开销相对较大</li>
<li><strong>难以控制</strong>：无法方便地暂停或恢复遍历过程</li>
</ol>
<p>在实际应用中，对于一般规模的二叉树，递归实现是首选方案。当树的深度可能很大时，需要考虑使用非递归实现来避免栈溢出问题。</p>
<hr>
<h1 id="018【入门】二叉树遍历的非递归实现和复杂度分析"><a href="#018【入门】二叉树遍历的非递归实现和复杂度分析" class="headerlink" title="018【入门】二叉树遍历的非递归实现和复杂度分析"></a>018【入门】二叉树遍历的非递归实现和复杂度分析</h1><h2 id="非递归实现的必要性"><a href="#非递归实现的必要性" class="headerlink" title="非递归实现的必要性"></a>非递归实现的必要性</h2><p>递归实现虽然简洁易懂，但在处理大型树时可能导致栈溢出。非递归实现使用显式栈来模拟递归过程，提供了更好的控制性和避免栈溢出的优势。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>用显式的栈数据结构来模拟系统递归调用栈的行为，手动管理遍历过程中的状态信息。</p>
<h2 id="先序遍历的非递归实现"><a href="#先序遍历的非递归实现" class="headerlink" title="先序遍历的非递归实现"></a>先序遍历的非递归实现</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>先序遍历要求”根-左-右”的访问顺序。使用栈时，由于栈是LIFO（后进先出）结构，需要先压入右子节点，再压入左子节点，这样弹栈时就是先处理左子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    先序遍历非递归实现</span></span><br><span class="line"><span class="string">    核心思路：使用一个栈。每次先访问节点本身，再依次压入右、左子节点（注意顺序，先右后左），这样弹栈时总是优先处理左子树，实现“中-左-右”顺序</span></span><br><span class="line"><span class="string">    时间复杂度：O(n)，每个节点进栈出栈各一次</span></span><br><span class="line"><span class="string">    空间复杂度：O(h)，h为树的高度</span></span><br><span class="line"><span class="string">    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(head)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            head = stack.pop()        <span class="comment"># 弹出栈顶节点</span></span><br><span class="line">            <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 立即打印（先序特点）</span></span><br><span class="line">            <span class="comment"># 关键：先压右子节点，再压左子节点</span></span><br><span class="line">            <span class="comment"># 这样弹栈时就是先处理左子树，再处理右子树</span></span><br><span class="line">            <span class="keyword">if</span> head.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.right)</span><br><span class="line">            <span class="keyword">if</span> head.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.left)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class18%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/%E5%85%88%E5%BA%8F.png" alt="先序2"></p>
<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以树 <code>1(2(4,5),3(6,7))</code> 为例：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>栈状态</th>
<th>弹出节点</th>
<th>打印</th>
<th>压入节点</th>
</tr>
</thead>
<tbody><tr>
<td>初始</td>
<td>[1]</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>[3,2]</td>
<td>1</td>
<td>1</td>
<td>3,2</td>
</tr>
<tr>
<td>2</td>
<td>[3,5,4]</td>
<td>2</td>
<td>2</td>
<td>5,4</td>
</tr>
<tr>
<td>3</td>
<td>[3,5]</td>
<td>4</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>[3]</td>
<td>5</td>
<td>5</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>[7,6]</td>
<td>3</td>
<td>3</td>
<td>7,6</td>
</tr>
<tr>
<td>6</td>
<td>[7]</td>
<td>6</td>
<td>6</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td>[]</td>
<td>7</td>
<td>7</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>输出结果</strong>：1 2 4 5 3 6 7</p>
<h2 id="中序遍历的非递归实现"><a href="#中序遍历的非递归实现" class="headerlink" title="中序遍历的非递归实现"></a>中序遍历的非递归实现</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>中序遍历要求”左-根-右”的访问顺序。需要先沿着左子树走到底，将路径上的所有节点压栈，然后开始弹栈处理节点，并转向右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历非递归实现</span></span><br><span class="line"><span class="string">    核心思路：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。</span></span><br><span class="line"><span class="string">    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 当前节点不为空，压栈并继续向左</span></span><br><span class="line">                stack.append(head)</span><br><span class="line">                head = head.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当前节点为空，说明左子树遍历完毕</span></span><br><span class="line">                head = stack.pop()        <span class="comment"># 弹出栈顶节点</span></span><br><span class="line">                <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 打印节点值（中序特点）</span></span><br><span class="line">                head = head.right         <span class="comment"># 转向右子树</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h3 id="算法状态分析"><a href="#算法状态分析" class="headerlink" title="算法状态分析"></a>算法状态分析</h3><p>中序遍历的非递归实现有两种状态：</p>
<ol>
<li><strong>下降状态</strong>：<code>head != None</code>，沿左子树向下走并压栈</li>
<li><strong>上升状态</strong>：<code>head == None</code>，弹栈处理节点并转向右子树</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class18%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/%E4%B8%AD%E5%BA%8F.png" alt="中序2"></p>
<h3 id="执行过程示例-1"><a href="#执行过程示例-1" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以树 <code>1(2(4,5),3(6,7))</code> 为例：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>head</th>
<th>栈状态</th>
<th>操作</th>
<th>打印</th>
</tr>
</thead>
<tbody><tr>
<td>初始</td>
<td>1</td>
<td>[]</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>[1]</td>
<td>压栈1，左移</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>[1,2]</td>
<td>压栈2，左移</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>None</td>
<td>[1,2,4]</td>
<td>压栈4，左移</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>[1,2]</td>
<td>弹栈4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>None</td>
<td>[1,2]</td>
<td>4右移(None)</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>[1]</td>
<td>弹栈2</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>5</td>
<td>[1]</td>
<td>2右移到5</td>
<td>-</td>
</tr>
<tr>
<td>8</td>
<td>None</td>
<td>[1,5]</td>
<td>压栈5，左移</td>
<td>-</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>输出结果</strong>：4 2 5 1 6 3 7</p>
<h2 id="后序遍历的非递归实现"><a href="#后序遍历的非递归实现" class="headerlink" title="后序遍历的非递归实现"></a>后序遍历的非递归实现</h2><p>后序遍历是最复杂的，因为需要确保在访问根节点之前，左右子树都已经被完全访问。提供两种实现方法：</p>
<h3 id="方法一：使用两个栈"><a href="#方法一：使用两个栈" class="headerlink" title="方法一：使用两个栈"></a>方法一：使用两个栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posOrderTwoStacks</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历非递归实现 - 双栈法</span></span><br><span class="line"><span class="string">    核心思路：第一个栈实现&quot;中-右-左&quot;遍历，结果压入第二个栈</span></span><br><span class="line"><span class="string">    最后弹出第二个栈得到&quot;左-右-中&quot;的后序遍历结果</span></span><br><span class="line"><span class="string">    即：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。</span></span><br><span class="line"><span class="string">    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []      <span class="comment"># 主栈：用于遍历</span></span><br><span class="line">        collect = []    <span class="comment"># 收集栈：用于收集结果</span></span><br><span class="line">        stack.append(head)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            head = stack.pop()</span><br><span class="line">            collect.append(head)      <span class="comment"># 收集节点到第二个栈</span></span><br><span class="line">            <span class="comment"># 注意：这里先压左子节点，再压右子节点</span></span><br><span class="line">            <span class="comment"># 这样遍历顺序就是&quot;中-右-左&quot;</span></span><br><span class="line">            <span class="keyword">if</span> head.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.left)</span><br><span class="line">            <span class="keyword">if</span> head.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反向弹出收集栈，得到&quot;左-右-中&quot;顺序</span></span><br><span class="line">        <span class="keyword">while</span> collect:</span><br><span class="line">            <span class="built_in">print</span>(collect.pop().val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h4 id="双栈法原理解析"><a href="#双栈法原理解析" class="headerlink" title="双栈法原理解析"></a>双栈法原理解析</h4><ol>
<li><strong>第一阶段</strong>：用第一个栈实现”中-右-左”遍历，类似先序遍历但左右子节点入栈顺序相反</li>
<li><strong>第二阶段</strong>：将第一阶段的结果压入第二个栈</li>
<li><strong>第三阶段</strong>：弹出第二个栈，得到”左-右-中”的后序遍历结果</li>
</ol>
<p><strong>关键洞察</strong>：”中-右-左”的逆序正好是”左-右-中”</p>
<h3 id="方法二：使用一个栈"><a href="#方法二：使用一个栈" class="headerlink" title="方法二：使用一个栈"></a>方法二：使用一个栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posOrderOneStack</span>(<span class="params">h</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历非递归实现 - 单栈法</span></span><br><span class="line"><span class="string">    核心思路：通过记录最近访问的节点，确保每个节点在其左右子树都被访问后才访问自己，从而严格实现“左-右-中”的后序遍历。</span></span><br><span class="line"><span class="string">    每个节点最多入栈两次，效率更高</span></span><br><span class="line"><span class="string">    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> h <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(h)</span><br><span class="line">        <span class="comment"># h的含义：最近一次处理（打印）的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack[-<span class="number">1</span>]  <span class="comment"># 查看栈顶元素但不弹出</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况1：有左子树且左子树未被处理过</span></span><br><span class="line">            <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h != cur.left <span class="keyword">and</span> h != cur.right:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="comment"># 情况2：有右子树且右子树未被处理过</span></span><br><span class="line">            <span class="keyword">elif</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h != cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            <span class="comment"># 情况3：左右子树都没有或都已处理完毕</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(cur.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                h = stack.pop()  <span class="comment"># 更新h为刚刚处理的节点</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h4 id="单栈法状态管理"><a href="#单栈法状态管理" class="headerlink" title="单栈法状态管理"></a>单栈法状态管理</h4><p><strong>核心变量h的含义变化</strong>：</p>
<ul>
<li><strong>初始时</strong>：h指向根节点（但实际表示”还没有处理过任何节点”）</li>
<li><strong>处理过程中</strong>：h始终指向最近一次处理（打印）的节点</li>
<li><strong>判断逻辑</strong>：通过比较当前节点的子节点与h的关系，判断子树是否已被处理</li>
</ul>
<p><strong>三种处理情况</strong>：</p>
<ol>
<li><strong>有左子树且未处理</strong>：<code>cur.left != None and h != cur.left and h != cur.right</code></li>
<li><strong>有右子树且未处理</strong>：<code>cur.right != None and h != cur.right</code></li>
<li><strong>可以处理当前节点</strong>：左右子树都不存在或都已处理完毕</li>
</ol>
<h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>所有非递归遍历算法的时间复杂度都是 <strong>O(n)</strong>：</p>
<ul>
<li><strong>先序和中序</strong>：每个节点进栈出栈各一次</li>
<li><strong>后序双栈法</strong>：每个节点进栈出栈总共两次（每个栈一次）</li>
<li><strong>后序单栈法</strong>：每个节点最多进栈两次，出栈一次</li>
</ul>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>额外空间复杂度对比</strong>：</p>
<table>
<thead>
<tr>
<th>实现方法</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>先序非递归</td>
<td>O(h)</td>
<td>一个栈，最大深度为树高</td>
</tr>
<tr>
<td>中序非递归</td>
<td>O(h)</td>
<td>一个栈，最大深度为树高</td>
</tr>
<tr>
<td>后序双栈法</td>
<td>O(n)</td>
<td>收集栈最坏情况存储所有节点</td>
</tr>
<tr>
<td>后序单栈法</td>
<td>O(h)</td>
<td>一个栈，最大深度为树高</td>
</tr>
<tr>
<td>递归实现</td>
<td>O(h)</td>
<td>系统调用栈，深度为树高</td>
</tr>
</tbody></table>
<p>其中h为树的高度：</p>
<ul>
<li><strong>最好情况</strong>：h &#x3D; O(log n)（平衡树）</li>
<li><strong>最坏情况</strong>：h &#x3D; O(n)（退化为链表）</li>
</ul>
<h2 id="实现方法选择建议"><a href="#实现方法选择建议" class="headerlink" title="实现方法选择建议"></a>实现方法选择建议</h2><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>实现难度</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td>先序非递归</td>
<td>O(n)</td>
<td>O(h)</td>
<td>简单</td>
<td>通用推荐</td>
</tr>
<tr>
<td>中序非递归</td>
<td>O(n)</td>
<td>O(h)</td>
<td>中等</td>
<td>BST相关问题</td>
</tr>
<tr>
<td>后序双栈法</td>
<td>O(n)</td>
<td>O(n)</td>
<td>简单</td>
<td>理解后序遍历逻辑</td>
</tr>
<tr>
<td>后序单栈法</td>
<td>O(n)</td>
<td>O(h)</td>
<td>困难</td>
<td>空间要求严格的场景</td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ol>
<li><strong>实际应用</strong>：根据具体需求选择，一般情况下递归实现更简洁</li>
<li><strong>性能要求高</strong>：选择非递归实现，避免函数调用开销</li>
<li><strong>内存受限</strong>：后序遍历优选单栈法，其他遍历方式空间复杂度相当</li>
</ol>
<h2 id="非递归实现的优势"><a href="#非递归实现的优势" class="headerlink" title="非递归实现的优势"></a>非递归实现的优势</h2><ol>
<li><strong>避免栈溢出</strong>：可以处理任意深度的树</li>
<li><strong>更好控制</strong>：可以方便地暂停、恢复遍历过程</li>
<li><strong>性能优化</strong>：减少函数调用开销</li>
<li><strong>状态保存</strong>：便于在遍历过程中保存额外信息</li>
</ol>
<p>非递归实现虽然代码复杂度较高，但在处理大规模数据或有特殊要求的场景中具有重要意义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/" class="post-title-link" itemprop="url">Academic Paper learning & Translation Records</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-04 14:00:00" itemprop="dateCreated datePublished" datetime="2025-08-04T14:00:00+08:00">2025-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:19:17" itemprop="dateModified" datetime="2025-08-05T16:19:17+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Review/" itemprop="url" rel="index"><span itemprop="name">Review</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Review/Translation/" itemprop="url" rel="index"><span itemprop="name">Translation</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文档用于记录自己读过的学术论文和亲自翻译的论文内容。每篇论文包含简要说明和个人理解，部分论文附有飞书文档或doi链接</p>
<hr>
<h1 id="翻译论文记录"><a href="#翻译论文记录" class="headerlink" title="翻译论文记录"></a>翻译论文记录</h1><h2 id="P´olya’s-Random-Walk-Theorem"><a href="#P´olya’s-Random-Walk-Theorem" class="headerlink" title="P´olya’s Random Walk Theorem"></a>P´olya’s Random Walk Theorem</h2><p>当时是为了随机过程的pre，然后翻译并推了一遍polya随机游走定理，记录一下。</p>
<p><strong>原文标题</strong>：P´olya’s Random Walk Theorem<br><strong>作者</strong>：Jonathan Novak<br><strong>出处</strong>：The American Mathematical Monthly, 2014•Taylor &amp; Francis<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://doi.org/10.48550/arXiv.1301.3916">点此查看全文</a><br><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/ILmQd6LHVoVouHxrqzbcUFLqnid?from=from_copylink">点此查看翻译版</a></p>
<h2 id="MDS-TSNE-UMAP"><a href="#MDS-TSNE-UMAP" class="headerlink" title="MDS&#x2F;TSNE&#x2F;UMAP"></a>MDS&#x2F;TSNE&#x2F;UMAP</h2><p>longlongago之前把生物信息里比较常用的三种降维算法都学和推了一遍，分别是MDS（multidimensional scaling）多维尺度分析、t-SNE（t-distributed Stochastic Neighbor Embedding）和UMAP（Uniform Manifold Approximation and Projection），记录一下翻译版。</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/SP81dw744o2KXBxNtlkc8eXQnxo?from=from_copylink">点此查看整合的笔记</a></p>
<h3 id="MDS"><a href="#MDS" class="headerlink" title="MDS"></a>MDS</h3><p>Multidimensional scaling，简称MDS，中文翻译成多维尺度分析。其原理是利用成对样本间的相似性，去构建合适的低维空间，使得样本在此空间的距离和在高维空间中的样本间的相似性尽可能的保持一致。我们可以用这种方式来可视化数据分布，PCA是MDS中特殊的一种。</p>
<p>感觉有点像层次分析法，比较早用于心理学&amp;社会科学上的一些相似性分析。以下公式为简单的优化思想，理论上可以从欧式距离推广到各种距离如曼哈顿、马氏等等。</p>
<p>原始文献有点太古老了，所以看的是csdn上的专栏：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&utm_medium=referral">https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&amp;utm_medium=referral</a></p>
<ul>
<li>Kruskal, J. B. (1964). “Multidimensional Scaling by Optimizing Goodness of Fit to a Nonmetric Hypothesis.” Psychometrika, 29(1), 1-27.</li>
<li>Shepard, R. N. (1962). “The Analysis of Proximities: Multidimensional Scaling with an Unknown Distance Function.” Psychometrika, 27(2), 125-140.</li>
</ul>
<h3 id="TSNE"><a href="#TSNE" class="headerlink" title="TSNE"></a>TSNE</h3><p>t-sne感觉是比较fashion的概率方法，很有意思。找了一篇论文<a target="_blank" rel="noopener" href="https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf</a></p>
<p><strong>原文标题</strong>：Visualizing Data using t-SNE<br><strong>作者</strong>：Laurens van der Maaten， Geoffrey Hinton<br><strong>出处</strong>：Journal of Machine Learning Research 9 (2008) 2579-2605<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">点此查看全文</a></p>
<h3 id="UMAP"><a href="#UMAP" class="headerlink" title="UMAP"></a>UMAP</h3><p>UMAP没有看太懂，主要是我没学过拓扑，但是其中模糊数学的部分很有意思，这篇论文刚刚发预印本的时候模糊数学还挺火的，现在不行了。</p>
<p><strong>原文标题</strong>：Uniform manifold approximation and projection<br><strong>作者</strong>：John Healy， Leland McInnes<br><strong>出处</strong>：Nature Reviews Methods Primers volume 4, Article number: 82 (2024)<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1802.03426">点此查看全文</a></p>
<h2 id="注意力机制相关"><a href="#注意力机制相关" class="headerlink" title="注意力机制相关"></a>注意力机制相关</h2><p>包括注意力机制到transformer的自注意力及其后续的变体，还有ESM3几何注意力机制、rfdiffusion的IGSO3等等。</p>
<h3 id="注意力机制的发展"><a href="#注意力机制的发展" class="headerlink" title="注意力机制的发展"></a>注意力机制的发展</h3><p>longlongago之前学深度学习补的：</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/ZhcAdjXrpoRE0exteQDc1WDZnDg?from=from_copylink">点此查看整合的笔记</a></p>
<h3 id="几何注意力机制"><a href="#几何注意力机制" class="headerlink" title="几何注意力机制"></a>几何注意力机制</h3><p>ESM3有用到，ESM3模型处理蛋白质结构信息的两种主要方法：几何注意力（Geometric Attention）和结构标记（Structure Tokens）。</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/NvxrdQV10oc6dAxO58jcRg2mnud?from=from_copylink">点此查看整合的笔记</a></p>
<h3 id="IGSO3"><a href="#IGSO3" class="headerlink" title="IGSO3"></a>IGSO3</h3><p>当时看rfdiffusion被吓坏了，这个证明真的很吓人</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/FSKFdRxOUoIyuWxeZ9DcizWfn9b?from=from_copylink">点此查看整合的笔记</a></p>
<h2 id="倾向性得分在观察性研究中因果效应分析的核心作用"><a href="#倾向性得分在观察性研究中因果效应分析的核心作用" class="headerlink" title="倾向性得分在观察性研究中因果效应分析的核心作用"></a>倾向性得分在观察性研究中因果效应分析的核心作用</h2><p>文理学院统计系汇报的pre，看完了之后连统计学都不想学了，数学和统计完全是两个学科啊！感觉自己喜欢的是统计计算而不是数理统计和传统的统计inference，润了润了润去计算了</p>
<p><strong>原文标题</strong>：The central role of the propensity score in observational studies for causal effect<br><strong>作者</strong>：PAUL R. ROSENBAUM, DONALD B. RUBIN<br><strong>出处</strong>：Biometrilca (1083), 70, 1, pp. 41-55<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://academic.oup.com/biomet/article-abstract/70/1/41/240879?login=false">点此查看全文</a><br><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/Zp95d0fS6om1iexY3AqcibQCnyh?from=from_copylink">点此查看翻译版</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/03/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E4%BB%B6%E7%95%99%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/03/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E4%BB%B6%E7%95%99%E6%A1%A3/" class="post-title-link" itemprop="url">吴恩达机器学习课程资料归档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-03 12:00:00 / Modified: 20:04:45" itemprop="dateCreated datePublished" datetime="2025-08-03T12:00:00+08:00">2025-08-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Review/" itemprop="url" rel="index"><span itemprop="name">Review</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Review/Online-course/" itemprop="url" rel="index"><span itemprop="name">Online course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大概是24年暑假期间一周速通学完了吴恩达的机器学习，真真真是深入浅出，言简意赅， 记录一下吴恩达机器学习课程相关的PDF资料、讲义、笔记等，方便日后复习与查阅。</p>
<h1 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.1387.top_right_bar_window_custom_collection.content.click">吴恩达机器学习（B站全套）</a></p>
<h1 id="课堂上的PDF笔记"><a href="#课堂上的PDF笔记" class="headerlink" title="课堂上的PDF笔记"></a>课堂上的PDF笔记</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/吴恩达机器学习的笔记/吴恩达机器学习的课堂Review.pdf" style="width:100%;height:800px"></iframe>

<h1 id="网盘整体的文件"><a href="#网盘整体的文件" class="headerlink" title="网盘整体的文件"></a>网盘整体的文件</h1><p>通过网盘分享的文件：A最新版 吴恩达机器学习Deeplearning.ai<br>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1RGHnExutISizVeFNNR4OnQ?pwd=ue7m">https://pan.baidu.com/s/1RGHnExutISizVeFNNR4OnQ?pwd=ue7m</a> 提取码: ue7m </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%20%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%20%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（3）- 队列和栈相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-02 14:42:46" itemprop="dateCreated datePublished" datetime="2025-08-02T14:42:46+08:00">2025-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:02:11" itemprop="dateModified" datetime="2025-08-05T16:02:11+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了栈和队列的基础实现、相互转换以及最小栈等核心内容，涵盖了链表实现、数组实现、循环队列等多种实现方式,包括了class013 -&gt; class016的内容。</p>
<hr>
<h1 id="013【入门】队列和栈-链表、数组实现"><a href="#013【入门】队列和栈-链表、数组实现" class="headerlink" title="013【入门】队列和栈-链表、数组实现"></a>013【入门】队列和栈-链表、数组实现</h1><h2 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h2><p>队列（Queue）是一种先进先出（FIFO, First In First Out）的线性数据结构。元素从队尾（rear）插入，从队首（front）删除。</p>
<h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><ul>
<li><strong>enqueue&#x2F;offer</strong>: 入队，将元素添加到队尾</li>
<li><strong>dequeue&#x2F;poll</strong>: 出队，从队首移除元素</li>
<li><strong>front&#x2F;peek</strong>: 查看队首元素，但不移除</li>
<li><strong>isEmpty</strong>: 判断队列是否为空</li>
<li><strong>size</strong>: 获取队列中元素个数</li>
</ul>
<h2 id="队列的实现方式"><a href="#队列的实现方式" class="headerlink" title="队列的实现方式"></a>队列的实现方式</h2><h3 id="方式一：基于双端队列（deque）实现"><a href="#方式一：基于双端队列（deque）实现" class="headerlink" title="方式一：基于双端队列（deque）实现"></a>方式一：基于双端队列（deque）实现</h3><p>Python内置的<code>collections.deque</code>提供了高效的双端操作，但常数时间较慢。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于Python内置deque实现的队列</span></span><br><span class="line"><span class="string">    内部使用双向链表，常数操作较慢但使用简单</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.queue = deque()  <span class="comment"># 内部存储使用deque（双端队列）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">offer</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向队列中加入元素，加到队尾&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">poll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从队列头部弹出元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队列头的元素但不弹出&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队列中元素个数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.queue)</span><br></pre></td></tr></table></figure>

<h3 id="方式二：基于固定数组实现"><a href="#方式二：基于固定数组实现" class="headerlink" title="方式二：基于固定数组实现"></a>方式二：基于固定数组实现</h3><p>在已知操作次数上限的情况下，使用固定数组实现具有更好的常数时间性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于固定数组实现的队列</span></span><br><span class="line"><span class="string">    适用于已知加入操作总次数上限的场景</span></span><br><span class="line"><span class="string">    常数时间性能更好，是实际刷题中最常用的方式</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化队列</span></span><br><span class="line"><span class="string">        参数: n - 加入操作的总次数上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue = [<span class="number">0</span>] * n  <span class="comment"># 固定大小数组</span></span><br><span class="line">        <span class="variable language_">self</span>.l = <span class="number">0</span>  <span class="comment"># 队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>.r = <span class="number">0</span>  <span class="comment"># 队尾指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.l == <span class="variable language_">self</span>.r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">offer</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入队操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.r] = num  <span class="comment"># 在队尾位置插入元素</span></span><br><span class="line">        <span class="variable language_">self</span>.r += <span class="number">1</span>  <span class="comment"># 队尾指针后移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">poll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队操作&quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.l]  <span class="comment"># 取队首元素</span></span><br><span class="line">        <span class="variable language_">self</span>.l += <span class="number">1</span>  <span class="comment"># 队首指针后移</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">head</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.l]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tail</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.r - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队列当前元素个数，区间[l, r)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.r - <span class="variable language_">self</span>.l</span><br></pre></td></tr></table></figure>

<h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><p>栈（Stack）是一种后进先出（LIFO, Last In First Out）的线性数据结构。元素只能从栈顶插入和删除。</p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><ul>
<li><strong>push</strong>: 压栈，将元素添加到栈顶</li>
<li><strong>pop</strong>: 弹栈，从栈顶移除元素</li>
<li><strong>peek&#x2F;top</strong>: 查看栈顶元素，但不移除</li>
<li><strong>isEmpty</strong>: 判断栈是否为空</li>
<li><strong>size</strong>: 获取栈中元素个数</li>
</ul>
<h2 id="栈的实现方式"><a href="#栈的实现方式" class="headerlink" title="栈的实现方式"></a>栈的实现方式</h2><h3 id="方式一：基于动态数组实现"><a href="#方式一：基于动态数组实现" class="headerlink" title="方式一：基于动态数组实现"></a>方式一：基于动态数组实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于Python内置列表实现的栈</span></span><br><span class="line"><span class="string">    使用动态数组，常数时间不是最优但使用简单</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []  <span class="comment"># 用列表模拟栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;压栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈的大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.stack)</span><br></pre></td></tr></table></figure>

<h3 id="方式二：基于固定数组实现-1"><a href="#方式二：基于固定数组实现-1" class="headerlink" title="方式二：基于固定数组实现"></a>方式二：基于固定数组实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于固定数组实现的栈</span></span><br><span class="line"><span class="string">    适用于已知同时在栈里元素个数上限的场景</span></span><br><span class="line"><span class="string">    常数时间性能更好，空间可以复用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化栈</span></span><br><span class="line"><span class="string">        参数: n - 同时在栈里的元素个数上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack = [<span class="number">0</span>] * n  <span class="comment"># 固定大小数组</span></span><br><span class="line">        <span class="variable language_">self</span>.size_ = <span class="number">0</span>  <span class="comment"># 当前栈元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size_ == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;压栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack[<span class="variable language_">self</span>.size_] = num  <span class="comment"># 在当前size位置插入</span></span><br><span class="line">        <span class="variable language_">self</span>.size_ += <span class="number">1</span>  <span class="comment"># 元素个数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size_ -= <span class="number">1</span>  <span class="comment"># 元素个数-1，先减后取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[<span class="variable language_">self</span>.size_]  <span class="comment"># 返回弹出的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[<span class="variable language_">self</span>.size_ - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size_</span><br></pre></td></tr></table></figure>

<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列是队列的一种特殊实现，通过循环使用固定大小的数组来避免空间浪费。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    循环队列实现</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/design-circular-queue/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化循环队列</span></span><br><span class="line"><span class="string">        参数: k - 队列容量上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue = [<span class="number">0</span>] * k  <span class="comment"># 固定大小数组</span></span><br><span class="line">        <span class="variable language_">self</span>.l = <span class="number">0</span>  <span class="comment"># 队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>.r = <span class="number">0</span>  <span class="comment"># 队尾指针</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>  <span class="comment"># 当前元素个数</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = k  <span class="comment"># 容量上限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enQueue</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        入队操作</span></span><br><span class="line"><span class="string">        返回: 成功返回True，队列满返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 队列已满</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.r] = value  <span class="comment"># 队尾插入元素</span></span><br><span class="line">            <span class="comment"># 队尾指针循环移动</span></span><br><span class="line">            <span class="variable language_">self</span>.r = <span class="number">0</span> <span class="keyword">if</span> <span class="variable language_">self</span>.r == <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">else</span> <span class="variable language_">self</span>.r + <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span>  <span class="comment"># 元素个数+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deQueue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        出队操作</span></span><br><span class="line"><span class="string">        返回: 成功返回True，队列空返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 队列为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 队首指针循环移动</span></span><br><span class="line">            <span class="variable language_">self</span>.l = <span class="number">0</span> <span class="keyword">if</span> <span class="variable language_">self</span>.l == <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">else</span> <span class="variable language_">self</span>.l + <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span>  <span class="comment"># 元素个数-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队首元素，队列为空返回-1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.l]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Rear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队尾元素，队列为空返回-1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 计算队尾指针的实际位置</span></span><br><span class="line">            last = <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">if</span> <span class="variable language_">self</span>.r == <span class="number">0</span> <span class="keyword">else</span> <span class="variable language_">self</span>.r - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.queue[last]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="variable language_">self</span>.limit</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="014【入门】队列和栈入门题目-栈和队列相互实现"><a href="#014【入门】队列和栈入门题目-栈和队列相互实现" class="headerlink" title="014【入门】队列和栈入门题目-栈和队列相互实现"></a>014【入门】队列和栈入门题目-栈和队列相互实现</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>队列是先进先出（FIFO），而栈是后进先出（LIFO）。要用栈实现队列，需要使用两个栈来模拟队列的行为。</p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用两个栈：</p>
<ul>
<li><strong>输入栈（in_stack）</strong>：负责接收新元素的push操作</li>
<li><strong>输出栈（out_stack）</strong>：负责输出元素的pop和peek操作</li>
</ul>
<h3 id="关键规则"><a href="#关键规则" class="headerlink" title="关键规则"></a>关键规则</h3><ol>
<li><strong>倒数据条件</strong>：只有当输出栈为空时，才能从输入栈倒数据</li>
<li><strong>倒数据原则</strong>：如果要倒数据，必须将输入栈的数据全部倒完</li>
<li><strong>时间复杂度</strong>：虽然单次操作可能是O(n)，但均摊时间复杂度是O(1)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用栈实现队列</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/implement-queue-using-stacks/</span></span><br><span class="line"><span class="string">    时间复杂度: 均摊O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.in_stack = []     <span class="comment"># 输入栈，负责push</span></span><br><span class="line">        <span class="variable language_">self</span>.out_stack = []    <span class="comment"># 输出栈，负责pop/peek</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inToOut</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        倒数据操作：从输入栈将数据倒入输出栈</span></span><br><span class="line"><span class="string">        核心规则：</span></span><br><span class="line"><span class="string">        1) 输出栈空了，才能倒数据</span></span><br><span class="line"><span class="string">        2) 如果倒数据，输入栈必须倒完</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.out_stack:                     <span class="comment"># 只有输出栈为空才能倒</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.in_stack:                   <span class="comment"># 输入栈必须倒完</span></span><br><span class="line">                <span class="variable language_">self</span>.out_stack.append(<span class="variable language_">self</span>.in_stack.pop())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入队操作：新元素加入输入栈&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.in_stack.append(x)                    <span class="comment"># 新元素压入输入栈</span></span><br><span class="line">        <span class="variable language_">self</span>.inToOut()                             <span class="comment"># 检查是否需要倒数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队操作：从输出栈弹出元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.inToOut()                             <span class="comment"># 确保输出栈有数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.out_stack.pop()                <span class="comment"># 弹出队首元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看队首元素：不移除，只查看&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.inToOut()                             <span class="comment"># 确保输出栈有数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.out_stack[-<span class="number">1</span>]                  <span class="comment"># 返回栈顶即队首</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.in_stack <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.out_stack  <span class="comment"># 两个栈都空才是空队列</span></span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>虽然<code>inToOut()</code>操作在最坏情况下需要O(n)时间，但通过均摊分析：</p>
<ul>
<li>每个元素最多被移动两次（输入栈→输出栈→出队列）</li>
<li>n次操作的总时间复杂度为O(n)</li>
<li>均摊时间复杂度为O(1)</li>
</ul>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>栈是后进先出（LIFO），队列是先进先出（FIFO）。要用队列实现栈，需要在每次push操作后重新排列队列中的元素。</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用一个双端队列（deque），在每次push新元素后，将队列中原有的元素依次移动到新元素后面，确保新元素总是在队首位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用双端队列实现栈</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/implement-stack-using-queues/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.queue = deque()                       <span class="comment"># 用deque实现队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        压栈操作</span></span><br><span class="line"><span class="string">        时间复杂度: O(n)</span></span><br><span class="line"><span class="string">        核心思想: 新元素入队后，将前面所有元素重新排列到新元素后面</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(<span class="variable language_">self</span>.queue)                        <span class="comment"># 记录当前队列长度</span></span><br><span class="line">        <span class="variable language_">self</span>.queue.append(x)                       <span class="comment"># 新元素加入队尾</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将前面的n个元素依次移动到队尾</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="variable language_">self</span>.queue.append(<span class="variable language_">self</span>.queue.popleft())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作：弹出队首元素，即栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看栈顶元素：返回队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.queue</span><br></pre></td></tr></table></figure>

<h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3><p>假设依次push元素1, 2, 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始状态: []</span><br><span class="line"></span><br><span class="line">push(1): [1]</span><br><span class="line"></span><br><span class="line">push(2): [2] -&gt; [2,1] (将1移动到2后面)</span><br><span class="line"></span><br><span class="line">push(3): [3,2,1] -&gt; [3,2,1] (将2,1依次移动到3后面)</span><br></pre></td></tr></table></figure>

<p>最终队列状态为<code>[3,2,1]</code>，队首元素3就是栈顶元素，符合LIFO特性。</p>
<hr>
<h1 id="015【入门】栈的入门题目-最小栈"><a href="#015【入门】栈的入门题目-最小栈" class="headerlink" title="015【入门】栈的入门题目-最小栈"></a>015【入门】栈的入门题目-最小栈</h1><h2 id="最小栈问题"><a href="#最小栈问题" class="headerlink" title="最小栈问题"></a>最小栈问题</h2><p>最小栈要求实现一个栈，除了基本的栈操作外，还要能够在O(1)时间内获取栈中的最小元素。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>核心挑战是如何在保持基本栈操作O(1)时间复杂度的同时，追踪当前栈中的最小值。当栈顶元素（恰好是最小值）被弹出时，需要快速知道剩余元素中的最小值。</p>
<h3 id="解决方案：辅助栈法"><a href="#解决方案：辅助栈法" class="headerlink" title="解决方案：辅助栈法"></a>解决方案：辅助栈法</h3><p>使用两个栈：</p>
<ul>
<li><strong>数据栈（data）</strong>：存储实际数据</li>
<li><strong>最小值栈（min）</strong>：存储对应位置的最小值</li>
</ul>
<h2 id="实现方法一：基于列表"><a href="#实现方法一：基于列表" class="headerlink" title="实现方法一：基于列表"></a>实现方法一：基于列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小栈实现方法一：使用Python列表</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/min-stack/</span></span><br><span class="line"><span class="string">    时间复杂度: 所有操作均为O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = []  <span class="comment"># 数据栈，存储实际元素</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">min</span> = []   <span class="comment"># 最小值栈，存储对应位置的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        压栈操作</span></span><br><span class="line"><span class="string">        核心思想: 每次压栈时，同时在最小值栈中记录当前的最小值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.data.append(val)  <span class="comment"># 将val压入数据栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.<span class="built_in">min</span> <span class="keyword">or</span> val &lt;= <span class="variable language_">self</span>.<span class="built_in">min</span>[-<span class="number">1</span>]:  <span class="comment"># 如果最小栈为空或val是新的最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>.append(val)  <span class="comment"># 将val压入最小栈</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则val不是最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>.append(<span class="variable language_">self</span>.<span class="built_in">min</span>[-<span class="number">1</span>])  <span class="comment"># 将当前最小值再次压入最小栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作：同时弹出两个栈的栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.data.pop()  <span class="comment"># 弹出数据栈栈顶</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">min</span>.pop()   <span class="comment"># 弹出最小栈栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[-<span class="number">1</span>]  <span class="comment"># 返回数据栈栈顶元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">min</span>[-<span class="number">1</span>]   <span class="comment"># 返回最小栈栈顶元素</span></span><br></pre></td></tr></table></figure>

<h3 id="工作原理示例"><a href="#工作原理示例" class="headerlink" title="工作原理示例"></a>工作原理示例</h3><p>假设依次压入元素：5, 2, 7, 1, 3</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>数据栈</th>
<th>最小栈</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>push(5)</td>
<td>[5]</td>
<td>[5]</td>
<td>5是第一个元素，也是最小值</td>
</tr>
<tr>
<td>push(2)</td>
<td>[5,2]</td>
<td>[5,2]</td>
<td>2比5小，成为新的最小值</td>
</tr>
<tr>
<td>push(7)</td>
<td>[5,2,7]</td>
<td>[5,2,2]</td>
<td>7比2大，最小值仍是2</td>
</tr>
<tr>
<td>push(1)</td>
<td>[5,2,7,1]</td>
<td>[5,2,2,1]</td>
<td>1比2小，成为新的最小值</td>
</tr>
<tr>
<td>push(3)</td>
<td>[5,2,7,1,3]</td>
<td>[5,2,2,1,1]</td>
<td>3比1大，最小值仍是1</td>
</tr>
</tbody></table>
<h2 id="实现方法二：基于固定数组"><a href="#实现方法二：基于固定数组" class="headerlink" title="实现方法二：基于固定数组"></a>实现方法二：基于固定数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小栈实现方法二：使用固定大小数组</span></span><br><span class="line"><span class="string">    适用于已知最大容量的场景，常数时间性能更好</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 根据leetcode测试数据实验得出的容量上限</span></span><br><span class="line">        <span class="comment"># 如果测试数据增加导致溢出，需要调大此值</span></span><br><span class="line">        <span class="variable language_">self</span>.MAXN = <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="number">0</span>] * <span class="variable language_">self</span>.MAXN  <span class="comment"># 数据数组</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">min</span> = [<span class="number">0</span>] * <span class="variable language_">self</span>.MAXN   <span class="comment"># 最小值数组</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>  <span class="comment"># 当前栈大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;压栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.size] = val  <span class="comment"># 在size位置存储val</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.size == <span class="number">0</span> <span class="keyword">or</span> val &lt;= <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size - <span class="number">1</span>]:  <span class="comment"># 第一个元素或新的最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size] = val  <span class="comment"># 存储val作为最小值</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># val不是最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size] = <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size - <span class="number">1</span>]  <span class="comment"># 复制前一个最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span>  <span class="comment"># 栈大小加1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作：只需将size减1，不需要实际删除数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.size - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>push操作</strong>：O(1) - 只需要常数次比较和赋值</li>
<li><strong>pop操作</strong>：O(1) - 只需要移动指针或减少计数</li>
<li><strong>top操作</strong>：O(1) - 直接访问数组元素</li>
<li><strong>getMin操作</strong>：O(1) - 直接访问最小值栈顶</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>总空间复杂度</strong>：O(n) - 需要两个栈存储数据</li>
<li><strong>额外空间</strong>：O(n) - 最小值栈的空间开销</li>
</ul>
<h3 id="优化思考"><a href="#优化思考" class="headerlink" title="优化思考"></a>优化思考</h3><p>虽然辅助栈法简单易懂，但存在空间冗余。可以考虑以下优化：</p>
<ol>
<li><strong>稀疏存储</strong>：最小值栈只在最小值更新时才压入新值</li>
<li><strong>差值存储</strong>：存储与最小值的差值而非绝对值</li>
<li><strong>链表实现</strong>：在节点中直接存储当前最小值</li>
</ol>
<hr>
<h1 id="数据结构选择指南"><a href="#数据结构选择指南" class="headerlink" title="数据结构选择指南"></a>数据结构选择指南</h1><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>常数因子</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Python内置容器</td>
<td>O(1)均摊</td>
<td>O(n)</td>
<td>较大</td>
<td>快速原型，不追求极致性能</td>
</tr>
<tr>
<td>固定数组</td>
<td>O(1)</td>
<td>O(n)</td>
<td>较小</td>
<td>已知容量上限，追求性能</td>
</tr>
<tr>
<td>双栈&#x2F;双队列</td>
<td>O(1)均摊</td>
<td>O(n)</td>
<td>中等</td>
<td>功能转换，教学示例</td>
</tr>
</tbody></table>
<h1 id="016【入门】双端队列-双链表和固定数组实现"><a href="#016【入门】双端队列-双链表和固定数组实现" class="headerlink" title="016【入门】双端队列-双链表和固定数组实现"></a>016【入门】双端队列-双链表和固定数组实现</h1><h2 id="双端队列的基本概念"><a href="#双端队列的基本概念" class="headerlink" title="双端队列的基本概念"></a>双端队列的基本概念</h2><p>双端队列（Deque，Double-ended Queue）是一种特殊的线性数据结构，允许在队列的两端进行插入和删除操作。与普通队列只能在一端插入、另一端删除不同，双端队列提供了更大的灵活性。</p>
<h3 id="双端队列的基本操作"><a href="#双端队列的基本操作" class="headerlink" title="双端队列的基本操作"></a>双端队列的基本操作</h3><ul>
<li><strong>insertFront</strong>: 在队首插入元素</li>
<li><strong>insertLast</strong>: 在队尾插入元素  </li>
<li><strong>deleteFront</strong>: 删除队首元素</li>
<li><strong>deleteLast</strong>: 删除队尾元素</li>
<li><strong>getFront</strong>: 获取队首元素</li>
<li><strong>getRear</strong>: 获取队尾元素</li>
<li><strong>isEmpty</strong>: 判断队列是否为空</li>
<li><strong>isFull</strong>: 判断队列是否已满</li>
</ul>
<h2 id="循环双端队列的实现"><a href="#循环双端队列的实现" class="headerlink" title="循环双端队列的实现"></a>循环双端队列的实现</h2><p>循环双端队列是双端队列的一种特殊实现，使用固定大小的数组并通过循环索引来管理队列的边界。</p>
<h3 id="实现方式一：基于Python列表"><a href="#实现方式一：基于Python列表" class="headerlink" title="实现方式一：基于Python列表"></a>实现方式一：基于Python列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于Python列表实现的循环双端队列</span></span><br><span class="line"><span class="string">    内部使用动态数组，操作简单但常数时间较慢</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/design-circular-deque/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化循环双端队列</span></span><br><span class="line"><span class="string">        参数: k - 队列容量上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.deque = []  <span class="comment"># 用列表模拟双端队列</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>    <span class="comment"># 当前队列大小</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = k   <span class="comment"># 队列容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertFront</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在队首插入元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(n) - 需要移动所有现有元素</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.deque.insert(<span class="number">0</span>, value)  <span class="comment"># 在索引0位置插入，其他元素后移</span></span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertLast</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在队尾插入元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(1)均摊</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.deque.append(value)  <span class="comment"># 直接添加到列表末尾</span></span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除队首元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(n) - 需要移动所有剩余元素</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.deque.pop(<span class="number">0</span>)  <span class="comment"># 删除索引0的元素，其他元素前移</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteLast</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除队尾元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.deque.pop()  <span class="comment"># 删除列表末尾元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队首元素，队列为空返回-1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deque[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队尾元素，队列为空返回-1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deque[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="variable language_">self</span>.limit</span><br></pre></td></tr></table></figure>

<h3 id="实现方式二：基于固定数组"><a href="#实现方式二：基于固定数组" class="headerlink" title="实现方式二：基于固定数组"></a>实现方式二：基于固定数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于固定数组实现的循环双端队列</span></span><br><span class="line"><span class="string">    使用循环索引管理队列边界，常数时间性能更好</span></span><br><span class="line"><span class="string">    适用于已知容量上限的场景</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化循环双端队列</span></span><br><span class="line"><span class="string">        参数: k - 队列容量上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.deque = [<span class="number">0</span>] * k  <span class="comment"># 固定长度数组</span></span><br><span class="line">        <span class="variable language_">self</span>.l = <span class="number">0</span>            <span class="comment"># 队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>.r = <span class="number">0</span>            <span class="comment"># 队尾指针</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>         <span class="comment"># 当前队列大小</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = k        <span class="comment"># 队列容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertFront</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在队首插入元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">                <span class="comment"># 空队列情况，队首和队尾指针都指向同一位置</span></span><br><span class="line">                <span class="variable language_">self</span>.l = <span class="variable language_">self</span>.r = <span class="number">0</span></span><br><span class="line">                <span class="variable language_">self</span>.deque[<span class="number">0</span>] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 队首指针向前移动（循环）</span></span><br><span class="line">                <span class="variable language_">self</span>.l = <span class="variable language_">self</span>.l - <span class="number">1</span> <span class="keyword">if</span> <span class="variable language_">self</span>.l != <span class="number">0</span> <span class="keyword">else</span> <span class="variable language_">self</span>.limit - <span class="number">1</span></span><br><span class="line">                <span class="variable language_">self</span>.deque[<span class="variable language_">self</span>.l] = value</span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertLast</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在队尾插入元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">                <span class="comment"># 空队列情况</span></span><br><span class="line">                <span class="variable language_">self</span>.l = <span class="variable language_">self</span>.r = <span class="number">0</span></span><br><span class="line">                <span class="variable language_">self</span>.deque[<span class="number">0</span>] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 队尾指针向后移动（循环）</span></span><br><span class="line">                <span class="variable language_">self</span>.r = <span class="number">0</span> <span class="keyword">if</span> <span class="variable language_">self</span>.r == <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">else</span> <span class="variable language_">self</span>.r + <span class="number">1</span></span><br><span class="line">                <span class="variable language_">self</span>.deque[<span class="variable language_">self</span>.r] = value</span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除队首元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.size == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 删除后队列变空，可选择重置指针</span></span><br><span class="line">                <span class="keyword">pass</span>  <span class="comment"># 这里不重置l和r，因为逻辑上没有影响</span></span><br><span class="line">            <span class="comment"># 队首指针向后移动（循环）</span></span><br><span class="line">            <span class="variable language_">self</span>.l = <span class="number">0</span> <span class="keyword">if</span> <span class="variable language_">self</span>.l == <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">else</span> <span class="variable language_">self</span>.l + <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteLast</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除队尾元素</span></span><br><span class="line"><span class="string">        时间复杂度: O(1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.size == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 删除后队列变空</span></span><br><span class="line">                <span class="keyword">pass</span>  <span class="comment"># 不重置指针</span></span><br><span class="line">            <span class="comment"># 队尾指针向前移动（循环）</span></span><br><span class="line">            <span class="variable language_">self</span>.r = <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">if</span> <span class="variable language_">self</span>.r == <span class="number">0</span> <span class="keyword">else</span> <span class="variable language_">self</span>.r - <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getFront</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deque[<span class="variable language_">self</span>.l]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队尾元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.deque[<span class="variable language_">self</span>.r]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="variable language_">self</span>.limit</span><br></pre></td></tr></table></figure>

<h2 id="循环索引的关键理解"><a href="#循环索引的关键理解" class="headerlink" title="循环索引的关键理解"></a>循环索引的关键理解</h2><h3 id="指针移动规律"><a href="#指针移动规律" class="headerlink" title="指针移动规律"></a>指针移动规律</h3><p>在固定数组实现中，关键是理解循环索引的移动：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向后移动（队尾插入，队首删除）</span></span><br><span class="line">next_index = <span class="number">0</span> <span class="keyword">if</span> current_index == limit - <span class="number">1</span> <span class="keyword">else</span> current_index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向前移动（队首插入，队尾删除）  </span></span><br><span class="line">prev_index = limit - <span class="number">1</span> <span class="keyword">if</span> current_index == <span class="number">0</span> <span class="keyword">else</span> current_index - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h3><ol>
<li><strong>空队列插入</strong>：第一个元素插入时，队首和队尾指针都指向同一位置</li>
<li><strong>单元素删除</strong>：删除唯一元素后队列变空，但指针位置不需要重置</li>
<li><strong>满队列检测</strong>：通过size变量而非指针位置来判断队列是否已满</li>
</ol>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="时间复杂度对比"><a href="#时间复杂度对比" class="headerlink" title="时间复杂度对比"></a>时间复杂度对比</h3><table>
<thead>
<tr>
<th>操作</th>
<th>列表实现</th>
<th>数组实现</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>insertFront</td>
<td>O(n)</td>
<td>O(1)</td>
<td>列表需要移动所有元素</td>
</tr>
<tr>
<td>insertLast</td>
<td>O(1)均摊</td>
<td>O(1)</td>
<td>列表可能需要扩容</td>
</tr>
<tr>
<td>deleteFront</td>
<td>O(n)</td>
<td>O(1)</td>
<td>列表需要移动所有元素</td>
</tr>
<tr>
<td>deleteLast</td>
<td>O(1)</td>
<td>O(1)</td>
<td>两种实现都是常数时间</td>
</tr>
<tr>
<td>getFront&#x2F;getRear</td>
<td>O(1)</td>
<td>O(1)</td>
<td>直接索引访问</td>
</tr>
</tbody></table>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>列表实现</strong>：O(k)，但可能因为动态扩容导致额外开销</li>
<li><strong>数组实现</strong>：O(k)，固定空间，无额外开销</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="双端队列的典型应用"><a href="#双端队列的典型应用" class="headerlink" title="双端队列的典型应用"></a>双端队列的典型应用</h3><ol>
<li><strong>滑动窗口问题</strong>：需要在窗口两端进行操作</li>
<li><strong>回文检测</strong>：从两端向中间检查字符</li>
<li><strong>撤销&#x2F;重做功能</strong>：需要在两端添加和删除操作记录</li>
<li><strong>广度优先搜索变种</strong>：某些图算法需要双向扩展</li>
</ol>
<h2 id="与其他数据结构的对比"><a href="#与其他数据结构的对比" class="headerlink" title="与其他数据结构的对比"></a>与其他数据结构的对比</h2><table>
<thead>
<tr>
<th>数据结构</th>
<th>队首操作</th>
<th>队尾操作</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>普通队列</td>
<td>删除O(1)</td>
<td>插入O(1)</td>
<td>FIFO场景</td>
</tr>
<tr>
<td>栈</td>
<td>插入&#x2F;删除O(1)</td>
<td>无操作</td>
<td>LIFO场景</td>
</tr>
<tr>
<td>双端队列</td>
<td>插入&#x2F;删除O(1)</td>
<td>插入&#x2F;删除O(1)</td>
<td>需要两端操作</td>
</tr>
<tr>
<td>动态数组</td>
<td>插入O(n)，删除O(n)</td>
<td>插入O(1)均摊，删除O(1)</td>
<td>随机访问</td>
</tr>
</tbody></table>
<p>双端队列提供了比普通队列和栈更大的灵活性，在需要两端操作的算法中具有重要作用。固定数组的循环实现虽然代码复杂度稍高，但提供了最优的时间和空间性能。刷题中优先选择固定数组实现，性能更好，实际工程中如果容量不确定，可以考虑列表实现或者动态扩容的数组；此外，固定数据能使得内存使用更可控。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（2）- 链表相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-02 12:42:46" itemprop="dateCreated datePublished" datetime="2025-08-02T12:42:46+08:00">2025-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:04:32" itemprop="dateModified" datetime="2025-08-05T16:04:32+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了class009 -&gt; class012，涵盖了链表的基础概念、反转操作、合并算法、链表运算以及分割技巧等内容。</p>
<hr>
<h1 id="009【入门】单双链表及其反转"><a href="#009【入门】单双链表及其反转" class="headerlink" title="009【入门】单双链表及其反转"></a>009【入门】单双链表及其反转</h1><h2 id="链表的基本概念"><a href="#链表的基本概念" class="headerlink" title="链表的基本概念"></a>链表的基本概念</h2><p>链表是一种线性数据结构，其中元素存储在节点中，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不必连续存储。</p>
<h3 id="单链表节点定义"><a href="#单链表节点定义" class="headerlink" title="单链表节点定义"></a>单链表节点定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单链表节点类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val                    <span class="comment"># 节点存储的数据值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span>                  <span class="comment"># 指向下一个节点的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="双链表节点定义"><a href="#双链表节点定义" class="headerlink" title="双链表节点定义"></a>双链表节点定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    双链表节点类</span></span><br><span class="line"><span class="string">    每个节点有两个指针：指向前驱和后继</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value                <span class="comment"># 节点存储的数据值</span></span><br><span class="line">        <span class="variable language_">self</span>.last = <span class="literal">None</span>                  <span class="comment"># 指向前一个节点的指针</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 指向下一个节点的指针</span></span><br></pre></td></tr></table></figure>

<h2 id="单链表反转算法"><a href="#单链表反转算法" class="headerlink" title="单链表反转算法"></a>单链表反转算法</h2><p>反转单链表测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<h3 id="迭代方法实现"><a href="#迭代方法实现" class="headerlink" title="迭代方法实现"></a>迭代方法实现</h3><p>单链表反转是链表操作中的经典问题，核心思想是改变节点间的指针方向。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListReverseOperations</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_linked_list</span>(<span class="params">head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        反转单链表 - 迭代实现</span></span><br><span class="line"><span class="string">        时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: head - 链表头节点</span></span><br><span class="line"><span class="string">        返回: 反转后链表的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span>                        <span class="comment"># 前驱节点指针，初始为None</span></span><br><span class="line">        next_node = <span class="literal">None</span>                  <span class="comment"># 临时保存下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:           <span class="comment"># 遍历整个链表</span></span><br><span class="line">            next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点，防止链表断裂</span></span><br><span class="line">            head.<span class="built_in">next</span> = pre               <span class="comment"># 当前节点指向前驱（反转指针）</span></span><br><span class="line">            pre = head                    <span class="comment"># 前驱指针前进到当前节点</span></span><br><span class="line">            head = next_node              <span class="comment"># 头指针前进到下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pre                        <span class="comment"># pre此时指向原链表的尾节点，即新链表的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="反转过程图解"><a href="#反转过程图解" class="headerlink" title="反转过程图解"></a>反转过程图解</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(2)/%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B.png" alt="反转图解"></p>
<p>具体在上面的实现中，是利用next向后移动 利用pre改变方指针向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line"></span><br><span class="line">第1步: pre=NULL, head=1, next=2</span><br><span class="line">      NULL &lt;- 1    2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">             pre  head</span><br><span class="line"></span><br><span class="line">第2步: pre=1, head=2, next=3  </span><br><span class="line">      NULL &lt;- 1 &lt;- 2    3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">                  pre  head</span><br><span class="line"></span><br><span class="line">第3步: pre=2, head=3, next=4</span><br><span class="line">      NULL &lt;- 1 &lt;- 2 &lt;- 3    4 -&gt; 5 -&gt; NULL</span><br><span class="line">                        pre  head</span><br><span class="line"></span><br><span class="line">最终: NULL &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5</span><br><span class="line">                                  pre</span><br></pre></td></tr></table></figure>

<h3 id="递归方法实现"><a href="#递归方法实现" class="headerlink" title="递归方法实现"></a>递归方法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_linked_list_recursive</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    反转单链表 - 递归实现</span></span><br><span class="line"><span class="string">    时间复杂度: O(n), 空间复杂度: O(n) - 递归栈空间</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数: head - 链表头节点</span></span><br><span class="line"><span class="string">    返回: 反转后链表的头节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基础情况：空链表或单节点链表</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归反转剩余部分</span></span><br><span class="line">    new_head = ListReverseOperations.reverse_linked_list_recursive(head.<span class="built_in">next</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反转当前节点与下一个节点的连接</span></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head             <span class="comment"># 下一个节点指回当前节点</span></span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 当前节点的next置空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> new_head                   <span class="comment"># 返回新的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="双链表反转算法"><a href="#双链表反转算法" class="headerlink" title="双链表反转算法"></a>双链表反转算法</h2><p>双链表的反转需要同时处理前驱和后继两个指针，相比单链表更加复杂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_double_list</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    反转双链表</span></span><br><span class="line"><span class="string">    时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数: head - 双链表头节点</span></span><br><span class="line"><span class="string">    返回: 反转后双链表的头节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pre = <span class="literal">None</span>                        <span class="comment"># 前驱节点指针</span></span><br><span class="line">    next_node = <span class="literal">None</span>                  <span class="comment"># 临时保存下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:           <span class="comment"># 遍历整个双链表</span></span><br><span class="line">        next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 交换当前节点的前驱和后继指针</span></span><br><span class="line">        head.<span class="built_in">next</span> = pre               <span class="comment"># next指向前驱</span></span><br><span class="line">        head.last = next_node         <span class="comment"># last指向后继</span></span><br><span class="line">        </span><br><span class="line">        pre = head                    <span class="comment"># 前驱指针前进</span></span><br><span class="line">        head = next_node              <span class="comment"># 头指针前进</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre                        <span class="comment"># 返回新的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="双链表反转的关键点"><a href="#双链表反转的关键点" class="headerlink" title="双链表反转的关键点"></a>双链表反转的关键点</h3><ol>
<li><strong>指针交换</strong>：每个节点的<code>next</code>和<code>last</code>指针需要互换方向</li>
<li><strong>边界处理</strong>：正确处理链表两端的NULL指针</li>
<li><strong>遍历顺序</strong>：确保在修改指针前保存必要的信息</li>
</ol>
<hr>
<h1 id="010【入门】合并两个有序链表"><a href="#010【入门】合并两个有序链表" class="headerlink" title="010【入门】合并两个有序链表"></a>010【入门】合并两个有序链表</h1><p>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个已排序的链表，将它们合并成一个新的有序链表。新链表应该通过拼接给定的两个链表的所有节点组成。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>采用<strong>双指针技术</strong>，比较两个链表当前节点的值，选择较小的节点添加到结果链表中，然后移动对应的指针。</p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_two_lists</span>(<span class="params">head1, head2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        时间复杂度: O(m + n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: head1, head2 - 两个有序链表的头节点</span></span><br><span class="line"><span class="string">        返回: 合并后有序链表的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 边界情况处理：其中一个链表为空</span></span><br><span class="line">        <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head2 <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> head1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定合并后链表的头节点</span></span><br><span class="line">        <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">            head = head1                  <span class="comment"># head1的值更小，作为头节点</span></span><br><span class="line">            cur1 = head1.<span class="built_in">next</span>             <span class="comment"># cur1指向head1的下一个节点</span></span><br><span class="line">            cur2 = head2                  <span class="comment"># cur2指向head2的当前节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = head2                  <span class="comment"># head2的值更小，作为头节点</span></span><br><span class="line">            cur1 = head1                  <span class="comment"># cur1指向head1的当前节点</span></span><br><span class="line">            cur2 = head2.<span class="built_in">next</span>             <span class="comment"># cur2指向head2的下一个节点</span></span><br><span class="line">        </span><br><span class="line">        pre = head                        <span class="comment"># pre用于构建结果链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 双指针遍历两个链表</span></span><br><span class="line">        <span class="keyword">while</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> cur2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur1.val &lt;= cur2.val:     <span class="comment"># cur1的值更小或相等</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur1           <span class="comment"># 将cur1连接到结果链表</span></span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span>          <span class="comment"># cur1指针后移</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># cur2的值更小</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur2           <span class="comment"># 将cur2连接到结果链表</span></span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span>          <span class="comment"># cur2指针后移</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span>                <span class="comment"># 结果链表指针后移</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理剩余节点：将未遍历完的链表直接连接到结果链表末尾</span></span><br><span class="line">        pre.<span class="built_in">next</span> = cur1 <span class="keyword">if</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> cur2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head                       <span class="comment"># 返回合并后链表的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="算法优化版本"><a href="#算法优化版本" class="headerlink" title="算法优化版本"></a>算法优化版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_two_lists_optimized</span>(<span class="params">head1, head2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个有序链表 - 优化版本</span></span><br><span class="line"><span class="string">    使用虚拟头节点简化边界处理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)               <span class="comment"># 创建虚拟头节点</span></span><br><span class="line">    current = dummy                   <span class="comment"># 当前指针指向虚拟头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双指针遍历两个链表</span></span><br><span class="line">    <span class="keyword">while</span> head1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">            current.<span class="built_in">next</span> = head1      <span class="comment"># 连接较小节点</span></span><br><span class="line">            head1 = head1.<span class="built_in">next</span>        <span class="comment"># 移动head1指针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current.<span class="built_in">next</span> = head2      <span class="comment"># 连接较小节点</span></span><br><span class="line">            head2 = head2.<span class="built_in">next</span>        <span class="comment"># 移动head2指针</span></span><br><span class="line">        current = current.<span class="built_in">next</span>        <span class="comment"># 移动结果链表指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接剩余节点</span></span><br><span class="line">    current.<span class="built_in">next</span> = head1 <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> head2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>                 <span class="comment"># 返回真正的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="合并过程示例"><a href="#合并过程示例" class="headerlink" title="合并过程示例"></a>合并过程示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">链表1: 1 -&gt; 2 -&gt; 4</span><br><span class="line">链表2: 1 -&gt; 3 -&gt; 4</span><br><span class="line"></span><br><span class="line">合并过程:</span><br><span class="line">step1: 比较1和1，选择链表1的1    结果: 1</span><br><span class="line">step2: 比较2和1，选择链表2的1    结果: 1 -&gt; 1  </span><br><span class="line">step3: 比较2和3，选择链表1的2    结果: 1 -&gt; 1 -&gt; 2</span><br><span class="line">step4: 比较4和3，选择链表2的3    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3</span><br><span class="line">step5: 比较4和4，选择链表1的4    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span><br><span class="line">step6: 连接剩余的4              结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="011【入门】两个链表相加"><a href="#011【入门】两个链表相加" class="headerlink" title="011【入门】两个链表相加"></a>011【入门】两个链表相加</h1><p>测试链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个非空链表来表示两个非负整数，数字最高位位于链表开始位置。它们的每个节点只存储一位数字，计算两个数的和并以相同形式返回一个表示和的链表。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>模拟手工加法运算，从链表尾部开始逐位相加，处理进位问题。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_two_numbers</span>(<span class="params">h1, h2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        两个链表数字相加</span></span><br><span class="line"><span class="string">        时间复杂度: O(max(m,n)), 空间复杂度: O(max(m,n))</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: h1, h2 - 两个表示数字的链表头节点</span></span><br><span class="line"><span class="string">        返回: 表示和的链表头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="literal">None</span>                        <span class="comment"># 结果链表头节点</span></span><br><span class="line">        cur = <span class="literal">None</span>                        <span class="comment"># 当前构建位置指针</span></span><br><span class="line">        carry = <span class="number">0</span>                         <span class="comment"># 进位标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历两个链表，直到都为空</span></span><br><span class="line">        <span class="keyword">while</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 获取当前位的数字，如果链表已结束则为0</span></span><br><span class="line">            val1 = h1.val <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            val2 = h2.val <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算当前位的和（包括进位）</span></span><br><span class="line">            total = val1 + val2 + carry</span><br><span class="line">            carry = total // <span class="number">10</span>           <span class="comment"># 计算新的进位</span></span><br><span class="line">            digit = total % <span class="number">10</span>            <span class="comment"># 当前位的数字</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 构建结果链表</span></span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="literal">None</span>:               <span class="comment"># 第一个节点</span></span><br><span class="line">                ans = ListNode(digit)</span><br><span class="line">                cur = ans</span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 后续节点</span></span><br><span class="line">                cur.<span class="built_in">next</span> = ListNode(digit)</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移动链表指针</span></span><br><span class="line">            h1 = h1.<span class="built_in">next</span> <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            h2 = h2.<span class="built_in">next</span> <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理最后的进位</span></span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans                        <span class="comment"># 返回结果链表头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="代码修正与优化"><a href="#代码修正与优化" class="headerlink" title="代码修正与优化"></a>代码修正与优化</h2><p>优化了源代码最后的进位问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_numbers_corrected</span>(<span class="params">h1, h2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    两个链表数字相加 - 优化版本，更加通用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="literal">None</span>                        <span class="comment"># 结果链表头节点</span></span><br><span class="line">    cur = <span class="literal">None</span>                        <span class="comment"># 当前构建位置指针</span></span><br><span class="line">    carry = <span class="number">0</span>                         <span class="comment"># 进位标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 安全获取节点值，避免空指针异常</span></span><br><span class="line">        val1 = h1.val <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        val2 = h2.val <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算当前位的和</span></span><br><span class="line">        total = val1 + val2 + carry</span><br><span class="line">        carry = total // <span class="number">10</span>           <span class="comment"># 新进位</span></span><br><span class="line">        digit = total % <span class="number">10</span>            <span class="comment"># 当前位数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建结果链表节点</span></span><br><span class="line">        new_node = ListNode(digit)</span><br><span class="line">        <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="literal">None</span>:               <span class="comment"># 初始化头节点</span></span><br><span class="line">            ans = cur = new_node</span><br><span class="line">        <span class="keyword">else</span>:                         <span class="comment"># 连接新节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = new_node</span><br><span class="line">            cur = new_node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 安全移动指针</span></span><br><span class="line">        h1 = h1.<span class="built_in">next</span> <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        h2 = h2.<span class="built_in">next</span> <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理最终进位</span></span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(carry)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">链表1: 2 -&gt; 4 -&gt; 3  (表示数字342)</span><br><span class="line">链表2: 5 -&gt; 6 -&gt; 4  (表示数字465)</span><br><span class="line"></span><br><span class="line">相加过程:</span><br><span class="line">位置0: 2 + 5 + 0(进位) = 7, 进位=0  结果: 7</span><br><span class="line">位置1: 4 + 6 + 0(进位) = 10, 进位=1  结果: 7 -&gt; 0</span><br><span class="line">位置2: 3 + 4 + 1(进位) = 8, 进位=0  结果: 7 -&gt; 0 -&gt; 8</span><br><span class="line"></span><br><span class="line">最终结果: 7 -&gt; 0 -&gt; 8 (表示数字807)</span><br><span class="line">验证: 342 + 465 = 807 ✓</span><br></pre></td></tr></table></figure>

<h2 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h2><ol>
<li><strong>不同长度链表</strong>：短链表结束后，继续处理长链表的剩余位</li>
<li><strong>最高位进位</strong>：最后可能产生新的最高位</li>
<li><strong>空链表</strong>：输入验证，确保链表非空</li>
<li><strong>单位数</strong>：正确处理个位数相加的情况</li>
</ol>
<hr>
<h1 id="012【入门】划分链表"><a href="#012【入门】划分链表" class="headerlink" title="012【入门】划分链表"></a>012【入门】划分链表</h1><p>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></p>
<h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个链表和一个特定值x，对链表进行分隔，使得所有小于x的节点都在大于或等于x的节点之前。保持两个分区中每个节点的初始相对位置。</p>
<h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>使用<strong>双链表分离</strong>的思想：</p>
<ol>
<li>创建两个独立的链表：小于x的节点链表和大于等于x的节点链表</li>
<li>遍历原链表，将节点分别添加到对应的链表中</li>
<li>最后将两个链表连接起来</li>
</ol>
<h2 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">head, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分链表</span></span><br><span class="line"><span class="string">        时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: head - 链表头节点, x - 划分值</span></span><br><span class="line"><span class="string">        返回: 划分后链表的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化两个链表的头尾指针</span></span><br><span class="line">        left_head = <span class="literal">None</span>                  <span class="comment"># 小于x的链表头指针</span></span><br><span class="line">        left_tail = <span class="literal">None</span>                  <span class="comment"># 小于x的链表尾指针</span></span><br><span class="line">        right_head = <span class="literal">None</span>                 <span class="comment"># 大于等于x的链表头指针</span></span><br><span class="line">        right_tail = <span class="literal">None</span>                 <span class="comment"># 大于等于x的链表尾指针</span></span><br><span class="line">        </span><br><span class="line">        next_node = <span class="literal">None</span>                  <span class="comment"># 临时保存下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历原链表，分离节点</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点</span></span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span>              <span class="comment"># 断开当前节点的连接</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:              <span class="comment"># 当前节点值小于x</span></span><br><span class="line">                <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 左链表为空</span></span><br><span class="line">                    left_head = head      <span class="comment"># 设置左链表头节点</span></span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 左链表非空</span></span><br><span class="line">                    left_tail.<span class="built_in">next</span> = head <span class="comment"># 连接到左链表尾部</span></span><br><span class="line">                left_tail = head          <span class="comment"># 更新左链表尾指针</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 当前节点值大于等于x</span></span><br><span class="line">                <span class="keyword">if</span> right_head <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 右链表为空</span></span><br><span class="line">                    right_head = head     <span class="comment"># 设置右链表头节点</span></span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 右链表非空</span></span><br><span class="line">                    right_tail.<span class="built_in">next</span> = head <span class="comment"># 连接到右链表尾部</span></span><br><span class="line">                right_tail = head         <span class="comment"># 更新右链表尾指针</span></span><br><span class="line">            </span><br><span class="line">            head = next_node              <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 连接两个链表</span></span><br><span class="line">        <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:            <span class="comment"># 如果左链表为空</span></span><br><span class="line">            <span class="keyword">return</span> right_head             <span class="comment"># 直接返回右链表</span></span><br><span class="line">        <span class="keyword">else</span>:                            <span class="comment"># 左链表非空</span></span><br><span class="line">            left_tail.<span class="built_in">next</span> = right_head   <span class="comment"># 连接左右链表</span></span><br><span class="line">            <span class="keyword">return</span> left_head              <span class="comment"># 返回左链表头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="代码修正与完善"><a href="#代码修正与完善" class="headerlink" title="代码修正与完善"></a>代码修正与完善</h2><p>优化了原代码在遍历阶段的指针指代可能不清晰的问题，修改了if else后的指定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition_corrected</span>(<span class="params">head, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分链表 - 修正版本</span></span><br><span class="line"><span class="string">        修复了原代码的语法错误和逻辑问题</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化四个指针</span></span><br><span class="line">        left_head = left_tail = <span class="literal">None</span>      <span class="comment"># 小于x的链表头尾指针</span></span><br><span class="line">        right_head = right_tail = <span class="literal">None</span>    <span class="comment"># 大于等于x的链表头尾指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历原链表</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点</span></span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span>              <span class="comment"># 断开当前节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:              <span class="comment"># 节点值小于x</span></span><br><span class="line">                <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 第一个小于x的节点</span></span><br><span class="line">                    left_head = left_tail = head</span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 后续小于x的节点</span></span><br><span class="line">                    left_tail.<span class="built_in">next</span> = head</span><br><span class="line">                    left_tail = head</span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 节点值大于等于x</span></span><br><span class="line">                <span class="keyword">if</span> right_head <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 第一个大于等于x的节点</span></span><br><span class="line">                    right_head = right_tail = head</span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 后续大于等于x的节点</span></span><br><span class="line">                    right_tail.<span class="built_in">next</span> = head</span><br><span class="line">                    right_tail = head</span><br><span class="line">            </span><br><span class="line">            head = next_node              <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 合并两个链表</span></span><br><span class="line">        <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:            <span class="comment"># 只有大于等于x的节点</span></span><br><span class="line">            <span class="keyword">return</span> right_head</span><br><span class="line">        </span><br><span class="line">        left_tail.<span class="built_in">next</span> = right_head       <span class="comment"># 连接两个链表</span></span><br><span class="line">        <span class="keyword">return</span> left_head                  <span class="comment"># 返回结果链表头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="优化版本：使用虚拟头节点"><a href="#优化版本：使用虚拟头节点" class="headerlink" title="优化版本：使用虚拟头节点"></a>优化版本：使用虚拟头节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition_optimized</span>(<span class="params">head, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    划分链表 - 优化版本</span></span><br><span class="line"><span class="string">    使用虚拟头节点简化代码逻辑，简化了边界处理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建虚拟头节点</span></span><br><span class="line">    left_dummy = ListNode(<span class="number">0</span>)          <span class="comment"># 小于x链表的虚拟头节点</span></span><br><span class="line">    right_dummy = ListNode(<span class="number">0</span>)         <span class="comment"># 大于等于x链表的虚拟头节点</span></span><br><span class="line">    </span><br><span class="line">    left = left_dummy                 <span class="comment"># 小于x链表的当前指针</span></span><br><span class="line">    right = right_dummy               <span class="comment"># 大于等于x链表的当前指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历原链表，分配节点</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">            left.<span class="built_in">next</span> = head          <span class="comment"># 连接到左链表</span></span><br><span class="line">            left = left.<span class="built_in">next</span>          <span class="comment"># 移动左指针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.<span class="built_in">next</span> = head         <span class="comment"># 连接到右链表</span></span><br><span class="line">            right = right.<span class="built_in">next</span>        <span class="comment"># 移动右指针</span></span><br><span class="line">        head = head.<span class="built_in">next</span>              <span class="comment"># 移动原链表指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 断开右链表的尾部连接，防止环</span></span><br><span class="line">    right.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接两个链表</span></span><br><span class="line">    left.<span class="built_in">next</span> = right_dummy.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left_dummy.<span class="built_in">next</span>            <span class="comment"># 返回真正的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原链表: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span><br><span class="line">划分值: x = 3</span><br><span class="line"></span><br><span class="line">分离过程:</span><br><span class="line">节点1 &lt; 3: 左链表 = 1</span><br><span class="line">节点4 &gt;= 3: 右链表 = 4  </span><br><span class="line">节点3 &gt;= 3: 右链表 = 4 -&gt; 3</span><br><span class="line">节点2 &lt; 3: 左链表 = 1 -&gt; 2</span><br><span class="line">节点5 &gt;= 3: 右链表 = 4 -&gt; 3 -&gt; 5</span><br><span class="line">节点2 &lt; 3: 左链表 = 1 -&gt; 2 -&gt; 2</span><br><span class="line"></span><br><span class="line">最终结果: 1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</span><br></pre></td></tr></table></figure>

<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><ol>
<li><strong>稳定性</strong>：保持原有的相对顺序</li>
<li><strong>原地操作</strong>：只调整指针，不创建新节点</li>
<li><strong>时间效率</strong>：单次遍历，O(n)时间复杂度</li>
<li><strong>空间效率</strong>：只使用常数额外空间</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><strong>链表排序的预处理</strong>：快速排序的分区操作</li>
<li><strong>数据分类</strong>：按条件将数据分为两组</li>
<li><strong>链表重组</strong>：根据特定规则重新排列链表节点</li>
</ol>
<hr>
<h1 id="链表操作技巧拓展"><a href="#链表操作技巧拓展" class="headerlink" title="链表操作技巧拓展"></a>链表操作技巧拓展</h1><h2 id="核心技巧与模式"><a href="#核心技巧与模式" class="headerlink" title="核心技巧与模式"></a>核心技巧与模式</h2><h3 id="1-双指针技术"><a href="#1-双指针技术" class="headerlink" title="1. 双指针技术"></a>1. 双指针技术</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_pointer_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    双指针模式：快慢指针、左右指针等</span></span><br><span class="line"><span class="string">    常用于链表中点查找、环检测、倒数第k个节点等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    slow = fast = head                    <span class="comment"># 快慢指针初始化</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>                  <span class="comment"># 慢指针每次移动1步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>             <span class="comment"># 快指针每次移动2步</span></span><br><span class="line">    <span class="keyword">return</span> slow                           <span class="comment"># 返回中点或其他目标位置</span></span><br></pre></td></tr></table></figure>

<h3 id="2-虚拟头节点"><a href="#2-虚拟头节点" class="headerlink" title="2. 虚拟头节点"></a>2. 虚拟头节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dummy_head_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    虚拟头节点模式：简化头节点的特殊处理</span></span><br><span class="line"><span class="string">    特别适用于可能删除头节点或构建新链表的场景</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)                   <span class="comment"># 创建虚拟头节点</span></span><br><span class="line">    dummy.<span class="built_in">next</span> = head                     <span class="comment"># 连接原链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在这里进行各种操作</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>                     <span class="comment"># 返回真正的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="3-递归模式"><a href="#3-递归模式" class="headerlink" title="3. 递归模式"></a>3. 递归模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归模式：将复杂问题分解为子问题</span></span><br><span class="line"><span class="string">    适用于链表反转、删除节点、合并等操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基础情况</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归处理子问题</span></span><br><span class="line">    result = recursive_pattern(head.<span class="built_in">next</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理当前层</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="4-节点分离与重组"><a href="#4-节点分离与重组" class="headerlink" title="4. 节点分离与重组"></a>4. 节点分离与重组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">separate_and_merge_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    分离重组模式：将链表按条件分离后重新组合</span></span><br><span class="line"><span class="string">    适用于链表划分、奇偶分离、按值分组等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建多个子链表的头尾指针</span></span><br><span class="line">    list1_head = list1_tail = <span class="literal">None</span></span><br><span class="line">    list2_head = list2_tail = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        next_node = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 断开连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> condition(head):               <span class="comment"># 根据条件分配</span></span><br><span class="line">            <span class="comment"># 添加到list1</span></span><br><span class="line">            <span class="keyword">if</span> list1_head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                list1_head = list1_tail = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                list1_tail.<span class="built_in">next</span> = head</span><br><span class="line">                list1_tail = head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 添加到list2</span></span><br><span class="line">            <span class="keyword">if</span> list2_head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                list2_head = list2_tail = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                list2_tail.<span class="built_in">next</span> = head</span><br><span class="line">                list2_tail = head</span><br><span class="line">        </span><br><span class="line">        head = next_node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重新组合链表</span></span><br><span class="line">    <span class="keyword">if</span> list1_tail:</span><br><span class="line">        list1_tail.<span class="built_in">next</span> = list2_head</span><br><span class="line">    <span class="keyword">return</span> list1_head <span class="keyword">if</span> list1_head <span class="keyword">else</span> list2_head</span><br></pre></td></tr></table></figure>

<h2 id="常见错误与注意事项"><a href="#常见错误与注意事项" class="headerlink" title="常见错误与注意事项"></a>常见错误与注意事项</h2><h3 id="1-空指针处理"><a href="#1-空指针处理" class="headerlink" title="1. 空指针处理"></a>1. 空指针处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrong_example</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span>.val                  <span class="comment"># 可能导致空指针异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确示例  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">correct_example</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:                <span class="comment"># 先检查再访问</span></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span>.val</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="2-内存泄漏防止"><a href="#2-内存泄漏防止" class="headerlink" title="2. 内存泄漏防止"></a>2. 内存泄漏防止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prevent_memory_leak</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    防止内存泄漏：及时断开不需要的连接</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        next_node = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 断开连接，防止环</span></span><br><span class="line">        head = next_node</span><br></pre></td></tr></table></figure>

<h3 id="3-边界情况处理"><a href="#3-边界情况处理" class="headerlink" title="3. 边界情况处理"></a>3. 边界情况处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_edge_cases</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理边界情况：空链表、单节点链表等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 空链表</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常处理逻辑</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h2 id="性能分析与优化"><a href="#性能分析与优化" class="headerlink" title="性能分析与优化"></a>性能分析与优化</h2><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>单次遍历操作</strong>：O(n) - 反转、合并、查找等</li>
<li><strong>嵌套遍历操作</strong>：O(n²) - 某些复杂的链表操作</li>
<li><strong>递归操作</strong>：O(n) - 但需要考虑递归栈空间</li>
</ul>
<h3 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h3><ul>
<li><strong>原地操作</strong>：优先使用指针操作而非创建新节点</li>
<li><strong>迭代替代递归</strong>：在可能的情况下避免递归栈开销</li>
<li><strong>临时变量最小化</strong>：只保存必要的指针变量</li>
</ul>
<h3 id="实际性能考虑"><a href="#实际性能考虑" class="headerlink" title="实际性能考虑"></a>实际性能考虑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">performance_optimized_merge</span>(<span class="params">h1, h2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    性能优化的链表合并</span></span><br><span class="line"><span class="string">    减少条件判断和指针操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    tail = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> h1 <span class="keyword">and</span> h2:</span><br><span class="line">        <span class="keyword">if</span> h1.val &lt;= h2.val:</span><br><span class="line">            tail.<span class="built_in">next</span>, h1 = h1, h1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tail.<span class="built_in">next</span>, h2 = h2, h2.<span class="built_in">next</span></span><br><span class="line">        tail = tail.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 直接连接剩余部分，无需循环</span></span><br><span class="line">    tail.<span class="built_in">next</span> = h1 <span class="keyword">or</span> h2</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%20%E4%BA%8C%E8%BF%9B%E5%88%B6&%E4%BD%8D%E8%BF%90%E7%AE%97&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%20%E4%BA%8C%E8%BF%9B%E5%88%B6&%E4%BD%8D%E8%BF%90%E7%AE%97&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（1）- 二进制&位运算&排序算法&二分搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-30 18:42:46" itemprop="dateCreated datePublished" datetime="2025-07-30T18:42:46+08:00">2025-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:27:19" itemprop="dateModified" datetime="2025-08-05T16:27:19+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了class002 -&gt; class 007的内容，涵盖了社会实验模拟、位运算、基础排序算法、算法验证方法、二分搜索以及复杂度分析等核心内容。</p>
<p>原代码是java版，我改成了python</p>
<hr>
<h1 id="002【入门】从社会实验到入门提醒"><a href="#002【入门】从社会实验到入门提醒" class="headerlink" title="002【入门】从社会实验到入门提醒"></a>002【入门】从社会实验到入门提醒</h1><h2 id="基尼系数的理论基础"><a href="#基尼系数的理论基础" class="headerlink" title="基尼系数的理论基础"></a>基尼系数的理论基础</h2><p>基尼系数是经济学中衡量收入分配不平等程度的重要指标，其数学定义为：</p>
<p>$$<br>G &#x3D; \frac{\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}|x_i - x_j|}{2n\sum_{i&#x3D;1}^{n}x_i}<br>$$</p>
<p>其中 $x_i$ 表示第 $i$ 个个体的财富值，$n$ 为总人数。</p>
<h3 id="基尼系数的经济学意义"><a href="#基尼系数的经济学意义" class="headerlink" title="基尼系数的经济学意义"></a>基尼系数的经济学意义</h3><ul>
<li><strong>G &#x3D; 0</strong>：完全平等，所有人财富相同</li>
<li><strong>G &#x3D; 1</strong>：完全不平等，一人拥有全部财富  </li>
<li><strong>G &#x3D; 0.4-0.5</strong>：国际公认的贫富差距警戒线</li>
<li><strong>G &gt; 0.5</strong>：社会可能面临动荡风险</li>
</ul>
<h2 id="财富分配模拟实验"><a href="#财富分配模拟实验" class="headerlink" title="财富分配模拟实验"></a>财富分配模拟实验</h2><p>通过计算机模拟研究在完全随机的财富转移过程中，社会财富分配的自然演化规律。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_gini</span>(<span class="params">wealth</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算基尼系数的函数</span></span><br><span class="line"><span class="string">    参数: wealth - 财富分布列表</span></span><br><span class="line"><span class="string">    返回: 基尼系数值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(wealth)                        <span class="comment"># 获取人数</span></span><br><span class="line">    sum_of_wealth = <span class="built_in">sum</span>(wealth)            <span class="comment"># 计算总财富</span></span><br><span class="line">    sum_of_absolute_differences = <span class="number">0</span>        <span class="comment"># 初始化财富差异总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算所有个体间财富差异的绝对值之和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_of_absolute_differences += <span class="built_in">abs</span>(wealth[i] - wealth[j])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据基尼系数公式计算并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> sum_of_absolute_differences / (<span class="number">2</span> * n * sum_of_wealth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">experiment</span>(<span class="params">n, t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    财富分配模拟实验</span></span><br><span class="line"><span class="string">    参数: n - 人数, t - 模拟轮数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    wealth = [<span class="number">100</span>] * n                     <span class="comment"># 初始化每人财富为100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):                     <span class="comment"># 进行t轮模拟</span></span><br><span class="line">        has_money = [w &gt; <span class="number">0</span> <span class="keyword">for</span> w <span class="keyword">in</span> wealth]  <span class="comment"># 判断每个人是否有钱可转</span></span><br><span class="line">        transfers = []                     <span class="comment"># 记录本轮转账列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):                 <span class="comment"># 遍历每个人</span></span><br><span class="line">            <span class="keyword">if</span> has_money[j]:               <span class="comment"># 如果该人有钱</span></span><br><span class="line">                other = j                  <span class="comment"># 初始化接收者为自己</span></span><br><span class="line">                <span class="keyword">while</span> other == j:          <span class="comment"># 确保接收者不是自己</span></span><br><span class="line">                    other = random.randint(<span class="number">0</span>, n - <span class="number">1</span>)  <span class="comment"># 随机选择其他人</span></span><br><span class="line">                transfers.append((j, other))          <span class="comment"># 记录转账关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统一执行所有转账，避免执行顺序影响结果</span></span><br><span class="line">        <span class="keyword">for</span> giver, receiver <span class="keyword">in</span> transfers:</span><br><span class="line">            wealth[giver] -= <span class="number">1</span>             <span class="comment"># 转出者财富减1</span></span><br><span class="line">            wealth[receiver] += <span class="number">1</span>          <span class="comment"># 接收者财富加1</span></span><br><span class="line">    </span><br><span class="line">    wealth.sort()                          <span class="comment"># 按财富排序便于观察分布</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出结果分析</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;财富分布(从贫穷到富有):&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> idx, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(wealth):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">int</span>(w), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">9</span>:                  <span class="comment"># 每10个数换行</span></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;社会基尼系数:&quot;</span>, calculate_gini(wealth))</span><br></pre></td></tr></table></figure>

<h3 id="实验意义与启示"><a href="#实验意义与启示" class="headerlink" title="实验意义与启示"></a>实验意义与启示</h3><ol>
<li><strong>随机性中的必然性</strong>：即使在完全公平的随机转移规则下，财富差距仍会自然产生</li>
<li><strong>马太效应</strong>：财富分配存在自然的分化趋势</li>
<li><strong>社会政策启示</strong>：需要主动的调节机制来维护社会公平</li>
</ol>
<hr>
<h1 id="003【入门】二进制和位运算"><a href="#003【入门】二进制和位运算" class="headerlink" title="003【入门】二进制和位运算"></a>003【入门】二进制和位运算</h1><h2 id="计算机数值表示系统"><a href="#计算机数值表示系统" class="headerlink" title="计算机数值表示系统"></a>计算机数值表示系统</h2><h3 id="正数的二进制表示"><a href="#正数的二进制表示" class="headerlink" title="正数的二进制表示"></a>正数的二进制表示</h3><p>正数采用标准的二进制表示法，最高位为符号位（0表示正数）。</p>
<h3 id="负数的补码表示"><a href="#负数的补码表示" class="headerlink" title="负数的补码表示"></a>负数的补码表示</h3><p>负数采用补码（Two’s Complement）表示：</p>
<ul>
<li>原码按位取反</li>
<li>结果加1</li>
</ul>
<p>$$<br>\text{负数补码} &#x3D; \sim(\text{原码}) + 1<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_binary</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    打印32位二进制表示</span></span><br><span class="line"><span class="string">    参数: num - 要打印的整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span>                                 <span class="comment"># 初始化二进制字符串</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):           <span class="comment"># 从最高位到最低位遍历</span></span><br><span class="line">        <span class="comment"># 通过位与运算判断第i位是否为1</span></span><br><span class="line">        s += <span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)                              <span class="comment"># 输出32位二进制表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示正负数的二进制表示</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = <span class="number">78</span>                                <span class="comment"># 正数示例</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正数<span class="subst">&#123;a&#125;</span>的二进制表示:&quot;</span>)</span><br><span class="line">    print_binary(a)</span><br><span class="line">    </span><br><span class="line">    b = -<span class="number">6</span>                                <span class="comment"># 负数示例  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;负数<span class="subst">&#123;b&#125;</span>的二进制表示:&quot;</span>)</span><br><span class="line">    print_binary(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证补码计算</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;~<span class="subst">&#123;a&#125;</span> + 1 = <span class="subst">&#123;~a + <span class="number">1</span>&#125;</span>&quot;</span>)        <span class="comment"># 计算a的相反数</span></span><br><span class="line">    print_binary(~a + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="核心位运算操作"><a href="#核心位运算操作" class="headerlink" title="核心位运算操作"></a>核心位运算操作</h2><h3 id="基本位运算符详解"><a href="#基本位运算符详解" class="headerlink" title="基本位运算符详解"></a>基本位运算符详解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bitwise_operations_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位运算操作演示&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;0b 是Python中表示二进制数字的前缀。&#x27;&#x27;&#x27;</span></span><br><span class="line">    g = <span class="number">0b0001010</span>                         <span class="comment"># 二进制字面量：10</span></span><br><span class="line">    h = <span class="number">0b0001100</span>                         <span class="comment"># 二进制字面量：12</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;操作数g:&quot;</span>, <span class="built_in">bin</span>(g))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;操作数h:&quot;</span>, <span class="built_in">bin</span>(h))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按位或运算：有1则1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g | h  =&quot;</span>, <span class="built_in">bin</span>(g | h))         <span class="comment"># 0b1110 = 14</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按位与运算：全1则1  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g &amp; h  =&quot;</span>, <span class="built_in">bin</span>(g &amp; h))         <span class="comment"># 0b1000 = 8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按位异或运算：不同则1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g ^ h  =&quot;</span>, <span class="built_in">bin</span>(g ^ h))         <span class="comment"># 0b0110 = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shift_operations_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;移位运算演示&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0b0011010</span>                         <span class="comment"># 二进制：26</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;原数: <span class="subst">&#123;i&#125;</span>, 二进制: <span class="subst">&#123;<span class="built_in">bin</span>(i)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 左移运算：相当于乘以2的幂次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> &lt;&lt; 1 = <span class="subst">&#123;i &lt;&lt; <span class="number">1</span>&#125;</span>&quot;</span>)        <span class="comment"># 26 * 2 = 52</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> &lt;&lt; 2 = <span class="subst">&#123;i &lt;&lt; <span class="number">2</span>&#125;</span>&quot;</span>)        <span class="comment"># 26 * 4 = 104  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> &lt;&lt; 3 = <span class="subst">&#123;i &lt;&lt; <span class="number">3</span>&#125;</span>&quot;</span>)        <span class="comment"># 26 * 8 = 208</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 右移运算：相当于除以2的幂次（向下取整）</span></span><br><span class="line">    k = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> &gt;&gt; 1 = <span class="subst">&#123;k &gt;&gt; <span class="number">1</span>&#125;</span>&quot;</span>)        <span class="comment"># 10 / 2 = 5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> &gt;&gt; 2 = <span class="subst">&#123;k &gt;&gt; <span class="number">2</span>&#125;</span>&quot;</span>)        <span class="comment"># 10 / 4 = 2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> &gt;&gt; 3 = <span class="subst">&#123;k &gt;&gt; <span class="number">3</span>&#125;</span>&quot;</span>)        <span class="comment"># 10 / 8 = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算与位运算的重要区别"><a href="#逻辑运算与位运算的重要区别" class="headerlink" title="逻辑运算与位运算的重要区别"></a>逻辑运算与位运算的重要区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">return_true</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行了return_true函数&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_false</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行了return_false函数&quot;</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logical_vs_bitwise</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;演示逻辑运算与位运算的区别&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 位运算测试 ===&quot;</span>)</span><br><span class="line">    <span class="comment"># 位运算：两个函数都会被调用</span></span><br><span class="line">    test1 = return_true() | return_false()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位运算结果: <span class="subst">&#123;test1&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 逻辑运算测试 ===&quot;</span>) </span><br><span class="line">    <span class="comment"># 逻辑运算：存在短路求值，第二个函数可能不被调用</span></span><br><span class="line">    test2 = return_true() <span class="keyword">or</span> return_false()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;逻辑运算结果: <span class="subst">&#123;test2&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="位运算的实际应用"><a href="#位运算的实际应用" class="headerlink" title="位运算的实际应用"></a>位运算的实际应用</h3><ol>
<li><strong>快速乘除法</strong>：左移代替乘法，右移代替除法</li>
<li><strong>奇偶性判断</strong>：<code>num &amp; 1 == 0</code> 判断偶数。这是因为：num &amp; 1 只保留 num 的二进制最低位，其余全部变成0。</li>
<li><strong>集合操作</strong>：用位掩码表示集合的并、交、差运算</li>
<li><strong>状态压缩</strong>：在动态规划中压缩状态空间</li>
</ol>
<hr>
<h1 id="004【入门】选择、冒泡、插入排序"><a href="#004【入门】选择、冒泡、插入排序" class="headerlink" title="004【入门】选择、冒泡、插入排序"></a>004【入门】选择、冒泡、插入排序</h1><h2 id="理解python中的class：什么是“实例化类”？"><a href="#理解python中的class：什么是“实例化类”？" class="headerlink" title="理解python中的class：什么是“实例化类”？"></a>理解python中的class：什么是“实例化类”？</h2><ul>
<li>类（class）：可以理解为一个“模具”或者“模板”，描述一类对象应该有哪些属性和行为。</li>
<li>实例（instance）：就是根据这个“模具”制造出来的一个具体的“物品”。</li>
<li>实例化：把类变成实例（对象）的过程，叫做实例化。</li>
</ul>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每次从未排序部分选择最小（或最大）元素，将其放置到已排序部分的末尾。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>比较次数</strong>：$\sum_{i&#x3D;0}^{n-2}(n-1-i) &#x3D; \frac{n(n-1)}{2} &#x3D; O(n^2)$</li>
<li><strong>交换次数</strong>：$O(n)$</li>
<li><strong>总体复杂度</strong>：$O(n^2)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span>:</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        交换数组中两个位置的元素</span></span><br><span class="line"><span class="string">        参数: arr - 数组, i,j - 要交换的索引</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        arr[i], arr[j] = arr[j], arr[i]  <span class="comment"># Python的元组赋值交换</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选择排序实现</span></span><br><span class="line"><span class="string">        时间复杂度: O(n²), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        不稳定排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:   <span class="comment"># 边界条件检查</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 外层循环控制已排序部分的边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">            min_index = i                  <span class="comment"># 假设当前位置为最小值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 内层循环在未排序部分寻找真正的最小值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt; arr[min_index]:  <span class="comment"># 找到更小的元素</span></span><br><span class="line">                    min_index = j           <span class="comment"># 更新最小值索引</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将找到的最小值与当前位置交换</span></span><br><span class="line">            SortingAlgorithms.swap(arr, i, min_index)</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>重复遍历数组，比较相邻元素并在必要时交换，使得大元素逐渐”冒泡”到数组末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冒泡排序实现</span></span><br><span class="line"><span class="string">    时间复杂度: O(n²), 空间复杂度: O(1)  </span></span><br><span class="line"><span class="string">    稳定排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:   <span class="comment"># 边界条件检查</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环控制未排序部分的右边界</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内层循环进行相邻元素比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(end):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:    <span class="comment"># 如果前面元素大于后面元素</span></span><br><span class="line">                SortingAlgorithms.swap(arr, i, i + <span class="number">1</span>)  <span class="comment"># 交换位置</span></span><br><span class="line">                <span class="comment"># 经过一轮后，最大元素&quot;冒泡&quot;到末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_optimized</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化版冒泡排序：添加提前终止条件</span></span><br><span class="line"><span class="string">    如果某轮遍历中没有发生交换，说明数组已有序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        swapped = <span class="literal">False</span>               <span class="comment"># 标记本轮是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(end):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                SortingAlgorithms.swap(arr, i, i + <span class="number">1</span>)</span><br><span class="line">                swapped = <span class="literal">True</span>        <span class="comment"># 发生了交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:               <span class="comment"># 如果本轮没有交换</span></span><br><span class="line">            <span class="keyword">break</span>                     <span class="comment"># 数组已有序，提前结束</span></span><br></pre></td></tr></table></figure>

<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>将数组分为已排序和未排序两部分，依次将未排序元素插入到已排序部分的正确位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序实现</span></span><br><span class="line"><span class="string">    时间复杂度: 最坏O(n²), 最好O(n), 平均O(n²)</span></span><br><span class="line"><span class="string">    空间复杂度: O(1)</span></span><br><span class="line"><span class="string">    稳定排序，对小规模或近似有序数据效率高</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:   <span class="comment"># 边界条件检查</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从第二个元素开始，逐个插入到已排序部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 从当前位置向前比较，寻找插入位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:    <span class="comment"># 如果前面元素大于后面元素</span></span><br><span class="line">                SortingAlgorithms.swap(arr, j, j + <span class="number">1</span>)  <span class="comment"># 交换位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>                  <span class="comment"># 找到正确位置，提前结束内层循环</span></span><br></pre></td></tr></table></figure>

<h3 id="插入排序的另一种实现"><a href="#插入排序的另一种实现" class="headerlink" title="插入排序的另一种实现"></a>插入排序的另一种实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort_v2</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序的另一种实现：先保存要插入的元素，然后移动其他元素</span></span><br><span class="line"><span class="string">    减少交换次数，提高效率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]                  <span class="comment"># 保存要插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span>                     <span class="comment"># 从已排序部分的末尾开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向右移动大于key的元素</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]       <span class="comment"># 元素后移</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        arr[j + <span class="number">1</span>] = key              <span class="comment"># 插入key到正确位置</span></span><br></pre></td></tr></table></figure>

<h2 id="排序算法性能对比"><a href="#排序算法性能对比" class="headerlink" title="排序算法性能对比"></a>排序算法性能对比</h2><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度(最好)</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
</tbody></table>
<hr>
<h1 id="005【入门】对数器-验证的重要手段"><a href="#005【入门】对数器-验证的重要手段" class="headerlink" title="005【入门】对数器-验证的重要手段"></a>005【入门】对数器-验证的重要手段</h1><h2 id="对数器的理论基础"><a href="#对数器的理论基础" class="headerlink" title="对数器的理论基础"></a>对数器的理论基础</h2><p>对数器（Logarithmic Validator）是一种系统性验证算法正确性的重要工具，通过大量随机测试用例来检验算法实现的可靠性。</p>
<h3 id="对数器设计的六个核心原则"><a href="#对数器设计的六个核心原则" class="headerlink" title="对数器设计的六个核心原则"></a>对数器设计的六个核心原则</h3><ol>
<li><strong>确定待测算法a</strong>：需要验证正确性的高效算法</li>
<li><strong>实现简单算法b</strong>：复杂度可能不优但逻辑简单、容易验证正确的算法  </li>
<li><strong>构建随机样本生成器</strong>：能够产生各种边界情况的测试数据</li>
<li><strong>对比验证</strong>：在相同输入下比较两种算法的输出结果</li>
<li><strong>错误定位</strong>：当发现不一致时，人工分析并修正错误</li>
<li><strong>大规模验证</strong>：通过大量测试建立对算法正确性的信心</li>
</ol>
<h2 id="对数器实现框架（以上节课的三种排序方法为例）"><a href="#对数器实现框架（以上节课的三种排序方法为例）" class="headerlink" title="对数器实现框架（以上节课的三种排序方法为例）"></a>对数器实现框架（以上节课的三种排序方法为例）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlgorithmValidator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;算法验证器类&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">random_array</span>(<span class="params">n, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成随机数组</span></span><br><span class="line"><span class="string">        参数: n - 数组长度, v - 元素值域[1,v]</span></span><br><span class="line"><span class="string">        返回: 长度为n的随机数组</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用列表推导式生成随机数组</span></span><br><span class="line">        <span class="keyword">return</span> [random.randint(<span class="number">1</span>, v) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy_array</span>(<span class="params">arr</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        数组深拷贝</span></span><br><span class="line"><span class="string">        参数: arr - 原数组</span></span><br><span class="line"><span class="string">        返回: 原数组的副本</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> arr[:]                     <span class="comment"># 切片操作创建新列表</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrays_equal</span>(<span class="params">arr1, arr2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        比较两个数组是否相等</span></span><br><span class="line"><span class="string">        参数: arr1, arr2 - 待比较的数组</span></span><br><span class="line"><span class="string">        返回: 布尔值表示是否相等</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr1) != <span class="built_in">len</span>(arr2):        <span class="comment"># 长度不等直接返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 逐元素比较</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(arr1, arr2):</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">comprehensive_sort_test</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        排序算法综合测试</span></span><br><span class="line"><span class="string">        使用对数器方法验证多种排序算法的正确性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 测试参数配置</span></span><br><span class="line">        N = <span class="number">200</span>                          <span class="comment"># 数组最大长度</span></span><br><span class="line">        V = <span class="number">1000</span>                         <span class="comment"># 元素最大值</span></span><br><span class="line">        test_times = <span class="number">50000</span>               <span class="comment"># 测试次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;算法验证开始...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> test_round <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">            <span class="comment"># 生成随机测试用例</span></span><br><span class="line">            n = random.randint(<span class="number">0</span>, N - <span class="number">1</span>)  <span class="comment"># 随机数组长度</span></span><br><span class="line">            arr = AlgorithmValidator.random_array(n, V)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 创建多个数组副本用于不同算法测试</span></span><br><span class="line">            arr_selection = AlgorithmValidator.copy_array(arr)</span><br><span class="line">            arr_bubble = AlgorithmValidator.copy_array(arr)  </span><br><span class="line">            arr_insertion = AlgorithmValidator.copy_array(arr)</span><br><span class="line">            arr_builtin = AlgorithmValidator.copy_array(arr)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 应用不同排序算法</span></span><br><span class="line">            SortingAlgorithms.selection_sort(arr_selection)</span><br><span class="line">            SortingAlgorithms.bubble_sort(arr_bubble)</span><br><span class="line">            SortingAlgorithms.insertion_sort(arr_insertion)</span><br><span class="line">            arr_builtin.sort()            <span class="comment"># Python内置排序作为标准答案</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 结果一致性验证</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (AlgorithmValidator.arrays_equal(arr_selection, arr_builtin) <span class="keyword">and</span></span><br><span class="line">                    AlgorithmValidator.arrays_equal(arr_bubble, arr_builtin) <span class="keyword">and</span>  </span><br><span class="line">                    AlgorithmValidator.arrays_equal(arr_insertion, arr_builtin)):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 发现错误时输出详细信息</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;发现算法错误!&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;测试轮次: <span class="subst">&#123;test_round + <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;原始数组: <span class="subst">&#123;arr&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;选择排序: <span class="subst">&#123;arr_selection&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;冒泡排序: <span class="subst">&#123;arr_bubble&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;插入排序: <span class="subst">&#123;arr_insertion&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;内置排序: <span class="subst">&#123;arr_builtin&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 每完成1000次测试输出进度</span></span><br><span class="line">            <span class="keyword">if</span> (test_round + <span class="number">1</span>) % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;已完成 <span class="subst">&#123;test_round + <span class="number">1</span>&#125;</span> 次测试...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;所有测试通过！算法实现正确。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="对数器方法的优势"><a href="#对数器方法的优势" class="headerlink" title="对数器方法的优势"></a>对数器方法的优势</h3><ol>
<li><strong>自动化验证</strong>：减少人工测试的工作量和错误率</li>
<li><strong>覆盖边界情况</strong>：随机生成能够触及各种极端情况</li>
<li><strong>置信度建立</strong>：大量测试通过后可以高度确信算法正确性</li>
<li><strong>错误定位</strong>：一旦发现问题能够提供具体的错误样例</li>
</ol>
<hr>
<h1 id="006【入门】二分搜索"><a href="#006【入门】二分搜索" class="headerlink" title="006【入门】二分搜索"></a>006【入门】二分搜索</h1><h2 id="二分搜索的数学基础"><a href="#二分搜索的数学基础" class="headerlink" title="二分搜索的数学基础"></a>二分搜索的数学基础</h2><p>二分搜索基于<strong>分治思想</strong>，每次将搜索空间减半，时间复杂度为 $O(\log n)$。</p>
<p>设数组长度为 $n$，经过 $k$ 次二分后搜索空间大小为 $\frac{n}{2^k}$，当搜索空间减小到1时：</p>
<p>$$\frac{n}{2^k} &#x3D; 1 \Rightarrow k &#x3D; \log_2 n$$</p>
<h2 id="基础二分搜索"><a href="#基础二分搜索" class="headerlink" title="基础二分搜索"></a>基础二分搜索</h2><h3 id="问题：判断有序数组中是否存在目标值"><a href="#问题：判断有序数组中是否存在目标值" class="headerlink" title="问题：判断有序数组中是否存在目标值"></a>问题：判断有序数组中是否存在目标值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_exist</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在有序数组中查找目标值是否存在</span></span><br><span class="line"><span class="string">    参数: arr - 有序数组, target - 目标值</span></span><br><span class="line"><span class="string">    返回: True/False 表示是否存在</span></span><br><span class="line"><span class="string">    时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:      <span class="comment"># 边界条件：空数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>         <span class="comment"># 初始化搜索边界[left, right]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:                  <span class="comment"># 搜索空间非空时继续</span></span><br><span class="line">        <span class="comment"># 防止整数溢出的中点计算方法</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span>   <span class="comment"># 等价于 (left + right) // 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:            <span class="comment"># 找到目标值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; target:           <span class="comment"># 目标值在左半部分</span></span><br><span class="line">            right = mid - <span class="number">1</span>               <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 目标值在右半部分  </span></span><br><span class="line">            left = mid + <span class="number">1</span>                <span class="comment"># 收缩左边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>                          <span class="comment"># 搜索完毕未找到</span></span><br></pre></td></tr></table></figure>

<h3 id="暴力验证方法"><a href="#暴力验证方法" class="headerlink" title="暴力验证方法"></a>暴力验证方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search_exist</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    线性搜索验证方法</span></span><br><span class="line"><span class="string">    用于对数器验证二分搜索的正确性</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> arr:                   <span class="comment"># 遍历数组每个元素</span></span><br><span class="line">        <span class="keyword">if</span> element == target:             <span class="comment"># 找到目标值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>                          <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure>

<h2 id="二分搜索的边界查找变种"><a href="#二分搜索的边界查找变种" class="headerlink" title="二分搜索的边界查找变种"></a>二分搜索的边界查找变种</h2><h3 id="查找左边界：-target的最左位置"><a href="#查找左边界：-target的最左位置" class="headerlink" title="查找左边界：&gt;&#x3D;target的最左位置"></a>查找左边界：&gt;&#x3D;target的最左位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在有序数组中查找 &gt;= target 的最左位置</span></span><br><span class="line"><span class="string">    参数: arr - 有序数组, target - 目标值</span></span><br><span class="line"><span class="string">    返回: 满足条件的最左索引，不存在返回-1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    ans = -<span class="number">1</span>                              <span class="comment"># 记录答案，初始化为-1表示未找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:            <span class="comment"># 当前元素满足条件</span></span><br><span class="line">            ans = mid                     <span class="comment"># 更新答案</span></span><br><span class="line">            right = mid - <span class="number">1</span>               <span class="comment"># 继续在左半部分寻找更左的位置</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 当前元素小于target</span></span><br><span class="line">            left = mid + <span class="number">1</span>                <span class="comment"># 在右半部分继续搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search_left_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性搜索验证：查找&gt;=target的最左位置&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):             <span class="comment"># 从左到右遍历</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt;= target:              <span class="comment"># 找到第一个满足条件的位置</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                             <span class="comment"># 未找到</span></span><br></pre></td></tr></table></figure>

<h3 id="查找右边界："><a href="#查找右边界：" class="headerlink" title="查找右边界：&lt;&#x3D;target的最右位置"></a>查找右边界：&lt;&#x3D;target的最右位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在有序数组中查找 &lt;= target 的最右位置</span></span><br><span class="line"><span class="string">    参数: arr - 有序数组, target - 目标值  </span></span><br><span class="line"><span class="string">    返回: 满足条件的最右索引，不存在返回-1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    ans = -<span class="number">1</span>                              <span class="comment"># 记录答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt;= target:            <span class="comment"># 当前元素满足条件</span></span><br><span class="line">            ans = mid                     <span class="comment"># 更新答案</span></span><br><span class="line">            left = mid + <span class="number">1</span>                <span class="comment"># 继续在右半部分寻找更右的位置</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 当前元素大于target</span></span><br><span class="line">            right = mid - <span class="number">1</span>               <span class="comment"># 在左半部分继续搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search_right_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性搜索验证：查找&lt;=target的最右位置&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 从右到左遍历</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= target:              <span class="comment"># 找到第一个满足条件的位置</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                             <span class="comment"># 未找到</span></span><br></pre></td></tr></table></figure>

<h2 id="峰值元素查找"><a href="#峰值元素查找" class="headerlink" title="峰值元素查找"></a>峰值元素查找</h2><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>在数组中找到任意一个峰值元素（比左右邻居都大的元素），假设边界外的元素为负无穷。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_peak_element</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找数组中的峰值元素</span></span><br><span class="line"><span class="string">    参数: arr - 整数数组（相邻元素不相等）</span></span><br><span class="line"><span class="string">    返回: 任意峰值元素的索引</span></span><br><span class="line"><span class="string">    时间复杂度: O(log n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 边界情况处理</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:                            <span class="comment"># 单元素数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>]:                   <span class="comment"># 第一个元素是峰值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> arr[n-<span class="number">1</span>] &gt; arr[n-<span class="number">2</span>]:              <span class="comment"># 最后一个元素是峰值</span></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在 [1, n-2] 范围内二分搜索</span></span><br><span class="line">    left, right = <span class="number">1</span>, n - <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid-<span class="number">1</span>] &gt; arr[mid]:         <span class="comment"># 左邻居更大，峰值在左半部分</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; arr[mid+<span class="number">1</span>]:       <span class="comment"># 右邻居更大，峰值在右半部分  </span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># arr[mid-1] &lt; arr[mid] &gt; arr[mid+1]</span></span><br><span class="line">            <span class="keyword">return</span> mid                    <span class="comment"># 找到峰值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                             <span class="comment"># 理论上不会到达这里</span></span><br></pre></td></tr></table></figure>

<h3 id="峰值查找的正确性证明"><a href="#峰值查找的正确性证明" class="headerlink" title="峰值查找的正确性证明"></a>峰值查找的正确性证明</h3><p><strong>定理</strong>：在满足相邻元素不相等的数组中，上述算法一定能找到峰值。</p>
<p><strong>证明</strong>：</p>
<ol>
<li>边界已处理端点峰值。</li>
<li>二分查找时，每次都能缩小到含有峰值的半区。</li>
<li>因为每次都“爬坡”，必然最终会达到一个峰值。</li>
<li>相邻元素不等消除了平台的歧义。</li>
<li>因此，算法在O(log n)时间内一定能找到一个峰值。</li>
</ol>
<h2 id="二分搜索验证框架"><a href="#二分搜索验证框架" class="headerlink" title="二分搜索验证框架"></a>二分搜索验证框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_binary_search_algorithms</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分搜索算法综合测试&quot;&quot;&quot;</span></span><br><span class="line">    N = <span class="number">100</span>                               <span class="comment"># 数组最大长度</span></span><br><span class="line">    V = <span class="number">1000</span>                              <span class="comment"># 元素值域</span></span><br><span class="line">    test_times = <span class="number">500000</span>                   <span class="comment"># 测试次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二分搜索算法测试开始...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">        <span class="comment"># 生成随机有序数组</span></span><br><span class="line">        n = random.randint(<span class="number">0</span>, N - <span class="number">1</span>)</span><br><span class="line">        arr = [random.randint(<span class="number">1</span>, V) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        arr.sort()                        <span class="comment"># 确保数组有序</span></span><br><span class="line">        </span><br><span class="line">        target = random.randint(<span class="number">0</span>, V - <span class="number">1</span>) <span class="comment"># 随机目标值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 验证基础二分搜索</span></span><br><span class="line">        <span class="keyword">if</span> binary_search_exist(arr, target) != linear_search_exist(arr, target):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;基础二分搜索错误!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 验证左边界查找    </span></span><br><span class="line">        <span class="keyword">if</span> binary_search_left_bound(arr, target) != linear_search_left_bound(arr, target):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;左边界查找错误!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 验证右边界查找</span></span><br><span class="line">        <span class="keyword">if</span> binary_search_right_bound(arr, target) != linear_search_right_bound(arr, target):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;右边界查找错误!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有二分搜索测试通过!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="007【入门】时间复杂度和空间复杂度"><a href="#007【入门】时间复杂度和空间复杂度" class="headerlink" title="007【入门】时间复杂度和空间复杂度"></a>007【入门】时间复杂度和空间复杂度</h1><h2 id="时间复杂度的数学基础"><a href="#时间复杂度的数学基础" class="headerlink" title="时间复杂度的数学基础"></a>时间复杂度的数学基础</h2><h3 id="渐近记号系统"><a href="#渐近记号系统" class="headerlink" title="渐近记号系统"></a>渐近记号系统</h3><p>设 $f(n)$ 和 $g(n)$ 为定义在正整数集上的函数：</p>
<ul>
<li><strong>大O记号</strong> $O(g(n))$：$f(n) &#x3D; O(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \geq n_0$ 有 $f(n) \leq c \cdot g(n)$</li>
<li><strong>大Ω记号</strong> $\Omega(g(n))$：$f(n) &#x3D; \Omega(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \geq n_0$ 有 $f(n) \geq c \cdot g(n)$  </li>
<li><strong>大Θ记号</strong> $\Theta(g(n))$：$f(n) &#x3D; \Theta(g(n))$ 当且仅当 $f(n) &#x3D; O(g(n))$ 且 $f(n) &#x3D; \Omega(g(n))$</li>
</ul>
<p>其实和泛函的函数的范数有点像，也就是这个映射算是有界的那种感觉。</p>
<h3 id="常见复杂度级别"><a href="#常见复杂度级别" class="headerlink" title="常见复杂度级别"></a>常见复杂度级别</h3><p>$$O(1) &lt; O(\log n) &lt; O(n) &lt; O(n \log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$$</p>
<h2 id="复杂嵌套循环分析"><a href="#复杂嵌套循环分析" class="headerlink" title="复杂嵌套循环分析"></a>复杂嵌套循环分析</h2><h3 id="等差数列型循环"><a href="#等差数列型循环" class="headerlink" title="等差数列型循环"></a>等差数列型循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quadratic_complexity_demo</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示O(n²)时间复杂度</span></span><br><span class="line"><span class="string">    等差数列求和：1 + 2 + ... + n = n(n+1)/2 = O(n²)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    operations = <span class="number">0</span>                        <span class="comment"># 记录操作次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):            <span class="comment"># 外层循环：i从1到N</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N + <span class="number">1</span>):        <span class="comment"># 内层循环：j从i到N</span></span><br><span class="line">            operations += <span class="number">1</span>               <span class="comment"># 模拟一次基本操作</span></span><br><span class="line">            <span class="comment"># 当i=1时，内层执行N次</span></span><br><span class="line">            <span class="comment"># 当i=2时，内层执行N-1次  </span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            <span class="comment"># 当i=N时，内层执行1次</span></span><br><span class="line">            <span class="comment"># 总计：N + (N-1) + ... + 1 = N(N+1)/2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N=<span class="subst">&#123;N&#125;</span>, 总操作次数=<span class="subst">&#123;operations&#125;</span>, 理论值=<span class="subst">&#123;N*(N+<span class="number">1</span>)//<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> operations</span><br></pre></td></tr></table></figure>

<h3 id="调和级数型循环"><a href="#调和级数型循环" class="headerlink" title="调和级数型循环"></a>调和级数型循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">n_log_n_complexity_demo</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示O(n log n)时间复杂度  </span></span><br><span class="line"><span class="string">    调和级数：1 + 1/2 + 1/3 + ... + 1/n ≈ ln(n) = O(log n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    operations = <span class="number">0</span>                        <span class="comment"># 记录操作次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):            <span class="comment"># 外层循环：i从1到N</span></span><br><span class="line">        j = i                             <span class="comment"># 内层循环起始值</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= N:                     <span class="comment"># 按i的倍数递增</span></span><br><span class="line">            operations += <span class="number">1</span>               <span class="comment"># 模拟一次基本操作</span></span><br><span class="line">            j += i                        <span class="comment"># j = i, 2i, 3i, ...</span></span><br><span class="line">            <span class="comment"># 当i=1时，内层执行N次（N/1）</span></span><br><span class="line">            <span class="comment"># 当i=2时，内层执行N/2次</span></span><br><span class="line">            <span class="comment"># 当i=3时，内层执行N/3次</span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            <span class="comment"># 总计：N(1 + 1/2 + 1/3 + ... + 1/N) = N·H_N ≈ N log N</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N=<span class="subst">&#123;N&#125;</span>, 总操作次数=<span class="subst">&#123;operations&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> operations</span><br></pre></td></tr></table></figure>

<h3 id="复杂度实验验证"><a href="#复杂度实验验证" class="headerlink" title="复杂度实验验证"></a>复杂度实验验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">complexity_benchmark</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过实际运行时间验证复杂度分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    test_sizes = [<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">8000</span>]   <span class="comment"># 测试规模</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 复杂度实验验证 ===&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;规模\tO(n²)时间\tO(n log n)时间\t比率&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> N <span class="keyword">in</span> test_sizes:</span><br><span class="line">        <span class="comment"># 测试O(n²)算法</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        quadratic_complexity_demo(N)</span><br><span class="line">        quadratic_time = time.time() - start_time</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 测试O(n log n)算法  </span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        n_log_n_complexity_demo(N)</span><br><span class="line">        n_log_n_time = time.time() - start_time</span><br><span class="line">        </span><br><span class="line">        ratio = quadratic_time / n_log_n_time <span class="keyword">if</span> n_log_n_time &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;N&#125;</span>\t<span class="subst">&#123;quadratic_time:<span class="number">.4</span>f&#125;</span>s\t<span class="subst">&#123;n_log_n_time:<span class="number">.4</span>f&#125;</span>s\t<span class="subst">&#123;ratio:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="单循环冒泡排序的复杂度分析"><a href="#单循环冒泡排序的复杂度分析" class="headerlink" title="单循环冒泡排序的复杂度分析"></a>单循环冒泡排序的复杂度分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">single_loop_bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用单个循环实现冒泡排序</span></span><br><span class="line"><span class="string">    虽然只有一个while循环，但时间复杂度仍然是O(n²)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    end = n - <span class="number">1</span>                           <span class="comment"># 未排序部分的右边界</span></span><br><span class="line">    i = <span class="number">0</span>                                 <span class="comment"># 当前比较位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> end &gt; <span class="number">0</span>:                        <span class="comment"># 外层逻辑：控制轮次</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:          <span class="comment"># 相邻元素比较</span></span><br><span class="line">            arr[i], arr[i + <span class="number">1</span>] = arr[i + <span class="number">1</span>], arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &lt; end - <span class="number">1</span>:                   <span class="comment"># 当前轮次未结束</span></span><br><span class="line">            i += <span class="number">1</span>                        <span class="comment"># 移动到下一个比较位置</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 当前轮次结束</span></span><br><span class="line">            end -= <span class="number">1</span>                      <span class="comment"># 缩小未排序范围</span></span><br><span class="line">            i = <span class="number">0</span>                         <span class="comment"># 重置比较位置</span></span><br><span class="line">            <span class="comment"># 虽然是单循环，但逻辑上等价于双层嵌套</span></span><br><span class="line">            <span class="comment"># 时间复杂度仍为O(n²)</span></span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><h3 id="动态数组的均摊复杂度分析"><a href="#动态数组的均摊复杂度分析" class="headerlink" title="动态数组的均摊复杂度分析"></a>动态数组的均摊复杂度分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_array_analysis</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    动态数组扩容的均摊复杂度分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    arr = []                              <span class="comment"># 初始空数组</span></span><br><span class="line">    operations = []                       <span class="comment"># 记录每次操作的代价</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):                   <span class="comment"># 插入16个元素</span></span><br><span class="line">        old_capacity = <span class="built_in">len</span>(arr)           <span class="comment"># 当前容量</span></span><br><span class="line">        arr.append(i)                     <span class="comment"># 插入元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟扩容过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; old_capacity:       <span class="comment"># 发生了扩容</span></span><br><span class="line">            <span class="comment"># Python的list实际扩容策略比较复杂，这里简化为2倍扩容</span></span><br><span class="line">            cost = old_capacity            <span class="comment"># 扩容代价：复制所有旧元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cost = <span class="number">1</span>                      <span class="comment"># 普通插入代价</span></span><br><span class="line">        </span><br><span class="line">        operations.append(cost)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;插入元素<span class="subst">&#123;i&#125;</span>, 当前大小=<span class="subst">&#123;<span class="built_in">len</span>(arr)&#125;</span>, 本次代价=<span class="subst">&#123;cost&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    total_cost = <span class="built_in">sum</span>(operations)</span><br><span class="line">    average_cost = total_cost / <span class="built_in">len</span>(operations)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总代价=<span class="subst">&#123;total_cost&#125;</span>, 平均代价=<span class="subst">&#123;average_cost:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数学分析：</span></span><br><span class="line">    <span class="comment"># 扩容发生在容量为1,2,4,8,...时</span></span><br><span class="line">    <span class="comment"># 总扩容代价：0 + 1 + 2 + 4 + 8 + ... &lt; 2n</span></span><br><span class="line">    <span class="comment"># 总插入代价：n  </span></span><br><span class="line">    <span class="comment"># 均摊代价：(2n + n) / n = 3 = O(1)</span></span><br></pre></td></tr></table></figure>

<h3 id="递归算法的空间复杂度"><a href="#递归算法的空间复杂度" class="headerlink" title="递归算法的空间复杂度"></a>递归算法的空间复杂度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_space_analysis</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归算法空间复杂度分析</span></span><br><span class="line"><span class="string">    计算阶乘的递归实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:                           <span class="comment"># 基础情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每次递归调用占用O(1)空间</span></span><br><span class="line">    <span class="comment"># 最大递归深度为n，所以空间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">return</span> n * recursive_space_analysis(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_space_analysis</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    迭代版本的阶乘计算</span></span><br><span class="line"><span class="string">    空间复杂度为O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="number">1</span>                           <span class="comment"># 只使用常数额外空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析的实用技巧"><a href="#复杂度分析的实用技巧" class="headerlink" title="复杂度分析的实用技巧"></a>复杂度分析的实用技巧</h2><h3 id="主定理（Master-Theorem）"><a href="#主定理（Master-Theorem）" class="headerlink" title="主定理（Master Theorem）"></a>主定理（Master Theorem）</h3><p>对于递归关系 $T(n) &#x3D; aT(\frac{n}{b}) + f(n)$，其中 $a \geq 1, b &gt; 1$：</p>
<ul>
<li>如果 $f(n) &#x3D; O(n^{\log_b a - \epsilon})$，则 $T(n) &#x3D; \Theta(n^{\log_b a})$</li>
<li>如果 $f(n) &#x3D; \Theta(n^{\log_b a})$，则 $T(n) &#x3D; \Theta(n^{\log_b a} \log n)$  </li>
<li>如果 $f(n) &#x3D; \Omega(n^{\log_b a + \epsilon})$，则 $T(n) &#x3D; \Theta(f(n))$</li>
</ul>
<h3 id="均摊分析方法"><a href="#均摊分析方法" class="headerlink" title="均摊分析方法"></a>均摊分析方法</h3><ul>
<li><strong>聚合分析</strong>：分析一系列操作的总代价</li>
<li><strong>核算法</strong>：为每种操作分配均摊代价</li>
<li><strong>势能法</strong>：定义势能函数分析代价分布</li>
</ul>
<h3 id="实际性能考虑因素"><a href="#实际性能考虑因素" class="headerlink" title="实际性能考虑因素"></a>实际性能考虑因素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">practical_performance_factors</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    影响实际性能的因素</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;影响算法实际性能的因素：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1. 常数因子：O(n)算法的常数可能很大&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2. 数据规模：小规模时简单算法可能更快&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3. 内存访问模式：缓存友好的算法性能更好&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4. 分支预测：减少条件分支可提高性能&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5. 编译器优化：现代编译器能显著优化代码&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6. 硬件特性：利用SIMD等特性可大幅提速&quot;</span>)</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/" class="post-title-link" itemprop="url">24 Spring - 概率论课程判断题留档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-30 11:42:46" itemprop="dateCreated datePublished" datetime="2025-07-30T11:42:46+08:00">2025-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:20:14" itemprop="dateModified" datetime="2025-08-02T12:20:14+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coursework/" itemprop="url" rel="index"><span itemprop="name">Coursework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  longlongago之前的概率论判断题作业，记录一下</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/概率论判断题大全.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/" class="post-title-link" itemprop="url">25 Spring - 模式识别笔记(5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-17 18:42:46" itemprop="dateCreated datePublished" datetime="2025-06-17T18:42:46+08:00">2025-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:21:04" itemprop="dateModified" datetime="2025-08-02T12:21:04+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Course/" itemprop="url" rel="index"><span itemprop="name">Course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式识别期末笔记"><a href="#模式识别期末笔记" class="headerlink" title="模式识别期末笔记"></a>模式识别期末笔记</h1><p>基于模式识别期末考纲最后一个part，符号源于课程讲义，整理了关于MLP及其网络训练、反向传播算法的相关笔记。</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/模式识别期末_MLP.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AgioPan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">AgioPan</p>
  <div class="site-description" itemprop="description">Solving equations, decoding life, exploring minds.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Agio910" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Agio910" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://orcid.org/0009-0005-1485-9515" title="orcid → https:&#x2F;&#x2F;orcid.org&#x2F;0009-0005-1485-9515" rel="noopener" target="_blank"><i class="fab fa-orcid fa-fw"></i>orcid</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:202111079094@mail.bnu.edu.cn" title="E-Mail → mailto:202111079094@mail.bnu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AgioPan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
