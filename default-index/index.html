<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog of AgioPan">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Blog of AgioPan">
<meta property="og:description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="AgioPan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog of AgioPan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of AgioPan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8822%EF%BC%89-%20%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8822%EF%BC%89-%20%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%B7%AE%E5%88%86/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（47）- 一维差分与等差数列差分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-09-10 08:30:00 / Modified: 15:10:35" itemprop="dateCreated datePublished" datetime="2025-09-10T08:30:00+08:00">2025-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class047的内容，总结了一维差分与等差数列差分的核心思想和应用。差分技巧是处理区间修改问题的重要工具，特别适用于大量区间操作后的批量查询场景。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习差分数组之前，需要掌握以下基础知识：</p>
<ul>
<li>数组的基本操作</li>
<li>前缀和的概念与应用</li>
<li>理解数组索引和边界处理</li>
</ul>
<hr>
<h1 id="047【必备】一维差分与等差数列差分"><a href="#047【必备】一维差分与等差数列差分" class="headerlink" title="047【必备】一维差分与等差数列差分"></a>047【必备】一维差分与等差数列差分</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="一维差分的基本思想"><a href="#一维差分的基本思想" class="headerlink" title="一维差分的基本思想"></a>一维差分的基本思想</h3><p>一维差分是一种优化区间修改操作的技巧：</p>
<ul>
<li><strong>原理</strong>：通过维护一个差分数组，将区间修改转化为两个单点修改</li>
<li><strong>适用场景</strong>：多次区间修改，最后统一查询所有位置的值</li>
<li><strong>限制</strong>：不支持边操作边查询，需要先完成所有修改再构建最终数组</li>
</ul>
<h3 id="等差数列差分"><a href="#等差数列差分" class="headerlink" title="等差数列差分"></a>等差数列差分</h3><p>等差数列差分是一维差分的扩展，用于处理区间内加等差数列的操作：</p>
<ul>
<li><strong>核心特性</strong>：等差数列的二阶差分是常数</li>
<li><strong>应用场景</strong>：需要在区间内按等差数列规律增加数值</li>
<li><strong>实现方式</strong>：通过二阶差分数组进行操作，最后两次前缀和还原</li>
</ul>
<hr>
<h2 id="题目一：航班预订统计"><a href="#题目一：航班预订统计" class="headerlink" title="题目一：航班预订统计"></a>题目一：航班预订统计</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>这里有n个航班，它们分别从1到n进行编号。有一份航班预订表bookings，表中第i条预订记录bookings[i] &#x3D; [firsti, lasti, seatsi]意味着在从firsti到lasti（包含firsti和lasti）的每个航班上预订了seatsi个座位。</p>
<p>请你返回一个长度为n的数组answer，里面的元素是每个航班预定的座位总数。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用差分数组优化区间修改操作：</p>
<ol>
<li><strong>差分数组构建</strong>：<code>diff[i]</code> 记录 <code>ans[i]</code> 相对于 <code>ans[i-1]</code> 的变化量</li>
<li><strong>区间修改转化</strong>：对于预订 <code>[first, last, seats]</code>：<ul>
<li><code>diff[first] += seats</code>：从first开始增加seats</li>
<li><code>diff[last + 1] -= seats</code>：从last+1开始撤销增加效应</li>
</ul>
</li>
<li><strong>结果还原</strong>：通过计算差分数组的前缀和得到最终结果<code>ans[i] = ans[i-1] + diff[i]</code></li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">corpFlightBookings</span>(<span class="params">self, bookings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用差分数组优化区间修改操作</span></span><br><span class="line"><span class="string">        时间复杂度：O(m + n)，空间复杂度：O(n)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 差分数组，长度 n+2 是为了方便处理边界，如 book[1]+1 可能达到 n+1</span></span><br><span class="line">        diff = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据每个预订记录，更新差分数组</span></span><br><span class="line">        <span class="keyword">for</span> first, last, seats <span class="keyword">in</span> bookings:</span><br><span class="line">            diff[first] += seats</span><br><span class="line">            <span class="keyword">if</span> last + <span class="number">1</span> &lt;= n: <span class="comment"># 边界检查</span></span><br><span class="line">                diff[last + <span class="number">1</span>] -= seats</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算前缀和来还原最终的座位数数组</span></span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="comment"># ans[0] 就是 diff[1] 的值 (因为航班从1开始编号)</span></span><br><span class="line">        ans[<span class="number">0</span>] = diff[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 当前航班的座位数 = 上一个航班的座位数 + 差分值</span></span><br><span class="line">            ans[i] = ans[i-<span class="number">1</span>] + diff[i+<span class="number">1</span>] <span class="comment"># diff的索引比ans大1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(m + n)，其中m是预订次数，n是航班数量</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心优势</strong>：将每次O(n)的区间修改优化为O(1)的两次单点修改</li>
</ul>
<hr>
<h2 id="题目二：等差数列差分模板"><a href="#题目二：等差数列差分模板" class="headerlink" title="题目二：等差数列差分模板"></a>题目二：等差数列差分模板</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>一开始1<del>n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)表示在l</del>r范围上依次加上首项为s、末项为e、公差为d的数列。m个操作做完之后，统计1~n范围上所有数字的最大值和异或和。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4231">https://www.luogu.com.cn/problem/P4231</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(22)/class47-%E4%B8%80%E9%98%B6%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/%E8%BF%87%E4%B8%A4%E9%81%8D%E5%89%8D%E7%BC%80%E5%92%8C.png" alt="过两遍前缀和"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(22)/class47-%E4%B8%80%E9%98%B6%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/%E5%8F%8D%E5%90%91%E6%8E%A8%E5%AF%BC.png" alt="反向推导"></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用二阶差分处理等差数列的区间加操作：</p>
<ol>
<li><strong>数学原理</strong>：等差数列的二阶差分是常数</li>
<li><strong>操作分解</strong>：在二阶差分数组上进行四个关键点修改</li>
<li><strong>结果构建</strong>：通过两次前缀和运算还原最终数组</li>
</ol>
<h3 id="关键函数解析"><a href="#关键函数解析" class="headerlink" title="关键函数解析"></a>关键函数解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_arithmetic_sequence</span>(<span class="params">l, r, s, e, d</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在二阶差分数组上进行修改，以实现对原数组的等差数列范围加。</span></span><br><span class="line"><span class="string">    这是通过数学推导得出的在二阶差分数组上的四个关键点修改。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    arr[l] += s <span class="comment">#在起始位置加上首项</span></span><br><span class="line">    arr[l + <span class="number">1</span>] += d - s <span class="comment"># 这确保了从位置l+1开始，一阶差分增加d（公差）</span></span><br><span class="line">    arr[r + <span class="number">1</span>] -= (d + e) <span class="comment">#在区间结束后，需要&quot;撤销&quot;等差数列的影响，因为后续的数字不会再增加</span></span><br><span class="line">    arr[r + <span class="number">2</span>] += e <span class="comment">#补偿操作，确保边界正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过两次前缀和运算，从二阶差分数组还原出最终数组。等差数列有一个重要性质：二阶差分是常数</span></span><br><span class="line"><span class="string">    第一次前缀和：arr 从二阶差分数组变为一阶差分数组。</span></span><br><span class="line"><span class="string">    第二次前缀和：arr 从一阶差分数组变为最终的结果数组。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 第一次前缀和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">2</span>):</span><br><span class="line">        arr[i] += arr[i - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 第二次前缀和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        arr[i] += arr[i - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">10000005</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN</span><br><span class="line">n, m = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    核心思想：二阶差分 (Difference of Differences)</span></span><br><span class="line"><span class="string">    1. 对一个数组`a`进行范围`[l, r]`加一个常数`c`，可以在其一阶差分数组`b`上</span></span><br><span class="line"><span class="string">       通过`b[l]+=c`, `b[r+1]-=c`实现。</span></span><br><span class="line"><span class="string">    2. 对一个数组`a`进行范围`[l, r]`加一个等差数列，其变化在一阶差分数组`b`上表现为：</span></span><br><span class="line"><span class="string">       `b[l]`增加首项`s`，`b[l+1...r]`范围增加公差`d`，`b[r+1]`有一个特殊变化。</span></span><br><span class="line"><span class="string">    3. 这个“范围加常数”的操作，又可以被一个二阶差分数组`c`来优化。</span></span><br><span class="line"><span class="string">    4. `set`函数中的四次修改，就是将“加等差数列”这一复杂操作，</span></span><br><span class="line"><span class="string">       分解为在二阶差分数组`c`上的四个单点修改。</span></span><br><span class="line"><span class="string">    5. 所有修改完成后，对`c`做一次前缀和得到`b`，再对`b`做一次前缀和得到最终的`a`。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    line_iter = <span class="built_in">iter</span>(lines)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            n_m_line = <span class="built_in">next</span>(line_iter)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n_m_line: <span class="keyword">break</span></span><br><span class="line">            n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, n_m_line.strip().split())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 清零 arr 数组以处理多个测试用例</span></span><br><span class="line">            <span class="comment"># 只需要清到可能被修改的最大位置即可，这里为了简单直接清一部分</span></span><br><span class="line">            max_r = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 读取m个操作并更新二阶差分数组</span></span><br><span class="line">            ops = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                l, r, s, e = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">next</span>(line_iter).strip().split())</span><br><span class="line">                ops.append((l, r, s, e))</span><br><span class="line">                max_r = <span class="built_in">max</span>(max_r, r)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_r + <span class="number">3</span>): <span class="comment"># 清理数组</span></span><br><span class="line">                arr[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> l, r, s, e <span class="keyword">in</span> ops:</span><br><span class="line">                <span class="keyword">if</span> r == l: <span class="comment"># 公差为0的特殊情况</span></span><br><span class="line">                    d = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d = (e - s) // (r - l)</span><br><span class="line">                set_arithmetic_sequence(l, r, s, e, d)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 还原最终数组</span></span><br><span class="line">            build()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算最大值和异或和</span></span><br><span class="line">            max_val = <span class="number">0</span></span><br><span class="line">            xor_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                max_val = <span class="built_in">max</span>(max_val, arr[i])</span><br><span class="line">                xor_sum ^= arr[i]</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;xor_sum&#125;</span> <span class="subst">&#123;max_val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(m + n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：二阶差分 + 两次前缀和</li>
</ul>
<hr>
<h2 id="题目三：水位高度计算"><a href="#题目三：水位高度计算" class="headerlink" title="题目三：水位高度计算"></a>题目三：水位高度计算</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>一群人落水后求每个位置的水位高度。每个人落水会产生复杂的水波模式，需要计算所有水波叠加后的最终水位。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5026">https://www.luogu.com.cn/problem/P5026</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(22)/class47-%E4%B8%80%E9%98%B6%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/%E9%97%AE%E9%A2%98%E4%B8%89%E6%8F%8F%E8%BF%B0%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="问题三描述可视化"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(22)/class47-%E4%B8%80%E9%98%B6%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/%E9%97%AE%E9%A2%98%E4%B8%89%E4%B8%8D%E8%B6%8A%E7%95%8C.png" alt="问题三不越界"></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>将复杂的水波描述分解为四个等差数列的叠加，使用OFFSET技巧处理负坐标：</p>
<ol>
<li><strong>水波分解</strong>：每次落水产生四个等差数列段</li>
<li><strong>坐标处理</strong>：使用OFFSET避免负数索引问题</li>
<li><strong>叠加计算</strong>：多次调用等差数列差分函数</li>
</ol>
<h3 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OFFSET = <span class="number">30001</span>  <span class="comment"># 数值保护，防止索引越界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fall</span>(<span class="params">v, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一个人落水，会产生四个等差数列的水波，调用四次set函数来模拟。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    set_arithmetic_sequence(x - <span class="number">3</span> * v + <span class="number">1</span>, x - <span class="number">2</span> * v, <span class="number">1</span>, v, <span class="number">1</span>)</span><br><span class="line">    set_arithmetic_sequence(x - <span class="number">2</span> * v + <span class="number">1</span>, x, v - <span class="number">1</span>, -v, -<span class="number">1</span>)</span><br><span class="line">    set_arithmetic_sequence(x + <span class="number">1</span>, x + <span class="number">2</span> * v, -v + <span class="number">1</span>, v, <span class="number">1</span>)</span><br><span class="line">    set_arithmetic_sequence(x + <span class="number">2</span> * v + <span class="number">1</span>, x + <span class="number">3</span> * v - <span class="number">1</span>, v - <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_arithmetic_sequence</span>(<span class="params">l, r, s, e, d</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    与上题完全相同的二阶差分修改函数，但所有索引都加上了 OFFSET。</span></span><br><span class="line"><span class="string">    OFFSET 技巧：</span></span><br><span class="line"><span class="string">    通过给所有位置索引加上一个大的偏移量，可以确保即使 `l` 是负数，</span></span><br><span class="line"><span class="string">    `l + OFFSET` 也是一个合法的正数数组下标，从而避免了复杂的边界条件判断。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    arr[l + OFFSET] += s</span><br><span class="line">    arr[l + <span class="number">1</span> + OFFSET] += d - s</span><br><span class="line">    arr[r + <span class="number">1</span> + OFFSET] -= d + e</span><br><span class="line">    arr[r + <span class="number">2</span> + OFFSET] += e</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    同样通过两次前缀和运算，从二阶差分数组还原出最终的水位高度数组。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数组足够大，只需要计算到受影响的最右边界即可</span></span><br><span class="line">    <span class="comment"># 简化处理，直接使用 m + OFFSET</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + OFFSET * <span class="number">2</span>):</span><br><span class="line">        arr[i] += arr[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + OFFSET * <span class="number">2</span>):</span><br><span class="line">        arr[i] += arr[i - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<h3 id="完整实现-1"><a href="#完整实现-1" class="headerlink" title="完整实现"></a>完整实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 湖泊最大宽度</span></span><br><span class="line">MAXN = <span class="number">1000001</span></span><br><span class="line"><span class="comment"># 数值保护，防止索引越界</span></span><br><span class="line">OFFSET = <span class="number">30001</span></span><br><span class="line"><span class="comment"># 准备一个足够大的数组来容纳所有可能的位置</span></span><br><span class="line">arr = [<span class="number">0</span>] * (OFFSET + MAXN + OFFSET)</span><br><span class="line">n, m = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    1. 将题目中复杂的水波描述，分解为四个等差数列的叠加。</span></span><br><span class="line"><span class="string">    2. 使用与上一题完全相同的“二阶差分”技巧来处理多个等差数列的范围增加操作。</span></span><br><span class="line"><span class="string">    3. 使用 OFFSET 技巧来优雅地处理可能为负数的位置索引，避免边界判断。</span></span><br><span class="line"><span class="string">    4. 所有落水操作完成后，通过两次前缀和还原出每个位置的最终水位。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    line_iter = <span class="built_in">iter</span>(lines)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            n_m_line = <span class="built_in">next</span>(line_iter)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n_m_line: <span class="keyword">break</span></span><br><span class="line">            n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, n_m_line.strip().split())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 找到可能影响的最大范围，用于清理数组</span></span><br><span class="line">            max_coord = <span class="number">0</span></span><br><span class="line">            ops = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                v, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">next</span>(line_iter).strip().split())</span><br><span class="line">                ops.append((v, x))</span><br><span class="line">                max_coord = <span class="built_in">max</span>(max_coord, x + <span class="number">3</span> * v)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_coord + OFFSET + <span class="number">2</span>):</span><br><span class="line">                arr[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对每次落水，更新二阶差分数组</span></span><br><span class="line">            <span class="keyword">for</span> v, x <span class="keyword">in</span> ops:</span><br><span class="line">                fall(v, x)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 还原最终水位</span></span><br><span class="line">            build()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 收集并打印 1~m 位置的答案</span></span><br><span class="line">            <span class="comment"># 正式位置 1...m 对应于 arr 数组中的 OFFSET+1...OFFSET+m</span></span><br><span class="line">            start = OFFSET + <span class="number">1</span></span><br><span class="line">            result = [<span class="built_in">str</span>(arr[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, start + m)]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(result))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n + m)</li>
<li><strong>空间复杂度</strong>：O(n + OFFSET)</li>
<li><strong>核心技巧</strong>：OFFSET处理负坐标 + 复杂水波分解</li>
</ul>
<hr>
<h2 id="差分技巧总结"><a href="#差分技巧总结" class="headerlink" title="差分技巧总结"></a>差分技巧总结</h2><h3 id="1-一维差分的应用场景"><a href="#1-一维差分的应用场景" class="headerlink" title="1. 一维差分的应用场景"></a>1. 一维差分的应用场景</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用情况：</span></span><br><span class="line"><span class="comment"># 1. 大量区间修改操作</span></span><br><span class="line"><span class="comment"># 2. 最后统一查询所有位置</span></span><br><span class="line"><span class="comment"># 3. 不需要边操作边查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本操作：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_add</span>(<span class="params">diff, l, r, val</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;区间[l,r]增加val&quot;&quot;&quot;</span></span><br><span class="line">    diff[l] += val</span><br><span class="line">    diff[r + <span class="number">1</span>] -= val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_result</span>(<span class="params">diff, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;构建最终结果&quot;&quot;&quot;</span></span><br><span class="line">    result = [<span class="number">0</span>] * n</span><br><span class="line">    result[<span class="number">0</span>] = diff[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        result[i] = result[i-<span class="number">1</span>] + diff[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="2-等差数列差分的核心原理"><a href="#2-等差数列差分的核心原理" class="headerlink" title="2. 等差数列差分的核心原理"></a>2. 等差数列差分的核心原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数学基础：</span></span><br><span class="line"><span class="comment"># 原数组：a[0], a[1], a[2], ...</span></span><br><span class="line"><span class="comment"># 一阶差分：b[i] = a[i] - a[i-1]</span></span><br><span class="line"><span class="comment"># 二阶差分：c[i] = b[i] - b[i-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等差数列性质：</span></span><br><span class="line"><span class="comment"># 等差数列的一阶差分是常数</span></span><br><span class="line"><span class="comment"># 等差数列的二阶差分是0（除了边界）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作模板：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arithmetic_sequence_add</span>(<span class="params">arr, l, r, s, e, d</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在l~r范围加等差数列[s,s+d,s+2d,...,e]&quot;&quot;&quot;</span></span><br><span class="line">    arr[l] += s</span><br><span class="line">    arr[l + <span class="number">1</span>] += d - s</span><br><span class="line">    arr[r + <span class="number">1</span>] -= (d + e)</span><br><span class="line">    arr[r + <span class="number">2</span>] += e</span><br></pre></td></tr></table></figure>

<h3 id="3-边界处理技巧"><a href="#3-边界处理技巧" class="headerlink" title="3. 边界处理技巧"></a>3. 边界处理技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OFFSET技巧：处理负坐标</span></span><br><span class="line">OFFSET = <span class="number">30001</span></span><br><span class="line">real_index = coordinate + OFFSET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 边界扩展：防止越界</span></span><br><span class="line">arr = [<span class="number">0</span>] * (n + <span class="number">2</span>)  <span class="comment"># 额外空间处理边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围检查</span></span><br><span class="line"><span class="keyword">if</span> r + <span class="number">1</span> &lt;= n:</span><br><span class="line">    diff[r + <span class="number">1</span>] -= val</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><table>
<thead>
<tr>
<th>方法</th>
<th>区间修改</th>
<th>单点查询</th>
<th>区间查询</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>暴力</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>修改少，查询多</td>
</tr>
<tr>
<td>差分数组</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>修改多，批量查询</td>
</tr>
<tr>
<td>线段树</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>边修改边查询</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-理解差分本质"><a href="#1-理解差分本质" class="headerlink" title="1. 理解差分本质"></a>1. 理解差分本质</h3><ul>
<li>差分是前缀和的逆运算</li>
<li>区间修改转化为端点修改</li>
<li>适用于修改多查询少的场景</li>
</ul>
<h3 id="2-掌握模板套路"><a href="#2-掌握模板套路" class="headerlink" title="2. 掌握模板套路"></a>2. 掌握模板套路</h3><ul>
<li>熟练掌握一维差分的基本模板</li>
<li>理解等差数列差分的数学原理</li>
<li>练习边界处理和特殊情况</li>
</ul>
<h3 id="3-注意实现细节"><a href="#3-注意实现细节" class="headerlink" title="3. 注意实现细节"></a>3. 注意实现细节</h3><ul>
<li>数组大小的合理设计</li>
<li>索引边界的仔细处理</li>
<li>OFFSET技巧的灵活运用</li>
</ul>
<h3 id="4-扩展应用"><a href="#4-扩展应用" class="headerlink" title="4. 扩展应用"></a>4. 扩展应用</h3><ul>
<li>二维差分矩阵</li>
<li>树上差分</li>
<li>线段树lazy标记的差分思想</li>
</ul>
<h3 id="5-调试技巧"><a href="#5-调试技巧" class="headerlink" title="5. 调试技巧"></a>5. 调试技巧</h3><ul>
<li>验证差分数组的正确性</li>
<li>检查前缀和构建过程</li>
<li>测试边界情况和特殊输入</li>
</ul>
<p>通过掌握差分数组的核心思想和实现技巧，可以高效解决各种区间修改问题。关键在于理解差分与前缀和的关系，以及合理的边界处理策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8821%EF%BC%89-%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8821%EF%BC%89-%20%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（21）- 构建前缀信息的技巧-解决子数组相关问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-09-09 10:30:00 / Modified: 14:37:59" itemprop="dateCreated datePublished" datetime="2025-09-09T10:30:00+08:00">2025-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class046的内容，总结了构建前缀信息的技巧来解决子数组相关问题。这类问题通过预处理前缀信息，结合哈希表等数据结构，可以将原本O(n²)或更高时间复杂度的问题优化到O(n)。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习前缀信息技巧之前，需要掌握以下基础知识：</p>
<ul>
<li>讲解026 - 哈希表的用法</li>
<li>数组基础操作和累加和概念</li>
<li>基本的数学推导能力</li>
</ul>
<hr>
<h1 id="046【必备】构建前缀信息的技巧-解决子数组相关问题"><a href="#046【必备】构建前缀信息的技巧-解决子数组相关问题" class="headerlink" title="046【必备】构建前缀信息的技巧-解决子数组相关问题"></a>046【必备】构建前缀信息的技巧-解决子数组相关问题</h1><h2 id="核心解题思路"><a href="#核心解题思路" class="headerlink" title="核心解题思路"></a>核心解题思路</h2><h3 id="前缀和的基本概念"><a href="#前缀和的基本概念" class="headerlink" title="前缀和的基本概念"></a>前缀和的基本概念</h3><p>前缀和是一种预处理技巧，通过构建辅助数组来快速计算任意区间的累加和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前缀和数组构建</span></span><br><span class="line">s = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)  <span class="comment"># 比原数组长1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    s[i + <span class="number">1</span>] = s[i] + nums[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区间[left, right]的和 = s[right+1] - s[left]</span></span><br></pre></td></tr></table></figure>

<h3 id="前缀信息-哈希表的套路"><a href="#前缀信息-哈希表的套路" class="headerlink" title="前缀信息 + 哈希表的套路"></a>前缀信息 + 哈希表的套路</h3><p>解决子数组问题的通用套路：</p>
<ol>
<li><strong>构建前缀信息</strong>：根据问题需求构建前缀和、前缀状态等</li>
<li><strong>设计哈希表</strong>：存储前缀信息的位置或次数</li>
<li><strong>遍历求解</strong>：边计算前缀信息，边查询哈希表更新答案</li>
</ol>
<hr>
<h2 id="题目一：前缀和数组-快速区间求和"><a href="#题目一：前缀和数组-快速区间求和" class="headerlink" title="题目一：前缀和数组 - 快速区间求和"></a>题目一：前缀和数组 - 快速区间求和</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个支持快速查询数组区间和的数据结构。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>通过预计算前缀和，实现O(1)时间复杂度的范围和查询：<br>通过预计算前缀和，实现O(1)时间复杂度的范围和查询。</p>
<ol>
<li>创建一个比原数组长1的前缀和数组 <code>s</code>。</li>
<li><code>s[i]</code> 存储原数组 <code>nums</code> 从 <code>0</code> 到 <code>i-1</code> 位置的累加和。</li>
<li><code>nums</code> 数组从 <code>left</code> 到 <code>right</code> 的范围和，<br> 就可以通过 <code>s[right+1] - s[left]</code> 快速得到。<br> s[right+1] 是 0…right 的和<br> s[left] 是 0…left-1 的和<br> 两者相减即为 left…right 的和。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(21)/class46-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7/%E9%A2%98%E7%9B%AE%E4%B8%80%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.png" alt="题目一暴力解法"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">arr = []</span><br><span class="line">n, aim = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># key : 某个前缀和</span></span><br><span class="line"><span class="comment"># value : 这个前缀和最早出现的位置</span></span><br><span class="line">prefix_sum_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过预计算前缀和，实现O(1)时间复杂度的范围和查询。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    prefix_sum_map.clear()</span><br><span class="line">    <span class="comment"># 重要 : 0这个前缀和，在-1位置（一个数字也没有的时候），就存在了</span></span><br><span class="line">    <span class="comment"># 这可以正确处理从0开始的子数组</span></span><br><span class="line">    prefix_sum_map[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    current_sum = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        current_sum += arr[i]</span><br><span class="line">        <span class="comment"># 查找是否存在一个 j，使得 0..j 的前缀和为 current_sum - aim</span></span><br><span class="line">        <span class="keyword">if</span> (current_sum - aim) <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">            j = prefix_sum_map[current_sum - aim]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - j)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 只记录每个前缀和第一次出现的位置</span></span><br><span class="line">        <span class="keyword">if</span> current_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">            prefix_sum_map[current_sum] = i</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理输入和输出的主函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> n, aim, arr</span><br><span class="line">    <span class="comment"># 高效读取所有输入行</span></span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    line_iter = <span class="built_in">iter</span>(lines)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            line = <span class="built_in">next</span>(line_iter)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            n, aim = <span class="built_in">map</span>(<span class="built_in">int</span>, line.strip().split())</span><br><span class="line">            arr_line = <span class="built_in">next</span>(line_iter)</span><br><span class="line">            arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, arr_line.strip().split()))</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(compute())</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>预处理时间复杂度</strong>：O(n)</li>
<li><strong>查询时间复杂度</strong>：O(1)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
</ul>
<hr>
<h2 id="题目二：累加和为给定值的最长子数组"><a href="#题目二：累加和为给定值的最长子数组" class="headerlink" title="题目二：累加和为给定值的最长子数组"></a>题目二：累加和为给定值的最长子数组</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个无序数组arr，其中元素可正、可负、可0。给定一个整数aim，求arr所有子数组中累加和为aim的最长子数组长度。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5">https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用前缀和 + 哈希表记录每个前缀和<strong>最早出现的位置</strong>：</p>
<ol>
<li>遍历数组，计算到当前位置 <code>i</code> 的前缀和 <code>s</code></li>
<li>如果存在位置 <code>j</code>，使得 <code>(0...i的前缀和) - (0...j的前缀和) = aim</code></li>
<li>即 <code>s - (0...j的前缀和) = aim</code>，所以需要查找前缀和为 <code>s - aim</code> 的位置</li>
<li>为了让子数组最长，<code>j</code> 应该尽可能小，所以只记录每个前缀和<strong>首次出现</strong>的位置</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(21)/class46-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7/%E9%A2%98%E7%9B%AE%E4%BA%8C.png" alt="题目二"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算累加和为aim的最长子数组长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    prefix_sum_map = &#123;&#125;</span><br><span class="line">    <span class="comment"># 重要：0这个前缀和，在-1位置（一个数字也没有的时候）就存在了</span></span><br><span class="line">    <span class="comment"># 这可以正确处理从0开始的子数组</span></span><br><span class="line">    prefix_sum_map[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    current_sum = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        current_sum += arr[i]</span><br><span class="line">        <span class="comment"># 查找是否存在一个 j，使得 0..j 的前缀和为 current_sum - aim</span></span><br><span class="line">        <span class="keyword">if</span> (current_sum - aim) <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">            j = prefix_sum_map[current_sum - aim]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - j)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 只记录每个前缀和第一次出现的位置</span></span><br><span class="line">        <span class="keyword">if</span> current_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">            prefix_sum_map[current_sum] = i</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment">### 类似上一题那样定义main和继续处理</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：记录最早位置 + 前缀和差值</li>
</ul>
<hr>
<h2 id="题目三：累加和为给定值的子数组个数"><a href="#题目三：累加和为给定值的子数组个数" class="headerlink" title="题目三：累加和为给定值的子数组个数"></a>题目三：累加和为给定值的子数组个数</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>返回无序数组中累加和为给定值的子数组个数。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>与寻找最长子数组类似，但哈希表存储的是<strong>前缀和出现的次数</strong>：</p>
<ul>
<li><code>prefix_sum_map[s - aim]</code> 的值代表有多少个合法的子数组可以在 <code>i</code> 位置结尾</li>
<li>累加这些次数得到总的子数组个数</li>
</ul>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算累加和为aim的子数组个数。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        与寻找最长子数组类似，但哈希表的用途不同。</span></span><br><span class="line"><span class="string">        1. 这里的哈希表 `prefix_sum_map` 存储的是 &#123;前缀和 -&gt; 该前缀和出现的次数&#125;。</span></span><br><span class="line"><span class="string">        2. 遍历数组，计算到位置 `i` 的前缀和 `s`。</span></span><br><span class="line"><span class="string">        3. 同样，我们寻找 `s - aim` 这个目标前缀和。</span></span><br><span class="line"><span class="string">        4. 哈希表中 `prefix_sum_map[s - aim]` 的值，就代表了有多少个合法的子数组</span></span><br><span class="line"><span class="string">           可以在 `i` 位置结尾。我们将这个次数累加到 `ans` 中。</span></span><br><span class="line"><span class="string">        5. 遍历完 `i` 后，更新 `s` 在哈希表中的出现次数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># key: 前缀和, value: 该前缀和出现的次数</span></span><br><span class="line">        <span class="comment"># 使用 defaultdict 可以简化代码</span></span><br><span class="line">        prefix_sum_map = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 0这个前缀和，在没有任何数字的时候，已经有1次了</span></span><br><span class="line">        <span class="comment"># 空集也算一个子集</span></span><br><span class="line">        prefix_sum_map[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># current_sum : 0...i前缀和</span></span><br><span class="line">            current_sum += num</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 查找有多少个 j 满足 0..j 的前缀和为 current_sum - aim</span></span><br><span class="line">            count = prefix_sum_map[current_sum - aim]</span><br><span class="line">            ans += count</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新当前前缀和的出现次数</span></span><br><span class="line">            prefix_sum_map[current_sum] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：记录出现次数 + 累加计数</li>
</ul>
<hr>
<h2 id="题目四：正数和负数个数相等的最长子数组"><a href="#题目四：正数和负数个数相等的最长子数组" class="headerlink" title="题目四：正数和负数个数相等的最长子数组"></a>题目四：正数和负数个数相等的最长子数组</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个无序数组arr，其中元素可正、可负、可0。求arr所有子数组中正数与负数个数相等的最长子数组的长度。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb">https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb</a></p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p><strong>问题转化</strong>：将原数组进行转换，正数变为1，负数变为-1，0保持为0。在新数组中，如果一个子数组的累加和为0，就意味着其中1和-1的数量相等，对应原数组中正数和负数数量相等。</p>
<p>之后算法就和”累加和为0的最长子数组”完全一样。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(21)/class46-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7/%E9%A2%98%E7%9B%AE%E5%9B%9B.png" alt="题目四"></p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    1. 这个问题可以转化为“累加和为0的最长子数组长度”问题。</span></span><br><span class="line"><span class="string">    2. 将原数组进行转换：正数变为1，负数变为-1，0保持为0。</span></span><br><span class="line"><span class="string">    3. 在新数组中，如果一个子数组的累加和为0，</span></span><br><span class="line"><span class="string">       就意味着其中的1和-1的数量相等，这正好对应原数组中正数和负数数量相等。</span></span><br><span class="line"><span class="string">    4. 之后，算法就和“累加和为aim的最长子数组”完全一样，只是这里的aim固定为0。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    prefix_sum_map.clear()</span><br><span class="line">    prefix_sum_map[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    current_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        current_sum += transformed_arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 寻找目标前缀和 (current_sum - 0)</span></span><br><span class="line">        <span class="keyword">if</span> current_sum <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">            j = prefix_sum_map[current_sum]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - j)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> current_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">            prefix_sum_map[current_sum] = i</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> n, transformed_arr</span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    line_iter = <span class="built_in">iter</span>(lines)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            line = <span class="built_in">next</span>(line_iter)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            n = <span class="built_in">int</span>(line.strip())</span><br><span class="line">            arr_line = <span class="built_in">next</span>(line_iter)</span><br><span class="line">            original_arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, arr_line.strip().split()))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 转换数组</span></span><br><span class="line">            transformed_arr = [<span class="number">0</span>] * n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                num = original_arr[i]</span><br><span class="line">                <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                    transformed_arr[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> num &lt; <span class="number">0</span>:</span><br><span class="line">                    transformed_arr[i] = -<span class="number">1</span></span><br><span class="line">                <span class="comment"># 0 保持为 0</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(compute())</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：问题转化 + 前缀和</li>
</ul>
<hr>
<h2 id="题目五：表现良好的最长时间段"><a href="#题目五：表现良好的最长时间段" class="headerlink" title="题目五：表现良好的最长时间段"></a>题目五：表现良好的最长时间段</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。当员工一天中的工作小时数大于8小时的时候，那么这一天就是劳累的一天。表现良好的时间段，意味在这段时间内，「劳累的天数」是严格大于不劳累的天数。请你返回表现良好时间段的最大长度。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-well-performing-interval/">https://leetcode.cn/problems/longest-well-performing-interval/</a></p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p><strong>问题转化</strong>：将 &gt;8 小时的天记为 +1，&lt;&#x3D;8 小时的天记为 -1。问题变成了”求和为正数的最长子数组长度”。</p>
<p>关键处理：</p>
<ol>
<li>如果当前前缀和 &gt; 0，说明从开头到当前位置整个时间段都表现良好</li>
<li>如果前缀和 &lt;&#x3D; 0，需要找到最早的位置 j，使得 j+1 到 i 的子数组和 &gt; 0</li>
<li>这等价于寻找前缀和为 <code>current_sum - 1</code> 的最早位置</li>
</ol>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestWPI</span>(<span class="params">self, hours: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 将问题进行转换：将 &gt;8 小时的天记为 +1，&lt;=8 小时的天记为 -1。</span></span><br><span class="line"><span class="string">           问题就变成了“求和为正数的最长子数组长度”。</span></span><br><span class="line"><span class="string">        2. 使用前缀和与哈希表。我们遍历数组，计算当前的前缀和 `current_sum`。</span></span><br><span class="line"><span class="string">        3. 哈希表 `prefix_sum_map` 存储 &#123;前缀和 -&gt; 该和首次出现的位置&#125;。</span></span><br><span class="line"><span class="string">        4. 如果当前前缀和 `current_sum` &gt; 0，说明从开头到当前位置的整个时间段都是</span></span><br><span class="line"><span class="string">           表现良好的，长度为 `i + 1`，这是一个候选答案。</span></span><br><span class="line"><span class="string">        5. 如果 `current_sum` &lt;= 0，我们需要找到一个最早的位置 `j`，使得 `j+1` 到 `i` 的</span></span><br><span class="line"><span class="string">           子数组和 &gt; 0。这等价于 `current_sum - prefix_sum[j] &gt; 0`，</span></span><br><span class="line"><span class="string">           即 `current_sum &gt; prefix_sum[j]`。</span></span><br><span class="line"><span class="string">           为了使 `i - j` 最长，我们需要 `j` 最早，并且 `prefix_sum[j]` 尽可能小。</span></span><br><span class="line"><span class="string">           我们寻找 `current_sum - 1` 这个前缀和最早出现的位置，因为它能保证</span></span><br><span class="line"><span class="string">           `prefix_sum[j]` 严格小于 `current_sum`，从而找到一个候选的更长子数组。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 某个前缀和，最早出现的位置</span></span><br><span class="line">        prefix_sum_map = &#123;&#125;</span><br><span class="line">        <span class="comment"># 0这个前缀和，最早出现在-1，一个数也没有的时候</span></span><br><span class="line">        prefix_sum_map[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(hours):</span><br><span class="line">            current_sum += <span class="number">1</span> <span class="keyword">if</span> h &gt; <span class="number">8</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果当前前缀和 &gt; 0，说明从0到i的整个子数组都是一个解</span></span><br><span class="line">            <span class="keyword">if</span> current_sum &gt; <span class="number">0</span>:</span><br><span class="line">                ans = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># current_sum &lt;= 0</span></span><br><span class="line">                <span class="comment"># 我们寻找是否存在一个更早的前缀和，值为 current_sum - 1</span></span><br><span class="line">                <span class="comment"># 如果存在，就能构成一个和为1的子数组，这也是一个解</span></span><br><span class="line">                <span class="keyword">if</span> (current_sum - <span class="number">1</span>) <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, i - prefix_sum_map[current_sum - <span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 只记录每个前缀和第一次出现的位置，因为我们要找的是最早的位置</span></span><br><span class="line">            <span class="keyword">if</span> current_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_map:</span><br><span class="line">                prefix_sum_map[current_sum] = i</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：转化为正数和问题 + 特殊查找逻辑</li>
</ul>
<hr>
<h2 id="题目六：使数组和能被P整除"><a href="#题目六：使数组和能被P整除" class="headerlink" title="题目六：使数组和能被P整除"></a>题目六：使数组和能被P整除</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个正整数数组 nums，请你移除最短子数组（可以为空），使得剩余元素的和能被 p 整除。不允许将整个数组都移除。请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-sum-divisible-by-p/">https://leetcode.cn/problems/make-sum-divisible-by-p/</a></p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><p><strong>关键观察</strong>：设总和为 <code>total</code>，我们需要移除一个子数组使得 <code>(total - 子数组和) % p = 0</code>。</p>
<p>设 <code>mod = total % p</code>，则需要移除的子数组和满足 <code>子数组和 % p = mod</code>。</p>
<p>使用前缀和余数 + 哈希表记录<strong>最晚出现的位置</strong>（为了让子数组最短）</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(21)/class46-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7/%E9%A2%98%E7%9B%AE%E5%85%AD%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.png" alt="题目六核心概念"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(21)/class46-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7/%E9%A2%98%E7%9B%AE%E5%85%AD-%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96.png" alt="题目六-问题转化"></p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], p: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 首先计算整个数组的和对 p 取模，得到 `mod`。</span></span><br><span class="line"><span class="string">           如果 `mod == 0`，则无需移除任何元素，返回 0。</span></span><br><span class="line"><span class="string">        2. 我们的目标是移除一个子数组，其和对 p 取模的结果也等于 `mod`。</span></span><br><span class="line"><span class="string">           这样 `(总和 - 子数组和) % p` 就会等于 `(mod - mod) % p = 0`。</span></span><br><span class="line"><span class="string">        3. 问题转化为：寻找和对 p 取模为 `mod` 的最短子数组。</span></span><br><span class="line"><span class="string">        4. 使用前缀和与哈希表。哈希表 `prefix_mod_map` 存储 &#123;前缀和模p -&gt; 该模值最晚出现的位置&#125;。</span></span><br><span class="line"><span class="string">           我们需要最晚的位置，是为了让 `i - j` 这个子数组长度最短。</span></span><br><span class="line"><span class="string">        5. 遍历数组，计算到 `i` 的前缀和模 `p` 的值 `current_mod`。</span></span><br><span class="line"><span class="string">        6. 我们需要寻找一个 `j`，使得 `(i...j)` 子数组的和模 `p` 为 `mod`。</span></span><br><span class="line"><span class="string">           这等价于 `(prefix_mod[i] - prefix_mod[j-1]) % p == mod`。</span></span><br><span class="line"><span class="string">           变形得 `prefix_mod[j-1] == (current_mod - mod + p) % p`。</span></span><br><span class="line"><span class="string">        7. 我们在哈希表中查找这个目标 `find` 值，如果找到，就更新最短子数组长度。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 整体余数</span></span><br><span class="line">        mod = <span class="built_in">sum</span>(nums) % p</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果总和本身就能被p整除，无需移除</span></span><br><span class="line">        <span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># key : 前缀和%p的余数</span></span><br><span class="line">        <span class="comment"># value : 最晚出现的位置</span></span><br><span class="line">        prefix_mod_map = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;</span><br><span class="line">        ans = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        current_mod = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 0...i这部分的余数</span></span><br><span class="line">            current_mod = (current_mod + num) % p</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 我们要找的目标前缀和余数 find</span></span><br><span class="line">            <span class="comment"># find = (current_mod - mod) % p</span></span><br><span class="line">            <span class="comment"># +p 是为了处理负数情况</span></span><br><span class="line">            find = (current_mod - mod + p) % p</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> find <span class="keyword">in</span> prefix_mod_map:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, i - prefix_mod_map[find])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 存入当前前缀和余数出现的位置</span></span><br><span class="line">            prefix_mod_map[current_mod] = i</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果ans等于原数组长度，说明我们必须移除整个数组，按题意返回-1</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; <span class="built_in">len</span>(nums) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(p)，最多存储p个不同的余数</li>
<li><strong>核心技巧</strong>：取模运算 + 最晚位置</li>
</ul>
<hr>
<h2 id="题目七：每个元音包含偶数次的最长子串"><a href="#题目七：每个元音包含偶数次的最长子串" class="headerlink" title="题目七：每个元音包含偶数次的最长子串"></a>题目七：每个元音包含偶数次的最长子串</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个字符串 s，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ 在子字符串中都恰好出现了偶数次。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/">https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/</a></p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p><strong>状态压缩</strong>：用5位二进制数表示五个元音字母出现次数的奇偶性。</p>
<ul>
<li>例如：<code>01100</code> 表示 ‘e’ 和 ‘i’ 出现了奇数次，’a’,’o’,’u’出现了偶数次</li>
<li>如果两个位置的状态码相同，说明中间子串中每个元音都出现了偶数次</li>
</ul>
<p>关键是找到相同状态码的最远距离。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(21)/class46-%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7/%E9%A2%98%E7%9B%AE%E4%B8%83.png" alt="题目七"></p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 我们只关心五个元音字母&#x27;a,e,i,o,u&#x27;出现次数的奇偶性。</span></span><br><span class="line"><span class="string">           这可以用一个5位的二进制数（状态码/bitmask）来表示。</span></span><br><span class="line"><span class="string">           例如，二进制 `01100` 表示 &#x27;e&#x27; 和 &#x27;i&#x27; 出现了奇数次，&#x27;a&#x27;,&#x27;o&#x27;,&#x27;u&#x27;出现了偶数次。</span></span><br><span class="line"><span class="string">        2. 遍历字符串，维护一个从开头到当前位置的`status`状态码。</span></span><br><span class="line"><span class="string">           遇到一个元音，就用异或(XOR)操作翻转其对应的位。</span></span><br><span class="line"><span class="string">        3. 问题转化为：找到两个位置 `i` 和 `j`，使得它们的前缀状态码相同。</span></span><br><span class="line"><span class="string">           如果 `prefix_status[i] == prefix_status[j]`，那么 `j+1` 到 `i` 的子串中，</span></span><br><span class="line"><span class="string">           所有元音的奇偶性变化都抵消了，即每个元音都出现了偶数次。</span></span><br><span class="line"><span class="string">        4. 我们需要找到最长的这样的子串，即最大化 `i - j`。</span></span><br><span class="line"><span class="string">        5. 使用一个数组 `status_map` 记录每个状态码第一次出现的位置。</span></span><br><span class="line"><span class="string">           `status_map[status] = earliest_index`。</span></span><br><span class="line"><span class="string">        6. 初始化 `status_map[0] = -1`，表示初始状态（0次，偶数）出现在-1位置。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 用一个数组来存储每种状态第一次出现的位置</span></span><br><span class="line">        <span class="comment"># 状态码范围是 0 (00000) 到 31 (11111)</span></span><br><span class="line">        status_map = [-<span class="number">2</span>] * <span class="number">32</span> <span class="comment">#-2是初始值，表示这个状态码没有出现过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始状态0 (所有元音都是偶数次0) 出现在-1位置</span></span><br><span class="line">        status_map[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        status = <span class="number">0</span></span><br><span class="line">        vowel_map = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># status : 0....i-1字符串上，aeiou的奇偶性</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查当前字符是否为元音，并更新状态</span></span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> vowel_map:</span><br><span class="line">                move = vowel_map[char] <span class="comment"># 在vowel_map里看，a是0，e是1，i是2，o是3，u是4</span></span><br><span class="line">                status ^= (<span class="number">1</span> &lt;&lt; move) <span class="comment"># status是0...i-1字符串上，aeiou的奇偶性，用异或操作翻转其对应的位</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># status: 0....i字符串上，aeiou的奇偶性，是个五位的二进制数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查当前状态是否之前出现过</span></span><br><span class="line">            <span class="keyword">if</span> status_map[status] != -<span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果出现过，计算长度并更新最大值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - status_map[status])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果是第一次出现，记录当前位置</span></span><br><span class="line">                status_map[status] = i</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(1)，状态数组固定大小32</li>
<li><strong>核心技巧</strong>：状态压缩 + 位运算</li>
</ul>
<hr>
<h2 id="核心套路总结"><a href="#核心套路总结" class="headerlink" title="核心套路总结"></a>核心套路总结</h2><h3 id="1-前缀信息构建模板"><a href="#1-前缀信息构建模板" class="headerlink" title="1. 前缀信息构建模板"></a>1. 前缀信息构建模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础前缀和</span></span><br><span class="line">prefix_sum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    prefix_sum[i + <span class="number">1</span>] = prefix_sum[i] + nums[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前缀状态（如奇偶性、余数等）</span></span><br><span class="line">prefix_state = initial_state</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    prefix_state = update_state(prefix_state, nums[i])</span><br><span class="line">    <span class="comment"># 处理当前状态</span></span><br></pre></td></tr></table></figure>

<h3 id="2-哈希表设计策略"><a href="#2-哈希表设计策略" class="headerlink" title="2. 哈希表设计策略"></a>2. 哈希表设计策略</h3><table>
<thead>
<tr>
<th>问题类型</th>
<th>哈希表存储内容</th>
<th>选择策略</th>
</tr>
</thead>
<tbody><tr>
<td>最长子数组</td>
<td>{前缀信息 → 最早位置}</td>
<td>只存首次出现</td>
</tr>
<tr>
<td>最短子数组</td>
<td>{前缀信息 → 最晚位置}</td>
<td>覆盖存储</td>
</tr>
<tr>
<td>子数组计数</td>
<td>{前缀信息 → 出现次数}</td>
<td>累加计数</td>
</tr>
</tbody></table>
<h3 id="3-边界条件处理"><a href="#3-边界条件处理" class="headerlink" title="3. 边界条件处理"></a>3. 边界条件处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重要：处理从0开始的子数组</span></span><br><span class="line">hash_map[initial_value] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免重复计算</span></span><br><span class="line"><span class="keyword">if</span> condition_to_update:</span><br><span class="line">    hash_map[key] = value</span><br></pre></td></tr></table></figure>

<h3 id="4-问题转化技巧"><a href="#4-问题转化技巧" class="headerlink" title="4. 问题转化技巧"></a>4. 问题转化技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正负数相等 → 转化为累加和为0</span></span><br><span class="line">transform = <span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> (-<span class="number">1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作时间 → 转化为劳累天数大于非劳累天数</span></span><br><span class="line">transform = <span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">8</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元音奇偶性 → 状态压缩</span></span><br><span class="line">state ^= (<span class="number">1</span> &lt;&lt; vowel_index)  <span class="comment"># 异或翻转对应位</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目类型</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>前缀和查询</td>
<td>O(1) 查询</td>
<td>O(n)</td>
<td>前缀和数组</td>
</tr>
<tr>
<td>最长子数组</td>
<td>O(n)</td>
<td>O(n)</td>
<td>哈希表</td>
</tr>
<tr>
<td>子数组计数</td>
<td>O(n)</td>
<td>O(n)</td>
<td>哈希表</td>
</tr>
<tr>
<td>状态压缩</td>
<td>O(n)</td>
<td>O(1)</td>
<td>固定数组</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-掌握核心思想"><a href="#1-掌握核心思想" class="headerlink" title="1. 掌握核心思想"></a>1. 掌握核心思想</h3><ul>
<li>理解前缀信息的作用：将子数组问题转化为两个前缀的差值问题</li>
<li>掌握哈希表的不同用法：位置记录 vs 次数统计</li>
<li>熟练运用问题转化技巧</li>
</ul>
<h3 id="2-注意实现细节"><a href="#2-注意实现细节" class="headerlink" title="2. 注意实现细节"></a>2. 注意实现细节</h3><ul>
<li>初始状态的正确设置（如 <code>map[0] = -1</code>）</li>
<li>哈希表更新时机的选择</li>
<li>边界条件的处理</li>
</ul>
<h3 id="3-练习变形题目"><a href="#3-练习变形题目" class="headerlink" title="3. 练习变形题目"></a>3. 练习变形题目</h3><ul>
<li>不同的累加和目标值</li>
<li>不同的转化规则</li>
<li>多种约束条件的组合</li>
</ul>
<h3 id="4-优化技巧"><a href="#4-优化技巧" class="headerlink" title="4. 优化技巧"></a>4. 优化技巧</h3><ul>
<li>状态压缩减少空间占用</li>
<li>合理选择数据结构</li>
<li>避免不必要的重复计算</li>
</ul>
<p>通过掌握前缀信息 + 哈希表的解题套路，可以高效解决各种子数组相关问题。关键在于正确构建前缀信息，合理设计哈希表存储策略，以及灵活运用问题转化技巧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8820%EF%BC%89-%20%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8820%EF%BC%89-%20%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（20）- 前缀树的原理和相关题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-07 08:30:00" itemprop="dateCreated datePublished" datetime="2025-09-07T08:30:00+08:00">2025-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-08 19:38:49" itemprop="dateModified" datetime="2025-09-08T19:38:49+08:00">2025-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class044和class045的内容，详细介绍了前缀树（Trie树）的原理和代码实现并总结了前缀树(Trie)在实际算法题目中的应用。前缀树是一种专门用于处理字符串前缀查询的高效数据结构，在搜索引擎、自动补全、拼写检查等场景中有广泛应用。</p>
<hr>
<h1 id="044【必备】前缀树原理和代码详解"><a href="#044【必备】前缀树原理和代码详解" class="headerlink" title="044【必备】前缀树原理和代码详解"></a>044【必备】前缀树原理和代码详解</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习前缀树之前，需要掌握以下基础知识：</p>
<ul>
<li>讲解008-数据结构分类</li>
<li>讲解017-二叉树基本概念</li>
<li>讲解019-处理输入和输出-推荐静态空间的实现</li>
<li>讲解026-哈希表的使用</li>
</ul>
<h2 id="前缀树基本概念"><a href="#前缀树基本概念" class="headerlink" title="前缀树基本概念"></a>前缀树基本概念</h2><h3 id="什么是前缀树"><a href="#什么是前缀树" class="headerlink" title="什么是前缀树"></a>什么是前缀树</h3><p>前缀树（Trie Tree），又叫字典树，是一种树形数据结构：</p>
<ul>
<li><strong>每个样本都从头节点开始</strong>，根据前缀字符或前缀数字建出来的一棵大树</li>
<li><strong>没有路就新建节点</strong>；已经有路了，就复用节点</li>
<li>每个节点代表一个字符，从根到某个节点的路径构成一个前缀</li>
</ul>
<h3 id="前缀树的特点"><a href="#前缀树的特点" class="headerlink" title="前缀树的特点"></a>前缀树的特点</h3><p><strong>使用场景</strong>：需要根据前缀信息来查询的场景</p>
<p><strong>优点</strong>：</p>
<ul>
<li>根据前缀信息选择树上的分支，可以节省大量的时间</li>
<li>查询效率高，时间复杂度为O(m)，其中m为字符串长度</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>比较浪费空间，空间复杂度与总字符数量和字符种类相关</li>
<li>需要预先知道字符集的范围</li>
</ul>
<p><strong>定制信息</strong>：</p>
<ul>
<li><code>pass</code>：有多少个单词经过了这个节点</li>
<li><code>end</code>：有多少个单词以这个节点结尾</li>
<li>节点的子节点可以用数组或哈希表&#x2F;字典来存储</li>
</ul>
<h2 id="核心节点结构"><a href="#核心节点结构" class="headerlink" title="核心节点结构"></a>核心节点结构</h2><p>每个前缀树节点通常包含以下信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="keyword">pass</span> = <span class="number">0</span>    <span class="comment"># 有多少个单词经过了这个节点</span></span><br><span class="line">        <span class="variable language_">self</span>.end = <span class="number">0</span>     <span class="comment"># 有多少个单词以这个节点结尾</span></span><br><span class="line">        <span class="variable language_">self</span>.nexts = []  <span class="comment"># 指向子节点的链接（数组或字典）</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class44-%E5%89%8D%E7%BC%80%E6%A0%91%E6%A6%82%E5%BF%B5/%E5%89%8D%E7%BC%80%E6%A0%91%E5%BD%A2%E5%BC%8F.png" alt="前缀树形式"></p>
<h2 id="实现方式一：用类描述（不推荐）"><a href="#实现方式一：用类描述（不推荐）" class="headerlink" title="实现方式一：用类描述（不推荐）"></a>实现方式一：用类描述（不推荐）</h2><h3 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h3><ul>
<li>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-ii-prefix-tree/">https://leetcode.cn/problems/implement-trie-ii-prefix-tree/</a></li>
</ul>
<h3 id="子节点用数组实现"><a href="#子节点用数组实现" class="headerlink" title="子节点用数组实现"></a>子节点用数组实现</h3><p>适用于字符集固定且较小的情况（如26个小写英文字母）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    提交时把类名、构造方法改为Trie</span></span><br><span class="line"><span class="string">    Trie树的实现，子节点用固定长度的数组存储。</span></span><br><span class="line"><span class="string">    适用于字符集固定且较小的情况（如26个小写英文字母）。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_TrieNode</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># pass: 有多少个单词经过了这个节点</span></span><br><span class="line">            <span class="variable language_">self</span>.pas = <span class="number">0</span></span><br><span class="line">            <span class="comment"># end: 有多少个单词以这个节点结尾</span></span><br><span class="line">            <span class="variable language_">self</span>.end = <span class="number">0</span></span><br><span class="line">            <span class="comment"># nexts: 指向26个可能的子节点的链接,是一个小数组</span></span><br><span class="line">            <span class="variable language_">self</span>.nexts = [<span class="literal">None</span>] * <span class="number">26</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化Trie树，创建一个空的根节点。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._root = <span class="variable language_">self</span>._TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        向前缀树中插入一个单词。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._root</span><br><span class="line">        node.pas += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从左往右遍历字符</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># 由字符，对应成走向哪条路 (0-25)</span></span><br><span class="line">            path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)  <span class="comment"># ord获取char的ASCII码,a的ASCII码是97</span></span><br><span class="line">            <span class="comment"># 检查这个字符的路径是否已经存在节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">                node.nexts[path] = <span class="variable language_">self</span>._TrieNode()  <span class="comment"># 如果path位置为空，则创建一个新节点</span></span><br><span class="line">            node = node.nexts[path]</span><br><span class="line">            node.pas += <span class="number">1</span></span><br><span class="line">        node.end += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">erase</span>(<span class="params">self, word: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果之前word插入过前缀树，那么此时删掉一次。</span></span><br><span class="line"><span class="string">        如果之前word没有插入过前缀树，那么什么也不做。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.countWordsEqualTo(word) &gt; <span class="number">0</span>:  <span class="comment"># 先用countWordsEqualTo方法检查word是否存在</span></span><br><span class="line">            node = <span class="variable language_">self</span>._root</span><br><span class="line">            node.pas -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">                path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                <span class="comment"># 如果删除后，路径上的节点的pass值为0，说明没有其他单词经过此路</span></span><br><span class="line">                <span class="comment"># 可以直接将后续节点删除（在Python中由垃圾回收处理）</span></span><br><span class="line">                node.nexts[path].pas -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> node.nexts[path].pas == <span class="number">0</span>:</span><br><span class="line">                    node.nexts[path] = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                node = node.nexts[path]</span><br><span class="line">            node.end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countWordsEqualTo</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查询前缀树里，word单词出现了几次。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            node = node.nexts[path]  <span class="comment"># 循环一次，node就走到下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> node.end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countWordsStartingWith</span>(<span class="params">self, pre: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查询前缀树里，有多少单词以pre做前缀。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> pre:</span><br><span class="line">            path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            node = node.nexts[path]</span><br><span class="line">        <span class="keyword">return</span> node.pas</span><br></pre></td></tr></table></figure>

<h3 id="子节点用哈希表实现"><a href="#子节点用哈希表实现" class="headerlink" title="子节点用哈希表实现"></a>子节点用哈希表实现</h3><p>适用于字符集不固定或非常大的情况，更节省空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Trie树的实现，子节点用字典存储。</span></span><br><span class="line"><span class="string">    适用于字符集不固定或非常大的情况，更节省空间。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_TrieNode</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="variable language_">self</span>.pas = <span class="number">0</span></span><br><span class="line">            <span class="variable language_">self</span>.end = <span class="number">0</span></span><br><span class="line">            <span class="comment"># nexts: 存储字符到子节点的映射</span></span><br><span class="line">            <span class="variable language_">self</span>.nexts = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._root = <span class="variable language_">self</span>._TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>):</span><br><span class="line">        node = <span class="variable language_">self</span>._root</span><br><span class="line">        node.pas += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node.nexts:</span><br><span class="line">                node.nexts[char] = <span class="variable language_">self</span>._TrieNode()</span><br><span class="line">            node = node.nexts[char]</span><br><span class="line">            node.pas += <span class="number">1</span></span><br><span class="line">        node.end += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">erase</span>(<span class="params">self, word: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.countWordsEqualTo(word) &gt; <span class="number">0</span>:</span><br><span class="line">            node = <span class="variable language_">self</span>._root</span><br><span class="line">            node.pas -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">                next_node = node.nexts[char]</span><br><span class="line">                next_node.pas -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> next_node.pas == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 如果pass为0，直接从字典中移除该路径</span></span><br><span class="line">                    node.nexts.pop(char)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                node = next_node</span><br><span class="line">            node.end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countWordsEqualTo</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        node = <span class="variable language_">self</span>._root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node.nexts:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            node = node.nexts[char]</span><br><span class="line">        <span class="keyword">return</span> node.end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countWordsStartingWith</span>(<span class="params">self, pre: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        node = <span class="variable language_">self</span>._root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> pre:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node.nexts:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            node = node.nexts[char]</span><br><span class="line">        <span class="keyword">return</span> node.pas</span><br></pre></td></tr></table></figure>

<h2 id="实现方式二：静态数组实现（推荐）"><a href="#实现方式二：静态数组实现（推荐）" class="headerlink" title="实现方式二：静态数组实现（推荐）"></a>实现方式二：静态数组实现（推荐）</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>抛弃节点对象的概念，将所有节点信息存储在几个大的全局数组中：</p>
<ul>
<li>使用一个整数 <code>cnt</code> 作为节点编号或索引</li>
<li><code>tree[i][j]</code>：表示编号为 i 的节点的第 j 条路（对应某个字符）指向的子节点的编号</li>
<li><code>end[i]</code>：表示以编号为 i 的节点结尾的单词数量</li>
<li><code>pas[i]</code>：表示经过编号为 i 的节点的单词数量</li>
</ul>
<p>这种方式内存是静态分配的，且数据在内存中连续，通常有更好的缓存性能。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class44-%E5%89%8D%E7%BC%80%E6%A0%91%E6%A6%82%E5%BF%B5/%E9%9D%99%E6%80%81%E5%89%8D%E7%BC%80%E6%A0%91.png" alt="静态前缀树"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class44-%E5%89%8D%E7%BC%80%E6%A0%91%E6%A6%82%E5%BF%B5/%E6%89%93%E6%95%A3%E4%BD%8D%E4%BF%A1%E6%81%AF.png" alt="打散位信息"></p>
<h3 id="测试链接-1"><a href="#测试链接-1" class="headerlink" title="测试链接"></a>测试链接</h3><ul>
<li>测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b">https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b</a></li>
</ul>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将来增加了数据量，就改大这个值</span></span><br><span class="line">MAXN = <span class="number">150001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量模拟 Java 的静态变量</span></span><br><span class="line">tree = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line">end = [<span class="number">0</span>] * MAXN</span><br><span class="line">pas = [<span class="number">0</span>] * MAXN</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    初始化/重置Trie。根节点编号为1，总节点数从1开始。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">word: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向前缀树中插入一个单词。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    pas[cur] += <span class="number">1</span>  <span class="comment"># pas[cur]：节点 cur 被经过的次数</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:  <span class="comment"># tree[cur][path]:邻接表的数组实现，记录了从节点 cur 出发，沿着字符 path 能到达的下一个节点</span></span><br><span class="line">            <span class="comment"># 如果路径不存在，创建一个新节点</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            tree[cur][path] = cnt</span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">        pas[cur] += <span class="number">1</span></span><br><span class="line">    end[cur] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查询一个单词在前缀树中出现的次数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">    <span class="keyword">return</span> end[cur]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_number</span>(<span class="params">pre: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查询以 pre 为前缀的单词数量。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> pre:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">    <span class="keyword">return</span> pas[cur]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">word: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从前缀树中删除一个单词。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> search(word) &gt; <span class="number">0</span>:</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 根节点的 pass 值减1</span></span><br><span class="line">        pas[cur] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="comment"># 路径上节点的 pass 值减1</span></span><br><span class="line">            pas[tree[cur][path]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pas[tree[cur][path]] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 如果 pass 减到0，说明此路径不再被任何单词使用，可以删除</span></span><br><span class="line">                tree[cur][path] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur = tree[cur][path]</span><br><span class="line">        <span class="comment"># 最后一个节点的 end 值减1</span></span><br><span class="line">        end[cur] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    清空Trie树，为下一个测试用例做准备。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> tree, end, pas</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cnt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            tree[i][j] = <span class="number">0</span></span><br><span class="line">        end[i] = <span class="number">0</span></span><br><span class="line">        pas[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理输入输出的主函数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    line_iter = <span class="built_in">iter</span>(lines)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 持续读取直到没有输入</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 为每个测试用例重置/构建Trie</span></span><br><span class="line">            build()</span><br><span class="line">            </span><br><span class="line">            m_line = <span class="built_in">next</span>(line_iter)  <span class="comment"># next获得迭代器里获得下一个对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> m_line: <span class="keyword">continue</span></span><br><span class="line">            m = <span class="built_in">int</span>(m_line.strip())</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                splits = <span class="built_in">next</span>(line_iter).strip().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">                op = <span class="built_in">int</span>(splits[<span class="number">0</span>])</span><br><span class="line">                word = splits[<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">                    insert(word)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">                    delete(word)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="number">3</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> search(word) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="number">4</span>:</span><br><span class="line">                    <span class="built_in">print</span>(prefix_number(word))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 清理本次用例的数据（虽然对于某些OJ，不清理也行，因为是新进程）</span></span><br><span class="line">            clear()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="前缀树的基本操作"><a href="#前缀树的基本操作" class="headerlink" title="前缀树的基本操作"></a>前缀树的基本操作</h2><h3 id="1-插入操作-Insert"><a href="#1-插入操作-Insert" class="headerlink" title="1. 插入操作 (Insert)"></a>1. 插入操作 (Insert)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">word: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入一个单词到前缀树中&quot;&quot;&quot;</span></span><br><span class="line">    node = root</span><br><span class="line">    node.<span class="keyword">pass</span> += <span class="number">1</span>  <span class="comment"># 根节点被经过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)  <span class="comment"># 计算字符对应的路径</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">            node.nexts[path] = TrieNode()  <span class="comment"># 创建新节点</span></span><br><span class="line">        node = node.nexts[path]  <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        node.<span class="keyword">pass</span> += <span class="number">1</span>  <span class="comment"># 更新经过次数</span></span><br><span class="line">    </span><br><span class="line">    node.end += <span class="number">1</span>  <span class="comment"># 标记单词结尾</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(m)，其中m是单词长度<br><strong>空间复杂度</strong>：O(m)，最坏情况下需要创建m个新节点</p>
<h3 id="2-查找操作-Search"><a href="#2-查找操作-Search" class="headerlink" title="2. 查找操作 (Search)"></a>2. 查找操作 (Search)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查找单词在前缀树中的出现次数&quot;&quot;&quot;</span></span><br><span class="line">    node = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 路径不存在，单词不在树中</span></span><br><span class="line">        node = node.nexts[path]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node.end  <span class="comment"># 返回以此节点结尾的单词数量</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(m)<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="3-前缀查询-Prefix-Search"><a href="#3-前缀查询-Prefix-Search" class="headerlink" title="3. 前缀查询 (Prefix Search)"></a>3. 前缀查询 (Prefix Search)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countWordsStartingWith</span>(<span class="params">prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询以prefix为前缀的单词数量&quot;&quot;&quot;</span></span><br><span class="line">    node = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        node = node.nexts[path]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node.<span class="keyword">pass</span>  <span class="comment"># 返回经过此节点的单词数量</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(m)<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="4-删除操作-Delete"><a href="#4-删除操作-Delete" class="headerlink" title="4. 删除操作 (Delete)"></a>4. 删除操作 (Delete)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">word: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从前缀树中删除一个单词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> search(word) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 单词不存在，无需删除</span></span><br><span class="line">    </span><br><span class="line">    node = root</span><br><span class="line">    node.<span class="keyword">pass</span> -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        next_node = node.nexts[path]</span><br><span class="line">        next_node.<span class="keyword">pass</span> -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> next_node.<span class="keyword">pass</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果经过次数为0，删除整个分支</span></span><br><span class="line">            node.nexts[path] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        node = next_node</span><br><span class="line">    </span><br><span class="line">    node.end -= <span class="number">1</span>  <span class="comment"># 减少结尾标记</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(m)<br><strong>空间复杂度</strong>：O(1)</p>
<h2 id="前缀树的应用场景"><a href="#前缀树的应用场景" class="headerlink" title="前缀树的应用场景"></a>前缀树的应用场景</h2><h3 id="1-自动补全"><a href="#1-自动补全" class="headerlink" title="1. 自动补全"></a>1. 自动补全</h3><p>前缀树非常适合实现自动补全功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">autocomplete</span>(<span class="params">prefix: <span class="built_in">str</span>, max_suggestions: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据前缀返回自动补全建议&quot;&quot;&quot;</span></span><br><span class="line">    node = root</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到前缀对应的节点</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.nexts[path]:</span><br><span class="line">            <span class="keyword">return</span> []  <span class="comment"># 前缀不存在</span></span><br><span class="line">        node = node.nexts[path]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从该节点开始收集所有单词</span></span><br><span class="line">    suggestions = []</span><br><span class="line">    _collect_words(node, prefix, suggestions, max_suggestions)</span><br><span class="line">    <span class="keyword">return</span> suggestions</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_collect_words</span>(<span class="params">node, current_prefix, suggestions, max_suggestions</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归收集以当前前缀开始的所有单词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(suggestions) &gt;= max_suggestions:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.end &gt; <span class="number">0</span>:</span><br><span class="line">        suggestions.append(current_prefix)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> node.nexts[i]:</span><br><span class="line">            next_char = <span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            _collect_words(node.nexts[i], current_prefix + next_char, </span><br><span class="line">                          suggestions, max_suggestions)</span><br></pre></td></tr></table></figure>

<h3 id="2-拼写检查"><a href="#2-拼写检查" class="headerlink" title="2. 拼写检查"></a>2. 拼写检查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spell_check</span>(<span class="params">word: <span class="built_in">str</span>, max_distance: <span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回与给定单词编辑距离在max_distance内的所有单词&quot;&quot;&quot;</span></span><br><span class="line">    suggestions = []</span><br><span class="line">    _find_similar_words(root, <span class="string">&quot;&quot;</span>, word, <span class="number">0</span>, max_distance, suggestions)</span><br><span class="line">    <span class="keyword">return</span> suggestions</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_find_similar_words</span>(<span class="params">node, current_word, target, distance, max_distance, suggestions</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用动态规划找到相似单词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> distance &gt; max_distance:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.end &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(current_word) == <span class="built_in">len</span>(target):</span><br><span class="line">        <span class="keyword">if</span> distance &lt;= max_distance:</span><br><span class="line">            suggestions.append(current_word)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归遍历所有可能的路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> node.nexts[i]:</span><br><span class="line">            next_char = <span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="comment"># 计算新的编辑距离</span></span><br><span class="line">            new_distance = distance</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(current_word) &lt; <span class="built_in">len</span>(target) <span class="keyword">and</span> target[<span class="built_in">len</span>(current_word)] != next_char:</span><br><span class="line">                new_distance += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            _find_similar_words(node.nexts[i], current_word + next_char, </span><br><span class="line">                              target, new_distance, max_distance, suggestions)</span><br></pre></td></tr></table></figure>

<h3 id="3-单词频率统计"><a href="#3-单词频率统计" class="headerlink" title="3. 单词频率统计"></a>3. 单词频率统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_word_frequency_stats</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取前缀树中的单词频率统计&quot;&quot;&quot;</span></span><br><span class="line">    stats = &#123;&#125;</span><br><span class="line">    _collect_frequencies(root, <span class="string">&quot;&quot;</span>, stats)</span><br><span class="line">    <span class="keyword">return</span> stats</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_collect_frequencies</span>(<span class="params">node, current_word, stats</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归收集所有单词及其频率&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node.end &gt; <span class="number">0</span>:</span><br><span class="line">        stats[current_word] = node.end</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> node.nexts[i]:</span><br><span class="line">            next_char = <span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            _collect_frequencies(node.nexts[i], current_word + next_char, stats)</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>O(m)</td>
<td>O(1)</td>
<td>m为单词长度，使用预分配的静态数组</td>
</tr>
<tr>
<td>查找</td>
<td>O(m)</td>
<td>O(1)</td>
<td>m为单词长度</td>
</tr>
<tr>
<td>前缀查询</td>
<td>O(m)</td>
<td>O(1)</td>
<td>m为前缀长度</td>
</tr>
<tr>
<td>删除</td>
<td>O(m)</td>
<td>O(1)</td>
<td>m为单词长度</td>
</tr>
<tr>
<td>自动补全</td>
<td>O(m + k)</td>
<td>O(h + k)</td>
<td>m&#x3D;前缀长度，k&#x3D;返回结果总字符数，h&#x3D;树最大深度</td>
</tr>
</tbody></table>
<p><strong>空间复杂度（整体）</strong>：O(ALPHABET_SIZE × N × M)</p>
<ul>
<li>ALPHABET_SIZE：字符集大小（如26）</li>
<li>N：插入的单词数量</li>
<li>M：平均单词长度</li>
</ul>
<h2 id="优化技巧和注意事项"><a href="#优化技巧和注意事项" class="headerlink" title="优化技巧和注意事项"></a>优化技巧和注意事项</h2><h3 id="1-内存优化"><a href="#1-内存优化" class="headerlink" title="1. 内存优化"></a>1. 内存优化</h3><p><strong>压缩前缀树（Compressed Trie）</strong>：</p>
<ul>
<li>将只有一个子节点的路径压缩成一条边</li>
<li>节省空间，但增加了实现复杂度</li>
</ul>
<p><strong>数组 vs 哈希表选择</strong>：</p>
<ul>
<li>字符集固定且较小：使用数组</li>
<li>字符集大或不确定：使用哈希表</li>
</ul>
<h3 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h3><p><strong>静态数组实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐使用静态数组，避免频繁的内存分配</span></span><br><span class="line">MAXN = <span class="number">150001</span></span><br><span class="line">tree = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br></pre></td></tr></table></figure>

<p><strong>批量操作</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">batch_insert</span>(<span class="params">words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;批量插入，减少函数调用开销&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        insert(word)</span><br></pre></td></tr></table></figure>

<h3 id="3-扩展功能"><a href="#3-扩展功能" class="headerlink" title="3. 扩展功能"></a>3. 扩展功能</h3><p><strong>支持通配符查询</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wildcard_search</span>(<span class="params">pattern: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;支持&#x27;.&#x27;作为通配符的查询&quot;&quot;&quot;</span></span><br><span class="line">    results = []</span><br><span class="line">    _wildcard_dfs(root, pattern, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, results)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_wildcard_dfs</span>(<span class="params">node, pattern, index, current_word, results</span>):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(pattern):</span><br><span class="line">        <span class="keyword">if</span> node.end &gt; <span class="number">0</span>:</span><br><span class="line">            results.append(current_word)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    char = pattern[index]</span><br><span class="line">    <span class="keyword">if</span> char == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        <span class="comment"># 通配符，尝试所有可能的字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> node.nexts[i]:</span><br><span class="line">                next_char = <span class="built_in">chr</span>(i + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">                _wildcard_dfs(node.nexts[i], pattern, index + <span class="number">1</span>, </span><br><span class="line">                            current_word + next_char, results)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 普通字符</span></span><br><span class="line">        path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node.nexts[path]:</span><br><span class="line">            _wildcard_dfs(node.nexts[path], pattern, index + <span class="number">1</span>, </span><br><span class="line">                        current_word + char, results)</span><br></pre></td></tr></table></figure>

<h2 id="实战应用示例"><a href="#实战应用示例" class="headerlink" title="实战应用示例"></a>实战应用示例</h2><h3 id="LeetCode相关题目"><a href="#LeetCode相关题目" class="headerlink" title="LeetCode相关题目"></a>LeetCode相关题目</h3><ol>
<li><strong>208. 实现 Trie (前缀树)</strong>：基础的前缀树实现</li>
<li><strong>211. 添加与搜索单词</strong>：支持通配符的前缀树</li>
<li><strong>212. 单词搜索 II</strong>：在二维网格中搜索单词</li>
<li><strong>421. 数组中两个数的最大异或值</strong>：使用前缀树优化位运算</li>
<li><strong>648. 单词替换</strong>：使用前缀树实现单词替换</li>
</ol>
<h3 id="工程实践建议"><a href="#工程实践建议" class="headerlink" title="工程实践建议"></a>工程实践建议</h3><ol>
<li><p><strong>选择合适的实现方式</strong>：</p>
<ul>
<li>简单应用：使用类实现</li>
<li>高性能要求：使用静态数组</li>
<li>内存敏感：使用哈希表</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：</p>
<ul>
<li>及时清理不需要的节点</li>
<li>考虑使用对象池减少GC压力</li>
</ul>
</li>
<li><p><strong>并发安全</strong>：</p>
<ul>
<li>读写分离</li>
<li>使用读写锁</li>
<li>考虑无锁数据结构</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前缀树是一种强大的字符串处理数据结构，特别适合：</p>
<ul>
<li><strong>前缀查询</strong>：快速找到所有具有特定前缀的字符串</li>
<li><strong>自动补全</strong>：实现搜索建议功能</li>
<li><strong>拼写检查</strong>：找到相似的单词</li>
<li><strong>字符串匹配</strong>：高效的模式匹配</li>
</ul>
<p>通过合理选择实现方式和优化策略，前缀树可以在保持高效性能的同时，提供丰富的字符串操作功能。在实际应用中，需要根据具体的使用场景选择最适合的实现方案。</p>
<hr>
<h1 id="045【必备】前缀树的相关题目"><a href="#045【必备】前缀树的相关题目" class="headerlink" title="045【必备】前缀树的相关题目"></a>045【必备】前缀树的相关题目</h1><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习前缀树相关题目之前，需要掌握以下基础知识：</p>
<ul>
<li>讲解044：前缀树原理和代码详解-静态空间的方式实现</li>
<li>基本的字符串操作和递归思想</li>
<li>深度优先搜索(DFS)的基本概念</li>
</ul>
<h2 id="前缀树基础回顾"><a href="#前缀树基础回顾" class="headerlink" title="前缀树基础回顾"></a>前缀树基础回顾</h2><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前缀树的全局变量设计</span></span><br><span class="line">MAXN = <span class="number">2000001</span>  <span class="comment"># 根据题目数据规模调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tree[i][j] 表示编号为i的节点，走向字符j的下一个节点编号</span></span><br><span class="line">tree = [[<span class="number">0</span>] * 字符集大小 <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line"><span class="comment"># pas[i] 表示编号为i的节点被多少个字符串经过</span></span><br><span class="line">pas = [<span class="number">0</span>] * MAXN</span><br><span class="line"><span class="comment"># end[i] 表示编号为i的节点是否为某个字符串的结尾</span></span><br><span class="line">end = [<span class="number">0</span>] * MAXN  <span class="comment"># 或存储具体的字符串</span></span><br><span class="line">cnt = <span class="number">0</span>  <span class="comment"># 节点计数器</span></span><br></pre></td></tr></table></figure>

<h3 id="基本操作模板"><a href="#基本操作模板" class="headerlink" title="基本操作模板"></a>基本操作模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化Trie，根节点编号为1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">word: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将字符串插入Trie&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    pas[cur] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = get_path(char)  <span class="comment"># 将字符映射到路径索引</span></span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            tree[cur][path] = cnt</span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">        pas[cur] += <span class="number">1</span></span><br><span class="line">    end[cur] = word  <span class="comment"># 或设置为True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;搜索字符串是否存在&quot;&quot;&quot;</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = get_path(char)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">    <span class="keyword">return</span> end[cur] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_prefix</span>(<span class="params">prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算以prefix为前缀的字符串数量&quot;&quot;&quot;</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">        path = get_path(char)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">    <span class="keyword">return</span> pas[cur]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="题目一：接头密匙（差值序列匹配）"><a href="#题目一：接头密匙（差值序列匹配）" class="headerlink" title="题目一：接头密匙（差值序列匹配）"></a>题目一：接头密匙（差值序列匹配）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>牛牛和他的朋友们约定了一套接头密匙系统，用于确认彼此身份。密匙由一组数字序列表示，两个密匙被认为是一致的，如果满足以下条件：</p>
<ul>
<li>密匙 b 的长度不超过密匙 a 的长度</li>
<li>对于任意 0 &lt;&#x3D; i &lt; length(b)，有 b[i+1] - b[i] &#x3D;&#x3D; a[i+1] - a[i]</li>
</ul>
<p>现在给定了m个密匙 b 的数组，以及n个密匙 a 的数组，请你返回一个长度为 m 的结果数组 ans，表示每个密匙b都有多少一致的密匙。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932">https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class45%E5%89%8D%E7%BC%80%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/%E8%AF%86%E5%88%AB%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="识别字符串"></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>问题的关键在于比较”差值序列”，而不是原始数字序列：</p>
<ol>
<li><strong>差值序列转换</strong>：将每个键 a (如 [3, 6, 50]) 转换为其差值字符串 (如 “3#44#”)</li>
<li><strong>前缀树构建</strong>：将所有 a 的差值字符串插入到一个前缀树 (Trie) 中。每个节点记录有多少个字符串经过它 (pass计数)</li>
<li><strong>前缀匹配查询</strong>：对于每个键 b，将其转换为差值字符串，在Trie中查询以此为前缀的字符串数量</li>
<li><strong>一致性判定</strong>：这个数量就是与 b 一致的 a 的数量。因为如果 a 的差值序列以 b 的差值序列为前缀，就满足题目中的“一致”条件</li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果将来增加了数据量，就改大这个值</span></span><br><span class="line">MAXN = <span class="number">2000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量模拟 Java 的静态变量</span></span><br><span class="line">tree = [[<span class="number">0</span>] * <span class="number">12</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line">pas = [<span class="number">0</span>] * MAXN</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化Trie，根节点编号为1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;0&#x27;~&#x27;9&#x27; -&gt; 0~9, &#x27;#&#x27; -&gt; 10, &#x27;-&#x27; -&gt; 11 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">char: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将字符映射到Trie的路径索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> char == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:  <span class="comment"># - 是负差值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(char)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">word: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将差值字符串插入Trie&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    pas[cur] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        path = get_path(char)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            tree[cur][path] = cnt</span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">        pas[cur] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">pre: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算以 pre 为前缀的字符串数量&quot;&quot;&quot;</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> pre:</span><br><span class="line">        path = get_path(char)</span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line">    <span class="keyword">return</span> pas[cur]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_consistent_keys</span>(<span class="params">b, a</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数，处理接头密匙逻辑&quot;&quot;&quot;</span></span><br><span class="line">    build()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将所有 a 的差值序列插入Trie</span></span><br><span class="line">    <span class="keyword">for</span> nums <span class="keyword">in</span> a:</span><br><span class="line">        diff_str_parts = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            diff_str_parts.append(<span class="built_in">str</span>(nums[i] - nums[i-<span class="number">1</span>]))</span><br><span class="line">            diff_str_parts.append(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">        insert(<span class="string">&quot;&quot;</span>.join(diff_str_parts))</span><br><span class="line">    </span><br><span class="line">    ans = [<span class="number">0</span>] * <span class="built_in">len</span>(b)</span><br><span class="line">    <span class="comment"># 查询每个 b 的差值序列在前缀树中的计数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        nums = b[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果 b 只有一个或零个元素，差值序列为空</span></span><br><span class="line">            <span class="comment"># 空前缀匹配所有插入的 a，所以结果是 a 的总数</span></span><br><span class="line">            ans[i] = <span class="built_in">len</span>(a)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff_str_parts = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                diff_str_parts.append(<span class="built_in">str</span>(nums[j] - nums[j-<span class="number">1</span>]))</span><br><span class="line">                diff_str_parts.append(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">            ans[i] = count(<span class="string">&quot;&quot;</span>.join(diff_str_parts))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(a数组的数字个数 * 10) + O(b数组的数字个数 * 10)</li>
<li><strong>空间复杂度</strong>：O(a数组的数字个数 * 10)，这是树上的节点数量</li>
<li><strong>核心技巧</strong>：差值序列 + 前缀匹配</li>
</ul>
<hr>
<h2 id="题目二：数组中两个数的最大异或值"><a href="#题目二：数组中两个数的最大异或值" class="headerlink" title="题目二：数组中两个数的最大异或值"></a>题目二：数组中两个数的最大异或值</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/</a></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：前缀树解法"><a href="#方法一：前缀树解法" class="headerlink" title="方法一：前缀树解法"></a>方法一：前缀树解法</h4><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><p>使用前缀树存储所有数字的二进制表示，然后贪心地寻找最大异或值：</p>
<ol>
<li><strong>二进制Trie构建</strong>：将所有数字的二进制表示（从高位到低位）插入到一个Trie中</li>
<li><strong>贪心搜索</strong>：遍历每个数字 <code>num</code>，然后在Trie中为它寻找一个最佳的配对 <code>x</code>，以最大化 <code>num XOR x</code></li>
<li><strong>位级贪心</strong>：寻找最佳配对的过程是贪心的：从最高位开始，对于 <code>num</code> 的每一位，我们都期望在Trie中找到与之相反的位。如果Trie中存在相反位的路径，我们就走这条路，这会使结果的当前位为1。如果不存在，我们只能走相同位的路径，结果的当前位为0</li>
<li><strong>最优解更新</strong>：遍历所有数字，找到全局最大异或值</li>
</ol>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class45%E5%89%8D%E7%BC%80%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/%E9%A2%98%E7%9B%AE2-%E5%BC%82%E6%88%96.png" alt="题目2-异或"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">3000001</span></span><br><span class="line">tree = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">high = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;构建Trie树，插入所有数字的二进制表示&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt, high</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到数组中的最大值，以确定需要处理的二进制位数</span></span><br><span class="line">    maximum = <span class="built_in">max</span>(nums) <span class="keyword">if</span> nums <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># high: 最高位的索引。例如，max=13(1101), bit_length=4, high=3</span></span><br><span class="line">    high = maximum.bit_length() - <span class="number">1</span> <span class="keyword">if</span> maximum &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span> <span class="comment">#bit_length返回的是二进制所需的位数，maximum&gt;0表示没有有效位数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        insert(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将一个数字的二进制位插入Trie&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 从最高有效位开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        path = (num &gt;&gt; i) &amp; <span class="number">1</span> <span class="comment">#将 num 的二进制表示向右移动 i 位，结果只保留最低位（第0位）</span></span><br><span class="line">        <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            tree[cur][path] = cnt</span><br><span class="line">        cur = tree[cur][path]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_xor</span>(<span class="params">num</span>): <span class="comment">#就前缀树的这个</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;对于给定的num，在Trie中寻找能使其异或结果最大的数&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># status: num 在第 i 位的状态 (0 or 1)</span></span><br><span class="line">        status = (num &gt;&gt; i) &amp; <span class="number">1</span> </span><br><span class="line">        <span class="comment"># want: 希望遇到的对方路径，即与 status相反的位，这样异或结果在该位上是1</span></span><br><span class="line">        want = <span class="number">1</span> - status</span><br><span class="line">        <span class="comment"># 检查Trie中是否存在期望的路径</span></span><br><span class="line">        <span class="keyword">if</span> tree[cur][want] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果期望的路径不存在，只能走另一条路</span></span><br><span class="line">            want = <span class="number">1</span> - want</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># (status ^ want) 是当前位实际的异或结果</span></span><br><span class="line">        <span class="comment"># 将其左移 i 位，加到 ans 中</span></span><br><span class="line">        ans |= (status ^ want) &lt;&lt; i <span class="comment">#计算当前位的异或结果，将结果左移到正确的位置，累加到最终答案中</span></span><br><span class="line">        cur = tree[cur][want] <span class="comment">#在Trie树中移动到下一个节点</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;清空Trie&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cnt + <span class="number">1</span>):</span><br><span class="line">        tree[i][<span class="number">0</span>] = tree[i][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findMaximumXOR1</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Trie解法主函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    build(nums)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, max_xor(num))</span><br><span class="line">    clear()</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="方法二：哈希表解法"><a href="#方法二：哈希表解法" class="headerlink" title="方法二：哈希表解法"></a>方法二：哈希表解法</h4><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><p>使用前缀树存储所有数字的二进制表示，然后贪心地寻找最大异或值：</p>
<ol>
<li>假设我们已经确定了最大值的前k位（从高到低），结果是 <code>ans</code>。</li>
<li>现在我们来确定第 i 位。我们贪心地希望第 i 位是 1。<br> 令我们的目标 <code>better = ans | (1 &lt;&lt; i)</code>。</li>
<li>问题转化为：是否存在两个数 <code>p</code> 和 <code>q</code>，使得 <code>(p XOR q)</code> 的前缀等于 <code>better</code>？<br> 这等价于 <code>p</code> 的前缀等于 <code>better</code> 的前缀 <code>XOR</code> <code>q</code> 的前缀。</li>
<li>我们将所有数字的前缀（保留高位，低位置0）放入一个哈希集合 <code>set</code> 中。</li>
<li>然后遍历这个集合，对于每个前缀 <code>p_prefix</code>，检查 <code>better ^ p_prefix</code> 是否也在集合中。</li>
<li>如果在，说明 <code>better</code> 这个目标是可以达成的，我们就更新 <code>ans = better</code>。<br> 否则，第 i 位只能是 0，<code>ans</code> 保持不变。</li>
<li>重复此过程直到最低位。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class45%E5%89%8D%E7%BC%80%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/%E9%A2%98%E7%9B%AE2-hashset%E8%A7%A3%E6%B3%95.png" alt="题目2-hashset解法"></p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findMaximumXOR2</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    哈希表解法主函数</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    从最高位向最低位，一位一位地确定最大异或值的可能值。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    maximum = <span class="built_in">max</span>(nums)</span><br><span class="line">    high_bit = maximum.bit_length() - <span class="number">1</span> <span class="keyword">if</span> maximum &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    seen_prefixes = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(high_bit, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 贪心目标：尝试让第 i 位为 1</span></span><br><span class="line">        better = ans | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">        seen_prefixes.clear() <span class="comment"># 先clear掉hashset里的所有元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将所有数字的 i-位前缀放入集合</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            seen_prefixes.add(num &gt;&gt; i)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 检查 better 这个前缀是否可以由集合中的某两个数异或得到</span></span><br><span class="line">        <span class="comment"># a ^ b = c  &lt;=&gt;  a ^ c = b</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> seen_prefixes: <span class="comment">#遍历hashset里的所有元素</span></span><br><span class="line">            <span class="keyword">if</span> (better &gt;&gt; i) ^ p <span class="keyword">in</span> seen_prefixes:</span><br><span class="line">                ans = better</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># if any(((better &gt;&gt; i) ^ p) in seen_prefixes for p in seen_prefixes):</span></span><br><span class="line">        <span class="comment">#     ans = better</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n * logV)，V是数值范围</li>
<li><strong>空间复杂度</strong>：O(n * logV)</li>
<li><strong>核心技巧</strong>：二进制前缀树 + 贪心搜索</li>
</ul>
<hr>
<h2 id="题目三：在二维字符数组中搜索可能的单词"><a href="#题目三：在二维字符数组中搜索可能的单词" class="headerlink" title="题目三：在二维字符数组中搜索可能的单词"></a>题目三：在二维字符数组中搜索可能的单词</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，返回所有二维网格上的单词。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中”相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/">https://leetcode.cn/problems/word-search-ii/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(20)/class45%E5%89%8D%E7%BC%80%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/%E9%A2%98%E7%9B%AE3-%E7%94%A8%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%A5%BD%E5%A4%84.png" alt="题目3-用前缀树的好处"></p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p>结合前缀树和深度优先搜索，实现高效的多单词同时搜索：</p>
<ol>
<li><strong>前缀树构建</strong>：将所有 <code>words</code> 构建成一棵前缀树。这使得我们可以同时搜索所有的单词。</li>
<li><strong>DFS</strong>：从 <code>board</code> 的每一个单元格出发，进行深度优先搜索（DFS）。</li>
<li><strong>Trie同步</strong>：DFS 的每一步不仅在 <code>board</code> 上移动，也同步在前缀树上移动。</li>
<li>如果在 <code>board</code> 上的路径能在前缀树中走通，说明这个路径是一个或多个单词的前缀。</li>
<li>如果走到了一个前缀树的 <code>end</code> 节点，说明找到了一个单词，将其加入结果集。</li>
<li><strong>剪枝优化</strong>：<br> a. 在DFS中，如果前缀树的某个路径后续没有单词了（pass计数为0），则停止该方向的搜索。<br> b. 找到一个单词后，将其从前缀树中“逻辑删除”（如将end设为None），并更新pass计数，避免重复查找和无效搜索。</li>
<li><strong>回溯处理</strong>：使用哨兵值标记已访问格子，回溯时恢复现场</li>
</ol>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量模拟静态数组</span></span><br><span class="line">MAXN = <span class="number">30001</span>  <span class="comment"># words.length * words[i].length</span></span><br><span class="line">tree = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line">pas = [<span class="number">0</span>] * MAXN</span><br><span class="line">end = [<span class="literal">None</span>] * MAXN</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将所有待查单词构建成一棵Trie树&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        pas[cur] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            path = <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                tree[cur][path] = cnt <span class="comment"># 把当前节点 cur 在这条路径 path 上的“指针”设为新节点编号</span></span><br><span class="line">            cur = tree[cur][path] <span class="comment"># 在Trie树中移动到下一个节点</span></span><br><span class="line">            pas[cur] += <span class="number">1</span></span><br><span class="line">        end[cur] = word</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;清理Trie树&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cnt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            tree[i][j] = <span class="number">0</span></span><br><span class="line">        pas[i] = <span class="number">0</span></span><br><span class="line">        end[i] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], i: <span class="built_in">int</span>, j: <span class="built_in">int</span>, t: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    深度优先搜索函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    board: 二维网格</span></span><br><span class="line"><span class="string">    i, j: 当前格子位置</span></span><br><span class="line"><span class="string">    t: 当前在前缀树中的节点编号</span></span><br><span class="line"><span class="string">    ans: 结果列表，里面是收集到的字符串</span></span><br><span class="line"><span class="string">    返回值: 从 (i,j) 出发，新收集到了几个字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 大剪枝：i，j越界 或 走了回头路(board[i][j] == 0，即ascii码=0)，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j == <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    tmp = board[i][j]</span><br><span class="line">    road = <span class="built_in">ord</span>(tmp) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">#路的编号而不是节点的编号</span></span><br><span class="line">    <span class="comment"># t: 当前节点, tree[t][road]: 下一节点</span></span><br><span class="line">    t_next = tree[t][road]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 剪枝：如果后续路径上没有任何单词（t_next == 0）或者结果已经收集全了(pas[t_next] == 0)，则无需继续搜索。不过其实这两个条件是等价的</span></span><br><span class="line">    <span class="keyword">if</span> t_next == <span class="number">0</span>: <span class="comment"># or pas[t_next] == 0:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># fix: 从当前 (i, j) 位置出发，总共收集到了几个新字符串</span></span><br><span class="line">    fix = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果当前Trie节点是一个单词的结尾</span></span><br><span class="line">    <span class="keyword">if</span> end[t_next] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        fix += <span class="number">1</span></span><br><span class="line">        ans.append(end[t_next]) <span class="comment"># 前缀树的尽头</span></span><br><span class="line">        <span class="comment"># 防止重复添加</span></span><br><span class="line">        end[t_next] = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 标记当前位置已访问</span></span><br><span class="line">    board[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 向上、下、左、右四个方向递归搜索</span></span><br><span class="line">    fix += dfs(board, i - <span class="number">1</span>, j, t_next, ans)</span><br><span class="line">    fix += dfs(board, i + <span class="number">1</span>, j, t_next, ans)</span><br><span class="line">    fix += dfs(board, i, j - <span class="number">1</span>, t_next, ans)</span><br><span class="line">    fix += dfs(board, i, j + <span class="number">1</span>, t_next, ans)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 剪枝优化：回溯时，更新Trie树的pass计数。</span></span><br><span class="line">    <span class="comment"># fix是本次DFS调用中找到的单词总数。</span></span><br><span class="line">    <span class="comment"># 将这些单词从后续的搜索路径中“移除”，避免不必要的搜索。</span></span><br><span class="line">    pas[t_next] -= fix <span class="comment"># 把本次从 t_next 开始的 DFS 一共找到的单词数 fix，从该 Trie 节点的经过计数 pas[t_next] 中减掉</span></span><br><span class="line">    <span class="comment"># 回溯：恢复现场。过程：进入格子前保存字符到 tmp → 标记已访问为 0（哨兵，避免重复走）→ 递归结束后把 board[i][j] 设回 tmp，这样其他路径还能正常使用该格子。</span></span><br><span class="line">    board[i][j] = tmp</span><br><span class="line">    <span class="keyword">return</span> fix</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findWords</span>(<span class="params">board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    build(words)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            dfs(board, i, j, <span class="number">1</span>, ans) <span class="comment"># 根节点编号为1</span></span><br><span class="line">    clear()</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(m * n * 4^L)，L是最长单词长度</li>
<li><strong>空间复杂度</strong>：O(总字符数)</li>
<li><strong>核心技巧</strong>：前缀树 + DFS + 动态剪枝</li>
</ul>
<hr>
<h2 id="前缀树应用总结"><a href="#前缀树应用总结" class="headerlink" title="前缀树应用总结"></a>前缀树应用总结</h2><h3 id="1-适用场景分析"><a href="#1-适用场景分析" class="headerlink" title="1. 适用场景分析"></a>1. 适用场景分析</h3><table>
<thead>
<tr>
<th>场景类型</th>
<th>典型特征</th>
<th>前缀树优势</th>
</tr>
</thead>
<tbody><tr>
<td>前缀匹配</td>
<td>查询以某字符串为前缀的内容</td>
<td>O(L)查询，支持前缀计数</td>
</tr>
<tr>
<td>多模式匹配</td>
<td>同时搜索多个字符串</td>
<td>共享前缀，减少重复搜索</td>
</tr>
<tr>
<td>字符串编码</td>
<td>处理字符到数字的映射</td>
<td>灵活的路径编码方案</td>
</tr>
<tr>
<td>动态剪枝</td>
<td>搜索过程中动态优化</td>
<td>pass计数支持智能剪枝</td>
</tr>
</tbody></table>
<h3 id="2-设计要点"><a href="#2-设计要点" class="headerlink" title="2. 设计要点"></a>2. 设计要点</h3><h4 id="字符映射策略"><a href="#字符映射策略" class="headerlink" title="字符映射策略"></a>字符映射策略</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据字符集选择合适的映射方案</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">if</span> char.isdigit():</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(char)  <span class="comment"># 数字字符</span></span><br><span class="line">    <span class="keyword">elif</span> char.isalpha():</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)  <span class="comment"># 字母字符</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> 特殊字符映射  <span class="comment"># 如&#x27;#&#x27;-&gt;10, &#x27;-&#x27;-&gt;11</span></span><br></pre></td></tr></table></figure>

<h4 id="节点信息设计"><a href="#节点信息设计" class="headerlink" title="节点信息设计"></a>节点信息设计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据需求选择节点存储的信息</span></span><br><span class="line">pas[i] = 经过次数      <span class="comment"># 支持前缀计数</span></span><br><span class="line">end[i] = 是否结尾      <span class="comment"># 支持单词判定</span></span><br><span class="line">end[i] = 完整单词      <span class="comment"># 支持单词返回</span></span><br></pre></td></tr></table></figure>

<h4 id="剪枝优化策略"><a href="#剪枝优化策略" class="headerlink" title="剪枝优化策略"></a>剪枝优化策略</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多种剪枝技巧组合使用</span></span><br><span class="line"><span class="keyword">if</span> tree[cur][path] == <span class="number">0</span>:    <span class="comment"># 路径不存在剪枝</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> pas[cur] == <span class="number">0</span>:           <span class="comment"># 无有效单词剪枝</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">pas[cur] -= found_count     <span class="comment"># 动态更新剪枝</span></span><br></pre></td></tr></table></figure>

<h3 id="3-性能优化技巧"><a href="#3-性能优化技巧" class="headerlink" title="3. 性能优化技巧"></a>3. 性能优化技巧</h3><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><ul>
<li>合理评估MAXN大小，避免内存浪费</li>
<li>及时清理无用节点，重复利用空间</li>
<li>考虑使用哈希表替代数组（适用于稀疏情况）</li>
</ul>
<h4 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化"></a>时间优化</h4><ul>
<li>预计算字符映射函数，避免重复计算</li>
<li>使用位运算优化二进制操作</li>
<li>合理设计剪枝条件，减少无效搜索</li>
</ul>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用的前缀树工具类设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, charset_size=<span class="number">26</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.MAXN = <span class="number">100001</span></span><br><span class="line">        <span class="variable language_">self</span>.tree = [[<span class="number">0</span>] * charset_size <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.MAXN)]</span><br><span class="line">        <span class="variable language_">self</span>.pas = [<span class="number">0</span>] * <span class="variable language_">self</span>.MAXN</span><br><span class="line">        <span class="variable language_">self</span>.end = [<span class="literal">False</span>] * <span class="variable language_">self</span>.MAXN</span><br><span class="line">        <span class="variable language_">self</span>.cnt = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="variable language_">self</span>.cnt + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.tree[i])):</span><br><span class="line">                <span class="variable language_">self</span>.tree[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="variable language_">self</span>.pas[i] = <span class="number">0</span></span><br><span class="line">            <span class="variable language_">self</span>.end[i] = <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-常见错误避免"><a href="#4-常见错误避免" class="headerlink" title="4. 常见错误避免"></a>4. 常见错误避免</h3><h4 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h4><ul>
<li>空字符串的处理</li>
<li>单字符串的特殊情况</li>
<li>数组越界检查</li>
</ul>
<h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><ul>
<li>全局变量的正确初始化和清理</li>
<li>递归过程中状态的正确传递</li>
<li>回溯时现场的完整恢复</li>
</ul>
<h4 id="逻辑正确性"><a href="#逻辑正确性" class="headerlink" title="逻辑正确性"></a>逻辑正确性</h4><ul>
<li>前缀匹配 vs 完全匹配的区别</li>
<li>路径索引映射的一致性</li>
<li>剪枝条件的准确性</li>
</ul>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-掌握基础操作"><a href="#1-掌握基础操作" class="headerlink" title="1. 掌握基础操作"></a>1. 掌握基础操作</h3><ul>
<li>熟练掌握前缀树的构建、插入、查询操作</li>
<li>理解pass计数和end标记的作用</li>
<li>练习不同字符集的映射方案</li>
</ul>
<h3 id="2-理解应用场景"><a href="#2-理解应用场景" class="headerlink" title="2. 理解应用场景"></a>2. 理解应用场景</h3><ul>
<li>识别哪些问题适合用前缀树解决</li>
<li>学会将复杂问题转化为前缀匹配问题</li>
<li>掌握前缀树与其他算法的结合使用</li>
</ul>
<h3 id="3-优化思维培养"><a href="#3-优化思维培养" class="headerlink" title="3. 优化思维培养"></a>3. 优化思维培养</h3><ul>
<li>学会分析时间空间复杂度</li>
<li>掌握各种剪枝优化技巧</li>
<li>培养动态调整搜索策略的能力</li>
</ul>
<h3 id="4-实战经验积累"><a href="#4-实战经验积累" class="headerlink" title="4. 实战经验积累"></a>4. 实战经验积累</h3><ul>
<li>多做不同类型的前缀树题目</li>
<li>总结常见的代码模板和套路</li>
<li>练习在限时条件下的快速实现</li>
</ul>
<p>通过系统学习前缀树的这些经典应用，可以很好地理解前缀树在实际算法问题中的强大作用，为解决更复杂的字符串和搜索问题打下坚实基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8819%EF%BC%89-%20%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E8%A7%A3%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8819%EF%BC%89-%20%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E8%A7%A3%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（19）- 根据数据量猜解法的核心技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-06 08:30:00" itemprop="dateCreated datePublished" datetime="2025-09-06T08:30:00+08:00">2025-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-08 18:26:04" itemprop="dateModified" datetime="2025-09-08T18:26:04+08:00">2025-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class043的内容，介绍了算法竞赛和面试中极其重要的一个技巧——<strong>根据数据量猜解法</strong>。这是”天字第一号重要技巧”，能够帮助我们在看到题目后迅速判断应该使用什么复杂度的算法。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习本技巧之前，需要掌握以下基础知识：</p>
<ul>
<li>时间复杂度的概念（讲解007）</li>
<li>全排列递归代码的执行细节（讲解038）</li>
</ul>
<hr>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="基本事实"><a href="#基本事实" class="headerlink" title="基本事实"></a>基本事实</h3><p>无论在什么测试平台、什么CPU上，都有一个基本的性能标准：</p>
<ul>
<li><strong>C&#x2F;C++</strong>：运行时间1秒，对应常数指令操作量约为 <strong>10^7 ~ 10^8</strong></li>
<li><strong>Java&#x2F;Python&#x2F;Go等其他语言</strong>：运行时间1-2秒，对应常数指令操作量约为 <strong>10^7 ~ 10^8</strong></li>
</ul>
<p>这个数量级是固定的，是我们进行算法复杂度估算的重要依据。</p>
<h3 id="运用条件"><a href="#运用条件" class="headerlink" title="运用条件"></a>运用条件</h3><p>要成功运用这个技巧，需要满足两个条件：</p>
<ol>
<li><p><strong>题目给定各个参数的范围最大值</strong></p>
<ul>
<li>正式笔试、比赛的题目一定会给出</li>
<li>面试中需要和面试官确认</li>
</ul>
</li>
<li><p><strong>对自己设计的算法有准确的时间复杂度估计</strong></p>
<ul>
<li>这需要扎实的算法基础</li>
<li>对各种算法模式的复杂度要熟悉</li>
</ul>
</li>
</ol>
<hr>
<h2 id="问题规模与可用算法对照表"><a href="#问题规模与可用算法对照表" class="headerlink" title="问题规模与可用算法对照表"></a>问题规模与可用算法对照表</h2><table>
<thead>
<tr>
<th>数据规模n</th>
<th>logn</th>
<th>n</th>
<th>n*logn</th>
<th>n*√n</th>
<th>n²</th>
<th>2^n</th>
<th>n!</th>
</tr>
</thead>
<tbody><tr>
<td>n ≤ 11</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>n ≤ 25</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr>
<td>n ≤ 5000</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>n ≤ 10^5</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>n ≤ 10^6</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>n ≤ 10^7</td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>n ≥ 10^8</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody></table>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><em><em>n</em>√n 复杂度</em>*：常出现在”莫队算法”相关题目中</li>
<li>这张表提供参考，但实际应用中要考虑多个参数的组合影响</li>
<li>关键是记住<strong>常数指令操作量 10^7 ~ 10^8</strong>这个基准</li>
</ul>
<hr>
<h1 id="043【必备】根据数据量猜解法的技巧-天字第一号重要技巧"><a href="#043【必备】根据数据量猜解法的技巧-天字第一号重要技巧" class="headerlink" title="043【必备】根据数据量猜解法的技巧-天字第一号重要技巧"></a>043【必备】根据数据量猜解法的技巧-天字第一号重要技巧</h1><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="案例一：最优的技能释放顺序"><a href="#案例一：最优的技能释放顺序" class="headerlink" title="案例一：最优的技能释放顺序"></a>案例一：最优的技能释放顺序</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>现在有一个打怪类型的游戏：</p>
<ul>
<li>你有n个技能，每个技能最多只能释放一次</li>
<li>每个技能有基础伤害值</li>
<li>当怪物血量小于等于某个阈值时，该技能可能造成双倍伤害</li>
<li>已知怪物有m点血量</li>
<li>求最少用几个技能能消灭怪物</li>
</ul>
<p><strong>约束条件：</strong></p>
<ul>
<li>1 ≤ n ≤ 10</li>
<li>1 ≤ m、x[i]、y[i] ≤ 10^6</li>
</ul>
<p><strong>测试链接：</strong> <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d88ef50f8dab4850be8cd4b95514bbbd">https://www.nowcoder.com/practice/d88ef50f8dab4850be8cd4b95514bbbd</a></p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>由于 n ≤ 10，我们可以尝试所有技能的排列组合：</p>
<ul>
<li>排列数：n! ≤ 10! &#x3D; 3,628,800</li>
<li>远小于 10^7，所以回溯算法完全可行</li>
</ul>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.kill = []      <span class="comment"># 技能伤害值</span></span><br><span class="line">        <span class="variable language_">self</span>.blood = []     <span class="comment"># 触发双倍伤害的血量阈值</span></span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, i: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        回溯算法核心函数</span></span><br><span class="line"><span class="string">        i: 当前使用的技能数量</span></span><br><span class="line"><span class="string">        r: 怪物剩余血量</span></span><br><span class="line"><span class="string">        返回: 从当前状态到击败怪物还需要的最少技能数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 怪物已被击败</span></span><br><span class="line">        <span class="keyword">if</span> r &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># base case: 技能用完但怪物未死</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="variable language_">self</span>.n:</span><br><span class="line">            <span class="keyword">return</span> math.inf</span><br><span class="line"></span><br><span class="line">        ans = math.inf</span><br><span class="line">        <span class="comment"># 尝试所有未使用的技能</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="variable language_">self</span>.n):</span><br><span class="line">            <span class="comment"># 将第j个技能换到位置i尝试</span></span><br><span class="line">            <span class="variable language_">self</span>._swap(i, j)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算伤害（是否触发双倍）</span></span><br><span class="line">            damage = <span class="variable language_">self</span>.kill[i] <span class="keyword">if</span> r &gt; <span class="variable language_">self</span>.blood[i] <span class="keyword">else</span> <span class="variable language_">self</span>.kill[i] * <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归求解</span></span><br><span class="line">            res = <span class="variable language_">self</span>._f(i + <span class="number">1</span>, r - damage)</span><br><span class="line">            <span class="keyword">if</span> res != math.inf:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + res)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            <span class="variable language_">self</span>._swap(i, j)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swap</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;交换第i个和第j个技能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.kill[i], <span class="variable language_">self</span>.kill[j] = <span class="variable language_">self</span>.kill[j], <span class="variable language_">self</span>.kill[i]</span><br><span class="line">        <span class="variable language_">self</span>.blood[i], <span class="variable language_">self</span>.blood[j] = <span class="variable language_">self</span>.blood[j], <span class="variable language_">self</span>.blood[i]</span><br></pre></td></tr></table></figure>

<h4 id="优化版本（剪枝）"><a href="#优化版本（剪枝）" class="headerlink" title="优化版本（剪枝）"></a>优化版本（剪枝）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_optimized</span>():</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">        n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        skills = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            skills.append(<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">        </span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">blood, used=<span class="built_in">set</span>(<span class="params"></span>)</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 剪枝1: 假设剩余技能全部打出双倍伤害</span></span><br><span class="line">            rest_max_damage = <span class="built_in">sum</span>([<span class="number">2</span> * skills[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> used])</span><br><span class="line">            <span class="keyword">if</span> blood &gt; rest_max_damage:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 剪枝2: 如果当前已使用技能数不优于已知答案</span></span><br><span class="line">            <span class="keyword">if</span> ans != -<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(used) &gt;= ans:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 成功条件</span></span><br><span class="line">            <span class="keyword">if</span> blood &lt;= <span class="number">0</span>:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">len</span>(used)) <span class="keyword">if</span> ans &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(used)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 失败条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(used) == n <span class="keyword">and</span> blood &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 尝试每个未使用的技能</span></span><br><span class="line">            <span class="keyword">for</span> i, (damage, threshold) <span class="keyword">in</span> <span class="built_in">enumerate</span>(skills):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> used:</span><br><span class="line">                    used.add(i)</span><br><span class="line">                    actual_damage = <span class="number">2</span> * damage <span class="keyword">if</span> blood &lt;= threshold <span class="keyword">else</span> damage</span><br><span class="line">                    dfs(blood - actual_damage, used)</span><br><span class="line">                    used.remove(i)</span><br><span class="line">        </span><br><span class="line">        dfs(m)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>

<h3 id="案例二：超级回文数的数目"><a href="#案例二：超级回文数的数目" class="headerlink" title="案例二：超级回文数的数目"></a>案例二：超级回文数的数目</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>
<p>给定两个正整数L和R，返回包含在范围[L, R]中的超级回文数的数目。</p>
<p><strong>约束条件：</strong></p>
<ul>
<li>1 ≤ len(L) ≤ 18</li>
<li>1 ≤ len(R) ≤ 18</li>
<li>L和R表示[1, 10^18)范围的整数</li>
</ul>
<p><strong>测试链接：</strong> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/super-palindromes/">https://leetcode.cn/problems/super-palindromes/</a></p>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>设超级回文数为S &#x3D; x²，其中S和x都是回文数：</p>
<ul>
<li>S最大为10^18，所以x最大为10^9</li>
<li>回文数的数量远少于普通数</li>
<li>可以通过”种子”生成回文数，种子范围约为10^5</li>
<li>时间复杂度约为O(√10^9) &#x3D; O(10^5)，完全可行</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(19)/class43-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E9%A2%98%E8%A7%A3/%E6%A0%B9%E6%8D%AEseed%E7%94%9F%E6%88%90%E5%9B%9E%E6%96%87%E6%95%B0.png" alt="根据seed生成回文数"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(19)/class43-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E9%A2%98%E8%A7%A3/%E5%B0%8F%E6%95%B0%E6%8D%AE%E5%8A%9E%E5%A4%A7%E4%BA%8B.png" alt="小数据办大事"></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><h5 id="方法一：枚举回文数的根"><a href="#方法一：枚举回文数的根" class="headerlink" title="方法一：枚举回文数的根"></a>方法一：枚举回文数的根</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">superpalindromesInRange1</span>(<span class="params">self, left: <span class="built_in">str</span>, right: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        核心思想：枚举所有可能的回文数x，检查x²是否也是回文且在范围内</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l, r = <span class="built_in">int</span>(left), <span class="built_in">int</span>(right)</span><br><span class="line">        limit = <span class="built_in">int</span>(math.sqrt(r))</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        seed = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 生成偶数长度回文数</span></span><br><span class="line">            num_even = <span class="variable language_">self</span>._even_enlarge(seed)</span><br><span class="line">            <span class="keyword">if</span> num_even &gt; limit:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            square = num_even * num_even</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._check(square, l, r):</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 生成奇数长度回文数</span></span><br><span class="line">            num_odd = <span class="variable language_">self</span>._odd_enlarge(seed)</span><br><span class="line">            <span class="keyword">if</span> num_odd &lt;= limit:</span><br><span class="line">                square = num_odd * num_odd</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._check(square, l, r):</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            seed += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_even_enlarge</span>(<span class="params">self, seed: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将种子扩展为偶数长度回文数，如123→123321&quot;&quot;&quot;</span></span><br><span class="line">        ans = seed</span><br><span class="line">        temp = seed</span><br><span class="line">        <span class="keyword">while</span> temp != <span class="number">0</span>:</span><br><span class="line">            ans = ans * <span class="number">10</span> + temp % <span class="number">10</span></span><br><span class="line">            temp //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_odd_enlarge</span>(<span class="params">self, seed: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将种子扩展为奇数长度回文数，如123→12321&quot;&quot;&quot;</span></span><br><span class="line">        ans = seed</span><br><span class="line">        temp = seed // <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> temp != <span class="number">0</span>:</span><br><span class="line">            ans = ans * <span class="number">10</span> + temp % <span class="number">10</span></span><br><span class="line">            temp //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_check</span>(<span class="params">self, num: <span class="built_in">int</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查数字是否在范围内且为回文数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> l &lt;= num &lt;= r <span class="keyword">and</span> <span class="variable language_">self</span>._is_palindrome_num(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_palindrome_num</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断数字是否为回文数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 双指针思想：同时从最高位和最低位比较</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> num // offset &gt;= <span class="number">10</span>:</span><br><span class="line">            offset *= <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> num // offset != num % <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            num = (num % offset) // <span class="number">10</span></span><br><span class="line">            offset //= <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h5 id="方法二：打表法"><a href="#方法二：打表法" class="headerlink" title="方法二：打表法"></a>方法二：打表法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 预计算所有超级回文数</span></span><br><span class="line">    _record = [</span><br><span class="line">        <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">121</span>, <span class="number">484</span>, <span class="number">10201</span>, <span class="number">12321</span>, <span class="number">14641</span>, <span class="number">40804</span>, <span class="number">44944</span>,</span><br><span class="line">        <span class="number">1002001</span>, <span class="number">1234321</span>, <span class="number">4008004</span>, <span class="number">100020001</span>, <span class="number">102030201</span>, <span class="number">104060401</span>,</span><br><span class="line">        <span class="comment"># ... 更多预计算的值</span></span><br><span class="line">        <span class="number">1234323468643234321</span>, <span class="number">4000000008000000004</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">superpalindromesInRange2</span>(<span class="params">self, left: <span class="built_in">str</span>, right: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        打表法：预先计算好所有超级回文数，查询时直接范围查找</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l, r = <span class="built_in">int</span>(left), <span class="built_in">int</span>(right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 二分查找或线性扫描</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="variable language_">self</span>._record:</span><br><span class="line">            <span class="keyword">if</span> l &lt;= num &lt;= r:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="案例三：回文数判断"><a href="#案例三：回文数判断" class="headerlink" title="案例三：回文数判断"></a>案例三：回文数判断</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>判断一个整数是否是回文数，不使用字符串转换。</p>
<p><strong>测试链接：</strong> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/">https://leetcode.cn/problems/palindrome-number/</a></p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ol>
<li>负数不是回文数。</li>
<li>计算出一个 <code>offset</code>，使其与 <code>num</code> 的位数相同（例如，num&#x3D;12321, offset&#x3D;10000）。<br> 这个 <code>offset</code> 可以用来取出最高位的数字 (<code>num // offset</code>)。</li>
<li>循环比较最高位 (<code>num // offset</code>) 和最低位 (<code>num % 10</code>)。</li>
<li>如果不相等，则不是回文数。</li>
<li>如果相等，则去掉最高位和最低位，继续比较。<ul>
<li>去掉最低位: <code>num % 10</code></li>
<li>去掉最高位: <code>num % offset</code></li>
<li>组合起来: <code>(num % offset) // 10</code></li>
</ul>
</li>
<li>同时，<code>offset</code> 需要除以 100，因为我们一次处理了两位数。</li>
</ol>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        不使用字符串转换判断回文数</span></span><br><span class="line"><span class="string">        核心思想：双指针，同时比较最高位和最低位</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算与num位数相同的offset</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> num // offset &gt;= <span class="number">10</span>:</span><br><span class="line">            offset *= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 同时比较首尾数字</span></span><br><span class="line">        <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 比较最高位和最低位</span></span><br><span class="line">            <span class="keyword">if</span> num // offset != num % <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 去掉首尾两位数字</span></span><br><span class="line">            num = (num % offset) // <span class="number">10</span></span><br><span class="line">            offset //= <span class="number">100</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="技巧应用步骤"><a href="#技巧应用步骤" class="headerlink" title="技巧应用步骤"></a>技巧应用步骤</h2><h3 id="1-分析数据规模"><a href="#1-分析数据规模" class="headerlink" title="1. 分析数据规模"></a>1. 分析数据规模</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：看到题目约束</span></span><br><span class="line"><span class="comment"># n ≤ 10, m ≤ 10^6</span></span><br><span class="line"><span class="comment"># 立即想到：n很小，可以用指数级算法；m较大，需要高效处理</span></span><br></pre></td></tr></table></figure>

<h3 id="2-估算操作次数"><a href="#2-估算操作次数" class="headerlink" title="2. 估算操作次数"></a>2. 估算操作次数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：全排列问题</span></span><br><span class="line"><span class="comment"># n ≤ 10 → n! ≤ 10! ≈ 3.6 × 10^6 &lt; 10^7 ✓ 可行</span></span><br><span class="line"><span class="comment"># n ≤ 15 → n! ≤ 15! ≈ 1.3 × 10^12 &gt; 10^8 ✗ 不可行</span></span><br></pre></td></tr></table></figure>

<h3 id="3-选择合适算法"><a href="#3-选择合适算法" class="headerlink" title="3. 选择合适算法"></a>3. 选择合适算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据复杂度选择算法类型：</span></span><br><span class="line"><span class="comment"># O(1), O(logn) → 数学公式、二分查找</span></span><br><span class="line"><span class="comment"># O(n) → 线性扫描、简单遍历  </span></span><br><span class="line"><span class="comment"># O(n logn) → 排序、分治算法</span></span><br><span class="line"><span class="comment"># O(n²) → 双重循环、动态规划</span></span><br><span class="line"><span class="comment"># O(2^n) → 回溯、状态压缩DP</span></span><br><span class="line"><span class="comment"># O(n!) → 全排列、旅行商问题</span></span><br></pre></td></tr></table></figure>

<h3 id="4-考虑常数优化"><a href="#4-考虑常数优化" class="headerlink" title="4. 考虑常数优化"></a>4. 考虑常数优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即使复杂度合适，也要考虑：</span></span><br><span class="line"><span class="comment"># - 剪枝优化</span></span><br><span class="line"><span class="comment"># - 缓存计算结果</span></span><br><span class="line"><span class="comment"># - 避免重复计算</span></span><br><span class="line"><span class="comment"># - 选择高效的数据结构</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="常见复杂度模式"><a href="#常见复杂度模式" class="headerlink" title="常见复杂度模式"></a>常见复杂度模式</h2><h3 id="1-递归分治"><a href="#1-递归分治" class="headerlink" title="1. 递归分治"></a>1. 递归分治</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># T(n) = a × T(n/b) + O(n^c)</span></span><br><span class="line"><span class="comment"># 主定理：比较a与b^c的大小关系</span></span><br></pre></td></tr></table></figure>

<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 状态数 × 转移复杂度</span></span><br><span class="line"><span class="comment"># 一维DP: O(n)</span></span><br><span class="line"><span class="comment"># 二维DP: O(n²)  </span></span><br><span class="line"><span class="comment"># 区间DP: O(n³)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-图算法"><a href="#3-图算法" class="headerlink" title="3. 图算法"></a>3. 图算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS/DFS: O(V + E)</span></span><br><span class="line"><span class="comment"># 最短路径: O(V²) 或 O(E logV)</span></span><br><span class="line"><span class="comment"># 最小生成树: O(E logE)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-字符串算法"><a href="#4-字符串算法" class="headerlink" title="4. 字符串算法"></a>4. 字符串算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力匹配: O(n×m)</span></span><br><span class="line"><span class="comment"># KMP: O(n + m)</span></span><br><span class="line"><span class="comment"># 字典树: O(总长度)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-熟记基准值"><a href="#1-熟记基准值" class="headerlink" title="1. 熟记基准值"></a>1. 熟记基准值</h3><ul>
<li><strong>核心记忆：10^7 ~ 10^8 操作&#x2F;秒</strong></li>
<li>常见数据规模的复杂度上限</li>
<li>不同语言的性能差异</li>
</ul>
<h3 id="2-积累经验"><a href="#2-积累经验" class="headerlink" title="2. 积累经验"></a>2. 积累经验</h3><ul>
<li>多做题，培养对复杂度的直觉</li>
<li>记录不同类型题目的常见数据规模</li>
<li>总结复杂度估算的常见陷阱</li>
</ul>
<h3 id="3-实践验证"><a href="#3-实践验证" class="headerlink" title="3. 实践验证"></a>3. 实践验证</h3><ul>
<li>实际提交验证时间复杂度估算</li>
<li>对比不同算法的实际运行时间</li>
<li>学会分析超时的原因</li>
</ul>
<h3 id="4-深入理解"><a href="#4-深入理解" class="headerlink" title="4. 深入理解"></a>4. 深入理解</h3><ul>
<li>不仅要会算复杂度，还要理解为什么</li>
<li>掌握各种算法的适用场景</li>
<li>学会在时间和空间之间做权衡</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“根据数据量猜解法”是算法竞赛和技术面试中极其重要的技巧：</p>
<ol>
<li><strong>核心原理</strong>：基于10^7~10^8操作&#x2F;秒的基准进行复杂度估算</li>
<li><strong>应用场景</strong>：快速判断算法可行性，指导解题方向</li>
<li><strong>关键要素</strong>：准确的复杂度分析 + 对数据规模的敏感度</li>
<li><strong>实战价值</strong>：避免选择错误的算法方向，提高解题效率</li>
</ol>
<p>通过掌握这个技巧，我们可以在看到题目的第一时间就大致确定解题的复杂度范围，从而选择合适的算法策略，这对于在有限时间内解决算法问题具有重要意义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8818%EF%BC%89-%20%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E3%80%81%E5%90%8C%E4%BD%99%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%99%A8%E6%89%93%E8%A1%A8%E8%A7%84%E5%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8818%EF%BC%89-%20%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E3%80%81%E5%90%8C%E4%BD%99%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AF%B9%E6%95%B0%E5%99%A8%E6%89%93%E8%A1%A8%E8%A7%84%E5%BE%8B/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（18）- 最大公约数、同余原理与对数器打表规律</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-05 10:30:00" itemprop="dateCreated datePublished" datetime="2025-09-05T10:30:00+08:00">2025-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-06 09:35:16" itemprop="dateModified" datetime="2025-09-06T09:35:16+08:00">2025-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记内容囊括class41-class42，class41讲的是数学基础中的最大公约数、最小公倍数计算，以及同余原理的应用。此外class42讲了对数器打表找规律的技巧，通过暴力解小规模数据，观察输出规律，最终得到高效的数学解法。</p>
<h2 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h2><p>这两个内容都和数学比较相关，所以放在了一起。同余原理等等都是抽象代数的基本操作，对数器打表则需要我们观察数学规律，然后再高效求解。</p>
<hr>
<h1 id="041【必备】最大公约数、同余原理"><a href="#041【必备】最大公约数、同余原理" class="headerlink" title="041【必备】最大公约数、同余原理"></a>041【必备】最大公约数、同余原理</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习本内容之前，需要掌握以下基础知识：</p>
<ul>
<li>基本的数学运算</li>
<li>递归的概念</li>
<li>二分查找的基本思想</li>
</ul>
<h2 id="重要说明-1"><a href="#重要说明-1" class="headerlink" title="重要说明"></a>重要说明</h2><ul>
<li>本期内容涵盖欧几里得算法（辗转相除法）的原理与实现</li>
<li>同余原理在防止大数溢出方面的应用</li>
<li>二分答案法与容斥原理的简单应用</li>
<li>更高效的Stein算法和裴蜀定理会在后续扩展课程中讲述</li>
</ul>
<h2 id="核心知识点一：最大公约数与最小公倍数"><a href="#核心知识点一：最大公约数与最小公倍数" class="headerlink" title="核心知识点一：最大公约数与最小公倍数"></a>核心知识点一：最大公约数与最小公倍数</h2><h3 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a>欧几里得算法（辗转相除法）</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>辗转相除法的核心是证明以下关系：<br>$$\gcd(a, b) &#x3D; \gcd(b, a \bmod b)$$</p>
<p>其中 $a \bmod b$ 表示 $a$ 除以 $b$ 的余数。</p>
<h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><p>设 $a \bmod b &#x3D; r$，即需要证明：$\gcd(a, b) &#x3D; \gcd(b, r)$</p>
<p><strong>证明过程：</strong></p>
<ol>
<li><p>由 $a \bmod b &#x3D; r$ 可得：</p>
<ul>
<li>$a &#x3D; b \times q + r$（其中 $q$ 为商）</li>
<li>$r &#x3D; a - b \times q$</li>
</ul>
</li>
<li><p>设 $u$ 是 $a$ 和 $b$ 的公因子，则有：$a &#x3D; s \times u$，$b &#x3D; t \times u$</p>
</li>
<li><p>将上式代入得：$r &#x3D; s \times u - t \times u \times q &#x3D; (s - t \times q) \times u$</p>
</li>
<li><p>这说明：$u$ 如果是 $a$ 和 $b$ 的公因子，那么 $u$ 也是 $r$ 的因子</p>
</li>
<li><p>反之，设 $v$ 是 $b$ 和 $r$ 的公因子，则有：$b &#x3D; x \times v$，$r &#x3D; y \times v$</p>
</li>
<li><p>代入得：$a &#x3D; x \times v \times q + y \times v &#x3D; (x \times q + y) \times v$</p>
</li>
<li><p>这说明：$v$ 如果是 $b$ 和 $r$ 的公因子，那么 $v$ 也是 $a$ 的公因子</p>
</li>
</ol>
<p><strong>结论：</strong> $a$ 和 $b$ 的全体公因子集合 &#x3D; $b$ 和 $r$ 的全体公因子集合，因此 $\gcd(a, b) &#x3D; \gcd(b, r)$</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtils</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用辗转相除法（欧几里得算法）计算最大公约数。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。</span></span><br><span class="line"><span class="string">        递归的基准情况是当 b 为 0 时，最大公约数是 a。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> <span class="variable language_">self</span>.gcd(b, a % b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算最小公倍数。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        两个数的最小公倍数可以通过公式 `(a * b) / gcd(a, b)` 计算得出。</span></span><br><span class="line"><span class="string">        为了防止 `a * b` 在某些语言中溢出，可以写成 `a / gcd(a, b) * b`。</span></span><br><span class="line"><span class="string">        在 Python 中，整数支持任意精度，不存在溢出问题，但这种写法仍然是好习惯。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用 // 保证整数除法</span></span><br><span class="line">        <span class="keyword">return</span> (a // <span class="variable language_">self</span>.gcd(a, b)) * b</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：$O((\log a)^3)$，其中 $a &gt; b$</li>
<li><strong>空间复杂度</strong>：$O(\log a)$（递归调用栈）</li>
<li><strong>核心优势</strong>：算法简洁，效率高，易于实现</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">utils = MathUtils()</span><br><span class="line">a, b = <span class="number">48</span>, <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;GCD of <span class="subst">&#123;a&#125;</span> and <span class="subst">&#123;b&#125;</span> is: <span class="subst">&#123;utils.gcd(a, b)&#125;</span>&quot;</span>)  <span class="comment"># 输出: 6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LCM of <span class="subst">&#123;a&#125;</span> and <span class="subst">&#123;b&#125;</span> is: <span class="subst">&#123;utils.lcm(a, b)&#125;</span>&quot;</span>)  <span class="comment"># 输出: 144</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="核心知识点二：神奇数问题（二分答案法-容斥原理）"><a href="#核心知识点二：神奇数问题（二分答案法-容斥原理）" class="headerlink" title="核心知识点二：神奇数问题（二分答案法 + 容斥原理）"></a>核心知识点二：神奇数问题（二分答案法 + 容斥原理）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个正整数如果能被 $a$ 或 $b$ 整除，那么它是神奇的。给定三个整数 $n$, $a$, $b$，返回第 $n$ 个神奇的数字。因为答案可能很大，所以返回答案对 $10^9 + 7$ 取模后的值。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/nth-magical-number/">https://leetcode.cn/problems/nth-magical-number/</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>这个问题巧妙地结合了两个重要算法：</p>
<ol>
<li><strong>二分答案法</strong>：答案具有单调性，可以二分查找</li>
<li><strong>容斥原理</strong>：计算能被 $a$ 或 $b$ 整除的数的个数</li>
</ol>
<h4 id="二分答案法分析"><a href="#二分答案法分析" class="headerlink" title="二分答案法分析"></a>二分答案法分析</h4><p>对于任意数字 $m$，小于等于 $m$ 的神奇数字个数具有单调性：$m$ 越大，神奇数字越多。因此可以二分查找第 $n$ 个神奇数字。</p>
<h4 id="容斥原理应用"><a href="#容斥原理应用" class="headerlink" title="容斥原理应用"></a>容斥原理应用</h4><p>计算 $1$ 到 $m$ 中能被 $a$ 或 $b$ 整除的数的个数：</p>
<p>$$\text{count} &#x3D; \lfloor\frac{m}{a}\rfloor + \lfloor\frac{m}{b}\rfloor - \lfloor\frac{m}{\text{lcm}(a,b)}\rfloor$$</p>
<p>其中减去 $\lfloor\frac{m}{\text{lcm}(a,b)}\rfloor$ 是因为被 $a$ 和 $b$ 同时整除的数被重复计算了。</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthMagicalNumber</span>(<span class="params">self, n: <span class="built_in">int</span>, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        寻找第 n 个神奇数字。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        答案本身具有单调性（越大的数，它前面的神奇数字越多），因此可以使用二分查找来寻找答案。</span></span><br><span class="line"><span class="string">        1. 定义查找范围：下界 `l=0`，上界 `r` 可以是一个足够大的数，例如 `n * min(a, b)`。</span></span><br><span class="line"><span class="string">        2. 二分中点为 `m`，我们需要快速计算出 `1` 到 `m` 之间有多少个神奇数字。</span></span><br><span class="line"><span class="string">        3. 这个数量可以通过容斥原理计算：`count = m/a + m/b - m/lcm(a, b)`。</span></span><br><span class="line"><span class="string">           其中 `lcm` 是 a 和 b 的最小公倍数。</span></span><br><span class="line"><span class="string">        4. 如果 `count &gt;= n`，说明第 `n` 个神奇数字可能就是 `m` 或者更小，所以我们将 `m` 存为候选答案，并向左查找 `r = m - 1`。</span></span><br><span class="line"><span class="string">        5. 如果 `count &lt; n`，说明 `m` 太小了，第 `n` 个神奇数字在 `m` 的右边，所以向右查找 `l = m + 1`。</span></span><br><span class="line"><span class="string">        6. 二分结束后，候选答案即为所求，最后对结果取模。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        lcm_val = <span class="variable language_">self</span>._lcm(a, b)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># l = 0, r = n * min(a, b) 是一个安全上界</span></span><br><span class="line">        l, r = <span class="number">0</span>, n * <span class="built_in">min</span>(a, b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 计算 1...m 中有多少个数是 a 或 b 的倍数</span></span><br><span class="line">            <span class="comment"># 使用容斥原理：(m中a的倍数) + (m中b的倍数) - (m中a和b公倍数的个数)</span></span><br><span class="line">            <span class="keyword">if</span> m // a + m // b - m // lcm_val &gt;= n:</span><br><span class="line">                ans = m</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans % mod</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_gcd</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> <span class="variable language_">self</span>._gcd(b, a % b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_lcm</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (a * b) // <span class="variable language_">self</span>._gcd(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：$O(\log(\text{n} \times \min(a, b)))$</li>
<li><strong>空间复杂度</strong>：$O(\log(\min(a, b)))$（递归调用栈）</li>
<li><strong>核心技巧</strong>：二分答案法 + 容斥原理</li>
</ul>
<hr>
<h2 id="核心知识点三：同余原理"><a href="#核心知识点三：同余原理" class="headerlink" title="核心知识点三：同余原理"></a>核心知识点三：同余原理</h2><h3 id="基本公理"><a href="#基本公理" class="headerlink" title="基本公理"></a>基本公理</h3><p>设 $m$ 为正整数（模），若：</p>
<ul>
<li>$a \equiv b \pmod{m}$</li>
<li>$c \equiv d \pmod{m}$</li>
</ul>
<p>则有：</p>
<ul>
<li><strong>加法</strong>：$a + c \equiv b + d \pmod{m}$</li>
<li><strong>减法</strong>：$a - c \equiv b - d \pmod{m}$</li>
<li><strong>乘法</strong>：$ac \equiv bd \pmod{m}$</li>
</ul>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>在模运算中，我们可以在每一步计算后都取模，这样可以：</p>
<ol>
<li>防止中间结果溢出</li>
<li>保持计算结果的正确性</li>
<li>提高计算效率</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="问题：计算-a-b-times-c-d-a-times-c-b-times-d-bmod-m"><a href="#问题：计算-a-b-times-c-d-a-times-c-b-times-d-bmod-m" class="headerlink" title="问题：计算 $((a + b) \times (c - d) + (a \times c - b \times d)) \bmod m$"></a>问题：计算 $((a + b) \times (c - d) + (a \times c - b \times d)) \bmod m$</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span>, d: <span class="built_in">int</span>, mod: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用 Python 的原生大整数计算，等同于 Java 的 BigInteger 版本。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        直接进行数学运算，让语言自动处理中间过程中可能出现的巨大数值。</span></span><br><span class="line"><span class="string">        最后对最终结果取模。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        o5 = a + b</span><br><span class="line">        o6 = c - d</span><br><span class="line">        o7 = a * c</span><br><span class="line">        o8 = b * d</span><br><span class="line">        o9 = o5 * o6</span><br><span class="line">        o10 = o7 - o8</span><br><span class="line">        o11 = o9 + o10</span><br><span class="line">        <span class="comment"># (res % mod + mod) % mod 是一个确保结果为正的通用技巧。</span></span><br><span class="line">        <span class="keyword">return</span> (o11 % mod + mod) % mod</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span>, d: <span class="built_in">int</span>, mod: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用同余原理在每一步运算后都取模。</span></span><br><span class="line"><span class="string">        核心思想 (同余原理)：</span></span><br><span class="line"><span class="string">        - (A + B) % M = ((A % M) + (B % M)) % M</span></span><br><span class="line"><span class="string">        - (A - B) % M = ((A % M) - (B % M) + M) % M  (加上M确保结果非负)</span></span><br><span class="line"><span class="string">        - (A * B) % M = ((A % M) * (B % M)) % M</span></span><br><span class="line"><span class="string">        这种方法可以保证所有中间计算结果都在一个可控的范围内，避免大数运算，效率更高。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        o1 = a % mod</span><br><span class="line">        o2 = b % mod</span><br><span class="line">        o3 = c % mod</span><br><span class="line">        o4 = d % mod</span><br><span class="line">        o5 = (o1 + o2) % mod</span><br><span class="line">        <span class="comment"># 加上 mod 再取模，是为了防止 o3 &lt; o4 时出现负数</span></span><br><span class="line">        o6 = (o3 - o4 + mod) % mod</span><br><span class="line">        o7 = (o1 * o3) % mod</span><br><span class="line">        o8 = (o2 * o4) % mod</span><br><span class="line">        o9 = (o5 * o6) % mod</span><br><span class="line">        o10 = (o7 - o8 + mod) % mod</span><br><span class="line">        ans = (o9 + o10) % mod</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h3><ol>
<li><p><strong>减法处理</strong>：$(a - b) \bmod m &#x3D; ((a \bmod m) - (b \bmod m) + m) \bmod m$</p>
<ul>
<li>加上 $m$ 是为了确保结果非负</li>
</ul>
</li>
<li><p><strong>除法同余</strong>：需要求逆元，比较复杂，会在后续课程中讲述</p>
</li>
<li><p><strong>数据类型</strong>：在需要防止溢出的语言中，乘法运算常用长整型做中间变量</p>
</li>
</ol>
<h3 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_long</span>():</span><br><span class="line">    <span class="keyword">return</span> random.randint(<span class="number">0</span>, sys.maxsize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试开始&quot;</span>)</span><br><span class="line">    test_time = <span class="number">100000</span></span><br><span class="line">    mod = <span class="number">1000000007</span></span><br><span class="line">    all_passed = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_time):</span><br><span class="line">        a = random_long()</span><br><span class="line">        b = random_long()</span><br><span class="line">        c = random_long()</span><br><span class="line">        d = random_long()</span><br><span class="line">        <span class="keyword">if</span> s.f1(a, b, c, d, mod) != s.f2(a, b, c, d, mod):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;出错了!&quot;</span>)</span><br><span class="line">            all_passed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> all_passed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;测试结束，全部通过!&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="算法技巧总结"><a href="#算法技巧总结" class="headerlink" title="算法技巧总结"></a>算法技巧总结</h2><h3 id="1-欧几里得算法模板"><a href="#1-欧几里得算法模板" class="headerlink" title="1. 欧几里得算法模板"></a>1. 欧几里得算法模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> (a * b) // gcd(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="2-二分答案法模板"><a href="#2-二分答案法模板" class="headerlink" title="2. 二分答案法模板"></a>2. 二分答案法模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_answer</span>(<span class="params">check_function, left, right</span>):</span><br><span class="line">    ans = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check_function(mid):</span><br><span class="line">            ans = mid</span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># 继续寻找更小的答案</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="3-容斥原理（两个集合）"><a href="#3-容斥原理（两个集合）" class="headerlink" title="3. 容斥原理（两个集合）"></a>3. 容斥原理（两个集合）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># |A ∪ B| = |A| + |B| - |A ∩ B|</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inclusion_exclusion_two_sets</span>(<span class="params">n, a, b</span>):</span><br><span class="line">    lcm_ab = lcm(a, b)</span><br><span class="line">    <span class="keyword">return</span> n // a + n // b - n // lcm_ab</span><br></pre></td></tr></table></figure>

<h3 id="4-同余运算模板"><a href="#4-同余运算模板" class="headerlink" title="4. 同余运算模板"></a>4. 同余运算模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_mod_operations</span>(<span class="params">a, b, mod</span>):</span><br><span class="line">    <span class="comment"># 加法</span></span><br><span class="line">    add_result = (a + b) % mod</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 减法（确保非负）</span></span><br><span class="line">    sub_result = (a - b + mod) % mod</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 乘法</span></span><br><span class="line">    mul_result = (a * b) % mod</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> add_result, sub_result, mul_result</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>欧几里得算法</td>
<td>$O(\log \min(a,b))$</td>
<td>$O(\log \min(a,b))$</td>
<td>求最大公约数</td>
</tr>
<tr>
<td>神奇数问题</td>
<td>$O(\log(n \times \min(a,b)))$</td>
<td>$O(\log \min(a,b))$</td>
<td>二分答案法</td>
</tr>
<tr>
<td>同余运算</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>防止溢出</td>
</tr>
</tbody></table>
<hr>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-掌握数学基础"><a href="#1-掌握数学基础" class="headerlink" title="1. 掌握数学基础"></a>1. 掌握数学基础</h3><ul>
<li>理解最大公约数和最小公倍数的定义</li>
<li>掌握同余的概念和性质</li>
<li>熟悉容斥原理的基本应用</li>
</ul>
<h3 id="2-算法思维训练"><a href="#2-算法思维训练" class="headerlink" title="2. 算法思维训练"></a>2. 算法思维训练</h3><ul>
<li><strong>二分答案法</strong>：当答案具有单调性时考虑使用</li>
<li><strong>容斥原理</strong>：处理集合交并关系的重要工具</li>
<li><strong>同余优化</strong>：在模运算中防止溢出的关键技巧</li>
</ul>
<h3 id="3-实践要点"><a href="#3-实践要点" class="headerlink" title="3. 实践要点"></a>3. 实践要点</h3><ul>
<li>欧几里得算法是最基础的数学算法，必须熟练掌握</li>
<li>同余原理在竞赛和工程中都很重要，特别是处理大数时</li>
<li>二分答案法是一种重要的算法思想，适用范围很广</li>
</ul>
<h3 id="4-扩展学习"><a href="#4-扩展学习" class="headerlink" title="4. 扩展学习"></a>4. 扩展学习</h3><ul>
<li><strong>Stein算法</strong>：更高效的最大公约数算法</li>
<li><strong>裴蜀定理</strong>：关于线性丢番图方程的重要定理</li>
<li><strong>扩展欧几里得算法</strong>：求解模逆元的基础</li>
<li><strong>中国剩余定理</strong>：处理多个同余方程组</li>
</ul>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul>
<li>在实现递归版本时注意栈溢出问题</li>
<li>处理负数时要特别小心同余运算</li>
<li>在竞赛中，往往需要对结果取模，要养成习惯</li>
</ul>
<p>通过掌握这些数学基础知识和算法技巧，可以为解决更复杂的数学相关算法问题打下坚实的基础。这些知识点不仅在算法竞赛中经常出现，在实际工程开发中也有重要应用价值。</p>
<h1 id="042【必备】对数器打表找规律的技巧"><a href="#042【必备】对数器打表找规律的技巧" class="headerlink" title="042【必备】对数器打表找规律的技巧"></a>042【必备】对数器打表找规律的技巧</h1><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习本内容之前，需要掌握以下基础知识：</p>
<ul>
<li>基本递归能力（推荐讲解038-常见经典递归过程解析）</li>
<li>动态规划的基本思想</li>
<li>博弈论的基础概念</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对数器打表找规律适用于：</p>
<ul>
<li>输入参数是简单类型</li>
<li>返回值也是简单类型</li>
<li>暴力解法可以处理小规模数据</li>
<li>存在数学规律可以发现</li>
</ul>
<h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><ol>
<li><strong>暴力实现</strong>：用最基本的递归实现求解小规模问题</li>
<li><strong>打表观察</strong>：打印小规模输入的答案，寻找规律</li>
<li><strong>规律验证</strong>：将观察到的规律转换为代码并验证</li>
<li><strong>优化实现</strong>：基于规律得到最优解</li>
</ol>
<h2 id="问题一：使用规格8和规格6的袋子买苹果"><a href="#问题一：使用规格8和规格6的袋子买苹果" class="headerlink" title="问题一：使用规格8和规格6的袋子买苹果"></a>问题一：使用规格8和规格6的袋子买苹果</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>有装下8个苹果的袋子、装下6个苹果的袋子，一定要保证买苹果时所有使用的袋子都装满。对于无法装满所有袋子的方案不予考虑，给定n个苹果，返回至少要多少个袋子。如果不存在每个袋子都装满的方案返回-1。</p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个典型的<strong>整数规划问题</strong>，可以用动态规划或递归求解，也可以通过观察规律得到数学解法。</p>
<h3 id="方法一：暴力递归（备忘录优化）"><a href="#方法一：暴力递归（备忘录优化）" class="headerlink" title="方法一：暴力递归（备忘录优化）"></a>方法一：暴力递归（备忘录优化）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bags1</span>(<span class="params">self, apple: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，调用递归并处理无效解的返回值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用 memoization (备忘录) 来优化递归，避免重复计算</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        ans = <span class="variable language_">self</span>._f(apple, memo)</span><br><span class="line">        <span class="comment"># 如果返回的是无穷大，说明无解，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans != math.inf <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, rest: <span class="built_in">int</span>, memo: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，计算装下 rest 个苹果所需的最少袋子数</span></span><br><span class="line"><span class="string">        核心思想 (回溯/动态规划)：</span></span><br><span class="line"><span class="string">        对于 `rest` 个苹果，我们有两种选择：</span></span><br><span class="line"><span class="string">        1. 用一个8个装的袋子，问题变为求解 `f(rest - 8)`。</span></span><br><span class="line"><span class="string">        2. 用一个6个装的袋子，问题变为求解 `f(rest - 6)`。</span></span><br><span class="line"><span class="string">        我们需要在这两种选择中，选择总袋子数最少的那一个。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> rest <span class="keyword">in</span> memo: <span class="comment"># 如果之前已经算过当前 rest（还剩多少苹果）对应的最少袋子数</span></span><br><span class="line">            <span class="keyword">return</span> memo[rest] </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># base case: 苹果数小于0，说明上一步的选择是无效的</span></span><br><span class="line">        <span class="keyword">if</span> rest &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> math.inf</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># base case: 苹果数为0，说明刚好装完，不再需要袋子</span></span><br><span class="line">        <span class="keyword">if</span> rest == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 尝试用一个8规格的袋子</span></span><br><span class="line">        p1 = <span class="variable language_">self</span>._f(rest - <span class="number">8</span>, memo)</span><br><span class="line">        <span class="comment"># 尝试用一个6规格的袋子</span></span><br><span class="line">        p2 = <span class="variable language_">self</span>._f(rest - <span class="number">6</span>, memo)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在有效解的基础上加1 (代表当前用的这个袋子)</span></span><br><span class="line">        res = <span class="built_in">min</span>(p1, p2) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        memo[rest] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="方法二：规律观察优化解"><a href="#方法二：规律观察优化解" class="headerlink" title="方法二：规律观察优化解"></a>方法二：规律观察优化解</h3><p>通过打表观察发现规律：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bags2</span>(<span class="params">self, apple: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过暴力解的输出观察规律，得到的数学优化方法</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    - 苹果数必须是偶数，因为袋子规格6和8都是偶数。</span></span><br><span class="line"><span class="string">    - 观察小数据量的解，发现 apple &lt; 18 时情况比较特殊，可以直接列出。</span></span><br><span class="line"><span class="string">    - 当 apple &gt;= 18 时，规律出现。为了用最少的袋子，应尽可能多地使用8个装的袋子。</span></span><br><span class="line"><span class="string">      可以证明任何 &gt;= 18 的偶数 `apple` 都可以表示为 `8*k + c` 的形式，</span></span><br><span class="line"><span class="string">      其中 `c` 是一个可以用6和8凑出来的小数（比如18, 20, 22）。</span></span><br><span class="line"><span class="string">      `apple - 18` 的部分全部用8个装的袋子，剩下的18个苹果用3个6个装的袋子。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># base case:如果苹果数是奇数，无解</span></span><br><span class="line">    <span class="keyword">if</span> (apple &amp; <span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># base case:处理18以下的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> apple &lt; <span class="number">18</span>:</span><br><span class="line">        <span class="keyword">if</span> apple == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> apple == <span class="number">6</span> <span class="keyword">or</span> apple == <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> apple == <span class="number">12</span> <span class="keyword">or</span> apple == <span class="number">14</span> <span class="keyword">or</span> apple == <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理18及以上的情况</span></span><br><span class="line">    <span class="comment"># (apple - 18) 用8个装的袋子，18用3个6个装的袋子</span></span><br><span class="line">    <span class="keyword">return</span> (apple - <span class="number">18</span>) // <span class="number">8</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="规律分析"><a href="#规律分析" class="headerlink" title="规律分析"></a>规律分析</h3><p>通过打表观察，我们发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">苹果数 : 最少袋子数</span><br><span class="line">0 : 0</span><br><span class="line">1 : -1 (奇数无解)</span><br><span class="line">2 : -1</span><br><span class="line">3 : -1 (奇数无解)</span><br><span class="line">4 : -1</span><br><span class="line">5 : -1 (奇数无解)</span><br><span class="line">6 : 1    (1个6袋)</span><br><span class="line">7 : -1 (奇数无解)</span><br><span class="line">8 : 1    (1个8袋)</span><br><span class="line">9 : -1 (奇数无解)</span><br><span class="line">10 : -1</span><br><span class="line">11 : -1 (奇数无解)</span><br><span class="line">12 : 2   (2个6袋)</span><br><span class="line">13 : -1 (奇数无解)</span><br><span class="line">14 : 2   (1个6袋+1个8袋)</span><br><span class="line">15 : -1 (奇数无解)</span><br><span class="line">16 : 2   (2个8袋)</span><br><span class="line">17 : -1 (奇数无解)</span><br><span class="line">18 : 3   (3个6袋)</span><br><span class="line">20 : 3   (1个6袋+1个8袋+1个6袋 或 其他组合)</span><br><span class="line">22 : 3   (1个6袋+2个8袋)</span><br><span class="line">24 : 3   (3个8袋)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>规律：当 <code>apple &gt;= 18</code> 且为偶数时，答案为 <code>(apple - 18) // 8 + 3</code></p>
<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>暴力递归</strong>：时间复杂度 O(N)，空间复杂度 O(N)</li>
<li><strong>规律优化</strong>：时间复杂度 O(1)，空间复杂度 O(1)</li>
</ul>
<hr>
<h2 id="问题二：A和B轮流吃草博弈问题"><a href="#问题二：A和B轮流吃草博弈问题" class="headerlink" title="问题二：A和B轮流吃草博弈问题"></a>问题二：A和B轮流吃草博弈问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>草一共有n的重量，两只牛轮流吃草，A牛先吃，B牛后吃。每只牛在自己的回合，吃草的重量必须是4的幂，1、4、16、64…。谁在自己的回合正好把草吃完谁赢，根据输入的n，返回谁赢。</p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个典型的<strong>博弈论问题</strong>，使用Min-Max算法求解。关键在于理解必胜态和必败态的概念。</p>
<h3 id="方法一：暴力递归（博弈论）"><a href="#方法一：暴力递归（博弈论）" class="headerlink" title="方法一：暴力递归（博弈论）"></a>方法一：暴力递归（博弈论）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">win1</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，启动递归</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用 memoization 优化</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._f(n, <span class="string">&quot;A&quot;</span>, memo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, rest: <span class="built_in">int</span>, cur: <span class="built_in">str</span>, memo: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，模拟博弈过程</span></span><br><span class="line"><span class="string">        核心思想 (博弈论 Min-Max 思想):</span></span><br><span class="line"><span class="string">        - `cur` (当前玩家)能赢的条件是：`cur` 存在一种走法，使得走完后，`enemy` (对手)面对的局面是必败的。</span></span><br><span class="line"><span class="string">        - 必败态：无论怎么走，留给对手的都是必胜态。</span></span><br><span class="line"><span class="string">        - 必胜态：存在一种走法，留给对手的是必败态。</span></span><br><span class="line"><span class="string">        - 我们遍历当前玩家所有可能的吃草量 (4的幂)，如果吃完后留给对手的局面是对手必败（即当前玩家赢），</span></span><br><span class="line"><span class="string">          那么当前局面就是必胜态，`cur` 赢。</span></span><br><span class="line"><span class="string">        - 如果所有走法都无法让对手输，那么 `cur` 输。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (rest, cur) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(rest, cur)]</span><br><span class="line"></span><br><span class="line">        enemy = <span class="string">&quot;B&quot;</span> <span class="keyword">if</span> cur == <span class="string">&quot;A&quot;</span> <span class="keyword">else</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># base case: 剩草小于5时，可以直接判断胜负</span></span><br><span class="line">        <span class="keyword">if</span> rest &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="comment"># 剩0或2时，当前玩家没法一步吃完，所以对手赢</span></span><br><span class="line">            <span class="comment"># 剩1,3,4时，当前玩家可以一步吃完，所以当前玩家赢</span></span><br><span class="line">            winner = enemy <span class="keyword">if</span> (rest == <span class="number">0</span> <span class="keyword">or</span> rest == <span class="number">2</span>) <span class="keyword">else</span> cur</span><br><span class="line">            memo[(rest, cur)] = winner</span><br><span class="line">            <span class="keyword">return</span> winner</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># rest &gt;= 5</span></span><br><span class="line">        <span class="comment"># 遍历所有可能的吃草量</span></span><br><span class="line">        pick = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pick &lt;= rest:</span><br><span class="line">            <span class="comment"># `_f(rest - pick, enemy)` 返回的是：当剩下 `rest-pick` 的草，轮到 `enemy` 时，最终谁会赢。</span></span><br><span class="line">            <span class="comment"># 如果这个结果是 `cur` 赢，说明 `cur` 只要选择吃 `pick` 的草，就能锁定胜局。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._f(rest - pick, enemy, memo) == cur:</span><br><span class="line">                memo[(rest, cur)] = cur</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 防止 pick * 4 溢出 (在 Python 中不是问题，但在某些语言中需要注意)</span></span><br><span class="line">            <span class="keyword">if</span> pick &gt; rest // <span class="number">4</span>: <span class="comment">#先算//，再与pick比较</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pick *= <span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果所有可能的走法都无法让 cur 赢，那么 enemy 赢</span></span><br><span class="line">        memo[(rest, cur)] = enemy</span><br><span class="line">        <span class="keyword">return</span> enemy</span><br></pre></td></tr></table></figure>

<h3 id="方法二：规律观察优化解-1"><a href="#方法二：规律观察优化解-1" class="headerlink" title="方法二：规律观察优化解"></a>方法二：规律观察优化解</h3><p>通过打表发现胜负规律：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">win2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过暴力解的输出，发现胜负结果以5为周期循环</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    观察 `win1` 的输出，可以发现：</span></span><br><span class="line"><span class="string">    n=0 -&gt; B (先手输)</span></span><br><span class="line"><span class="string">    n=1 -&gt; A (先手赢)</span></span><br><span class="line"><span class="string">    n=2 -&gt; B (先手输)</span></span><br><span class="line"><span class="string">    n=3 -&gt; A (先手赢)</span></span><br><span class="line"><span class="string">    n=4 -&gt; A (先手赢)</span></span><br><span class="line"><span class="string">    n=5 -&gt; B (先手输)</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    胜负状态是 (B, A, B, A, A)，以5为周期。</span></span><br><span class="line"><span class="string">    当 n % 5 的结果是 0 或 2 时，先手方 A 面对的是必败局面，所以 B 赢。</span></span><br><span class="line"><span class="string">    否则 A 赢。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">or</span> n % <span class="number">5</span> == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="规律分析-1"><a href="#规律分析-1" class="headerlink" title="规律分析"></a>规律分析</h3><p>通过打表观察：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">草量 : 赢家</span><br><span class="line">0 : B</span><br><span class="line">1 : A</span><br><span class="line">2 : B</span><br><span class="line">3 : A</span><br><span class="line">4 : A</span><br><span class="line">5 : B</span><br><span class="line">6 : A</span><br><span class="line">7 : B</span><br><span class="line">8 : A</span><br><span class="line">9 : A</span><br><span class="line">10 : B</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>发现模式：<code>(B, A, B, A, A)</code> 以5为周期重复。</p>
<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>暴力递归</strong>：时间复杂度 O(N×logN)，空间复杂度 O(N)</li>
<li><strong>规律优化</strong>：时间复杂度 O(1)，空间复杂度 O(1)</li>
</ul>
<hr>
<h2 id="问题三：判断连续正整数和"><a href="#问题三：判断连续正整数和" class="headerlink" title="问题三：判断连续正整数和"></a>问题三：判断连续正整数和</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断一个数字是否是若干数量(数量&gt;1)的连续正整数的和。</p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个<strong>数论问题</strong>，可以通过数学推导得到简洁的判断条件。</p>
<h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is1</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        暴力尝试所有可能的连续正整数序列</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        - 从 1 开始，尝试每一个数 `start` 作为连续序列的起始点。</span></span><br><span class="line"><span class="string">        - 对于每一个 `start`，累加 `start, start+1, start+2, ...`</span></span><br><span class="line"><span class="string">        - 如果累加和等于 `num`，则找到了一个解，返回 True。</span></span><br><span class="line"><span class="string">        - 如果累加和大于 `num`，则以 `start` 为起点的序列不可能，跳出内层循环。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># start 是连续区间的开始</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">            current_sum = start</span><br><span class="line">            <span class="comment"># 从 start+1 开始累加</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> current_sum + j &gt; num:</span><br><span class="line">                    <span class="comment"># 累加和已超，后续不可能相等</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> current_sum + j == num:</span><br><span class="line">                    <span class="comment"># 找到了一个解</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                current_sum += j</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二：数学规律"><a href="#方法二：数学规律" class="headerlink" title="方法二：数学规律"></a>方法二：数学规律</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is2</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过数学推导得出的结论</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    一个正整数 `num` 可以表示为连续k(k&gt;1)个正整数之和的充要条件是：`num` 不是2的幂。</span></span><br><span class="line"><span class="string">    证明：</span></span><br><span class="line"><span class="string">    1. 设 `num = a + (a+1) + ... + (a+k-1) = k*a + k*(k-1)/2`</span></span><br><span class="line"><span class="string">    2. `2*num = k*(2a + k - 1)`</span></span><br><span class="line"><span class="string">    3. `k` 和 `2a+k-1` 中一个是奇数，一个是偶数。</span></span><br><span class="line"><span class="string">    4. 如果 `num` 是2的幂，`num = 2^p`，那么 `2*num = 2^(p+1)`。</span></span><br><span class="line"><span class="string">       `2^(p+1)` 的所有因子都是2的幂（偶数），无法分解成一奇一偶的乘积</span></span><br><span class="line"><span class="string">       （除了 1*2^(p+1)，但这要求 k=1 或 2a+k-1=1，都与 k&gt;1, a&gt;=1 矛盾）。</span></span><br><span class="line"><span class="string">    5. 所以，如果 `num` 是2的幂，则无解。反之，如果 `num` 不是2的幂，则 `num` 必有奇数因子，可以构造出解。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    判断一个数是否是2的幂，可以通过位运算 `num &amp; (num - 1) == 0` 来实现。</span></span><br><span class="line"><span class="string">    这是因为num的二进制表示只有一个1，所以num-1的二进制表示只有一个0，所以num &amp; (num - 1) == 0。</span></span><br><span class="line"><span class="string">    所以，判断一个数不是2的幂，就是 `(num &amp; (num - 1)) != 0`。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">3</span>: <span class="comment"># 1和2不满足条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 如果一个数是2的幂，它的二进制表示中只有一个1</span></span><br><span class="line">    <span class="comment"># num &amp; (num - 1) 的作用是消除最右边的1。</span></span><br><span class="line">    <span class="comment"># 如果结果为0，说明num只有一个1，是2的幂。</span></span><br><span class="line">    <span class="comment"># 如果结果不为0，说明num不是2的幂。</span></span><br><span class="line">    <span class="keyword">return</span> (num &amp; (num - <span class="number">1</span>)) != <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="数学推导详解"><a href="#数学推导详解" class="headerlink" title="数学推导详解"></a>数学推导详解</h3><p>对于连续k个正整数的和：<br>$$\text{sum} &#x3D; a + (a+1) + \ldots + (a+k-1) &#x3D; ka + \frac{k(k-1)}{2}$$</p>
<p>整理得：<br>$$2 \times \text{sum} &#x3D; k(2a + k - 1)$$</p>
<p>这说明 $2 \times \text{sum}$ 可以分解为两个因子的乘积，且一个是奇数，一个是偶数。</p>
<p>如果 $\text{sum} &#x3D; 2^p$，则 $2 \times \text{sum} &#x3D; 2^{p+1}$，所有因子都是偶数，无法满足一奇一偶的要求。</p>
<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>暴力枚举</strong>：时间复杂度 O(N²)，空间复杂度 O(1)</li>
<li><strong>数学规律</strong>：时间复杂度 O(1)，空间复杂度 O(1)</li>
</ul>
<hr>
<h2 id="问题四：RED字符串好串计数"><a href="#问题四：RED字符串好串计数" class="headerlink" title="问题四：RED字符串好串计数"></a>问题四：RED字符串好串计数</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>可以用r、e、d三种字符拼接字符串，如果拼出来的字符串中有且仅有1个长度&gt;&#x3D;2的回文子串，那么这个字符串定义为”好串”。返回长度为n的所有可能的字符串中，好串有多少个。结果对 1000000007 取模，1 &lt;&#x3D; n &lt;&#x3D; 10^9。</p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个<strong>组合数学问题</strong>，通过暴力递归生成所有可能的字符串并检验，然后观察规律。</p>
<h3 id="方法一：暴力递归"><a href="#方法一：暴力递归" class="headerlink" title="方法一：暴力递归"></a>方法一：暴力递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num1</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，启动暴力递归生成所有字符串并检查</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        path = [<span class="string">&#x27;&#x27;</span>] * n</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._f(path, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, path: <span class="built_in">list</span>, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成所有长度为n的字符串</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(path): <span class="comment">#这就是base case</span></span><br><span class="line">            <span class="comment"># 字符串生成完毕，检查是否为&quot;好串&quot;</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历所有长度&gt;=2的子串</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(l + <span class="number">1</span>, <span class="built_in">len</span>(path)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="variable language_">self</span>._is_palindrome(path, l, r):</span><br><span class="line">                        cnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="comment"># 超过1个回文子串，直接判定为非好串</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 最终检查回文子串数量是否正好为1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> cnt == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 在 i 位置尝试 &#x27;r&#x27;, &#x27;e&#x27;, &#x27;d&#x27; 三种字符</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            path[i] = <span class="string">&#x27;r&#x27;</span></span><br><span class="line">            ans += <span class="variable language_">self</span>._f(path, i + <span class="number">1</span>)</span><br><span class="line">            path[i] = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">            ans += <span class="variable language_">self</span>._f(path, i + <span class="number">1</span>)</span><br><span class="line">            path[i] = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">            ans += <span class="variable language_">self</span>._f(path, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_palindrome</span>(<span class="params">self, s: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        辅助函数，检查子串是否为回文</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二：规律观察"><a href="#方法二：规律观察" class="headerlink" title="方法二：规律观察"></a>方法二：规律观察</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">num2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过暴力解的结果，发现数学规律</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    运行 `num1` 得到：</span></span><br><span class="line"><span class="string">    n=1: 0</span></span><br><span class="line"><span class="string">    n=2: 3   (rr, ee, dd)</span></span><br><span class="line"><span class="string">    n=3: 18  (rre, rrd, rer, der, ...)</span></span><br><span class="line"><span class="string">    n=4: 30</span></span><br><span class="line"><span class="string">    n=5: 36</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    可以发现规律：</span></span><br><span class="line"><span class="string">    n=1 -&gt; 0</span></span><br><span class="line"><span class="string">    n=2 -&gt; 3</span></span><br><span class="line"><span class="string">    n=3 -&gt; 18</span></span><br><span class="line"><span class="string">    n&gt;3 -&gt; ans(n-1) + 6，即为一个等差数列，通项公式为 `18 + (n-3)*6 = 6*n`。</span></span><br><span class="line"><span class="string">    但题目中的答案是 `6*(n+1)`，我们来验证</span></span><br><span class="line"><span class="string">    n=4: 6*(4+1)=30.</span></span><br><span class="line"><span class="string">    n=5: 6*(5+1)=36.</span></span><br><span class="line"><span class="string">    这个规律是正确的。所以可以直接用公式计算。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mod = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span></span><br><span class="line">    <span class="comment"># (6 * (n + 1)) % mod</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">6</span> * (n + <span class="number">1</span>)) % mod</span><br></pre></td></tr></table></figure>

<h3 id="规律分析-2"><a href="#规律分析-2" class="headerlink" title="规律分析"></a>规律分析</h3><p>通过打表观察：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">长度 : 好串数量</span><br><span class="line">1 : 0    (无法构成长度&gt;=2的回文)</span><br><span class="line">2 : 3    (rr, ee, dd)</span><br><span class="line">3 : 18   </span><br><span class="line">4 : 30   = 6×(4+1)</span><br><span class="line">5 : 36   = 6×(5+1)</span><br><span class="line">6 : 42   = 6×(6+1)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>发现规律：</p>
<ul>
<li>n&#x3D;1: 0</li>
<li>n&#x3D;2: 3  </li>
<li>n&#x3D;3: 18</li>
<li>n≥4: 6×(n+1)</li>
</ul>
<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>暴力递归</strong>：时间复杂度 O(3^N × N³)，空间复杂度 O(N)</li>
<li><strong>规律优化</strong>：时间复杂度 O(1)，空间复杂度 O(1)</li>
</ul>
<hr>
<h2 id="核心技巧总结"><a href="#核心技巧总结" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-对数器打表的通用流程"><a href="#1-对数器打表的通用流程" class="headerlink" title="1. 对数器打表的通用流程"></a>1. 对数器打表的通用流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_by_pattern_finding</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对数器打表找规律的标准流程&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤1: 实现暴力解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">brute_force_solution</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="comment"># 用最基本的递归或暴力方法实现</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤2: 打表观察规律</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入 : 输出&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(small_range):</span><br><span class="line">        result = brute_force_solution(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> : <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤3: 根据观察到的规律实现优化解</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">optimized_solution</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="comment"># 基于规律的O(1)或低复杂度解法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> optimized_solution(n)</span><br></pre></td></tr></table></figure>

<h3 id="2-递归-记忆化模板"><a href="#2-递归-记忆化模板" class="headerlink" title="2. 递归 + 记忆化模板"></a>2. 递归 + 记忆化模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_with_memo</span>(<span class="params">params</span>):</span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">if</span> state <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[state]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> is_base_case(state):</span><br><span class="line">            <span class="keyword">return</span> base_result</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归计算</span></span><br><span class="line">        result = calculate_from_subproblems(state)</span><br><span class="line">        memo[state] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(initial_state)</span><br></pre></td></tr></table></figure>

<h3 id="3-博弈论问题模板"><a href="#3-博弈论问题模板" class="headerlink" title="3. 博弈论问题模板"></a>3. 博弈论问题模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">game_theory_solution</span>(<span class="params">state, current_player</span>):</span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">can_win</span>(<span class="params">state, player</span>):</span><br><span class="line">        <span class="keyword">if</span> (state, player) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(state, player)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> is_terminal_state(state):</span><br><span class="line">            <span class="keyword">return</span> determine_winner(state, player)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 尝试所有可能的移动</span></span><br><span class="line">        <span class="keyword">for</span> move <span class="keyword">in</span> get_possible_moves(state):</span><br><span class="line">            new_state = apply_move(state, move)</span><br><span class="line">            opponent = get_opponent(player)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果存在一步移动使得对手必败，当前玩家必胜</span></span><br><span class="line">            <span class="keyword">if</span> can_win(new_state, opponent) == player:</span><br><span class="line">                memo[(state, player)] = player</span><br><span class="line">                <span class="keyword">return</span> player</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 所有移动都无法获胜，当前玩家必败</span></span><br><span class="line">        opponent = get_opponent(player)</span><br><span class="line">        memo[(state, player)] = opponent</span><br><span class="line">        <span class="keyword">return</span> opponent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> can_win(state, current_player)</span><br></pre></td></tr></table></figure>

<h3 id="4-位运算判断2的幂"><a href="#4-位运算判断2的幂" class="headerlink" title="4. 位运算判断2的幂"></a>4. 位运算判断2的幂</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_power_of_two</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断n是否为2的幂&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_not_power_of_two</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断n是否不是2的幂&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) != <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="复杂度分析总结-1"><a href="#复杂度分析总结-1" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>问题类型</th>
<th>暴力解复杂度</th>
<th>优化解复杂度</th>
<th>核心技巧</th>
</tr>
</thead>
<tbody><tr>
<td>苹果袋子问题</td>
<td>O(N)</td>
<td>O(1)</td>
<td>动态规划→数学规律</td>
</tr>
<tr>
<td>吃草博弈</td>
<td>O(N×logN)</td>
<td>O(1)</td>
<td>博弈论→周期性规律</td>
</tr>
<tr>
<td>连续正整数和</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>数论→2的幂判断</td>
</tr>
<tr>
<td>好串计数</td>
<td>O(3^N×N³)</td>
<td>O(1)</td>
<td>穷举打表→发现数学规律</td>
</tr>
</tbody></table>
<hr>
<h2 id="学习建议-1"><a href="#学习建议-1" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-掌握基础技能"><a href="#1-掌握基础技能" class="headerlink" title="1. 掌握基础技能"></a>1. 掌握基础技能</h3><ul>
<li><strong>递归思维</strong>：熟练掌握递归的设计和实现</li>
<li><strong>动态规划</strong>：理解状态转移和最优子结构</li>
<li><strong>博弈论基础</strong>：了解必胜态和必败态的概念</li>
<li><strong>数学基础</strong>：具备基本的数论和组合数学知识</li>
</ul>
<h3 id="2-培养观察能力"><a href="#2-培养观察能力" class="headerlink" title="2. 培养观察能力"></a>2. 培养观察能力</h3><ul>
<li><strong>模式识别</strong>：善于从数据中发现周期性、递推性等规律</li>
<li><strong>数学直觉</strong>：能够将观察到的规律转化为数学公式</li>
<li><strong>验证习惯</strong>：发现规律后及时验证其正确性</li>
</ul>
<h3 id="3-实践要点-1"><a href="#3-实践要点-1" class="headerlink" title="3. 实践要点"></a>3. 实践要点</h3><ul>
<li><strong>小数据打表</strong>：从小规模数据开始，逐步观察规律</li>
<li><strong>多角度思考</strong>：尝试不同的观察角度和数学工具</li>
<li><strong>渐进优化</strong>：从暴力解→记忆化→数学公式的渐进优化过程</li>
</ul>
<h3 id="4-常见规律类型"><a href="#4-常见规律类型" class="headerlink" title="4. 常见规律类型"></a>4. 常见规律类型</h3><ul>
<li><strong>周期性规律</strong>：如博弈问题中的周期性胜负模式</li>
<li><strong>递推关系</strong>：如斐波那契数列、等差数列等</li>
<li><strong>数学性质</strong>：如2的幂的位运算性质</li>
<li><strong>组合规律</strong>：如排列组合中的计数问题</li>
</ul>
<h3 id="5-注意事项-1"><a href="#5-注意事项-1" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul>
<li><strong>边界条件</strong>：特别注意小数据的边界情况</li>
<li><strong>数据范围</strong>：考虑大数据下的溢出和效率问题</li>
<li><strong>规律验证</strong>：确保发现的规律在所有情况下都成立</li>
<li><strong>代码实现</strong>：将数学规律正确转化为代码逻辑</li>
</ul>
<p>通过掌握对数器打表找规律的技巧，可以将许多看似复杂的问题转化为简单的数学计算，大幅提升算法效率。这种方法在算法竞赛和实际工程中都有重要应用价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8817%EF%BC%89-%20N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8817%EF%BC%89-%20N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（17）- N皇后问题与位运算优化版本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-04 08:30:00" itemprop="dateCreated datePublished" datetime="2025-09-04T08:30:00+08:00">2025-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-08 18:38:59" itemprop="dateModified" datetime="2025-09-08T18:38:59+08:00">2025-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class40的内容，基于N皇后问题Python实现，分析了经典回溯算法和位运算优化版本的原理与实现。N皇后问题是回溯算法的经典应用，也是展示位运算巧妙应用的绝佳案例。</p>
<h1 id="040【必备】N皇后问题-重点是位运算的版本"><a href="#040【必备】N皇后问题-重点是位运算的版本" class="headerlink" title="040【必备】N皇后问题-重点是位运算的版本"></a>040【必备】N皇后问题-重点是位运算的版本</h1><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(17)/class40-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.png" alt="n皇后问题描述"></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>N皇后问题是在N×N的棋盘上放置N个皇后，使得任意两个皇后都不能相互攻击的问题。皇后可以攻击同一行、同一列或同一对角线上的任何棋子。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens-ii/">https://leetcode.cn/problems/n-queens-ii/</a></p>
<h2 id="核心挑战"><a href="#核心挑战" class="headerlink" title="核心挑战"></a>核心挑战</h2><p>N皇后问题的时间复杂度是O(N!)，这意味着随着N的增长，计算量会急剧增加。因此，优化常数时间和进行有效剪枝变得尤为重要。</p>
<hr>
<h2 id="方法一：数组表示路径（经典回溯）"><a href="#方法一：数组表示路径（经典回溯）" class="headerlink" title="方法一：数组表示路径（经典回溯）"></a>方法一：数组表示路径（经典回溯）</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用数组 <code>path[i] = j</code> 表示第i行的皇后放在第j列。对于每一行，尝试所有可能的列位置，通过冲突检测函数判断是否可以放置皇后。</p>
<p>具体实现流程：</p>
<ol>
<li>在每一行，<code>ban = col | left | right</code> 计算出所有被攻击的位置。（共同的限制）</li>
<li><code>candidate = limit &amp; (~ban)</code> 找出所有可以放置皇后的候选位置（列）。</li>
<li>循环遍历 <code>candidate</code> 中的每一个 <code>1</code>（代表一个可行的列）。<br> <code>place = candidate &amp; (-candidate)</code> 是一个巧妙的技巧，用于分离出最右边的 <code>1</code>。</li>
<li>对于每一个可行的 <code>place</code>，递归到下一行，并更新三个位掩码：<ul>
<li>列限制: <code>col | place</code></li>
<li>左对角线限制: <code>(left | place) &gt;&gt; 1</code> (下一行，对角线向右移一位)</li>
<li>右对角线限制: <code>(right | place) &lt;&lt; 1</code> (下一行，对角线向左移一位)</li>
</ul>
</li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">totalNQueens1</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主函数，初始化路径数组并启动递归</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># path[i] = j 表示第 i 行的皇后放在了第 j 列</span></span><br><span class="line">    path = [-<span class="number">1</span>] * n</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._f1(<span class="number">0</span>, path, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_f1</span>(<span class="params">self, i: <span class="built_in">int</span>, path: <span class="built_in">list</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归函数，尝试在第 i 行放置皇后</span></span><br><span class="line"><span class="string">    核心思想 (经典回溯法):</span></span><br><span class="line"><span class="string">    1. 递归地为每一行选择一个列来放置皇后。 </span></span><br><span class="line"><span class="string">    2. 当处理第 `i` 行时，遍历所有列 `j`。</span></span><br><span class="line"><span class="string">    3. 对于每个位置 `(i, j)`，检查是否与之前 `0` 到 `i-1` 行已放置的皇后冲突。</span></span><br><span class="line"><span class="string">    4. 如果不冲突，则将皇后放置在 `(i, j)`，然后递归到下一行 `i+1`。</span></span><br><span class="line"><span class="string">    5. 递归返回后，隐式地&quot;撤销&quot;选择（因为下一次循环会覆盖 `path[i]`），继续尝试当前行的下一列。</span></span><br><span class="line"><span class="string">    6. 当 `i` 到达 `n` 时，说明所有 `n` 个皇后都成功放置，找到一个解，返回 1。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">        <span class="comment"># 所有行都成功放置了皇后，找到一个有效的解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历当前 i 行的所有列 j</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 检查在 (i, j) 位置放皇后是否与之前的皇后冲突</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._check(path, i, j):</span><br><span class="line">            <span class="comment"># 如果不冲突，记录位置</span></span><br><span class="line">            path[i] = j</span><br><span class="line">            <span class="comment"># 递归到下一行</span></span><br><span class="line">            ans += <span class="variable language_">self</span>._f1(i + <span class="number">1</span>, path, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_check</span>(<span class="params">self, path: <span class="built_in">list</span>, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    检查在(i,j)位置放置皇后是否会与之前的皇后冲突</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 遍历 0 到 i-1 行，检查冲突</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="comment"># path[k] 是第 k 行皇后的列位置</span></span><br><span class="line">        <span class="comment"># 检查列冲突: j == path[k]</span></span><br><span class="line">        <span class="comment"># 检查对角线冲突: abs(i - k) == abs(j - path[k])</span></span><br><span class="line">        <span class="keyword">if</span> j == path[k] <span class="keyword">or</span> <span class="built_in">abs</span>(i - k) == <span class="built_in">abs</span>(j - path[k]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(17)/class40-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/%E5%85%AC%E5%85%B1%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E5%88%A4%E6%96%AD.png" alt="公共对角线的判断"></p>
<h3 id="冲突检测详解"><a href="#冲突检测详解" class="headerlink" title="冲突检测详解"></a>冲突检测详解</h3><ol>
<li><strong>列冲突</strong>：<code>j == path[k]</code> - 同一列不能有两个皇后</li>
<li><strong>对角线冲突</strong>：<code>abs(i - k) == abs(j - path[k])</code> - 对角线上行差的绝对值等于列差的绝对值</li>
</ol>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N! × N)，每个位置需要O(N)时间检查冲突</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>优缺点</strong>：思路清晰但效率较低</li>
</ul>
<hr>
<h2 id="方法二：位运算优化（推荐）"><a href="#方法二：位运算优化（推荐）" class="headerlink" title="方法二：位运算优化（推荐）"></a>方法二：位运算优化（推荐）</h2><h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用三个整数的位信息来表示所有被占用的位置，从而极大地加速冲突检测：</p>
<ul>
<li><strong>col</strong>：第k位为1表示第k列被占用</li>
<li><strong>left</strong>：第k位为1表示左上到右下对角线被占用</li>
<li><strong>right</strong>：第k位为1表示右上到左下对角线被占用</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(17)/class40-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/col%E5%8F%98%E9%87%8F.png" alt="col变量"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(17)/class40-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/left%E5%8F%98%E9%87%8F.png" alt="left变量"></p>
<h3 id="对角线映射规律"><a href="#对角线映射规律" class="headerlink" title="对角线映射规律"></a>对角线映射规律</h3><h4 id="左上到右下对角线（left）"><a href="#左上到右下对角线（left）" class="headerlink" title="左上到右下对角线（left）"></a>左上到右下对角线（left）</h4><ul>
<li>特点：行-列的值相同</li>
<li>下一行时：对角线向右移动一位，用右移操作 <code>&gt;&gt; 1</code></li>
</ul>
<h4 id="右上到左下对角线（right）"><a href="#右上到左下对角线（right）" class="headerlink" title="右上到左下对角线（right）"></a>右上到左下对角线（right）</h4><ul>
<li>特点：行+列的值相同</li>
<li>下一行时：对角线向左移动一位，用左移操作 <code>&lt;&lt; 1</code></li>
</ul>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">totalNQueens2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主函数，初始化 limit 并启动位运算递归</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> n &gt; <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># n = 5 -&gt; limit = 0b11111</span></span><br><span class="line">    <span class="comment"># limit 用于标记棋盘的有效列范围</span></span><br><span class="line">    limit = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._f2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_f2</span>(<span class="params">self, limit: <span class="built_in">int</span>, col: <span class="built_in">int</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    位运算递归函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数说明：</span></span><br><span class="line"><span class="string">    - limit: 标记棋盘大小的掩码</span></span><br><span class="line"><span class="string">    - col: 列占用情况</span></span><br><span class="line"><span class="string">    - left: 左上到右下对角线占用情况  </span></span><br><span class="line"><span class="string">    - right: 右上到左下对角线占用情况</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> col == limit:</span><br><span class="line">        <span class="comment"># 所有列都被占用，意味着所有皇后都已成功放置，找到一个解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 总限制，合并所有被占用的列和对角线，limit表示是几皇后问题</span></span><br><span class="line">    ban = col | left | right</span><br><span class="line">    <span class="comment"># ~ban : 1可放皇后，0不能放</span></span><br><span class="line">    <span class="comment"># limit &amp; (~ban) 得到当前行所有可以放置皇后的位置</span></span><br><span class="line">    candidate = limit &amp; (~ban)   <span class="comment">#Python 的整数是无限位的，~ban 会把高位也翻成 1，需要用 limit 把有效的 n 位以外的位裁掉。</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当还有候选位置时</span></span><br><span class="line">    <span class="keyword">while</span> candidate != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 提取出最右侧的1，代表本次尝试要放置皇后的位置</span></span><br><span class="line">        <span class="comment"># 例如 candidate = 0b010100, -candidate = 0b101100</span></span><br><span class="line">        <span class="comment"># place = 0b000100</span></span><br><span class="line">        place = candidate &amp; (-candidate)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从候选位置中移除刚刚选择的位置</span></span><br><span class="line">        candidate ^= place</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归到下一行，并更新限制</span></span><br><span class="line">        ans += <span class="variable language_">self</span>._f2(limit, col | place, (left | place) &gt;&gt; <span class="number">1</span>, (right | place) &lt;&lt; <span class="number">1</span>) <span class="comment">#最终返回的 ans 是：该 n 皇后问题的解的总数</span></span><br><span class="line">        <span class="comment"># col | place: 更新占用列；| 为按位或，把新放皇后的位置并入列占用。</span></span><br><span class="line">        <span class="comment"># (left | place) &gt;&gt; 1: 更新左对角占用；当前行对角占用并上新位置后，右移一位表示到下一行左对角“向右移”。</span></span><br><span class="line">        <span class="comment"># (right | place) &lt;&lt; 1: 更新右对角占用；到下一行右对角“向左移”，用左移一位表示。</span></span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="关键位运算技巧"><a href="#关键位运算技巧" class="headerlink" title="关键位运算技巧"></a>关键位运算技巧</h3><h4 id="1-提取最右边的1"><a href="#1-提取最右边的1" class="headerlink" title="1. 提取最右边的1"></a>1. 提取最右边的1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place = candidate &amp; (-candidate)</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：<code>-candidate</code> 是 <code>candidate</code> 的补码，两者相与得到最右边的1</li>
<li>例子：<code>candidate = 0b010100</code>, <code>-candidate = 0b101100</code>, <code>place = 0b000100</code></li>
</ul>
<h4 id="2-移除已选择的位"><a href="#2-移除已选择的位" class="headerlink" title="2. 移除已选择的位"></a>2. 移除已选择的位</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidate ^= place</span><br></pre></td></tr></table></figure>
<ul>
<li>使用异或操作移除已经选择的位置</li>
</ul>
<h4 id="3-计算有效候选位置"><a href="#3-计算有效候选位置" class="headerlink" title="3. 计算有效候选位置"></a>3. 计算有效候选位置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidate = limit &amp; (~ban)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>~ban</code>：翻转ban得到可放置的位置</li>
<li><code>limit</code>：确保只考虑有效的n位棋盘范围</li>
</ul>
<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以4皇后问题为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">初始状态：</span><br><span class="line">limit = 0b1111 (4位棋盘)</span><br><span class="line">col = 0, left = 0, right = 0</span><br><span class="line"></span><br><span class="line">第1行：</span><br><span class="line">ban = 0, candidate = 0b1111</span><br><span class="line">可选位置：第0,1,2,3列</span><br><span class="line"></span><br><span class="line">选择第0列 (place = 0b0001)：</span><br><span class="line">下一行状态：col=0b0001, left=0b0010, right=0b0010</span><br><span class="line"></span><br><span class="line">第2行：</span><br><span class="line">ban = 0b0001 | 0b0010 | 0b0010 = 0b0011</span><br><span class="line">candidate = 0b1111 &amp; 0b1100 = 0b1100</span><br><span class="line">可选位置：第2,3列</span><br><span class="line"></span><br><span class="line">... 继续递归</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N!)，但常数时间大幅优化</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>优势</strong>：位运算操作极快，适合大规模问题</li>
</ul>
<hr>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>根据代码测试结果：（测试电脑：联想ThinkBook 16+）</p>
<table>
<thead>
<tr>
<th>N值</th>
<th>数组方法</th>
<th>位运算方法</th>
<th>性能提升</th>
</tr>
</thead>
<tbody><tr>
<td>14</td>
<td>188224</td>
<td>9011</td>
<td>约10倍</td>
</tr>
<tr>
<td>14</td>
<td>超时</td>
<td>~10秒内</td>
<td>数十倍</td>
</tr>
</tbody></table>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    n = <span class="number">14</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试方法1</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    ans1 = s.totalNQueens1(n)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;方法1答案 : <span class="subst">&#123;ans1&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;方法1运行时间 : <span class="subst">&#123;<span class="built_in">int</span>((end_time - start_time) * <span class="number">1000</span>)&#125;</span> 毫秒&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试方法2</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    ans2 = s.totalNQueens2(n)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;方法2答案 : <span class="subst">&#123;ans2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;方法2运行时间 : <span class="subst">&#123;<span class="built_in">int</span>((end_time - start_time) * <span class="number">1000</span>)&#125;</span> 毫秒&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="位运算核心技巧总结"><a href="#位运算核心技巧总结" class="headerlink" title="位运算核心技巧总结"></a>位运算核心技巧总结</h2><h3 id="1-基本位操作"><a href="#1-基本位操作" class="headerlink" title="1. 基本位操作"></a>1. 基本位操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置第i位为1</span></span><br><span class="line">num |= (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除第i位</span></span><br><span class="line">num &amp;= ~(<span class="number">1</span> &lt;&lt; i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查第i位是否为1</span></span><br><span class="line"><span class="keyword">if</span> num &amp; (<span class="number">1</span> &lt;&lt; i):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转第i位</span></span><br><span class="line">num ^= (<span class="number">1</span> &lt;&lt; i)</span><br></pre></td></tr></table></figure>

<h3 id="2-高级位技巧"><a href="#2-高级位技巧" class="headerlink" title="2. 高级位技巧"></a>2. 高级位技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最右边的1</span></span><br><span class="line">rightmost_one = num &amp; (-num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除最右边的1</span></span><br><span class="line">num &amp;= (num - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建n位全1的掩码</span></span><br><span class="line">mask = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-对角线映射"><a href="#3-对角线映射" class="headerlink" title="3. 对角线映射"></a>3. 对角线映射</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左上到右下：下一行右移</span></span><br><span class="line">left_diag = (left_diag | place) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右上到左下：下一行左移  </span></span><br><span class="line">right_diag = (right_diag | place) &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="优化策略总结"><a href="#优化策略总结" class="headerlink" title="优化策略总结"></a>优化策略总结</h2><h3 id="1-数据结构选择"><a href="#1-数据结构选择" class="headerlink" title="1. 数据结构选择"></a>1. 数据结构选择</h3><ul>
<li><strong>数组方法</strong>：直观但需要O(N)时间检查冲突</li>
<li><strong>位运算方法</strong>：用位信息表示状态，O(1)时间冲突检测</li>
</ul>
<h3 id="2-状态表示优化"><a href="#2-状态表示优化" class="headerlink" title="2. 状态表示优化"></a>2. 状态表示优化</h3><ul>
<li>用整数的二进制位表示多个布尔状态</li>
<li>利用位运算的并行性处理多个位</li>
</ul>
<h3 id="3-算法剪枝"><a href="#3-算法剪枝" class="headerlink" title="3. 算法剪枝"></a>3. 算法剪枝</h3><ul>
<li>早期冲突检测</li>
<li>状态压缩减少内存访问</li>
</ul>
<h3 id="4-常数优化"><a href="#4-常数优化" class="headerlink" title="4. 常数优化"></a>4. 常数优化</h3><ul>
<li>位运算替代数组操作</li>
<li>减少函数调用开销</li>
</ul>
<hr>
<h2 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h2><h3 id="1-回溯算法模板"><a href="#1-回溯算法模板" class="headerlink" title="1. 回溯算法模板"></a>1. 回溯算法模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">if</span> is_solution(state):</span><br><span class="line">        record_solution(state)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> get_choices(state):</span><br><span class="line">        <span class="keyword">if</span> is_valid(choice, state):</span><br><span class="line">            make_choice(choice, state)</span><br><span class="line">            backtrack(state)</span><br><span class="line">            undo_choice(choice, state)  <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure>

<h3 id="2-位运算在算法中的应用"><a href="#2-位运算在算法中的应用" class="headerlink" title="2. 位运算在算法中的应用"></a>2. 位运算在算法中的应用</h3><ul>
<li>状态压缩</li>
<li>集合操作</li>
<li>快速计算</li>
<li>空间优化</li>
</ul>
<h3 id="3-性能优化思路"><a href="#3-性能优化思路" class="headerlink" title="3. 性能优化思路"></a>3. 性能优化思路</h3><ul>
<li>算法层面：减少时间复杂度</li>
<li>实现层面：优化常数因子</li>
<li>数据结构层面：选择合适的表示方式</li>
</ul>
<h3 id="4-问题分析方法"><a href="#4-问题分析方法" class="headerlink" title="4. 问题分析方法"></a>4. 问题分析方法</h3><ul>
<li>理解问题约束</li>
<li>识别状态表示</li>
<li>设计状态转移</li>
<li>考虑优化空间</li>
</ul>
<hr>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="1-约束满足问题（CSP）"><a href="#1-约束满足问题（CSP）" class="headerlink" title="1. 约束满足问题（CSP）"></a>1. 约束满足问题（CSP）</h3><ul>
<li>数独求解</li>
<li>图着色问题</li>
<li>任务调度</li>
</ul>
<h3 id="2-位运算优化适用场景"><a href="#2-位运算优化适用场景" class="headerlink" title="2. 位运算优化适用场景"></a>2. 位运算优化适用场景</h3><ul>
<li>状态空间较小（通常≤64位）</li>
<li>需要频繁的集合操作</li>
<li>对性能要求极高的场景</li>
</ul>
<h3 id="3-工程实践建议"><a href="#3-工程实践建议" class="headerlink" title="3. 工程实践建议"></a>3. 工程实践建议</h3><ul>
<li>先实现清晰版本，再考虑优化</li>
<li>位运算虽快但可读性差，需要充分注释</li>
<li>在性能关键路径上应用位运算优化</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>N皇后问题展示了从经典回溯算法到位运算优化的完整演进过程。位运算版本虽然理解难度较高，但在性能上有显著提升，特别适合处理大规模问题。掌握这种优化思路对于解决其他状态空间搜索问题具有重要意义。</p>
<p>通过对比两种方法，我们可以看到算法优化的不同层次：算法设计层面的改进和实现技巧层面的优化。在实际工程中，应该根据具体需求在代码可读性和执行效率之间做出合理权衡。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89-%20%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89-%20%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（16）- 嵌套类问题的递归解题套路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-03 10:30:00" itemprop="dateCreated datePublished" datetime="2025-09-03T10:30:00+08:00">2025-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-08 18:26:54" itemprop="dateModified" datetime="2025-09-08T18:26:54+08:00">2025-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是讲解039的内容，总结了嵌套类问题的递归解题套路。这类问题的共同特点是存在嵌套结构（如括号嵌套），需要用递归来处理。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习嵌套类问题之前，需要掌握以下基础知识：</p>
<ul>
<li>讲解017、020、021、023、036、037、038</li>
<li>这些章节都分析过递归，尤其是讲解038，不熟悉的同学可以先熟悉一下</li>
</ul>
<hr>
<h1 id="039【必备】嵌套类问题的递归解题套路"><a href="#039【必备】嵌套类问题的递归解题套路" class="headerlink" title="039【必备】嵌套类问题的递归解题套路"></a>039【必备】嵌套类问题的递归解题套路</h1><h2 id="核心解题思路"><a href="#核心解题思路" class="headerlink" title="核心解题思路"></a>核心解题思路</h2><h3 id="基本套路模板"><a href="#基本套路模板" class="headerlink" title="基本套路模板"></a>基本套路模板</h3><p>嵌套类问题的解题套路可以概括为：</p>
<ol>
<li><strong>定义全局变量</strong> <code>where</code>：记录当前解析到的位置</li>
<li><strong>递归函数</strong> <code>f(i)</code>：从位置i开始解析，遇到字符串终止或嵌套条件终止就返回</li>
<li><strong>返回值机制</strong>：<code>f(i)</code>负责这一段的结果，返回前更新全局变量<code>where</code></li>
<li><strong>位置传递</strong>：让上级函数通过<code>where</code>知道解析到了什么位置，进而继续</li>
</ol>
<h3 id="执行细节"><a href="#执行细节" class="headerlink" title="执行细节"></a>执行细节</h3><ul>
<li>如果<code>f(i)</code>遇到<strong>嵌套条件开始</strong>，就调用下级递归去处理嵌套</li>
<li>下级会负责嵌套部分的计算结果</li>
<li><code>f(i)</code>下级处理完成后，可以根据下级更新的全局变量<code>where</code>，知道该从什么位置继续解析</li>
</ul>
<hr>
<h2 id="题目一：含有嵌套的表达式求值"><a href="#题目一：含有嵌套的表达式求值" class="headerlink" title="题目一：含有嵌套的表达式求值"></a>题目一：含有嵌套的表达式求值</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>请写一个整数计算器，支持加减乘三种运算和括号。</p>
<ul>
<li>数据范围：0 &lt; |s| &lt; 100，保证计算结果始终在整型范围内</li>
<li>要求：空间复杂度 O(n)，时间复杂度 O(n)</li>
</ul>
<p><strong>测试链接</strong>：</p>
<ul>
<li>LeetCode：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-iii/">https://leetcode.cn/problems/basic-calculator-iii/</a></li>
<li>牛客网：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4">https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4</a></li>
</ul>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用递归处理括号嵌套，同时用两个列表分别存储数字和操作符。通过<code>push</code>辅助函数处理运算优先级：</p>
<ul>
<li><strong>乘除法优先级高</strong>：遇到时立即计算，并更新数字列表的最后一个数</li>
<li><strong>加减法优先级低</strong>：先将数字和操作符存入列表</li>
<li><strong>遇到左括号<code>(</code></strong>：递归调用自身 <code>_f</code> 来计算括号内的值，把它当作一个整体的数字</li>
<li><strong>遇到右括号 <code>)</code> 或字符串末尾</strong>：结束当前层级的计算,并对 <code>numbers</code> 和 <code>ops</code> 列表中的加减法进行最终求和</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(16)/class39-%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/%E5%AE%9E%E7%8E%B0%E4%B8%89%E7%A7%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91.png" alt="实现三种运算符的底层逻辑"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化共享索引并启动递归</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.where = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._f(<span class="built_in">list</span>(s), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># s[i....]开始计算，遇到字符串终止 或者 遇到)停止</span></span><br><span class="line">    <span class="comment"># 返回 : 自己负责的这一段，计算的结果</span></span><br><span class="line">    <span class="comment"># 返回之间，更新全局变量where，为了上游函数知道从哪继续！</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>], i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，处理一个括号内的或整个表达式的求值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        numbers = []</span><br><span class="line">        ops = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] != <span class="string">&#x27;)&#x27;</span>: <span class="comment"># 未终止且未遇到右括号</span></span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit(): <span class="comment"># 是数字</span></span><br><span class="line">                cur = cur * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] != <span class="string">&#x27;(&#x27;</span>: <span class="comment"># 不是左括号</span></span><br><span class="line">                <span class="comment"># 遇到了运算符 + - * /</span></span><br><span class="line">                <span class="variable language_">self</span>._push(numbers, ops, cur, s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 是左括号</span></span><br><span class="line">                <span class="comment"># i (.....)</span></span><br><span class="line">                <span class="comment"># 遇到了左括号！</span></span><br><span class="line">                <span class="comment"># 递归调用 f，计算括号内的结果</span></span><br><span class="line">                cur = <span class="variable language_">self</span>._f(s, i + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 递归返回后，where 指向了 &#x27;)&#x27; 的位置，i 需要跳到 &#x27;)&#x27; 之后</span></span><br><span class="line">                i = <span class="variable language_">self</span>.where + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果碰到了右括号，将最后一个数字（或括号运算结果）加入列表，并更新全局索引</span></span><br><span class="line">        <span class="variable language_">self</span>._push(numbers, ops, cur, <span class="string">&#x27;+&#x27;</span>) <span class="comment"># 末尾添加一个 &#x27;+&#x27; 不影响最终计算</span></span><br><span class="line">        <span class="comment"># 更新全局索引，让上级函数知道从哪继续</span></span><br><span class="line">        <span class="variable language_">self</span>.where = i</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._compute(numbers, ops)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_push</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], ops: <span class="type">List</span>[<span class="built_in">str</span>], cur: <span class="built_in">int</span>, op: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;辅助函数，处理数字和操作符的入栈逻辑，并处理乘除法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> ops[-<span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> ops[-<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="comment"># 如果是第一个数，或者前一个运算符是+或-，直接入栈</span></span><br><span class="line">            numbers.append(cur)</span><br><span class="line">            ops.append(op)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果前一个运算符是*或/，立即计算</span></span><br><span class="line">            top_number = numbers[-<span class="number">1</span>]</span><br><span class="line">            top_op = ops[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> top_op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                numbers[-<span class="number">1</span>] = top_number * cur</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># top_op == &#x27;/&#x27;</span></span><br><span class="line">                <span class="comment"># Python 的 // 是向下取整，题目要求向零取整</span></span><br><span class="line">                numbers[-<span class="number">1</span>] = <span class="built_in">int</span>(top_number / cur)</span><br><span class="line">            ops[-<span class="number">1</span>] = op <span class="comment"># 更新操作符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 具体例子   </span></span><br><span class="line">            <span class="comment"># 原始：3 * 4 + 5</span></span><br><span class="line">            <span class="comment">#     处理到 * 4 时：</span></span><br><span class="line">            <span class="comment">#     - numbers: [3, 4] → [12] (3*4=12)</span></span><br><span class="line">            <span class="comment">#     - ops: [&#x27;*&#x27;] → [&#x27;+&#x27;] (更新操作符)  </span></span><br><span class="line">            <span class="comment"># 这样下一个数字 5 就能正确地与 12 进行加法运算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_compute</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], ops: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;辅助函数，计算只有加减法的最终结果&quot;&quot;&quot;</span></span><br><span class="line">        ans = numbers[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(numbers)):</span><br><span class="line">            ans += numbers[i] <span class="keyword">if</span> ops[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -numbers[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：递归处理嵌套 + 分离处理优先级</li>
</ul>
<hr>
<h2 id="题目二：含有嵌套的字符串解码"><a href="#题目二：含有嵌套的字符串解码" class="headerlink" title="题目二：含有嵌套的字符串解码"></a>题目二：含有嵌套的字符串解码</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为：<code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 k 次。</p>
<p><strong>示例</strong>：输入：<code>s = &quot;3[a2[c]]&quot;</code>，输出：<code>&quot;accaccacc&quot;</code></p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>递归解码嵌套字符串。有嵌套就一定有数字：</p>
<ul>
<li><strong>遇到字母</strong>：直接拼接到当前层级的结果 <code>path</code> 中</li>
<li><strong>遇到数字</strong>：累加成一个完整的数字 <code>cnt</code>，这代表后续 <code>[]</code> 内字符串的重复次数</li>
<li><strong>遇到左括号<code>[</code></strong>：说明进入了一个新的嵌套层级。此时，递归调用 <code>_f</code> 来解码 <code>[]</code> 内的子问题。递归返回后，将得到的子字符串重复 <code>cnt</code> 次，拼接到 <code>path</code> 中。</li>
<li><strong>遇到右括号 <code>]</code> 或字符串末尾</strong>：当前层级解码结束，返回 <code>path</code>。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(16)/class39-%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/where%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.png" alt="where全局变量"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(16)/class39-%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/%E8%A7%A3%E7%A0%81%E5%B5%8C%E5%A5%97%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="解码嵌套字符串"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化共享索引并启动递归</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.where = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._f(<span class="built_in">list</span>(s), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># s[i....]开始计算，遇到字符串终止 或者 遇到 ] 停止</span></span><br><span class="line">    <span class="comment"># 返回 : 自己负责的这一段字符串的结果</span></span><br><span class="line">    <span class="comment"># 返回之间，更新全局变量where，为了上游函数知道从哪继续！</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, s: <span class="built_in">list</span>, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，解码一个层级的字符串</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        path = []</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] != <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;z&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;A&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>:  <span class="comment"># 比较范围</span></span><br><span class="line">                path.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                cnt = cnt * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 遇到 [ </span></span><br><span class="line">                <span class="comment"># 递归调用 f 来解码括号内的内容</span></span><br><span class="line">                inner_str = <span class="variable language_">self</span>._f(s, i + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 将解码后的子串重复 cnt 次</span></span><br><span class="line">                path.append(cnt * inner_str)</span><br><span class="line">                <span class="comment"># 更新 i 到 &#x27;]&#x27; 之后的位置</span></span><br><span class="line">                i = <span class="variable language_">self</span>.where + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 重置 cnt</span></span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新全局索引，以便上层函数知道从哪里继续</span></span><br><span class="line">        <span class="variable language_">self</span>.where = i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(path)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：递归处理嵌套 + 字符串重复</li>
</ul>
<hr>
<h2 id="题目三：含有嵌套的分子式求原子数量"><a href="#题目三：含有嵌套的分子式求原子数量" class="headerlink" title="题目三：含有嵌套的分子式求原子数量"></a>题目三：含有嵌套的分子式求原子数量</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个字符串化学式 <code>formula</code>，返回每种原子的数量。</p>
<ul>
<li>原子总是以一个大写字母开始，接着跟随0个或任意个小写字母</li>
<li>如果数量大于1，原子后会跟着数字表示原子的数量</li>
<li>如果数量等于1则不会跟数字</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-atoms/">https://leetcode.cn/problems/number-of-atoms/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>递归解析嵌套分子式，返回原子计数字典</p>
<p>具体流程如下：</p>
<ul>
<li>循环解析当前层级，直到遇到 ‘)’ 或字符串末尾。</li>
<li>解析过程中维护三个状态：<code>name</code> (当前原子名), <code>pre</code> (括号内解析结果的字典), <code>cnt</code> (倍数)。</li>
<li>当遇到下一个大写字母或左括号 <code>(</code> 时，说明前一个“单元”（原子或括号）已经解析完毕，<br>  调用 <code>_fill</code> 函数将其信息合并到当前层级的总结果 <code>ans</code> 字典中。</li>
<li>遇到 <code>(</code>，递归调用 <code>_f</code> 获取括号内的原子构成，存入 <code>pre</code> 字典。</li>
<li>遇到大写字母，开始一个新的原子名 <code>name</code>。</li>
<li>遇到小写字母，追加到 <code>name</code>。</li>
<li>遇到数字，累加成倍数 <code>cnt</code>。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(16)/class39-%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/%E8%A7%A3%E8%AF%BB%E5%8E%9F%E5%AD%90%E4%B8%AA%E6%95%B0.png" alt="解读原子个数"></p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countOfAtoms</span>(<span class="params">self, formula: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化共享索引并启动递归，最后格式化输出</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.where = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 调用递归函数获取原子计数的字典</span></span><br><span class="line">        atom_map = <span class="variable language_">self</span>._f(<span class="built_in">list</span>(formula), <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建最终的输出字符串</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 按原子名称的字母顺序排序，返回有序表</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(atom_map.keys()):</span><br><span class="line">            ans.append(key) <span class="comment"># 先添加原子名称再添加数量</span></span><br><span class="line">            cnt = atom_map[key]</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">                ans.append(<span class="built_in">str</span>(cnt))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, s: <span class="built_in">list</span>, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，解析一个层级的分子式，返回一个字典</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = defaultdict(<span class="built_in">int</span>)  <span class="comment"># 创建默认字典</span></span><br><span class="line">        name = []  <span class="comment"># 存储当前原子名称</span></span><br><span class="line">        pre = <span class="literal">None</span>  <span class="comment"># 历史记录</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] != <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;A&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> <span class="keyword">or</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="comment"># 遇到新单元，先把之前收集的信息处理掉</span></span><br><span class="line">                <span class="variable language_">self</span>._fill(ans, name, pre, cnt)</span><br><span class="line">                <span class="comment"># 重置状态</span></span><br><span class="line">                name.clear()  <span class="comment"># 清空列表中的所有元素</span></span><br><span class="line">                pre = <span class="literal">None</span></span><br><span class="line">                cnt = <span class="number">0</span>  <span class="comment"># 重置倍数</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;A&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">                    name.append(s[i])</span><br><span class="line">                    i += <span class="number">1</span>  <span class="comment"># 移动到下一个字符</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 遇到 (</span></span><br><span class="line">                    <span class="comment"># 递归处理括号内的表达式</span></span><br><span class="line">                    pre = <span class="variable language_">self</span>._f(s, i + <span class="number">1</span>)</span><br><span class="line">                    i = <span class="variable language_">self</span>.where + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;a&#x27;</span> &lt;= s[i] &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                name.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 遇到数字</span></span><br><span class="line">                cnt = cnt * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环结束，处理最后一个单元</span></span><br><span class="line">        <span class="variable language_">self</span>._fill(ans, name, pre, cnt)</span><br><span class="line">        <span class="comment"># 更新全局索引</span></span><br><span class="line">        <span class="variable language_">self</span>.where = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fill</span>(<span class="params">self, ans: <span class="built_in">dict</span>, name: <span class="built_in">list</span>, pre: <span class="built_in">dict</span>, cnt: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;辅助函数，将一个解析完的单元（原子或括号）合并到总结果中&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">or</span> pre:</span><br><span class="line">            <span class="comment"># 如果没有数字，倍数默认为1</span></span><br><span class="line">            cnt = <span class="number">1</span> <span class="keyword">if</span> cnt == <span class="number">0</span> <span class="keyword">else</span> cnt</span><br><span class="line">            <span class="keyword">if</span> name:</span><br><span class="line">                <span class="comment"># 如果是原子，直接累加数量</span></span><br><span class="line">                key = <span class="string">&quot;&quot;</span>.join(name)</span><br><span class="line">                ans[key] += cnt</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果是括号内的字典 pre</span></span><br><span class="line">                <span class="comment"># 遍历字典，将其中每个原子的数量乘以倍数 cnt，再累加</span></span><br><span class="line">                <span class="keyword">for</span> key, val <span class="keyword">in</span> pre.items():</span><br><span class="line">                    ans[key] += val * cnt</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>核心技巧</strong>：递归处理嵌套 + 字典合并</li>
</ul>
<hr>
<h2 id="核心套路总结"><a href="#核心套路总结" class="headerlink" title="核心套路总结"></a>核心套路总结</h2><h3 id="1-递归函数设计模板"><a href="#1-递归函数设计模板" class="headerlink" title="1. 递归函数设计模板"></a>1. 递归函数设计模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;主函数，初始化全局变量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.where = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._f(<span class="built_in">list</span>(s), <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, s: <span class="built_in">list</span>, i: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归函数核心模板&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化当前层级的状态变量</span></span><br><span class="line">        result = []  <span class="comment"># 或其他适当的数据结构</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] != 终止条件:</span><br><span class="line">            <span class="keyword">if</span> 普通字符处理:</span><br><span class="line">                <span class="comment"># 直接处理</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> 嵌套开始标志:</span><br><span class="line">                <span class="comment"># 递归调用处理嵌套</span></span><br><span class="line">                nested_result = <span class="variable language_">self</span>._f(s, i + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 处理递归结果</span></span><br><span class="line">                result.append(nested_result)</span><br><span class="line">                <span class="comment"># 更新位置</span></span><br><span class="line">                i = <span class="variable language_">self</span>.where + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 其他情况处理</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新全局位置</span></span><br><span class="line">        <span class="variable language_">self</span>.where = i</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="2-全局变量where的作用"><a href="#2-全局变量where的作用" class="headerlink" title="2. 全局变量where的作用"></a>2. 全局变量where的作用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># where的三个关键作用：</span></span><br><span class="line"><span class="comment"># 1. 记录当前递归函数解析到的位置</span></span><br><span class="line"><span class="comment"># 2. 让上级函数知道下级函数处理到哪里了</span></span><br><span class="line"><span class="comment"># 3. 实现递归层级之间的位置传递</span></span><br></pre></td></tr></table></figure>

<h3 id="3-嵌套处理的通用策略"><a href="#3-嵌套处理的通用策略" class="headerlink" title="3. 嵌套处理的通用策略"></a>3. 嵌套处理的通用策略</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遇到嵌套开始标志时：</span></span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> s[i] == <span class="string">&#x27;[&#x27;</span>:  <span class="comment"># 根据具体问题调整</span></span><br><span class="line">    <span class="comment"># 1. 递归调用处理嵌套内容</span></span><br><span class="line">    nested_result = <span class="variable language_">self</span>._f(s, i + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 处理递归返回的结果</span></span><br><span class="line">    process_nested_result(nested_result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 更新当前位置到嵌套结束后</span></span><br><span class="line">    i = <span class="variable language_">self</span>.where + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>表达式求值</td>
<td>O(n)</td>
<td>O(n)</td>
<td>列表 + 递归栈</td>
</tr>
<tr>
<td>字符串解码</td>
<td>O(n)</td>
<td>O(n)</td>
<td>字符串 + 递归栈</td>
</tr>
<tr>
<td>分子式解析</td>
<td>O(n)</td>
<td>O(n)</td>
<td>字典 + 递归栈</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><h3 id="1-理解递归本质"><a href="#1-理解递归本质" class="headerlink" title="1. 理解递归本质"></a>1. 理解递归本质</h3><ul>
<li>递归是处理嵌套结构的自然选择</li>
<li>每一层递归负责处理一个层级的内容</li>
<li>通过全局变量实现层级间的信息传递</li>
</ul>
<h3 id="2-掌握状态管理"><a href="#2-掌握状态管理" class="headerlink" title="2. 掌握状态管理"></a>2. 掌握状态管理</h3><ul>
<li>明确每层递归需要维护哪些状态</li>
<li>合理设计辅助函数处理复杂逻辑</li>
<li>注意状态的重置和更新时机</li>
</ul>
<h3 id="3-练习边界处理"><a href="#3-练习边界处理" class="headerlink" title="3. 练习边界处理"></a>3. 练习边界处理</h3><ul>
<li>递归终止条件的设计</li>
<li>嵌套边界的正确处理</li>
<li>特殊情况的考虑（空字符串、单字符等）</li>
</ul>
<h3 id="4-优化技巧"><a href="#4-优化技巧" class="headerlink" title="4. 优化技巧"></a>4. 优化技巧</h3><ul>
<li>使用合适的数据结构（列表、字典、栈等）</li>
<li>避免重复计算和冗余操作</li>
<li>考虑空间复杂度的优化</li>
</ul>
<h3 id="5-调试方法"><a href="#5-调试方法" class="headerlink" title="5. 调试方法"></a>5. 调试方法</h3><ul>
<li>画出递归调用的层级关系图</li>
<li>追踪全局变量where的变化</li>
<li>验证每层递归的输入输出</li>
</ul>
<p>通过掌握这个通用的嵌套类问题解题套路，可以有效解决包含括号、方括号等嵌套结构的各类算法问题。关键在于理解递归的层级关系和全局变量的作用机制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89-%20%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89-%20%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（15）- 常见经典递归过程解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-02 10:30:00" itemprop="dateCreated datePublished" datetime="2025-09-02T10:30:00+08:00">2025-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-08 18:27:11" itemprop="dateModified" datetime="2025-09-08T18:27:11+08:00">2025-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是 <strong>038【必备】常见经典递归过程解析</strong> 的内容，总结了7道经典递归题目，涵盖了递归的核心思想和技巧，包括带路径的递归、不带路径的递归、回溯算法等重要概念。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习本节内容之前，建议先熟悉以下章节：</p>
<ul>
<li>讲解017、020、021、023、036、037（这些章节都分析过递归）</li>
</ul>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="递归与回溯的关系"><a href="#递归与回溯的关系" class="headerlink" title="递归与回溯的关系"></a>递归与回溯的关系</h3><ul>
<li><strong>任何递归都是DFS且非常灵活</strong></li>
<li><strong>回溯这个术语并不重要</strong>，它只是递归过程中的恢复现场操作</li>
<li><strong>带路径的递归 vs 不带路径的递归</strong>：大部分DP和状态压缩DP可以认为是路径简化了结构</li>
</ul>
<hr>
<h1 id="038【必备】常见经典递归过程解析"><a href="#038【必备】常见经典递归过程解析" class="headerlink" title="038【必备】常见经典递归过程解析"></a>038【必备】常见经典递归过程解析</h1><h2 id="题目一：返回字符串全部子序列（去重）"><a href="#题目一：返回字符串全部子序列（去重）" class="headerlink" title="题目一：返回字符串全部子序列（去重）"></a>题目一：返回字符串全部子序列（去重）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>返回字符串全部子序列，子序列要求去重。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a">https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用递归的方式，对于字符串中的每一个字符，我们都有两种选择：</p>
<ol>
<li>将该字符包含在当前子序列中</li>
<li>不将该字符包含在当前子序列中</li>
</ol>
<p>通过递归遍历所有这些选择，就能得到所有可能的子序列。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E5%AD%90%E5%BA%8F%E5%88%97%E5%8E%BB%E9%87%8D.png" alt="子序列去重"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：使用列表作为路径"><a href="#方法一：使用列表作为路径" class="headerlink" title="方法一：使用列表作为路径"></a>方法一：使用列表作为路径</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generatePermutation1</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数 f1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用集合 set 来自动处理重复的子序列</span></span><br><span class="line">        result_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># path 使用列表来模拟 Java 的 StringBuilder，方便添加和删除字符</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="variable language_">self</span>._f1(s, <span class="number">0</span>, path, result_set)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(result_set))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f1</span>(<span class="params">self, s: <span class="built_in">str</span>, i: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">str</span>], result_set: <span class="type">Set</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，用于生成所有子序列</span></span><br><span class="line"><span class="string">        s[i...]，之前决定的路径path，set收集结果时去重</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 当索引 i 到达字符串末尾时，所有字符都已考虑完毕</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">            result_set.add(<span class="string">&quot;&quot;</span>.join(path))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 决策1: 选择当前字符 s[i]</span></span><br><span class="line">            path.append(s[i])  <span class="comment"># 加到路径中去</span></span><br><span class="line">            <span class="variable language_">self</span>._f1(s, i + <span class="number">1</span>, path, result_set)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 回溯：撤销选择，为下一种决策做准备</span></span><br><span class="line">            path.pop()  <span class="comment"># 从路径中移除，删掉最后一个字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策2: 不选择当前字符 s[i]</span></span><br><span class="line">            <span class="variable language_">self</span>._f1(s, i + <span class="number">1</span>, path, result_set)</span><br></pre></td></tr></table></figure>

<h4 id="方法二：使用固定长度列表和size指针"><a href="#方法二：使用固定长度列表和size指针" class="headerlink" title="方法二：使用固定长度列表和size指针"></a>方法二：使用固定长度列表和size指针</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generatePermutation2</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数 f2</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 预先分配一个与原字符串等长的列表作为路径容器</span></span><br><span class="line">        path = [<span class="string">&#x27;&#x27;</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="variable language_">self</span>._f2(s, <span class="number">0</span>, path, <span class="number">0</span>, result_set)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(result_set))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f2</span>(<span class="params">self, s: <span class="built_in">str</span>, i: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">str</span>], size: <span class="built_in">int</span>, result_set: <span class="type">Set</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        与f1思想相同，但使用不同的方式来维护路径</span></span><br><span class="line"><span class="string">        这方法不用回溯，因为path是固定长度的列表，size指针来表示有效字符长度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># path[:size] 表示路径中的有效部分</span></span><br><span class="line">            result_set.add(<span class="string">&quot;&quot;</span>.join(path[:size]))</span><br><span class="line">            <span class="comment"># path[:size]: 取列表/序列 path 的前 size 个元素（左闭右开，不会越界，超过长度就取到末尾）</span></span><br><span class="line">            <span class="comment"># &quot;&quot;.join(...): 用空字符串作为分隔符，把可迭代对象里的“字符串元素”拼接成一个整体字符串</span></span><br><span class="line">            <span class="comment"># result_set.add(...): 将结果添加到集合中，自动去重</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 决策1: 选择当前字符 s[i]，将其放入 path 的 size 位置</span></span><br><span class="line">            path[size] = s[i]</span><br><span class="line">            <span class="variable language_">self</span>._f2(s, i + <span class="number">1</span>, path, size + <span class="number">1</span>, result_set) <span class="comment">#size+1表明有效字符长度+1，指针后移</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策2: 不选择当前字符 s[i]，直接进入下一层递归</span></span><br><span class="line">            <span class="variable language_">self</span>._f2(s, i + <span class="number">1</span>, path, size, result_set)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n × n)，子序列个数2^n，平均长度O(n)级别</li>
<li><strong>空间复杂度</strong>：O(2^n × n)</li>
<li><strong>核心技巧</strong>：递归选择 + set去重</li>
</ul>
<hr>
<h2 id="题目二：返回数组的所有组合（去重）"><a href="#题目二：返回数组的所有组合（去重）" class="headerlink" title="题目二：返回数组的所有组合（去重）"></a>题目二：返回数组的所有组合（去重）</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums，其中可能包含重复元素，请你返回该数组所有可能的组合。答案不能包含重复的组合。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>与生成子序列（排列）不同，这里通过<strong>一次性决策一组相同数字</strong>的方式来避免重复。</p>
<ol>
<li>先对数组排序。</li>
<li>在递归到位置 <code>i</code> 时，首先找到下一个与 <code>nums[i]</code> 不同的数的位置 <code>j</code>。<br> 这表示从 <code>i</code> 到 <code>j-1</code> 都是相同的数。</li>
<li>决策1：这组相同的数一个都不要。直接从 <code>j</code> 位置继续递归。</li>
<li>决策2：依次决策要1个、2个…直到 <code>j-i</code> 个相同的数。<br> 每做一次选择，就将数加入路径，然后从 <code>j</code> 位置继续递归。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E7%94%9F%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%84%E5%90%88.png" alt="生成不同的组合"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 排序是关键，它使得相同的元素相邻，便于后续去重处理</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        path = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>._f(nums, <span class="number">0</span>, path, <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">int</span>], size: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成不重复的组合</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 当 i 到达数组末尾时，形成一个组合</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(path[:size])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 找到下一个不同于 nums[i] 的元素的位置 j</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[j] == nums[i]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策1: 当前数 nums[i] 一个都不要</span></span><br><span class="line">            <span class="variable language_">self</span>._f(nums, j, path, size, ans)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策2: 依次尝试要 1 个、2 个... k 个 nums[i]</span></span><br><span class="line">            <span class="comment"># 从这一段相同数字里，依次选择 1 个、2 个、…、(j-i) 个放入路径，然后递归从 j 开始，即处理下一组数去</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                path[size] = nums[k]</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 每次选择后，都从下一个不同的数 j 开始继续递归</span></span><br><span class="line">                <span class="variable language_">self</span>._f(nums, j, path, size, ans)</span><br></pre></td></tr></table></figure>

<h3 id="区别：set去重-vs-剪枝去重"><a href="#区别：set去重-vs-剪枝去重" class="headerlink" title="区别：set去重 vs 剪枝去重"></a>区别：set去重 vs 剪枝去重</h3><ul>
<li><strong>剪枝去重</strong>：当有相同的元素时，不进入递归，直接跳过，避免重复计算。（本题有用到这方面的考虑）</li>
<li><strong>set去重</strong>：当有相同的元素时，会进入递归，但最终结果会去重。（但是题目1没有）</li>
</ul>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n × n)，所有不重复组合数量≤2^n</li>
<li><strong>空间复杂度</strong>：O(2^n × n)</li>
<li><strong>核心技巧</strong>：排序 + 剪枝去重</li>
</ul>
<hr>
<h2 id="题目三：返回没有重复值数组的全部排列"><a href="#题目三：返回没有重复值数组的全部排列" class="headerlink" title="题目三：返回没有重复值数组的全部排列"></a>题目三：返回没有重复值数组的全部排列</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>没有重复项数字的全排列。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用<strong>交换模型</strong>：</p>
<ol>
<li>递归函数 <code>_f(nums, i)</code> 的任务是确定数组中第 <code>i</code> 个位置应该放哪个数。</li>
<li>我们可以从 <code>i</code> 到 <code>len(nums)-1</code> 的范围内选择一个数，将它与 <code>nums[i]</code> 交换，<br> 这样就确定了第 <code>i</code> 位。</li>
<li>然后递归调用 <code>_f(nums, i+1)</code> 去确定第 <code>i+1</code> 位。</li>
<li>当 <code>i</code> 到达数组末尾时，一个完整的排列就形成了。</li>
<li>递归返回后，必须将之前交换的元素换回来（回溯），以确保不影响其他分支的决策。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%881%EF%BC%89.png" alt="全排列（1）"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%882%EF%BC%89.png" alt="全排列（2）"></p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="variable language_">self</span>._f(nums, <span class="number">0</span>, ans)  <span class="comment"># 复用了原数组做路径</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成全排列</span></span><br><span class="line"><span class="string">        核心思想 (交换模型)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 当 i 到达数组长度时，一个完整的排列就形成了</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(nums[:])  <span class="comment"># 将当前排列的副本加入结果列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 尝试将 i 到 len(nums)-1 的每个数放到 i 位置上</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 将 nums[j] 换到当前要确定的 i 位置</span></span><br><span class="line">                <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line">                <span class="comment"># 递归去确定下一个位置 i+1</span></span><br><span class="line">                <span class="variable language_">self</span>._f(nums, i + <span class="number">1</span>, ans)</span><br><span class="line">                <span class="comment"># 回溯：将数组恢复原样，以便 for 循环下一次迭代能正确执行</span></span><br><span class="line">                <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n! × n)</li>
<li><strong>空间复杂度</strong>：O(n!)</li>
<li><strong>核心技巧</strong>：交换模型 + 回溯</li>
</ul>
<hr>
<h2 id="题目四：返回可能有重复值数组的全部排列（去重）"><a href="#题目四：返回可能有重复值数组的全部排列（去重）" class="headerlink" title="题目四：返回可能有重复值数组的全部排列（去重）"></a>题目四：返回可能有重复值数组的全部排列（去重）</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>有重复项数组的去重全排列。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p>核心思想 (在交换模型基础上增加剪枝逻辑)：<br>与生成无重复数字的全排列思路基本一致，但增加了一个去重机制。</p>
<ol>
<li>在确定第 <code>i</code> 个位置的数时，我们遍历 <code>j</code> from <code>i</code> to <code>len-1</code>。</li>
<li>为了防止产生重复排列，我们规定：在第 <code>i</code> 个位置，一个数只能被放一次。<br> 例如，对于 <code>[1, 2, 2]</code>，在确定第0位时，我们尝试放第一个 <code>2</code>，<br> 就不应该再尝试放第二个 <code>2</code>，因为这两种情况后续会产生完全相同的排列。</li>
<li>使用一个集合 <code>seen</code> (或 <code>set</code>) 来记录在当前位置 <code>i</code> 已经尝试过的数字。<br> 如果 <code>nums[j]</code> 已经被放过，就跳过。</li>
</ol>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="variable language_">self</span>._f(nums, <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成不重复的全排列</span></span><br><span class="line"><span class="string">        在交换模型基础上增加剪枝逻辑</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(nums[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># seen 集合用于记录在当前 i 位置上已经尝试过的数字</span></span><br><span class="line">            seen: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># nums[j]没有来到过i位置，才会去尝试</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    <span class="comment"># 记录下来，表示 nums[j] 这个值已经在 i 位置上用过了</span></span><br><span class="line">                    seen.add(nums[j])</span><br><span class="line">                    <span class="comment"># 交换，将 nums[j] 放到 i 位置</span></span><br><span class="line">                    <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line">                    <span class="comment"># 递归处理下一个位置</span></span><br><span class="line">                    <span class="variable language_">self</span>._f(nums, i + <span class="number">1</span>, ans)</span><br><span class="line">                    <span class="comment"># 回溯，恢复数组</span></span><br><span class="line">                    <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n! × n)</li>
<li><strong>空间复杂度</strong>：O(n!)</li>
<li><strong>核心技巧</strong>：交换模型 + 集合去重</li>
</ul>
<hr>
<h2 id="题目五：用递归逆序一个栈"><a href="#题目五：用递归逆序一个栈" class="headerlink" title="题目五：用递归逆序一个栈"></a>题目五：用递归逆序一个栈</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>用递归函数逆序栈，不能使用任何额外的数据结构。</p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p>需要两个递归函数：</p>
<ol>
<li><code>bottom_out</code>：移除并返回栈底元素，同时保持其他元素顺序不变</li>
<li><code>reverse</code>：利用bottom_out函数来逆序整个栈</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E9%80%86%E5%BA%8F%E6%A0%88bottom_out%E6%96%B9%E6%B3%95.png" alt="逆序栈bottom_out方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E9%80%86%E5%BA%8F%E6%A0%88reverse%E6%96%B9%E6%B3%95.png" alt="逆序栈reverse方法"></p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主递归函数，用于逆序整个栈。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 假设有一个函数 `_bottom_out` 可以移除并返回栈底元素。</span></span><br><span class="line"><span class="string">        2. `reverse` 函数首先调用 `_bottom_out` 得到栈底元素 `num`。</span></span><br><span class="line"><span class="string">        3. 然后，递归调用 `reverse` 来逆序剩下的 n-1 个元素的栈。</span></span><br><span class="line"><span class="string">        4. 最后，将之前取出的栈底元素 `num` 压入已逆序的栈中，此时它就成了新的栈顶。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归地移除并获取栈底元素</span></span><br><span class="line">        num = <span class="variable language_">self</span>._bottom_out(stack)</span><br><span class="line">        <span class="comment"># 递归地逆序剩余的栈</span></span><br><span class="line">        <span class="variable language_">self</span>.reverse(stack)</span><br><span class="line">        <span class="comment"># 将取出的栈底元素压入栈顶</span></span><br><span class="line">        stack.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bottom_out</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        辅助递归函数，移除并返回栈底元素，同时保持其他元素顺序不变。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 弹出栈顶元素 `ans`。</span></span><br><span class="line"><span class="string">        2. 如果栈空了，说明 `ans` 就是我们想要的栈底元素，返回它。</span></span><br><span class="line"><span class="string">        3. 如果栈不空，递归调用 `_bottom_out` 获取剩下部分的栈底元素 `last`。</span></span><br><span class="line"><span class="string">        4. 在递归返回的过程中，将之前弹出的 `ans` 重新压栈，以恢复栈的状态。</span></span><br><span class="line"><span class="string">        5. 将从递归深处得到的 `last` 一路返回上去。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> ans  <span class="comment"># 如果栈空了，说明ans就是栈底元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = <span class="variable language_">self</span>._bottom_out(stack)  <span class="comment"># 递归获取剩下部分的栈底元素</span></span><br><span class="line">            stack.append(ans)  <span class="comment"># 在递归返回过程中，将之前弹出的ans重新压栈</span></span><br><span class="line">            <span class="keyword">return</span> last  <span class="comment"># 将从递归深处得到的last一路返回上去</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原栈: [1, 2, 3, 4, 5] (5在栈顶)</span><br><span class="line"></span><br><span class="line">第1次reverse调用:</span><br><span class="line">  bottom_out取出栈底1，栈变为[2, 3, 4, 5]</span><br><span class="line">  递归reverse([2, 3, 4, 5])</span><br><span class="line">  返回后将1压入栈顶</span><br><span class="line"></span><br><span class="line">第2次reverse调用:</span><br><span class="line">  bottom_out取出栈底2，栈变为[3, 4, 5]</span><br><span class="line">  递归reverse([3, 4, 5])</span><br><span class="line">  返回后将2压入栈顶</span><br><span class="line"></span><br><span class="line">...以此类推</span><br><span class="line"></span><br><span class="line">最终结果: [1, 2, 3, 4, 5] (1在栈顶)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n²)</li>
<li><strong>空间复杂度</strong>：O(n) (递归栈空间)</li>
<li><strong>核心技巧</strong>：双递归函数配合</li>
</ul>
<hr>
<h2 id="题目六：用递归排序一个栈"><a href="#题目六：用递归排序一个栈" class="headerlink" title="题目六：用递归排序一个栈"></a>题目六：用递归排序一个栈</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>用递归函数排序栈，只能使用栈提供的push、pop、isEmpty三个方法，以及递归函数。要求排完序后，从栈顶到栈底从小到大。</p>
<p>除此之外不能使用任何的容器，数组也不行。就是排序过程中只能用：(1) 栈提供的push、pop、isEmpty三个方法，(2) 递归函数，并且返回值最多为单个整数</p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个类似选择排序的递归实现。</p>
<ol>
<li>整个排序过程分为 <code>deep</code> 轮，<code>deep</code> 是当前未排序部分的栈深度。</li>
<li>在每一轮中，目标是找出这 <code>deep</code> 个元素中的最大值（可能不止一个），并将它们“沉”到这 <code>deep</code> 个元素的最底部。</li>
<li><code>_max()</code> 函数：递归地在 <code>deep</code> 层中找到最大值。</li>
<li><code>_times()</code> 函数：递归地在 <code>deep</code> 层中统计这个最大值出现了几次 <code>k</code>。</li>
<li><code>_down()</code> 函数：递归地将这 <code>k</code> 个最大值移动到 <code>deep</code> 层的底部，同时保持其他 <code>deep-k</code> 个元素的相对顺序。</li>
<li>完成一轮后，未排序的深度减少 <code>k</code> (<code>deep -= k</code>)，然后对剩下的 <code>deep</code> 个元素重复此过程。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6.png" alt="排列栈_整体框架"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_deep%E6%96%B9%E6%B3%95.png" alt="排列栈_deep方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_max%E6%96%B9%E6%B3%95.png" alt="排列栈_max方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_times%E6%96%B9%E6%B3%95.png" alt="排列栈_times方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_down%E6%96%B9%E6%B3%95.png" alt="排列栈_down方法"></p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort_stack</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        deep = <span class="variable language_">self</span>._deep(stack)</span><br><span class="line">        <span class="keyword">while</span> deep &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 找到当前 deep 范围内的最大值</span></span><br><span class="line">            maximum = <span class="variable language_">self</span>._<span class="built_in">max</span>(stack, deep)</span><br><span class="line">            <span class="comment"># 统计最大值出现的次数</span></span><br><span class="line">            k = <span class="variable language_">self</span>._times(stack, deep, maximum)</span><br><span class="line">            <span class="comment"># 将这 k 个最大值沉底</span></span><br><span class="line">            <span class="variable language_">self</span>._down(stack, deep, maximum, k)</span><br><span class="line">            <span class="comment"># 待排序的深度减少 k</span></span><br><span class="line">            deep -= k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_deep</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈的深度，不改变栈的数据状况&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = stack.pop()</span><br><span class="line">        deep = <span class="variable language_">self</span>._deep(stack) + <span class="number">1</span></span><br><span class="line">        stack.append(num)  <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> deep</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_max</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>], deep: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从栈当前的顶部开始，往下数deep层，返回这deep层里的最大值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 返回一个极小值作为基准</span></span><br><span class="line">        num = stack.pop()</span><br><span class="line">        rest_max = <span class="variable language_">self</span>._<span class="built_in">max</span>(stack, deep - <span class="number">1</span>)</span><br><span class="line">        current_max = <span class="built_in">max</span>(num, rest_max)</span><br><span class="line">        stack.append(num)  <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> current_max</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_times</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>], deep: <span class="built_in">int</span>, maximum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回maximum在deep层中出现的次数，不改变栈的数据状况&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = stack.pop()</span><br><span class="line">        rest_times = <span class="variable language_">self</span>._times(stack, deep - <span class="number">1</span>, maximum)</span><br><span class="line">        times = rest_times + (<span class="number">1</span> <span class="keyword">if</span> num == maximum <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        stack.append(num)  <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_down</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>], deep: <span class="built_in">int</span>, maximum: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将k个最大值沉到deep层的底部，剩下的数据状况不变&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 递归到底部时，先把k个最大值压入栈</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                stack.append(maximum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = stack.pop()</span><br><span class="line">            <span class="variable language_">self</span>._down(stack, deep - <span class="number">1</span>, maximum, k)</span><br><span class="line">            <span class="comment"># 在递归返回时，只把非最大值的元素压回去</span></span><br><span class="line">            <span class="keyword">if</span> num != maximum:</span><br><span class="line">                stack.append(num)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n²)</li>
<li><strong>空间复杂度</strong>：O(n) (递归栈空间)</li>
<li><strong>核心技巧</strong>：多递归函数配合 + 选择排序思想</li>
</ul>
<hr>
<h2 id="题目七：打印n层汉诺塔问题的最优移动轨迹"><a href="#题目七：打印n层汉诺塔问题的最优移动轨迹" class="headerlink" title="题目七：打印n层汉诺塔问题的最优移动轨迹"></a>题目七：打印n层汉诺塔问题的最优移动轨迹</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>打印n层汉诺塔问题的最优移动轨迹。</p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个经典的递归分治问题。要将 i 个盘子从 A 移动到 C：</p>
<ol>
<li>先将 i-1 个盘子从 A 移动到 B (辅助柱)。</li>
<li>再将第 i 个盘子 (最大的那个) 从 A 移动到 C。</li>
<li>最后将 i-1 个盘子从 B 移动到 C。<br>这个过程完美地将一个大问题分解为两个规模更小的相同问题和一个简单的单步操作。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.png" alt="汉诺塔问题描述"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E6%9C%80%E4%BC%98%E7%A7%BB%E5%8A%A8%E8%BD%A8%E8%BF%B9.png" alt="汉诺塔的最优移动轨迹"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%B5%81%E7%A8%8B.png" alt="汉诺塔的抽象流程"></p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TowerOfHanoi</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        汉诺塔问题主函数入口</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>._f(n, <span class="string">&quot;左&quot;</span>, <span class="string">&quot;右&quot;</span>, <span class="string">&quot;中&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, i: <span class="built_in">int</span>, start: <span class="built_in">str</span>, end: <span class="built_in">str</span>, other: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，解决将 i 个圆盘从 start 移动到 end 的问题</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case：如果只有一个圆盘，直接移动</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;移动圆盘 1 从 <span class="subst">&#123;start&#125;</span> 到 <span class="subst">&#123;end&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 步骤1: 将 i-1 个圆盘从 start 移动到 other</span></span><br><span class="line">            <span class="variable language_">self</span>._f(i - <span class="number">1</span>, start, other, end)</span><br><span class="line">            <span class="comment"># 步骤2: 移动第 i 个圆盘从 start 到 end</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;移动圆盘 <span class="subst">&#123;i&#125;</span> 从 <span class="subst">&#123;start&#125;</span> 到 <span class="subst">&#123;end&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 步骤3: 将 i-1 个圆盘从 other 移动到 end</span></span><br><span class="line">            <span class="variable language_">self</span>._f(i - <span class="number">1</span>, other, end, start)</span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例（n-3）"><a href="#执行过程示例（n-3）" class="headerlink" title="执行过程示例（n&#x3D;3）"></a>执行过程示例（n&#x3D;3）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决 3 层汉诺塔问题的步骤：</span><br><span class="line">移动圆盘 1 从 左 到 右</span><br><span class="line">移动圆盘 2 从 左 到 中</span><br><span class="line">移动圆盘 1 从 右 到 中</span><br><span class="line">移动圆盘 3 从 左 到 右</span><br><span class="line">移动圆盘 1 从 中 到 左</span><br><span class="line">移动圆盘 2 从 中 到 右</span><br><span class="line">移动圆盘 1 从 左 到 右</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n)</li>
<li><strong>空间复杂度</strong>：O(n) (递归栈空间)</li>
<li><strong>核心技巧</strong>：递归分治</li>
</ul>
<hr>
<h2 id="递归技巧总结"><a href="#递归技巧总结" class="headerlink" title="递归技巧总结"></a>递归技巧总结</h2><h3 id="1-递归模板"><a href="#1-递归模板" class="headerlink" title="1. 递归模板"></a>1. 递归模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_function</span>(<span class="params">parameters</span>):</span><br><span class="line">    <span class="comment"># base case: 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> base_condition:</span><br><span class="line">        <span class="keyword">return</span> base_result</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归调用：分解问题</span></span><br><span class="line">    result = recursive_function(modified_parameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理当前层的逻辑</span></span><br><span class="line">    current_result = process(result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> current_result</span><br></pre></td></tr></table></figure>

<h3 id="2-回溯模板"><a href="#2-回溯模板" class="headerlink" title="2. 回溯模板"></a>2. 回溯模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> satisfied:</span><br><span class="line">        result.append(path[:])  <span class="comment"># 收集结果</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        path.append(choice)</span><br><span class="line">        backtrack(path, remaining_choices)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>

<h3 id="3-常见递归模式"><a href="#3-常见递归模式" class="headerlink" title="3. 常见递归模式"></a>3. 常见递归模式</h3><h4 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对每个元素有选择：要 or 不要</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">i, path</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        process(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 要当前元素</span></span><br><span class="line">    path.append(arr[i])</span><br><span class="line">    choose(i + <span class="number">1</span>, path)</span><br><span class="line">    path.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不要当前元素</span></span><br><span class="line">    choose(i + <span class="number">1</span>, path)</span><br></pre></td></tr></table></figure>

<h4 id="交换模式"><a href="#交换模式" class="headerlink" title="交换模式"></a>交换模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全排列问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">arr, i</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        process(arr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(arr)):</span><br><span class="line">        swap(arr, i, j)</span><br><span class="line">        permute(arr, i + <span class="number">1</span>)</span><br><span class="line">        swap(arr, i, j)  <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心技巧</th>
</tr>
</thead>
<tbody><tr>
<td>字符串子序列</td>
<td>O(2^n × n)</td>
<td>O(2^n × n)</td>
<td>选择模式 + set去重</td>
</tr>
<tr>
<td>数组组合</td>
<td>O(2^n × n)</td>
<td>O(2^n × n)</td>
<td>排序 + 剪枝去重</td>
</tr>
<tr>
<td>无重复全排列</td>
<td>O(n! × n)</td>
<td>O(n!)</td>
<td>交换模式 + 回溯</td>
</tr>
<tr>
<td>有重复全排列</td>
<td>O(n! × n)</td>
<td>O(n!)</td>
<td>交换模式 + 集合去重</td>
</tr>
<tr>
<td>递归逆序栈</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>双递归函数</td>
</tr>
<tr>
<td>递归排序栈</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>多递归函数</td>
</tr>
<tr>
<td>汉诺塔</td>
<td>O(2^n)</td>
<td>O(n)</td>
<td>递归分治</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>理解递归本质</strong>：递归就是函数调用自己，关键在于找到递归关系和base case</p>
</li>
<li><p><strong>掌握常见模式</strong>：</p>
<ul>
<li>选择模式（子集、组合问题）</li>
<li>交换模式（排列问题）</li>
<li>分治模式（汉诺塔、归并排序等）</li>
</ul>
</li>
<li><p><strong>注意回溯时机</strong>：</p>
<ul>
<li>何时需要回溯（恢复现场）</li>
<li>何时不需要回溯（使用额外空间）</li>
</ul>
</li>
<li><p><strong>优化技巧</strong>：</p>
<ul>
<li>剪枝去重 vs set去重</li>
<li>空间复用（固定长度数组 + size指针）</li>
<li>预处理（排序、哈希表等）</li>
</ul>
</li>
<li><p><strong>递归栈深度</strong>：注意递归深度，避免栈溢出</p>
</li>
<li><p><strong>实践建议</strong>：</p>
<ul>
<li>多画递归树理解执行过程</li>
<li>从简单案例开始推导</li>
<li>注意边界条件的处理</li>
</ul>
</li>
</ol>
<p>递归是解决很多复杂问题的有力工具，掌握好递归的思想和常见模式，可以大大提升解决问题的能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（14）- 二叉树高频题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-22 10:30:00 / Modified: 20:53:28" itemprop="dateCreated datePublished" datetime="2025-08-22T10:30:00+08:00">2025-08-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class036→037的内容，总结了二叉树相关的9+7&#x3D;16道高频算法题目。class36涵盖了二叉树的遍历、序列化、构造、验证等核心操作，但不包含树型动态规划的内容。class037算是036的补充，讲了二叉树相关的另外7道高频算法题目，包含了最近公共祖先（LCA）问题、路径搜索、平衡性验证、搜索二叉树相关操作。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习二叉树高频题目之前，需要掌握以下基础知识：</p>
<ul>
<li>队列用数组实现（讲解013）</li>
<li>二叉树入门内容（讲解017~018）</li>
</ul>
<h2 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h2><ul>
<li>本期和下期视频会讲解二叉树高频题目，但不含树型dp的题目</li>
<li>树型dp问题会放在【必备】课程的动态规划大章节部分讲述</li>
<li>树型dp中的换根dp问题会放在【扩展】课程的动态规划大章节部分讲述</li>
<li>AVL树的实现、树的左旋右旋等内容也会在【扩展】课程里讲述</li>
<li>问题1又叫LCA问题，非常重要！Tarjan算法解决LCA的批量查询、树链剖分算法解决LCA的在线查询会在【扩展】课程讲述</li>
<li>数组的打家劫舍问题变形很多，会在【必备】课程的动态规划大章节部分讲述</li>
<li>再次强调树型dp的整体讲解，会在【必备】课程的动态规划大章节部分讲述</li>
</ul>
<hr>
<h1 id="036【必备】二叉树高频题目-上-不含树型dp"><a href="#036【必备】二叉树高频题目-上-不含树型dp" class="headerlink" title="036【必备】二叉树高频题目-上-不含树型dp"></a>036【必备】二叉树高频题目-上-不含树型dp</h1><h2 id="初始化的二叉树类"><a href="#初始化的二叉树类" class="headerlink" title="初始化的二叉树类"></a>初始化的二叉树类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br></pre></td></tr></table></figure>

<h2 id="题目一：二叉树的层序遍历"><a href="#题目一：二叉树的层序遍历" class="headerlink" title="题目一：二叉树的层序遍历"></a>题目一：二叉树的层序遍历</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉树的根节点 root，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用广度优先搜索（BFS）进行层序遍历，有两种实现方式：</p>
<ol>
<li><strong>普通BFS</strong>：使用队列存储节点，用哈希表记录每个节点的层级</li>
<li><strong>优化BFS</strong>：按层处理，每次处理完整一层的所有节点</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="层序遍历的实现"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B02.png" alt="层序遍历的实现2"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：普通BFS"><a href="#方法一：普通BFS" class="headerlink" title="方法一：普通BFS"></a>方法一：普通BFS</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时把方法名改为levelOrder，此方法为普通bfs（宽度/广度优先搜索，叫宽度搜索的原因是层的最大节点数为宽度），此题不推荐</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder1</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 核心思想：标准的广度优先搜索（BFS）。</span></span><br><span class="line">    <span class="comment"># 使用一个队列存储待访问节点，同时用一个哈希表（字典）来记录每个节点所在的层级。</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> root:<span class="comment">#根节点有东西</span></span><br><span class="line">        <span class="comment"># Python的deque是一个高效的双端队列，非常适合用于BFS</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="comment"># 字典用于存储 node -&gt; level 的映射</span></span><br><span class="line">        levels = &#123;root: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:<span class="comment"># 队列不空的时候从队列中取出一个节点</span></span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            level = levels[cur]                </span><br><span class="line">            <span class="comment"># 如果当前层级是第一次遇到，就在ans中创建一个新列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) == level: <span class="comment">#ans 列表的长度总是等于当前已经处理过的层级数量，包括第0层，说明当前节点的层级 level 正好等于已经创建的层级数量，味着这个层级还没有被处理过，需要创建新的列表</span></span><br><span class="line">                ans.append([])               </span><br><span class="line">            <span class="comment"># 将当前节点的值加入对应层级的列表</span></span><br><span class="line">            ans[level].append(cur.val)              </span><br><span class="line">            <span class="comment"># 将子节点加入队列，并记录它们的层级</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append(cur.left)</span><br><span class="line">                levels[cur.left] = level + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append(cur.right)</span><br><span class="line">                levels[cur.right] = level + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    <span class="comment"># 核心思想：标准的广度优先搜索（BFS），使用一个队列存储待访问节点，</span></span><br><span class="line">    <span class="comment"># 同时用一个哈希表（字典）来记录每个节点所在的层级。</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二：优化BFS（推荐）"><a href="#方法二：优化BFS（推荐）" class="headerlink" title="方法二：优化BFS（推荐）"></a>方法二：优化BFS（推荐）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder2</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 核心思想：优化的广度优先搜索（BFS），按层处理。</span></span><br><span class="line">    <span class="comment"># 外层while循环控制层级，内层for循环精确地处理当前层的所有节点。</span></span><br><span class="line">    <span class="comment"># 这样就无需额外的哈希表来存储节点的层级信息。</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment"># 当队列不为空，说明还有节点待处理</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue) <span class="comment"># 当前层的节点数量</span></span><br><span class="line">            level_list = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size): <span class="comment"># 精确处理当前层的所有节点</span></span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level_list.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: <span class="comment"># 将下一层节点入队</span></span><br><span class="line">                    queue.append(cur.left) </span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right) <span class="comment"># append是加在右边的</span></span><br><span class="line">            ans.append(level_list)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以树结构 <code>1-&gt;2,3; 2-&gt;4,5; 3-&gt;6</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始状态：queue = [1], ans = []</span><br><span class="line"></span><br><span class="line">处理第0层：</span><br><span class="line">  size = 1, level_list = []</span><br><span class="line">  取出节点1，level_list = [1]</span><br><span class="line">  将节点2,3入队，queue = [2, 3]</span><br><span class="line">  ans = [[1]]</span><br><span class="line"></span><br><span class="line">处理第1层：</span><br><span class="line">  size = 2, level_list = []</span><br><span class="line">  取出节点2，level_list = [2]，将4,5入队</span><br><span class="line">  取出节点3，level_list = [2, 3]，将6入队</span><br><span class="line">  queue = [4, 5, 6]</span><br><span class="line">  ans = [[1], [2, 3]]</span><br><span class="line"></span><br><span class="line">处理第2层：</span><br><span class="line">  size = 3, level_list = []</span><br><span class="line">  依次取出4,5,6，level_list = [4, 5, 6]</span><br><span class="line">  ans = [[1], [2, 3], [4, 5, 6]]</span><br></pre></td></tr></table></figure>


<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，N为节点数</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：按层BFS遍历</li>
</ul>
<hr>
<h2 id="题目二：二叉树的锯齿形层序遍历"><a href="#题目二：二叉树的锯齿形层序遍历" class="headerlink" title="题目二：二叉树的锯齿形层序遍历"></a>题目二：二叉树的锯齿形层序遍历</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>在按层BFS的基础上，增加一个布尔标记 <code>reverse</code>。每一层遍历结束后，根据 <code>reverse</code> 的值决定是否要将当前层收集到的节点值列表进行反转。</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交以下的方法</span></span><br><span class="line"><span class="comment"># 用每次处理一层的优化bfs就非常容易实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 核心思想：在按层BFS的基础上，增加一个布尔标记 `reverse`。</span></span><br><span class="line">    <span class="comment"># 每一层遍历结束后，根据 `reverse` 的值决定是否要将当前层收集到的节点值列表进行反转。</span></span><br><span class="line">    <span class="comment"># 然后切换 `reverse` 的状态，供下一层使用。</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="comment"># false 代表从左往右</span></span><br><span class="line">        <span class="comment"># true 代表从右往左</span></span><br><span class="line">        reverse = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level_list = []</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤1: 像常规的按层BFS一样，先收集当前层的所有节点值</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level_list.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤2: 根据reverse标记决定是否反转当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span> reverse:</span><br><span class="line">                level_list.reverse()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤3: 将处理好的层列表加入结果，并切换reverse标记</span></span><br><span class="line">            ans.append(level_list)</span><br><span class="line">            reverse = <span class="keyword">not</span> reverse</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：层序遍历 + 交替反转</li>
</ul>
<hr>
<h2 id="题目三：二叉树的最大特殊宽度"><a href="#题目三：二叉树的最大特殊宽度" class="headerlink" title="题目三：二叉树的最大特殊宽度"></a>题目三：二叉树的最大特殊宽度</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树的宽度与满二叉树相同，但不一定是满的。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>给每个节点进行编号，就像在一个完全二叉树中一样。根节点编号为1，其左子节点为 2<em>i，右子节点为 2</em>i + 1。每一层的宽度就等于该层最右边节点的编号减去最左边节点的编号，再加1。</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 核心思想：给每个节点进行编号，就像在一个完全二叉树中一样。</span></span><br><span class="line">    <span class="comment"># 根节点编号为1，其左子节点为 2*i，右子节点为 2*i + 1。</span></span><br><span class="line">    <span class="comment"># 每一层的宽度就等于该层最右边节点的编号减去最左边节点的编号，再加1。</span></span><br><span class="line">    <span class="comment"># 我们使用按层BFS来遍历，同时在队列中存储 (节点, 编号) 对。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 队列中存储 (节点, 节点编号) 的元组</span></span><br><span class="line">    queue = deque([(root, <span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment"># 记录当前层的起始编号</span></span><br><span class="line">        start_id = queue[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node, node_id = queue.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在遍历到当前层最后一个节点时，计算宽度，这个是额外的步骤</span></span><br><span class="line">            <span class="keyword">if</span> i == size - <span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, node_id - start_id + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将子节点及其新编号加入队列</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append((node.left, node_id * <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append((node.right, node_id * <span class="number">2</span> + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：完全二叉树编号规则</li>
</ul>
<hr>
<h2 id="题目四：求二叉树的最大深度、最小深度"><a href="#题目四：求二叉树的最大深度、最小深度" class="headerlink" title="题目四：求二叉树的最大深度、最小深度"></a>题目四：求二叉树的最大深度、最小深度</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li>求二叉树的最大深度</li>
<li>求二叉树的最小深度</li>
</ol>
<p><strong>测试链接</strong>：</p>
<ul>
<li>最大深度：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></li>
<li>最小深度：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></li>
</ul>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><h4 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h4><p>核心思想：递归。一棵树的最大深度等于其左、右子树最大深度中的较大者，再加1（根节点本身）。空树的深度为0，这是递归的基准情况，一定要到叶节点底部。</p>
<h4 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h4><p>递归，但需要特殊处理。最小深度是从根节点到最近的”叶子节点”的路径长度。如果一个节点只有一个子树，那么我们必须沿着这个非空的子树继续寻找叶子节点。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%B1%82%E5%AD%90%E6%A0%91%E6%9C%80%E5%A4%A7or%E5%B0%8F%E6%B7%B1%E5%BA%A6.png" alt="求子树最大or小深度"></p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="最大深度-1"><a href="#最大深度-1" class="headerlink" title="最大深度"></a>最大深度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.maxDepth(root.left), <span class="variable language_">self</span>.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="最小深度-1"><a href="#最小深度-1" class="headerlink" title="最小深度"></a>最小深度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="comment"># 当前的树是空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    left_depth = <span class="variable language_">self</span>.minDepth(root.left)</span><br><span class="line">    right_depth = <span class="variable language_">self</span>.minDepth(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># case 1: 如果左子树或右子树为空，我们不能取它为最小值（因为那条路没有叶子）。</span></span><br><span class="line">    <span class="comment"># 此时必须走另一条非空的路。`left_depth + right_depth + 1` 巧妙地处理了</span></span><br><span class="line">    <span class="comment"># (左=0, 右=N) -&gt; N+1 和 (左=N, 右=0) -&gt; N+1 的情况。</span></span><br><span class="line">    <span class="keyword">if</span> left_depth == <span class="number">0</span> <span class="keyword">or</span> right_depth == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> left_depth + right_depth + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># case 2: 如果左右子树都不为空，那么最小深度就是两者中的较小值加1。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(left_depth, right_depth) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：递归分治</li>
</ul>
<hr>
<h2 id="题目五：二叉树先序序列化和反序列化"><a href="#题目五：二叉树先序序列化和反序列化" class="headerlink" title="题目五：二叉树先序序列化和反序列化"></a>题目五：二叉树先序序列化和反序列化</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个算法来序列化和反序列化二叉树。将树转换为字符串（序列化），再将字符串转换为树（反序列化）。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化与反序列化"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="层序遍历反序列化"></p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>使用先序遍历（根-左-右）将树递归地转换成字符串。空节点用特殊字符’#’表示，节点之间用’,’分隔。</p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>利用先序遍历的顺序，递归地重建树。字符串按’,’分割成列表，然后用一个迭代器顺序消费这些值来构建节点。</p>
<h3 id="重要说明-1"><a href="#重要说明-1" class="headerlink" title="重要说明"></a>重要说明</h3><p>二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，但是<strong>无法通过中序遍历</strong>的方式实现序列化和反序列化，因为不同的两棵树可能得到同样的中序序列。</p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中序遍历的反面例子，比如如下两棵树</span></span><br><span class="line"><span class="comment">#         __2</span></span><br><span class="line"><span class="comment">#        /</span></span><br><span class="line"><span class="comment">#       1</span></span><br><span class="line"><span class="comment">#       和</span></span><br><span class="line"><span class="comment">#       1__</span></span><br><span class="line"><span class="comment">#          \</span></span><br><span class="line"><span class="comment">#           2</span></span><br><span class="line"><span class="comment"># 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交这个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用先序遍历（根-左-右）将树递归地转换成字符串。</span></span><br><span class="line">        <span class="comment"># 空节点用特殊字符&#x27;#&#x27;表示，节点之间用&#x27;,&#x27;分隔。 #叫sharp</span></span><br><span class="line">        res = [] <span class="comment">#res是结果列表result</span></span><br><span class="line">        <span class="variable language_">self</span>._f(root, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, root, res</span>): <span class="comment"># 递归函数求先序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            res.append(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        <span class="variable language_">self</span>._f(root.left, res)</span><br><span class="line">        <span class="variable language_">self</span>._f(root.right, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># 核心思想：利用先序遍历的顺序，递归地重建树。</span></span><br><span class="line">        <span class="comment"># 字符串按&#x27;,&#x27;分割成列表，然后用一个迭代器顺序消费这些值来构建节点。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        vals = <span class="built_in">iter</span>(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._g(vals)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_g</span>(<span class="params">self, vals</span>): <span class="comment"># 递归函数求反序列化</span></span><br><span class="line">        val = <span class="built_in">next</span>(vals) <span class="comment"># 迭代器，next是取下一个值，val是理论上是字符串，next能逐个取值</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先构建根节点，然后递归构建左子树，再递归构建右子树</span></span><br><span class="line">        head = Code05_PreorderSerializeAndDeserialize.TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">        head.left = <span class="variable language_">self</span>._g(vals)</span><br><span class="line">        head.right = <span class="variable language_">self</span>._g(vals)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：先序遍历 + 迭代器</li>
</ul>
<hr>
<h2 id="题目六：二叉树按层序列化和反序列化"><a href="#题目六：二叉树按层序列化和反序列化" class="headerlink" title="题目六：二叉树按层序列化和反序列化"></a>题目六：二叉树按层序列化和反序列化</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用层序遍历的方式实现二叉树的序列化和反序列化。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>使用广度优先搜索（BFS）进行层序遍历。队列中的每个节点，都将其左右子节点（即使是None）的信息加入结果字符串。</p>
<h4 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h4><p>同样使用BFS和队列来重建树。先创建根节点并入队，然后依次出队父节点，并从字符串值列表中读出左右子节点的信息进行构建和连接。</p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交这个类，补点思想即：把所有空节点也序列化/反序列化出来，不遗漏任何节点位置。</span></span><br><span class="line"><span class="comment"># 按层序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用广度优先搜索（BFS）进行层序遍历。</span></span><br><span class="line">        <span class="comment"># 队列中的每个节点，都将其左右子节点（即使是None）的信息加入结果字符串。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>  <span class="comment"># 空树直接返回空字符串</span></span><br><span class="line">        res = []</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                res.append(<span class="built_in">str</span>(cur.val))  <span class="comment"># 记录当前节点值</span></span><br><span class="line">                queue.append(cur.left)    <span class="comment"># 即使是None也加入队列，补点思想</span></span><br><span class="line">                queue.append(cur.right)   <span class="comment"># 即使是None也加入队列，补点思想</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">&quot;#&quot;</span>)  <span class="comment"># 用&#x27;#&#x27;表示空节点，补点思想</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(res)  <span class="comment"># 用逗号连接成字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># 核心思想：同样使用BFS和队列来重建树。</span></span><br><span class="line">        <span class="comment"># 先创建根节点并入队，然后依次出队父节点，并从字符串值列表中读出左右子节点的信息进行构建和连接。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 空字符串返回空树</span></span><br><span class="line">        nodes = data.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># 字符串按逗号分割成列表</span></span><br><span class="line">        root = <span class="variable language_">self</span>.generate(nodes[<span class="number">0</span>])  <span class="comment"># 构建根节点</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        index = <span class="number">1</span>  <span class="comment"># 指向下一个要处理的节点值在nodes中的位置</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            parent = queue.popleft() <span class="comment">#这个循环是按层从顶到下遍历的，parent是父节点</span></span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nodes):</span><br><span class="line">                <span class="comment"># 生成父节点的左孩子，补点思想</span></span><br><span class="line">                parent.left = <span class="variable language_">self</span>.generate(nodes[index])</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nodes):</span><br><span class="line">                <span class="comment"># 生成父节点的右孩子，补点思想</span></span><br><span class="line">                parent.right = <span class="variable language_">self</span>.generate(nodes[index])</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 只将非空子节点入队</span></span><br><span class="line">            <span class="keyword">if</span> parent.left:</span><br><span class="line">                queue.append(parent.left)</span><br><span class="line">            <span class="keyword">if</span> parent.right:</span><br><span class="line">                queue.append(parent.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 空点返回None，补点思想</span></span><br><span class="line">        <span class="keyword">return</span> Code06_LevelorderSerializeAndDeserialize.TreeNode(<span class="built_in">int</span>(val))  <span class="comment"># 普通点返回节点对象</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：层序遍历 + 补点思想</li>
</ul>
<hr>
<h2 id="题目七：利用先序与中序遍历序列构造二叉树"><a href="#题目七：利用先序与中序遍历序列构造二叉树" class="headerlink" title="题目七：利用先序与中序遍历序列构造二叉树"></a>题目七：利用先序与中序遍历序列构造二叉树</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。要求没有重复元素。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%85%88%E5%BA%8F+%E4%B8%AD%E5%BA%8F%E9%87%8D%E6%9E%84%E6%A0%91.png" alt="先序+中序重构树"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%85%88%E5%BA%8F+%E4%B8%AD%E5%BA%8F%E9%87%8D%E6%9E%84%E6%A0%912.png" alt="先序+中序重构树2"></p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p>递归分治。先序遍历的第一个元素是当前子树的根。在中序遍历中找到这个根，其左边的所有元素构成左子树，右边的所有元素构成右子树。根据左子树的元素数量，可以确定先序遍历中左右子树的范围，从而递归构建。</p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交如下的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, pre: <span class="type">List</span>[<span class="built_in">int</span>], tin: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin <span class="keyword">or</span> <span class="built_in">len</span>(pre) != <span class="built_in">len</span>(tin):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 为了快速查找根节点在中序遍历中的位置，预处理成哈希表</span></span><br><span class="line">    in_map = &#123;val: i <span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(tin)&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._f(pre, <span class="number">0</span>, <span class="built_in">len</span>(pre) - <span class="number">1</span>, tin, <span class="number">0</span>, <span class="built_in">len</span>(tin) - <span class="number">1</span>, in_map) <span class="comment">#初始化方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, pre, l1, r1, tin, l2, r2, in_map</span>):</span><br><span class="line">    <span class="keyword">if</span> l1 &gt; r1:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    head = <span class="variable language_">self</span>.TreeNode(pre[l1])</span><br><span class="line">    <span class="keyword">if</span> l1 == r1: <span class="comment"># 如果l1和r1相等，说明只有一个节点，直接返回head</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># k是根节点在中序遍历中的位置</span></span><br><span class="line">    k = in_map[pre[l1]]</span><br><span class="line">    <span class="comment"># 左子树的节点数量</span></span><br><span class="line">    left_size = k - l2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归构建左子树和右子树</span></span><br><span class="line">    <span class="comment"># pre : l1(........)[.......r1] -&gt; l1是根, (l1+1...l1+left_size)是左子树, (...)是右子树</span></span><br><span class="line">    <span class="comment"># in  : (l2......)k[........r2] -&gt; k是根, (l2...k-1)是左子树, [...]是右子树</span></span><br><span class="line">    head.left = <span class="variable language_">self</span>._f(pre, l1 + <span class="number">1</span>, l1 + left_size, tin, l2, k - <span class="number">1</span>, in_map)</span><br><span class="line">    head.right = <span class="variable language_">self</span>._f(pre, l1 + left_size + <span class="number">1</span>, r1, tin, k + <span class="number">1</span>, r2, in_map)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：递归分治 + 哈希表优化</li>
</ul>
<hr>
<h2 id="题目八：验证完全二叉树"><a href="#题目八：验证完全二叉树" class="headerlink" title="题目八：验证完全二叉树"></a>题目八：验证完全二叉树</h2><h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，确定它是否是一个完全二叉树。在一棵完全二叉树中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都要靠左。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">https://leetcode.cn/problems/check-completeness-of-a-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="判断完全二叉树"></p>
<h3 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用BFS进行层序遍历。一棵完全二叉树有两个特点：</p>
<ol>
<li>任何节点不能只有右孩子没有左孩子</li>
<li>在层序遍历中，一旦遇到第一个孩子不双全的节点，之后遇到的所有节点都必须是叶子节点</li>
</ol>
<h3 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交以下的方法，实际上是一个又一个节点的bfs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isCompleteTree</span>(<span class="params">self, h: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> h:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    queue = deque([h])</span><br><span class="line">    <span class="comment"># 是否遇到过左右两个孩子不双全的节点</span></span><br><span class="line">    leaf_stage = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="comment"># case 1: 如果一个节点只有右孩子没有左孩子，必不是完全二叉树</span></span><br><span class="line">        <span class="comment"># case 2: 如果已经遇到了不双全的节点(进入leaf_stage)，后面又出现了孩子节点，也不是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> node.left <span class="keyword">and</span> node.right) <span class="keyword">or</span> \</span><br><span class="line">            (leaf_stage <span class="keyword">and</span> (node.left <span class="keyword">or</span> node.right)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一旦遇到孩子不双全的节点，就进入leaf_stage设为true，下一次循环中进行判断</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            leaf_stage = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：BFS + 状态标记</li>
</ul>
<hr>
<h2 id="题目九：求完全二叉树的节点个数"><a href="#题目九：求完全二叉树的节点个数" class="headerlink" title="题目九：求完全二叉树的节点个数"></a>题目九：求完全二叉树的节点个数</h2><h3 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个完全二叉树，求出该树的节点个数。要求时间复杂度低于O(N)。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9.png" alt="统计完全二叉树节点"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B92.png" alt="统计完全二叉树节点2"></p>
<h3 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h3><p>利用完全二叉树的性质进行优化。对于任意节点，其左子树和右子树中，至少有一个是满二叉树。通过比较左右子树的高度，可以判断出哪个是满二叉树，从而用公式 (2^h - 1) 快速计算其节点数，然后只需递归计算另一半子树。每次递归都会下降一层，所以递归深度最多是 O(logN)，每次调用 _mostLeft 的时间复杂度是 O(logN)，这使得时间复杂度从O(N)降低到O((logN)^2)。</p>
<h3 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, head: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    h = <span class="variable language_">self</span>._mostLeft(head, <span class="number">1</span>)  <span class="comment"># 计算整棵树的高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._f(head, <span class="number">1</span>, h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, cur, level, h</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    cur: 当前来到的节点</span></span><br><span class="line"><span class="string">    level: 当前cur来到的节点在第几层</span></span><br><span class="line"><span class="string">    h: 整棵树的高度</span></span><br><span class="line"><span class="string">    返回: cur这棵子树上有多少节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> level == h: <span class="comment"># base case: 遍历到了最底层</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果右子树的最左路径能到达整棵树的最后一层</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._mostLeft(cur.right, level + <span class="number">1</span>) == h:</span><br><span class="line">        <span class="comment"># 说明cur的左子树是满二叉树，其节点数可以直接计算</span></span><br><span class="line">        <span class="comment"># 节点总数 = 左子树节点数(2^(h-level)-1) + 根节点(1) + 递归求右子树节点数</span></span><br><span class="line">        <span class="comment"># 合并后就是 (1 &lt;&lt; (h - level)) + 递归求右子树</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level)) + <span class="variable language_">self</span>._f(cur.right, level + <span class="number">1</span>, h) <span class="comment">#1 &lt;&lt; n 表示将数字1向左移动n位</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#if else判断往左递归还是往右递归</span></span><br><span class="line">        <span class="comment"># 否则，说明cur的右子树是比左子树少一层的满二叉树</span></span><br><span class="line">        <span class="comment"># 节点总数 = 右子树节点数(2^(h-level-1)-1) + 根节点(1) + 递归求左子树节点数</span></span><br><span class="line">        <span class="comment"># 合并后就是 (1 &lt;&lt; (h - level - 1)) + 递归求左子树</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level - <span class="number">1</span>)) + <span class="variable language_">self</span>._f(cur.left, level + <span class="number">1</span>, h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_mostLeft</span>(<span class="params">self, cur, level</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    当前节点是cur，并且它在level层</span></span><br><span class="line"><span class="string">    返回从cur开始不停往左，能扎到几层</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">        cur = cur.left</span><br><span class="line">    <span class="keyword">return</span> level - <span class="number">1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O((logN)²)</li>
<li><strong>空间复杂度</strong>：O(logN)</li>
<li><strong>核心技巧</strong>：完全二叉树性质 + 满二叉树公式</li>
</ul>
<hr>
<h2 id="核心技巧总结"><a href="#核心技巧总结" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-BFS层序遍历"><a href="#1-BFS层序遍历" class="headerlink" title="1. BFS层序遍历"></a>1. BFS层序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准BFS模板</span></span><br><span class="line">queue = deque([root])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    size = <span class="built_in">len</span>(queue)  <span class="comment"># 当前层节点数</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):  <span class="comment"># 处理当前层</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="comment"># 处理当前节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br></pre></td></tr></table></figure>

<h3 id="2-树的递归"><a href="#2-树的递归" class="headerlink" title="2. 树的递归"></a>2. 树的递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 处理当前节点</span></span><br><span class="line">    traverse(root.left)   <span class="comment"># 递归左子树</span></span><br><span class="line">    traverse(root.right)  <span class="comment"># 递归右子树</span></span><br></pre></td></tr></table></figure>

<h3 id="3-完全二叉树编号"><a href="#3-完全二叉树编号" class="headerlink" title="3. 完全二叉树编号"></a>3. 完全二叉树编号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根节点编号为1</span></span><br><span class="line"><span class="comment"># 左子节点编号为 2*i</span></span><br><span class="line"><span class="comment"># 右子节点编号为 2*i + 1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-序列化技巧"><a href="#4-序列化技巧" class="headerlink" title="4. 序列化技巧"></a>4. 序列化技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先序序列化：根-左-右</span></span><br><span class="line"><span class="comment"># 层序序列化：逐层BFS + 补点</span></span><br><span class="line"><span class="comment"># 中序无法唯一确定树结构</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心算法</th>
</tr>
</thead>
<tbody><tr>
<td>层序遍历</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS</td>
</tr>
<tr>
<td>锯齿形遍历</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 反转</td>
</tr>
<tr>
<td>最大宽度</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 编号</td>
</tr>
<tr>
<td>最大&#x2F;最小深度</td>
<td>O(N)</td>
<td>O(H)</td>
<td>递归</td>
</tr>
<tr>
<td>先序序列化</td>
<td>O(N)</td>
<td>O(N)</td>
<td>递归 + 迭代器</td>
</tr>
<tr>
<td>层序序列化</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 补点</td>
</tr>
<tr>
<td>构造二叉树</td>
<td>O(N)</td>
<td>O(N)</td>
<td>递归 + 哈希表</td>
</tr>
<tr>
<td>验证完全二叉树</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 状态</td>
</tr>
<tr>
<td>完全二叉树节点数</td>
<td>O((logN)²)</td>
<td>O(logN)</td>
<td>递归 + 性质</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>掌握BFS和DFS</strong>：这是处理树问题的两大基本方法</p>
</li>
<li><p><strong>理解递归本质</strong>：树的递归结构使得很多问题都可以用递归解决</p>
</li>
<li><p><strong>灵活运用数据结构</strong>：</p>
<ul>
<li>队列（BFS）</li>
<li>哈希表（快速查找）</li>
<li>迭代器（序列化处理）</li>
</ul>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空树处理</li>
<li>叶子节点判断</li>
<li>层级边界</li>
</ul>
</li>
<li><p><strong>理解树的性质</strong>：</p>
<ul>
<li>完全二叉树的特点</li>
<li>满二叉树的节点公式</li>
<li>不同遍历方式的特点</li>
</ul>
</li>
<li><p><strong>练习组合技巧</strong>：很多树的问题需要组合多种基础算法</p>
</li>
</ol>
<p>通过掌握这些经典的二叉树算法，可以为后续学习更复杂的树型动态规划和高级树结构打下坚实的基础。</p>
<h1 id="037【必备】二叉树高频题目-下-不含树型dp"><a href="#037【必备】二叉树高频题目-下-不含树型dp" class="headerlink" title="037【必备】二叉树高频题目-下-不含树型dp"></a>037【必备】二叉树高频题目-下-不含树型dp</h1><h2 id="初始化的二叉树类-1"><a href="#初始化的二叉树类-1" class="headerlink" title="初始化的二叉树类"></a>初始化的二叉树类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br></pre></td></tr></table></figure>

<h2 id="题目一：普通二叉树上寻找两个节点的最近公共祖先"><a href="#题目一：普通二叉树上寻找两个节点的最近公共祖先" class="headerlink" title="题目一：普通二叉树上寻找两个节点的最近公共祖先"></a>题目一：普通二叉树上寻找两个节点的最近公共祖先</h2><h3 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88.png" alt="普通二叉树查找最近共同祖先"></p>
<h3 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h3><p>采用递归的方式深度优先搜索：</p>
<ol>
<li>如果当前节点为空，或者等于p或q中的一个，那么它本身就是其子树中p或q的LCA</li>
<li>否则，递归地在左子树和右子树中寻找p和q</li>
<li>如果左右子树都返回了非空节点，说明p和q分别位于当前节点的两侧，当前节点就是LCA</li>
<li>如果只有一个子树返回了非空节点，说明p和q都在那个子树中，返回那个非空节点即可</li>
<li>如果左右子树都返回空，说明p和q都不在此子树中。</li>
</ol>
<h3 id="算法实现-9"><a href="#算法实现-9" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        寻找最近公共祖先的核心函数</span></span><br><span class="line"><span class="string">        采用递归的方式深度优先搜索</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遇到空，或者p，或者q，直接返回</span></span><br><span class="line">        <span class="comment"># 这是递归的基准情况 (base case)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="comment"># 如果root不空的话，这样从下往上会一直传p或者q</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在左子树和右子树中递归查找 p 和 q</span></span><br><span class="line">        l = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        r = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左树也搜到，右树也搜到，返回root</span></span><br><span class="line">        <span class="comment"># 这意味着p和q分别在root的左右两侧，root是它们的LCA</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> r:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果左右子树的搜索结果都为空，说明p,q不在此子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># l和r一个为空，一个不为空</span></span><br><span class="line">        <span class="comment"># 返回不空的那个，这个非空节点要么是p或q本身，要么已经是p和q的LCA</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> l <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，最坏情况下需要遍历所有节点</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度，递归栈的深度</li>
<li><strong>核心技巧</strong>：递归 + 分情况讨论</li>
</ul>
<hr>
<h2 id="题目二：搜索二叉树上寻找两个节点的最近公共祖先"><a href="#题目二：搜索二叉树上寻找两个节点的最近公共祖先" class="headerlink" title="题目二：搜索二叉树上寻找两个节点的最近公共祖先"></a>题目二：搜索二叉树上寻找两个节点的最近公共祖先</h2><h3 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88.png" alt="搜索二叉树查找最近共同祖先"></p>
<h3 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h3><p>利用BST的特性，可以高效地进行迭代查找：</p>
<ol>
<li>从根节点开始遍历</li>
<li>如果p和q的值都小于当前节点的值，说明LCA必定在左子树，往左走</li>
<li>如果p和q的值都大于当前节点的值，说明LCA必定在右子树，往右走</li>
<li>如果当前节点的值在p和q的值之间（或者等于其中一个），那么当前节点就是第一个”分叉点”，即为LCA</li>
</ol>
<h3 id="算法实现-10"><a href="#算法实现-10" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在二叉搜索树(BST)中寻找最近公共祖先</span></span><br><span class="line"><span class="string">        利用BST的特性，可以高效地进行迭代查找</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定p和q节点值的范围</span></span><br><span class="line">        min_val = <span class="built_in">min</span>(p.val, q.val)</span><br><span class="line">        max_val = <span class="built_in">max</span>(p.val, q.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历，直到找到LCA</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="comment"># 如果当前节点的值大于p和q的最大值，说明LCA在左子树</span></span><br><span class="line">            <span class="keyword">if</span> root.val &gt; max_val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="comment"># 如果当前节点的值小于p和q的最小值，说明LCA在右子树</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; min_val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="comment"># 否则，当前节点的值在[min_val, max_val]之间，它就是LCA</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 理论上在有效输入下不会到达这里</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-10"><a href="#算法分析-10" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：利用BST性质 + 迭代</li>
</ul>
<hr>
<h2 id="题目三：收集累加和等于aim的所有路径"><a href="#题目三：收集累加和等于aim的所有路径" class="headerlink" title="题目三：收集累加和等于aim的所有路径"></a>题目三：收集累加和等于aim的所有路径</h2><h3 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，返回所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/dfs%E5%9B%9E%E6%BA%AF%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="dfs回溯的概念"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/dfs%E5%9B%9E%E6%BA%AF%E7%9A%84%E6%A6%82%E5%BF%B52.png" alt="dfs回溯的概念2"></p>
<h3 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用DFS + 回溯的方法：</p>
<ol>
<li>维护一个当前路径 <code>path</code> 和当前路径和 <code>current_sum</code></li>
<li>深入遍历树，每经过一个节点，就将其加入 <code>path</code>，并更新 <code>current_sum</code></li>
<li>当到达一个叶子节点时，检查 <code>current_sum + cur.val</code>是否等于目标值，如果是，将当前路径（包括叶子节点）的一个副本添加到最终结果 <code>ans</code> 中</li>
<li>遍历完一个节点的所有子树后，需要回溯，即将该节点从 <code>path</code> 中移除，以便返回到父节点继续搜索其他分支</li>
</ol>
<h3 id="算法实现-11"><a href="#算法实现-11" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化结果列表和路径列表，并启动递归搜索</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            path = []</span><br><span class="line">            <span class="comment"># 调用递归辅助函数 f</span></span><br><span class="line">            <span class="variable language_">self</span>.f(root, targetSum, <span class="number">0</span>, path, ans) <span class="comment"># 一开始sum=0，ans也是空列表，path也是空列表</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, cur: TreeNode, aim: <span class="built_in">int</span>, current_sum: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">int</span>], ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归辅助函数，用于深度优先搜索所有路径</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前节点值加入路径</span></span><br><span class="line">        path.append(cur.val) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否为叶节点</span></span><br><span class="line">        is_leaf = cur.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="literal">None</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> is_leaf:</span><br><span class="line">            <span class="comment"># 叶节点</span></span><br><span class="line">            <span class="comment"># 如果当前路径和加上叶节点的值等于目标值，则找到一个有效路径</span></span><br><span class="line">            <span class="keyword">if</span> current_sum + cur.val == aim: </span><br><span class="line">                <span class="comment"># 将路径的副本添加到结果中</span></span><br><span class="line">                <span class="comment"># 必须是副本(path[:])，否则后续的回溯操作会影响已存入的结果</span></span><br><span class="line">                ans.append(path[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是叶节点</span></span><br><span class="line">            <span class="comment"># 递归探索左子树</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                <span class="variable language_">self</span>.f(cur.left, aim, current_sum + cur.val, path, ans)</span><br><span class="line">            <span class="comment"># 递归探索右子树</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                <span class="variable language_">self</span>.f(cur.right, aim, current_sum + cur.val, path, ans)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 回溯步骤：当一个节点的左右子树都探索完毕后，</span></span><br><span class="line">        <span class="comment"># 将该节点从当前路径中移除，返回到其父节点的递归调用中。</span></span><br><span class="line">        path.pop() <span class="comment"># 用 path.pop() 把刚才加入的那个节点移除，恢复到进入递归前的状态</span></span><br></pre></td></tr></table></figure>

<h3 id="回溯不会死循环的原因"><a href="#回溯不会死循环的原因" class="headerlink" title="回溯不会死循环的原因"></a>回溯不会死循环的原因</h3><ol>
<li><strong>控制流是”递归调用”不是”循环依赖”</strong>：每次调用只会递归左子树、右子树各最多一次</li>
<li><strong>for&#x2F;if 的次数是固定的</strong>：子树递归只发生在固定的分支中，不会因为pop重复触发</li>
<li><strong>pop 只是在撤销路径，不改变遍历指针</strong>：pop 修改的是 path 内容，用于恢复现场；并不改变 cur、cur.left、cur.right 的结构或递归栈帧。可以把它看作：DFS 到底（或到叶&#x2F;路尽）后，撤销上一步选择，然后走兄弟分支；兄弟分支走完，再撤销并上返……直到根。整个过程单调“回退”栈帧，不可能形成死循环。这个调用栈帧的所有工作（检查&#x2F;递归左右）都完成了，撤销现场后，自然结束返回到父调用。</li>
</ol>
<h3 id="算法分析-11"><a href="#算法分析-11" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N²)，最坏情况下每条路径都需要复制</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：DFS + 回溯 + 路径复制</li>
</ul>
<hr>
<h2 id="题目四：验证平衡二叉树"><a href="#题目四：验证平衡二叉树" class="headerlink" title="题目四：验证平衡二叉树"></a>题目四：验证平衡二叉树</h2><h3 id="问题描述-12"><a href="#问题描述-12" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。一个高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5.png" alt="平衡二叉树概念"></p>
<h3 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用后序遍历的思想：</p>
<ol>
<li>要判断当前节点是否平衡，需要先知道其左右子树的高度</li>
<li>这天然地符合后序遍历的顺序（先左、再右、后根）</li>
<li>递归地计算左子树和右子树的高度</li>
<li>在计算完左右子树高度后，检查它们的高度差</li>
<li>使用一个实例变量来记录是否已发现不平衡，一旦发现不平衡，就将此标志设为False，后续的递归调用可以提前终止。</li>
</ol>
<h3 id="算法实现-12"><a href="#算法实现-12" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># balance是实例变量，用于在递归调用中共享状态，所以能够实现全局变量的效果</span></span><br><span class="line">        <span class="comment"># 每次判断开始时，在主函数中将其重置为true</span></span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，用于启动平衡性检查</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 重置平衡标志</span></span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 调用递归函数计算高度并检查平衡性</span></span><br><span class="line">        <span class="variable language_">self</span>.height(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.balance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, cur: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归计算节点高度，并在此过程中检查平衡性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 核心思想（后序遍历）：</span></span><br><span class="line">        <span class="comment"># 1. 要判断当前节点是否平衡，需要先知道其左右子树的高度。</span></span><br><span class="line">        <span class="comment"># 2. 这天然地符合后序遍历的顺序（先左、再右、后根）。</span></span><br><span class="line">        <span class="comment"># 3. 递归地计算左子树和右子树的高度。</span></span><br><span class="line">        <span class="comment"># 4. 在计算完左右子树高度后，检查它们的高度差。如果差值大于1，说明树不平衡。</span></span><br><span class="line">        <span class="comment"># 5. 使用一个全局或实例变量 `self.balance` 来记录是否已发现不平衡。</span></span><br><span class="line">        <span class="comment">#    一旦发现不平衡，就将此标志设为False，后续的递归调用可以提前终止。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一旦发现不平衡，或者当前节点为空，返回0，后续计算已无意义或到达递归边界</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.balance <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归计算左子树的高度</span></span><br><span class="line">        lh = <span class="variable language_">self</span>.height(cur.left)</span><br><span class="line">        <span class="comment"># 递归计算右子树的高度</span></span><br><span class="line">        rh = <span class="variable language_">self</span>.height(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查左右子树的高度差</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(lh - rh) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果高度差大于1，则标记为不平衡</span></span><br><span class="line">            <span class="variable language_">self</span>.balance = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回当前节点的高度，即左右子树中较高者的高度加1</span></span><br><span class="line">        <span class="comment"># 叶子节点的高度为 1，因为它的左右子树高度都是 0，返回 max(0, 0) + 1 = 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lh, rh) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-12"><a href="#算法分析-12" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：后序遍历 + 全局状态</li>
</ul>
<hr>
<h2 id="题目五：验证搜索二叉树"><a href="#题目五：验证搜索二叉树" class="headerlink" title="题目五：验证搜索二叉树"></a>题目五：验证搜索二叉树</h2><h3 id="问题描述-13"><a href="#问题描述-13" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%88%A4%E6%96%AD%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%96%B9%E6%B3%951.png" alt="判断搜索二叉树方法1"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%88%A4%E6%96%AD%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%96%B9%E6%B3%952.png" alt="判断搜索二叉树方法2"></p>
<h3 id="核心思想-13"><a href="#核心思想-13" class="headerlink" title="核心思想"></a>核心思想</h3><p>有两种实现方法：</p>
<h4 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h4><p>一个有效的BST，其中序遍历的结果必然是一个严格递增的序列。</p>
<h4 id="方法二：递归验证"><a href="#方法二：递归验证" class="headerlink" title="方法二：递归验证"></a>方法二：递归验证</h4><p>对任意一个节点，它必须满足：</p>
<ol>
<li>它的左子树是BST，且左子树所有节点的值都小于它自身的值</li>
<li>它的右子树是BST，且右子树所有节点的值都大于它自身的值</li>
</ol>
<h3 id="算法实现-13"><a href="#算法实现-13" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：迭代实现的中序遍历"><a href="#方法一：迭代实现的中序遍历" class="headerlink" title="方法一：迭代实现的中序遍历"></a>方法一：迭代实现的中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST1</span>(<span class="params">self, head: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过迭代方式进行中序遍历来验证BST。</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    一个有效的BST，其中序遍历的结果必然是一个严格递增的序列。</span></span><br><span class="line"><span class="string">    因此，我们可以在遍历过程中，持续比较当前节点的值和前一个节点的值。</span></span><br><span class="line"><span class="string">    如果发现当前节点值小于或等于前一个节点值，那么它就不是一个BST。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    stack = []</span><br><span class="line">    pre_node = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用cur指针和栈来模拟递归的中序遍历</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            <span class="comment"># 一直向左，将路径上的节点入栈</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 左边到头了，从栈中弹出一个节点，这个就是中序遍历的当前节点</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查中序遍历的有序性，pre_node是当前节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> pre_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> pre_node.val &gt;= cur.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新前一个节点，然后转向右子树</span></span><br><span class="line">            pre_node = cur</span><br><span class="line">            cur = cur.right</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二：递归实现"><a href="#方法二：递归实现" class="headerlink" title="方法二：递归实现"></a>方法二：递归实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 实例变量，用于在递归调用中传递子树的最小值和最大值</span></span><br><span class="line">    <span class="variable language_">self</span>.min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST2</span>(<span class="params">self, head: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过递归方式验证BST。</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    对任意一个节点，它必须满足：</span></span><br><span class="line"><span class="string">    1. 它的左子树是BST，且左子树所有节点的值都小于它自身的值。</span></span><br><span class="line"><span class="string">    2. 它的右子树是BST，且右子树所有节点的值都大于它自身的值。</span></span><br><span class="line"><span class="string">    这个过程可以通过后序遍历，在返回时收集子树的信息（是否为BST，最大值，最小值）来完成。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Base case是 head is None，即空树的情况，</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 基准情况：空树是有效的BST</span></span><br><span class="line">        <span class="comment"># 初始化min和max，确保不影响上层计算</span></span><br><span class="line">        <span class="variable language_">self</span>.min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归检查左子树是不是有效的BST</span></span><br><span class="line">    is_left_ok = <span class="variable language_">self</span>.isValidBST2(head.left)</span><br><span class="line">    l_min = <span class="variable language_">self</span>.min_val  <span class="comment"># 保存左子树的最小值</span></span><br><span class="line">    l_max = <span class="variable language_">self</span>.max_val  <span class="comment"># 保存左子树的最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归检查右子树是不是有效的BST</span></span><br><span class="line">    is_right_ok = <span class="variable language_">self</span>.isValidBST2(head.right)</span><br><span class="line">    r_min = <span class="variable language_">self</span>.min_val</span><br><span class="line">    r_max = <span class="variable language_">self</span>.max_val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新当前树的min和max值</span></span><br><span class="line">    <span class="variable language_">self</span>.min_val = <span class="built_in">min</span>(l_min, r_min, head.val)</span><br><span class="line">    <span class="variable language_">self</span>.max_val = <span class="built_in">max</span>(l_max, r_max, head.val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 综合判断当前节点是否满足BST的条件</span></span><br><span class="line">    <span class="comment"># 1. 左右子树本身都是BST (is_left_ok and is_right_ok)</span></span><br><span class="line">    <span class="comment"># 2. 左子树的最大值必须小于当前节点值 (l_max &lt; head.val)</span></span><br><span class="line">    <span class="comment"># 3. 右子树的最小值必须大于当前节点值 (head.val &lt; r_min)</span></span><br><span class="line">    <span class="keyword">return</span> is_left_ok <span class="keyword">and</span> is_right_ok <span class="keyword">and</span> l_max &lt; head.val <span class="keyword">and</span> head.val &lt; r_min</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-13"><a href="#算法分析-13" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：中序遍历有序性 &#x2F; 递归验证BST性质</li>
</ul>
<hr>
<h2 id="题目六：修剪搜索二叉树"><a href="#题目六：修剪搜索二叉树" class="headerlink" title="题目六：修剪搜索二叉树"></a>题目六：修剪搜索二叉树</h2><h3 id="问题描述-14"><a href="#问题描述-14" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">https://leetcode.cn/problems/trim-a-binary-search-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E4%BF%AE%E5%89%AA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="修剪搜索二叉树"></p>
<h3 id="核心思想-14"><a href="#核心思想-14" class="headerlink" title="核心思想"></a>核心思想</h3><p>利用BST的性质进行递归：</p>
<ol>
<li>如果 <code>cur.val &lt; low</code>，那么 <code>cur</code> 和它的整个左子树都应该被删除，修剪后的树必定在右子树中</li>
<li>如果 <code>cur.val &gt; high</code>，那么 <code>cur</code> 和它的整个右子树都应该被删除，修剪后的树必定在左子树中</li>
<li>如果 <code>low &lt;= cur.val &lt;= high</code>，那么当前节点应该被保留，继续递归地修剪左右子树</li>
</ol>
<h3 id="算法实现-14"><a href="#算法实现-14" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, cur: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归地修剪二叉搜索树。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        利用BST的性质进行递归。对于当前节点 `cur`：</span></span><br><span class="line"><span class="string">        1. 如果 `cur.val &lt; low`，那么 `cur` 和它的整个左子树都应该被删除。</span></span><br><span class="line"><span class="string">           修剪后的树必定在 `cur` 的右子树中，因此我们返回对右子树的修剪结果。</span></span><br><span class="line"><span class="string">        2. 如果 `cur.val &gt; high`，那么 `cur` 和它的整个右子树都应该被删除。</span></span><br><span class="line"><span class="string">           修剪后的树必定在 `cur` 的左子树中，因此我们返回对左子树的修剪结果。</span></span><br><span class="line"><span class="string">        3. 如果 `low &lt;= cur.val &lt;= high`，那么 `cur` 节点应该被保留。</span></span><br><span class="line"><span class="string">           我们继续递归地修剪它的左子树和右子树，并将返回的结果作为 `cur` 新的左、右孩子。</span></span><br><span class="line"><span class="string">           最后返回 `cur` 本身。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case是 cur is None，即空树的情况，返回None</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点值太小，应该在右子树中寻找有效部分</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; low:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.trimBST(cur.right, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点值太大，应该在左子树中寻找有效部分</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; high:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.trimBST(cur.left, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点在 [low, high] 范围内，保留该节点</span></span><br><span class="line">        <span class="comment"># 然后递归地处理它的左子树和右子树</span></span><br><span class="line">        cur.left = <span class="variable language_">self</span>.trimBST(cur.left, low, high)</span><br><span class="line">        cur.right = <span class="variable language_">self</span>.trimBST(cur.right, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回处理后的当前节点</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-14"><a href="#算法分析-14" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，最坏情况下访问所有节点</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：利用BST性质 + 递归修剪</li>
</ul>
<hr>
<h2 id="题目七：二叉树打家劫舍问题"><a href="#题目七：二叉树打家劫舍问题" class="headerlink" title="题目七：二叉树打家劫舍问题"></a>题目七：二叉树打家劫舍问题</h2><h3 id="问题描述-15"><a href="#问题描述-15" class="headerlink" title="问题描述"></a>问题描述</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为”根”。除了”根”之外，每栋房子有且只有一个”父”房子与之相连。一番侦察之后，聪明的小偷意识到”这个地方的所有房屋的排列类似于一棵二叉树”。如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的前提下，小偷一晚能够盗取的最高金额。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98.png" alt="打家劫舍问题"></p>
<h3 id="核心思想-15"><a href="#核心思想-15" class="headerlink" title="核心思想"></a>核心思想</h3><p>树形DP问题。对于任意一个节点，我们考虑两种情况：</p>
<ol>
<li>偷当前节点：那么它的左右孩子节点都不能偷</li>
<li>不偷当前节点：那么它的左右孩子可以偷也可以不偷，取两者中的较大值</li>
</ol>
<p>通过后序遍历，我们可以先计算出左右子树的结果，再用来推导当前节点的结果。</p>
<h3 id="算法实现-15"><a href="#算法实现-15" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 实例变量，用于在递归中保存子问题的解</span></span><br><span class="line">        <span class="comment"># yes: 表示在X子树中，偷头节点的情况下能获得的最大收益</span></span><br><span class="line">        <span class="comment"># no: 表示在X子树中，不偷头节点的情况下能获得的最大收益</span></span><br><span class="line">        <span class="variable language_">self</span>.yes = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.no = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，启动递归计算</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.f(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.yes, <span class="variable language_">self</span>.no)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，采用后序遍历计算以root为根的子树的打劫收益</span></span><br><span class="line"><span class="string">        核心思想 (树形DP):</span></span><br><span class="line"><span class="string">        对于任意一个节点 `root`，我们考虑两种情况：</span></span><br><span class="line"><span class="string">        1. 偷 `root` 节点：那么它的左右孩子节点都不能偷。</span></span><br><span class="line"><span class="string">           最大收益 = `root.val` + 左子树不偷的最大收益 + 右子树不偷的最大收益。</span></span><br><span class="line"><span class="string">        2. 不偷 `root` 节点：那么它的左右孩子可以偷也可以不偷，取两者中的较大值。</span></span><br><span class="line"><span class="string">           最大收益 = max(偷左孩子，不偷左孩子) + max(偷右孩子，不偷右孩子)。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        通过后序遍历，我们可以先计算出左右子树的结果，再用来推导当前节点的结果。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 基准情况：空节点收益为0</span></span><br><span class="line">            <span class="variable language_">self</span>.yes = <span class="number">0</span></span><br><span class="line">            <span class="variable language_">self</span>.no = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 暂存当前节点的收益</span></span><br><span class="line">        current_yes = root.val</span><br><span class="line">        current_no = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先递归处理左子树，再处理右子树</span></span><br><span class="line">        <span class="variable language_">self</span>.f(root.left)</span><br><span class="line">        <span class="comment"># 此时 self.yes 和 self.no 是左子树的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新当前节点的收益：</span></span><br><span class="line">        <span class="comment"># 如果偷当前节点，则不能偷左孩子，所以加上左子树不偷的收益 no</span></span><br><span class="line">        current_yes += <span class="variable language_">self</span>.no </span><br><span class="line">        <span class="comment"># 如果不偷当前节点，则左孩子可偷可不偷，取最大值</span></span><br><span class="line">        current_no += <span class="built_in">max</span>(<span class="variable language_">self</span>.yes, <span class="variable language_">self</span>.no)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归处理右子树</span></span><br><span class="line">        <span class="variable language_">self</span>.f(root.right)</span><br><span class="line">        <span class="comment"># 此时 self.yes 和 self.no 是右子树的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再次更新当前节点的收益：</span></span><br><span class="line">        <span class="comment"># 加上右子树的贡献</span></span><br><span class="line">        current_yes += <span class="variable language_">self</span>.no</span><br><span class="line">        current_no += <span class="built_in">max</span>(<span class="variable language_">self</span>.yes, <span class="variable language_">self</span>.no)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将最终计算出的当前节点的结果，存回实例变量，供上层调用使用</span></span><br><span class="line">        <span class="variable language_">self</span>.yes = current_yes</span><br><span class="line">        <span class="variable language_">self</span>.no = current_no</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-15"><a href="#算法分析-15" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：树形DP + 后序遍历</li>
</ul>
<hr>
<h2 id="核心技巧总结-1"><a href="#核心技巧总结-1" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-LCA问题模板"><a href="#1-LCA问题模板" class="headerlink" title="1. LCA问题模板"></a>1. LCA问题模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>

<h3 id="2-路径搜索-回溯模板"><a href="#2-路径搜索-回溯模板" class="headerlink" title="2. 路径搜索 + 回溯模板"></a>2. 路径搜索 + 回溯模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, path, target</span>):</span><br><span class="line">    path.append(node.val)  <span class="comment"># 选择</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> is_leaf(node):</span><br><span class="line">        <span class="keyword">if</span> meets_condition():</span><br><span class="line">            result.append(path[:])  <span class="comment"># 记录答案</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(node.left, path, target)   <span class="comment"># 递归</span></span><br><span class="line">        dfs(node.right, path, target)  <span class="comment"># 递归</span></span><br><span class="line">    </span><br><span class="line">    path.pop()  <span class="comment"># 撤销选择（回溯）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-BST性质利用"><a href="#3-BST性质利用" class="headerlink" title="3. BST性质利用"></a>3. BST性质利用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BST中序遍历是有序的</span></span><br><span class="line"><span class="comment"># BST搜索可以利用大小关系剪枝</span></span><br><span class="line"><span class="comment"># BST的LCA在分叉点</span></span><br></pre></td></tr></table></figure>

<h3 id="4-树形DP模板"><a href="#4-树形DP模板" class="headerlink" title="4. 树形DP模板"></a>4. 树形DP模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_dp</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> base_case</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 后序遍历：先处理子树</span></span><br><span class="line">    left_result = tree_dp(node.left)</span><br><span class="line">    right_result = tree_dp(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据子树结果计算当前节点结果</span></span><br><span class="line">    current_result = combine(node.val, left_result, right_result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> current_result</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结-1"><a href="#复杂度分析总结-1" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心算法</th>
</tr>
</thead>
<tbody><tr>
<td>普通二叉树LCA</td>
<td>O(N)</td>
<td>O(H)</td>
<td>递归DFS</td>
</tr>
<tr>
<td>BST的LCA</td>
<td>O(H)</td>
<td>O(1)</td>
<td>利用BST性质</td>
</tr>
<tr>
<td>路径和问题</td>
<td>O(N²)</td>
<td>O(H)</td>
<td>DFS + 回溯</td>
</tr>
<tr>
<td>验证平衡二叉树</td>
<td>O(N)</td>
<td>O(H)</td>
<td>后序遍历</td>
</tr>
<tr>
<td>验证BST</td>
<td>O(N)</td>
<td>O(H)</td>
<td>中序遍历&#x2F;递归</td>
</tr>
<tr>
<td>修剪BST</td>
<td>O(N)</td>
<td>O(H)</td>
<td>递归修剪</td>
</tr>
<tr>
<td>打家劫舍III</td>
<td>O(N)</td>
<td>O(H)</td>
<td>树形DP</td>
</tr>
</tbody></table>
<h2 id="学习建议-1"><a href="#学习建议-1" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>掌握LCA问题</strong>：这是树算法中的经典问题，有多种解法和应用</p>
</li>
<li><p><strong>理解BST性质</strong>：</p>
<ul>
<li>中序遍历有序</li>
<li>可以利用大小关系进行搜索优化</li>
<li>左子树 &lt; 根 &lt; 右子树</li>
</ul>
</li>
<li><p><strong>掌握回溯模板</strong>：</p>
<ul>
<li>做选择 → 递归 → 撤销选择</li>
<li>注意保存结果时要使用副本</li>
</ul>
</li>
<li><p><strong>理解树形DP</strong>：</p>
<ul>
<li>后序遍历获取子树信息</li>
<li>根据子树状态计算当前状态</li>
<li>状态定义要考虑所有可能情况</li>
</ul>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空节点处理</li>
<li>叶子节点判断</li>
<li>单节点情况</li>
</ul>
</li>
<li><p><strong>练习状态管理</strong>：</p>
<ul>
<li>实例变量在递归中的使用</li>
<li>多个状态的传递和更新</li>
</ul>
</li>
</ol>
<p>通过掌握这些经典的二叉树问题，可以深入理解树的递归性质，为学习更高级的树算法和动态规划打下基础。这些问题模式在实际编程中经常出现，是算法面试的重点内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（13）- 数据结构设计高频题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-20 10:30:00 / Modified: 13:39:16" itemprop="dateCreated datePublished" datetime="2025-08-20T10:30:00+08:00">2025-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class035的内容，总结了数据结构设计类题目的高频考点，包含7道经典数据结构设计题目的详细解析。这些题目主要基于哈希表的O(1)操作时间复杂度特性。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习数据结构设计高频题之前，需要掌握以下基础知识：</p>
<ul>
<li>动态数组和扩容分析（007讲）</li>
<li>链表入门内容（009~012讲）</li>
<li>堆结构（025讲）</li>
<li>哈希表、有序表、比较器的使用（026讲）</li>
</ul>
<h2 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h2><p>本节以数据结构设计高频题为主，并不涉及太难的数据结构设计题目，很多题的原理都是基于哈希表的O(1)时间复杂度。数据结构设计的更难题目，需要学习更多数据结构之后才能解决，如前缀树、并查集、线段树等。</p>
<h1 id="035【必备】数据结构设计高频题"><a href="#035【必备】数据结构设计高频题" class="headerlink" title="035【必备】数据结构设计高频题"></a>035【必备】数据结构设计高频题</h1><h2 id="题目一：setAll功能的哈希表"><a href="#题目一：setAll功能的哈希表" class="headerlink" title="题目一：setAll功能的哈希表"></a>题目一：setAll功能的哈希表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>哈希表常见的三个操作是put、get和containsKey，而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是把所有记录value都设成统一的值。请设计并实现这种有setAll功能的哈希表，并且put、get、containsKey和setAll四个操作的时间复杂度都为O(1)。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967">https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>采用”懒更新”(Lazy Update)策略，setAll操作只记录一个全局值和当前时间戳，并不实际修改数据。当get一个键时，通过比较该键自身的时间戳和全局setAll的时间戳，来实时决定返回它自己的值还是全局的值。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/%E4%B8%BAhash%E8%A1%A8%E8%AE%BE%E7%BD%AEsetall%E6%96%B9%E6%B3%95.png" alt="为hash表设置setall方法"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetAllHashMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心数据结构，存储键和它对应的值与时间戳</span></span><br><span class="line">        <span class="comment"># 格式为: &#123; key: [value, time] &#125;</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        <span class="comment"># setAll操作设定的统一值</span></span><br><span class="line">        <span class="variable language_">self</span>.set_all_value = <span class="number">0</span></span><br><span class="line">        <span class="comment"># setAll操作发生的时间戳</span></span><br><span class="line">        <span class="variable language_">self</span>.set_all_time = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 全局时间戳，用于记录每次操作的顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, k, v</span>):</span><br><span class="line">        <span class="comment"># 核心思想：为每个put操作记录一个独立的时间戳</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="comment"># 如果键已存在，更新其值和时间戳</span></span><br><span class="line">            value = <span class="variable language_">self</span>.<span class="built_in">map</span>[k]</span><br><span class="line">            value[<span class="number">0</span>] = v</span><br><span class="line">            value[<span class="number">1</span>] = <span class="variable language_">self</span>.cnt</span><br><span class="line">            <span class="variable language_">self</span>.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果键不存在，创建新的条目</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[k] = [v, <span class="variable language_">self</span>.cnt]</span><br><span class="line">            <span class="variable language_">self</span>.cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_all</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="comment"># 核心思想：只记录setAll的值和时间戳，不实际遍历map</span></span><br><span class="line">        <span class="comment"># 这是一个懒更新策略，只有在get的时候才根据时间戳判断</span></span><br><span class="line">        <span class="variable language_">self</span>.set_all_value = v</span><br><span class="line">        <span class="variable language_">self</span>.set_all_time = <span class="variable language_">self</span>.cnt</span><br><span class="line">        <span class="variable language_">self</span>.cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="comment"># 核心思想：比较单个key的更新时间和全局setAll的更新时间</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        value = <span class="variable language_">self</span>.<span class="built_in">map</span>[k]</span><br><span class="line">        <span class="comment"># 如果这个key的最后更新时间晚于setAll的时间，说明它的值是有效的</span></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">1</span>] &gt; <span class="variable language_">self</span>.set_all_time:</span><br><span class="line">            <span class="keyword">return</span> value[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 否则，它的值已经被setAll覆盖了，应返回setAll的值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.set_all_value</span><br></pre></td></tr></table></figure>

<p><strong>高效读写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建一个SetAllHashMap对象，模拟带有setAll操作的哈希表，模拟牛客网的输入输出处理</span></span><br><span class="line">    solution = SetAllHashMap()</span><br><span class="line">    <span class="comment"># 读取所有输入行（提高输入效率）</span></span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(lines): <span class="comment"># 遍历所有行</span></span><br><span class="line">        line = lines[i].strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="comment"># 跳过空行</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取本组操作数n</span></span><br><span class="line">        n = <span class="built_in">int</span>(line)</span><br><span class="line">        <span class="comment"># 每个测试用例开始前重置数据结构</span></span><br><span class="line">        solution.__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连续读取n行操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 解析当前操作的所有参数，map是把字符串转换成列表，int指明了列表的元素类型</span></span><br><span class="line">            parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, lines[i].strip().split()))</span><br><span class="line">            op = parts[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># op=1，put操作，后面有两个参数a, b</span></span><br><span class="line">                a, b = parts[<span class="number">1</span>], parts[<span class="number">2</span>]</span><br><span class="line">                solution.put(a, b)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># op=2，get操作，后面一个参数a</span></span><br><span class="line">                a = parts[<span class="number">1</span>]</span><br><span class="line">                <span class="built_in">print</span>(solution.get(a))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># op=3，setAll操作，后面一个参数a</span></span><br><span class="line">                a = parts[<span class="number">1</span>]</span><br><span class="line">                solution.set_all(a)</span><br><span class="line">        <span class="comment"># 处理完一组数据，i+1进入下一组或结束</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 在提交时，类名需要改为 Main</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)，N为键的数量</li>
<li><strong>核心技巧</strong>：时间戳比较 + 懒更新策略</li>
</ul>
<h2 id="题目二：实现LRU结构"><a href="#题目二：实现LRU结构" class="headerlink" title="题目二：实现LRU结构"></a>题目二：实现LRU结构</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>实现 LRUCache 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量capacity初始化LRU缓存</li>
<li><code>int get(int key)</code> 如果关键字key存在于缓存中，则返回关键字的值，否则返回-1</li>
<li><code>void put(int key, int value)</code> 如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字</li>
</ul>
<p>函数get和put必须以O(1)的平均时间复杂度运行。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>结合了哈希表和双向链表：哈希表提供了对任意键的O(1)快速访问，而双向链表则负责维护数据的访问顺序，使其能在O(1)时间内将最新访问的节点移到队尾，并在容量满时淘汰队首的最久未使用节点。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/lru%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="lru结构的实现"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="comment"># 内部类，定义双向链表节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleNode</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="number">0</span>, val=<span class="number">0</span></span>):</span><br><span class="line">            <span class="variable language_">self</span>.key = key</span><br><span class="line">            <span class="variable language_">self</span>.val = val</span><br><span class="line">            <span class="variable language_">self</span>.last = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 内部类，实现双向链表，用于维护节点的访问顺序</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleList</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 哨兵节点，简化边界条件处理</span></span><br><span class="line">            <span class="variable language_">self</span>.head = <span class="variable language_">self</span>.DoubleNode() <span class="comment">#头节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail = <span class="variable language_">self</span>.DoubleNode() <span class="comment">#尾节点</span></span><br><span class="line">            <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail <span class="comment">#头节点的下一个节点是尾节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail.last = <span class="variable language_">self</span>.head <span class="comment">#尾节点的上一个节点是头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将一个节点添加到链表尾部（表示最近使用）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add_node_to_tail</span>(<span class="params">self, node</span>):</span><br><span class="line">            node.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail <span class="comment"># 将新节点添加到尾节点的前一个位置</span></span><br><span class="line">            node.last = <span class="variable language_">self</span>.tail.last <span class="comment"># 将新节点的上一个节点设置为尾节点的前一个节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail.last.<span class="built_in">next</span> = node <span class="comment"># 将尾节点的前一个节点的下一个节点设置为新节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail.last = node <span class="comment"># 将尾节点的前一个节点设置为新节点</span></span><br><span class="line">            <span class="comment"># 这样设置是为了把尾节点和前一个节点的两条指针变成四条指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将指定节点移动到链表尾部</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">move_node_to_tail</span>(<span class="params">self, node</span>):</span><br><span class="line">            <span class="comment"># 先将节点从原位置断开</span></span><br><span class="line">            node.last.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>.last = node.last</span><br><span class="line">            <span class="comment"># 再将节点添加到尾部</span></span><br><span class="line">            <span class="variable language_">self</span>.add_node_to_tail(node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移除链表头部节点（最久未使用的节点）并返回</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">remove_head</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 如果链表为空（只有哨兵节点），则无法移除</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.head.<span class="built_in">next</span> == <span class="variable language_">self</span>.tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node_to_remove = <span class="variable language_">self</span>.head.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 从链表中移除</span></span><br><span class="line">            node_to_remove.last.<span class="built_in">next</span> = node_to_remove.<span class="built_in">next</span></span><br><span class="line">            node_to_remove.<span class="built_in">next</span>.last = node_to_remove.last</span><br><span class="line">            <span class="keyword">return</span> node_to_remove</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用哈希表实现O(1)查找，使用双向链表实现O(1)的节点移动（更新访问顺序）</span></span><br><span class="line">        <span class="comment"># 哈希表，存储 key -&gt; DoubleNode 的映射</span></span><br><span class="line">        <span class="variable language_">self</span>.key_node_map = &#123;&#125;</span><br><span class="line">        <span class="comment"># 双向链表实例，维护节点的LRU顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.node_list = <span class="variable language_">self</span>.DoubleList()</span><br><span class="line">        <span class="comment"># 缓存的容量</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果key存在</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.key_node_map:</span><br><span class="line">            <span class="comment"># 获取节点</span></span><br><span class="line">            node = <span class="variable language_">self</span>.key_node_map[key]</span><br><span class="line">            <span class="comment"># 将该节点移动到链表尾部，表示最近被访问</span></span><br><span class="line">            <span class="variable language_">self</span>.node_list.move_node_to_tail(node)</span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="comment"># 如果key不存在，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 如果key已存在</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.key_node_map:</span><br><span class="line">            <span class="comment"># 更新节点的值</span></span><br><span class="line">            node = <span class="variable language_">self</span>.key_node_map[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            <span class="comment"># 将该节点移动到链表尾部</span></span><br><span class="line">            <span class="variable language_">self</span>.node_list.move_node_to_tail(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果缓存已满</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.key_node_map) == <span class="variable language_">self</span>.capacity:</span><br><span class="line">                <span class="comment"># 移除链表头部的最久未使用节点，之后会再把新节点添加到尾部</span></span><br><span class="line">                removed_node = <span class="variable language_">self</span>.node_list.remove_head()</span><br><span class="line">                <span class="comment"># 从哈希表中删除对应的key</span></span><br><span class="line">                <span class="keyword">del</span> <span class="variable language_">self</span>.key_node_map[removed_node.key]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 创建新节点</span></span><br><span class="line">            new_node = <span class="variable language_">self</span>.DoubleNode(key, value)</span><br><span class="line">            <span class="comment"># 存入哈希表</span></span><br><span class="line">            <span class="variable language_">self</span>.key_node_map[key] = new_node</span><br><span class="line">            <span class="comment"># 将新节点添加到链表尾部</span></span><br><span class="line">            <span class="variable language_">self</span>.node_list.add_node_to_tail(new_node)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：get和put操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(capacity)</li>
<li><strong>核心技巧</strong>：哈希表 + 双向链表</li>
</ul>
<h2 id="题目三：插入、删除和获取随机元素O-1-时间的结构"><a href="#题目三：插入、删除和获取随机元素O-1-时间的结构" class="headerlink" title="题目三：插入、删除和获取随机元素O(1)时间的结构"></a>题目三：插入、删除和获取随机元素O(1)时间的结构</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构：</p>
<ul>
<li><code>insert(val)</code>：当元素val不存在时，向集合中插入该项</li>
<li><code>remove(val)</code>：元素val存在时，从集合中移除该项</li>
<li><code>getRandom()</code>：随机返回现有集合中的一项</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">https://leetcode.cn/problems/insert-delete-getrandom-o1/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>结合了动态数组与哈希表，数组负责存储元素以实现O(1)的随机获取，哈希表则存储”值到数组索引”的映射以实现O(1)的查找。其remove操作的精髓在于：将待删除元素与数组的最后一个元素交换，然后直接删除数组末尾。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/hash%E8%A1%A8%E5%8A%A0%E5%85%A5%E7%A7%BB%E9%99%A4%E5%92%8C%E5%BE%97%E5%88%B0%E9%9A%8F%E6%9C%BA%E7%B4%A2%E5%BC%95.png" alt="hash表加入移除和得到随机索引"></p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想：</span></span><br><span class="line">        <span class="comment"># 1. 使用哈希表（字典）存储 值 -&gt; 索引 的映射，实现O(1)的查找。</span></span><br><span class="line">        <span class="comment"># 2. 使用动态数组（列表）存储值，实现O(1)的随机访问。</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125;  </span><br><span class="line">        <span class="variable language_">self</span>.arr = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果值已存在，直接返回False</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 将值添加到数组末尾</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.append(val)</span><br><span class="line">        <span class="comment"># 在哈希表中记录新值及其索引,map[val]返回val在数组中的索引</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[val] = <span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果值不存在，直接返回False</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 核心步骤：为了实现O(1)删除，将被删除元素与数组末尾元素交换，然后删除末尾元素。</span></span><br><span class="line">        <span class="comment"># 获取待删除元素的索引</span></span><br><span class="line">        val_index = <span class="variable language_">self</span>.<span class="built_in">map</span>[val]</span><br><span class="line">        <span class="comment"># 获取数组末尾的元素</span></span><br><span class="line">        end_value = <span class="variable language_">self</span>.arr[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将末尾元素放到待删除元素的位置</span></span><br><span class="line">        <span class="variable language_">self</span>.arr[val_index] = end_value</span><br><span class="line">        <span class="comment"># 更新哈希表中末尾元素的索引，只更新索引不更新值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[end_value] = val_index</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从哈希表中删除目标值</span></span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[val]</span><br><span class="line">        <span class="comment"># 从数组中删除末尾元素，两者同步更新</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 利用数组的特性，随机选择一个索引并返回对应的值</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(<span class="variable language_">self</span>.arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：数组末尾交换删除</li>
</ul>
<h2 id="题目四：插入、删除和获取随机元素O-1-时间且允许重复数字的结构"><a href="#题目四：插入、删除和获取随机元素O-1-时间且允许重复数字的结构" class="headerlink" title="题目四：插入、删除和获取随机元素O(1)时间且允许重复数字的结构"></a>题目四：插入、删除和获取随机元素O(1)时间且允许重复数字的结构</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构，且允许有重复数字：</p>
<ul>
<li><code>insert(val)</code>：向集合中插入元素val</li>
<li><code>remove(val)</code>：从集合中移除元素val的一个实例</li>
<li><code>getRandom()</code>：随机返回现有集合中的一项</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/">https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/</a></p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p>与不允许重复的版本类似，但哈希表需要存储一个值所有出现位置的索引集合。</p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedCollection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想：与不允许重复的版本类似，但哈希表需要存储一个值所有出现位置的索引集合。</span></span><br><span class="line">        <span class="comment"># 注意：字典中每个key指向的是不同的集合(set)，而不是同一个数组</span></span><br><span class="line">        <span class="comment"># 字典：存储 值 -&gt; 索引集合 的映射</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="comment"># 列表：存储所有值</span></span><br><span class="line">        <span class="variable language_">self</span>.arr = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 判断是否是第一次插入该值</span></span><br><span class="line">        is_new = val <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span></span><br><span class="line">        <span class="comment"># 将值添加到数组末尾</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.append(val)</span><br><span class="line">        <span class="comment"># 在哈希表中记录新值的索引</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[val].add(<span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> is_new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果值不存在，无法删除</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 核心步骤：同样是与末尾元素交换以实现O(1)删除</span></span><br><span class="line">        <span class="comment"># 获取待删除值的一个索引</span></span><br><span class="line">        val_index = <span class="variable language_">self</span>.<span class="built_in">map</span>[val].pop()</span><br><span class="line">        <span class="comment"># 获取末尾元素的值和索引</span></span><br><span class="line">        end_value = <span class="variable language_">self</span>.arr[-<span class="number">1</span>]</span><br><span class="line">        end_index = <span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果待删除的元素恰好是末尾元素，则不需要交换</span></span><br><span class="line">        <span class="keyword">if</span> val_index != end_index:</span><br><span class="line">            <span class="comment"># 用末尾元素覆盖待删除元素的位置</span></span><br><span class="line">            <span class="variable language_">self</span>.arr[val_index] = end_value</span><br><span class="line">            <span class="comment"># 更新末尾元素在哈希表中的索引记录</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[end_value].remove(end_index) </span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[end_value].add(val_index)</span><br><span class="line">            <span class="comment">#这里的 map 是一个存储集合的集合，所以需要通过 map[key] 先获取到集合，然后对集合调用 remove() 和 add() 方法。这是 Python 中嵌套数据结构的常见操作模式。</span></span><br><span class="line">        <span class="comment"># 从数组中移除末尾元素</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果移除后，某个值的索引集合为空，则从哈希表中彻底删除该值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[val]:</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[val]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 随机获取一个元素</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(<span class="variable language_">self</span>.arr)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：索引集合管理</li>
</ul>
<h2 id="题目五：快速获得数据流的中位数的结构"><a href="#题目五：快速获得数据流的中位数的结构" class="headerlink" title="题目五：快速获得数据流的中位数的结构"></a>题目五：快速获得数据流的中位数的结构</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，[2,3,4]的中位数是3，[2,3]的中位数是(2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两个操作的数据结构：</p>
<ul>
<li><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中</li>
<li><code>double findMedian()</code> - 返回目前所有元素的中位数</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用两个堆来维护数据流，一个大顶堆和一个小顶堆。大顶堆存储数据流中较小的一半数字，小顶堆存储数据流中较大的一半数字。这样，中位数总是可以通过两个堆的堆顶元素快速得到。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0.png" alt="找中位数"></p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用两个堆来维护数据流，一个大顶堆和一个小顶堆。</span></span><br><span class="line">        <span class="comment"># 大顶堆 (max_heap) 存储数据流中较小的一半数字。</span></span><br><span class="line">        <span class="comment"># 小顶堆 (min_heap) 存储数据流中较大的一半数字。</span></span><br><span class="line">        <span class="comment"># 这样，中位数总是可以通过两个堆的堆顶元素快速得到。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Python的heapq是小顶堆，为了实现大顶堆，我们存入元素的相反数。</span></span><br><span class="line">        <span class="variable language_">self</span>.max_heap = []</span><br><span class="line">        <span class="variable language_">self</span>.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 步骤1: 决定将新元素添加到哪个堆。</span></span><br><span class="line">        <span class="comment"># 如果大顶堆为空，或者新元素小于等于大顶堆的堆顶，则放入大顶堆。</span></span><br><span class="line">        <span class="comment"># 否则，放入小顶堆。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.max_heap <span class="keyword">or</span> -<span class="variable language_">self</span>.max_heap[<span class="number">0</span>] &gt;= num:</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.max_heap, -num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.min_heap, num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2: 平衡两个堆的大小，确保它们的size之差不超过1。</span></span><br><span class="line">        <span class="variable language_">self</span>._balance()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># 根据两个堆的大小来计算中位数。</span></span><br><span class="line">        <span class="comment"># 如果大小相等（总元素为偶数），中位数是两个堆顶的平均值。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) == <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap):</span><br><span class="line">            <span class="comment"># 注意从大顶堆取值时要取反，恢复其原始值。</span></span><br><span class="line">            <span class="keyword">return</span> (-<span class="variable language_">self</span>.max_heap[<span class="number">0</span>] + <span class="variable language_">self</span>.min_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">        <span class="comment"># 如果大小不等（总元素为奇数），中位数就是那个size更大的堆的堆顶。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="variable language_">self</span>.max_heap[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap) <span class="keyword">else</span> <span class="variable language_">self</span>.min_heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 私有辅助方法，用于平衡两个堆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_balance</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 当两个堆的大小差距为2时，需要从元素多的堆移动一个到元素少的堆。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) - <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap)) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap):</span><br><span class="line">                heapq.heappush(<span class="variable language_">self</span>.min_heap, -heapq.heappop(<span class="variable language_">self</span>.max_heap))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(<span class="variable language_">self</span>.max_heap, -heapq.heappop(<span class="variable language_">self</span>.min_heap))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：addNum为O(logN)，findMedian为O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：双堆平衡</li>
</ul>
<h2 id="题目六：最大频率栈"><a href="#题目六：最大频率栈" class="headerlink" title="题目六：最大频率栈"></a>题目六：最大频率栈</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p>
<p>实现 FreqStack 类：</p>
<ul>
<li><code>FreqStack()</code> 构造一个空的堆栈</li>
<li><code>void push(int val)</code> 将一个整数val压入栈顶</li>
<li><code>int pop()</code> 删除并返回堆栈中出现频率最高的元素</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-frequency-stack/">https://leetcode.cn/problems/maximum-frequency-stack/</a></p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用一个哈希表记录每个值出现的频率，使用另一个哈希表将频率映射到一个栈，这个栈存储了所有出现该频率的数字。使用一个变量实时追踪当前的最大频率。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/%E6%9C%80%E9%AB%98%E9%A2%91%E7%8E%87%E6%A0%88.png" alt="最高频率栈"></p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment">#这个初始化的是hashmap</span></span><br><span class="line">        <span class="comment"># 核心思想:</span></span><br><span class="line">        <span class="comment"># 1. 使用一个哈希表 (value_times) 记录每个值出现的频率。</span></span><br><span class="line">        <span class="comment"># 2. 使用另一个哈希表 (cnt_values) 将频率映射到一个栈（列表），这个栈存储了所有出现该频率的数字。</span></span><br><span class="line">        <span class="comment"># 3. 使用一个变量 (top_times) 实时追踪当前的最大频率。</span></span><br><span class="line">        <span class="comment"># pop操作总是从最大频率对应的栈中弹出元素，这保证了既是最高频也是最“新”的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 出现的最大次数</span></span><br><span class="line">        <span class="variable language_">self</span>.top_times = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每层节点 (每个频率有哪些数)</span></span><br><span class="line">        <span class="comment"># defaultdict(list) 会在key不存在时自动创建一个空列表</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt_values = defaultdict(<span class="built_in">list</span>) </span><br><span class="line">        <span class="comment"># 每一个数出现了几次</span></span><br><span class="line">        <span class="comment"># defaultdict(int) 会在key不存在时自动创建一个0</span></span><br><span class="line">        <span class="variable language_">self</span>.value_times = defaultdict(<span class="built_in">int</span>) </span><br><span class="line">        <span class="comment">#实际上，cnt_values和value_times是两个哈希表，一个存储频率，一个存储频率对应的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 步骤1: 更新该值的频率</span></span><br><span class="line">        <span class="variable language_">self</span>.value_times[val] += <span class="number">1</span></span><br><span class="line">        current_freq = <span class="variable language_">self</span>.value_times[val]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2: 将该值压入其新频率对应的栈中</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt_values[current_freq].append(val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3: 更新全局最大频率</span></span><br><span class="line">        <span class="variable language_">self</span>.top_times = <span class="built_in">max</span>(<span class="variable language_">self</span>.top_times, current_freq)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤1: 从最大频率对应的栈中弹出最近压入的元素</span></span><br><span class="line">        ans = <span class="variable language_">self</span>.cnt_values[<span class="variable language_">self</span>.top_times].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2: 如果弹出后，该频率的栈为空了，说明最大频率需要降低</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.cnt_values[<span class="variable language_">self</span>.top_times]:</span><br><span class="line">            <span class="variable language_">self</span>.top_times -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3: 更新被弹出元素自身的频率记录</span></span><br><span class="line">        <span class="variable language_">self</span>.value_times[ans] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：push和pop操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：频率分层存储</li>
</ul>
<h2 id="题目七：全O-1-的数据结构"><a href="#题目七：全O-1-的数据结构" class="headerlink" title="题目七：全O(1)的数据结构"></a>题目七：全O(1)的数据结构</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>请你实现一个数据结构支持以下操作：</p>
<ul>
<li><code>Inc(key)</code> - 插入一个新的值为1的key，或者使一个存在的key增加一，保证key不为空字符串</li>
<li><code>Dec(key)</code> - 如果这个key的值是1，那么把他从数据结构中移除掉。否则使一个存在的key值减一。如果这个key不存在，这个函数不做任何事情。key保证不为空字符串</li>
<li><code>GetMaxKey()</code> - 返回key中值最大的任意一个。如果没有元素存在，返回一个空字符串””</li>
<li><code>GetMinKey()</code> - 返回key中值最小的任意一个。如果没有元素存在，返回一个空字符串””</li>
</ul>
<p>挑战：以O(1)的时间复杂度实现所有操作。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-oone-data-structure/">https://leetcode.cn/problems/all-oone-data-structure/</a></p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用一个双向链表来组织桶(Bucket)，链表按桶的计数值(cnt)升序排列。每个桶包含一个集合，存储所有计数值等于该桶cnt的key。使用一个哈希表来存储key -&gt; Bucket的映射，实现O(1)的key定位。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/all1%E7%B1%BB.png" alt="all1类"></p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllOne</span>:</span><br><span class="line">    <span class="comment"># 内部类，定义双向链表的节点，也叫“桶”</span></span><br><span class="line">    <span class="comment"># 每个桶存储具有相同计数值的所有key</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bucket</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cnt</span>):</span><br><span class="line">            <span class="variable language_">self</span>.cnt = cnt</span><br><span class="line">            <span class="variable language_">self</span>.keys = <span class="built_in">set</span>()</span><br><span class="line">            <span class="variable language_">self</span>.last = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想:</span></span><br><span class="line">        <span class="comment"># 1. 使用一个双向链表来组织桶(Bucket)，链表按桶的计数值(cnt)升序排列。</span></span><br><span class="line">        <span class="comment"># 2. 每个桶(Bucket)包含一个集合(set)，存储所有计数值等于该桶cnt的key。</span></span><br><span class="line">        <span class="comment"># 3. 使用一个哈希表(map)来存储 key -&gt; Bucket 的映射，实现O(1)的key定位。</span></span><br><span class="line">        <span class="comment"># inc/dec操作本质上是将key从一个桶移动到相邻的下一个/上一个桶。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建头尾哨兵节点，简化边界处理</span></span><br><span class="line">        <span class="variable language_">self</span>.head = <span class="variable language_">self</span>.Bucket(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.tail = <span class="variable language_">self</span>.Bucket(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">        <span class="comment"># 将头节点的下一个指针指向尾节点，尾节点的上一个指针指向头节点，这样操作后，双向链表形成了一个初始的空结构：head &lt;-&gt; tail</span></span><br><span class="line">        <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">        <span class="variable language_">self</span>.tail.last = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="comment"># 存储 key 到其所在 Bucket 的映射</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 辅助函数：在指定位置(prev_bucket)后插入一个新桶(new_bucket)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert_after</span>(<span class="params">self, prev_bucket, new_bucket</span>):</span><br><span class="line">        new_bucket.<span class="built_in">next</span> = prev_bucket.<span class="built_in">next</span></span><br><span class="line">        new_bucket.last = prev_bucket</span><br><span class="line">        prev_bucket.<span class="built_in">next</span>.last = new_bucket</span><br><span class="line">        prev_bucket.<span class="built_in">next</span> = new_bucket</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 辅助函数：从链表中移除一个桶，让前后的指针跳过当前桶</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_remove_bucket</span>(<span class="params">self, bucket</span>):</span><br><span class="line">        bucket.last.<span class="built_in">next</span> = bucket.<span class="built_in">next</span></span><br><span class="line">        bucket.<span class="built_in">next</span>.last = bucket.last</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 核心步骤：将key从当前桶移动到cnt+1的桶</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="comment"># case 1: 新key，计数值为1</span></span><br><span class="line">            <span class="comment"># 找到或创建cnt=1的桶</span></span><br><span class="line">            target_bucket = <span class="variable language_">self</span>.head.<span class="built_in">next</span> <span class="comment">#定位到第一个桶</span></span><br><span class="line">            <span class="keyword">if</span> target_bucket.cnt != <span class="number">1</span>:</span><br><span class="line">                target_bucket = <span class="variable language_">self</span>.Bucket(<span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>._insert_after(<span class="variable language_">self</span>.head, target_bucket)</span><br><span class="line">            <span class="comment"># 将key加入桶和map</span></span><br><span class="line">            target_bucket.keys.add(key)</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = target_bucket</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># case 2: key已存在</span></span><br><span class="line">            current_bucket = <span class="variable language_">self</span>.<span class="built_in">map</span>[key] <span class="comment">#map是双向的</span></span><br><span class="line">            new_cnt = current_bucket.cnt + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到或创建cnt=new_cnt的桶</span></span><br><span class="line">            target_bucket = current_bucket.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> target_bucket.cnt != new_cnt:</span><br><span class="line">                target_bucket = <span class="variable language_">self</span>.Bucket(new_cnt)</span><br><span class="line">                <span class="variable language_">self</span>._insert_after(current_bucket, target_bucket)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动key</span></span><br><span class="line">            target_bucket.keys.add(key)</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = target_bucket</span><br><span class="line">            current_bucket.keys.remove(key)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果原桶变空，则移除</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_bucket.keys:</span><br><span class="line">                <span class="variable language_">self</span>._remove_bucket(current_bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 核心步骤：将key从当前桶移动到cnt-1的桶</span></span><br><span class="line">        current_bucket = <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">        current_bucket.keys.remove(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_bucket.cnt &gt; <span class="number">1</span>:</span><br><span class="line">            new_cnt = current_bucket.cnt - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到或创建cnt=new_cnt的桶</span></span><br><span class="line">            target_bucket = current_bucket.last</span><br><span class="line">            <span class="keyword">if</span> target_bucket.cnt != new_cnt:</span><br><span class="line">                target_bucket = <span class="variable language_">self</span>.Bucket(new_cnt)</span><br><span class="line">                <span class="variable language_">self</span>._insert_after(current_bucket.last, target_bucket)</span><br><span class="line">            <span class="comment"># 移动key</span></span><br><span class="line">            target_bucket.keys.add(key)</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = target_bucket</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果cnt为1，dec后直接从map中移除</span></span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果原桶变空，则移除</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_bucket.keys:</span><br><span class="line">            <span class="variable language_">self</span>._remove_bucket(current_bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMaxKey</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 最大计数值的桶在tail哨兵节点的前面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.tail.last == <span class="variable language_">self</span>.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从桶的集合中任意取一个key即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(<span class="built_in">iter</span>(<span class="variable language_">self</span>.tail.last.keys)) </span><br><span class="line">        <span class="comment"># self.tail.last - 获取尾哨兵节点的前一个节点，也就是链表中最后一个实际的桶</span></span><br><span class="line">        <span class="comment"># .keys - 这个桶中存储的键的集合（set）</span></span><br><span class="line">        <span class="comment"># iter(...) - 将集合转换为迭代器</span></span><br><span class="line">        <span class="comment"># next(...) - 从迭代器中获取第一个元</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinKey</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 最小计数值的桶在head哨兵节点的后面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.head.<span class="built_in">next</span> == <span class="variable language_">self</span>.tail:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从桶的集合中任意取一个key即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(<span class="built_in">iter</span>(<span class="variable language_">self</span>.head.<span class="built_in">next</span>.keys))</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：双向链表 + 桶分组</li>
</ul>
<h2 id="数据结构设计核心技巧总结"><a href="#数据结构设计核心技巧总结" class="headerlink" title="数据结构设计核心技巧总结"></a>数据结构设计核心技巧总结</h2><h3 id="1-哈希表的O-1-特性"><a href="#1-哈希表的O-1-特性" class="headerlink" title="1. 哈希表的O(1)特性"></a>1. 哈希表的O(1)特性</h3><p>大部分设计题都基于哈希表的O(1)查找、插入、删除特性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本哈希表操作</span></span><br><span class="line">hash_map = &#123;&#125;</span><br><span class="line">hash_map[key] = value  <span class="comment"># O(1) 插入</span></span><br><span class="line">val = hash_map[key]    <span class="comment"># O(1) 查找</span></span><br><span class="line"><span class="keyword">del</span> hash_map[key]      <span class="comment"># O(1) 删除</span></span><br></pre></td></tr></table></figure>

<h3 id="2-时间戳技巧"><a href="#2-时间戳技巧" class="headerlink" title="2. 时间戳技巧"></a>2. 时间戳技巧</h3><p>用于实现懒更新策略：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间戳比较</span></span><br><span class="line"><span class="keyword">if</span> operation_time &gt; global_time:</span><br><span class="line">    <span class="keyword">return</span> local_value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> global_value</span><br></pre></td></tr></table></figure>

<h3 id="3-双向链表维护顺序"><a href="#3-双向链表维护顺序" class="headerlink" title="3. 双向链表维护顺序"></a>3. 双向链表维护顺序</h3><p>适用于需要频繁移动元素位置的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双向链表节点移动</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_to_tail</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># 断开原连接</span></span><br><span class="line">    node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">    node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    <span class="comment"># 插入到尾部</span></span><br><span class="line">    node.<span class="built_in">next</span> = tail</span><br><span class="line">    node.prev = tail.prev</span><br><span class="line">    tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">    tail.prev = node</span><br></pre></td></tr></table></figure>

<h3 id="4-数组末尾交换删除"><a href="#4-数组末尾交换删除" class="headerlink" title="4. 数组末尾交换删除"></a>4. 数组末尾交换删除</h3><p>实现O(1)删除的经典技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将待删除元素与末尾元素交换</span></span><br><span class="line">arr[del_index] = arr[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">map</span>[arr[-<span class="number">1</span>]] = del_index  <span class="comment"># 更新索引映射</span></span><br><span class="line">arr.pop()  <span class="comment"># 删除末尾元素</span></span><br></pre></td></tr></table></figure>

<h3 id="5-双堆维护极值"><a href="#5-双堆维护极值" class="headerlink" title="5. 双堆维护极值"></a>5. 双堆维护极值</h3><p>适用于动态维护中位数或其他统计量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 维护两个堆的平衡</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">len</span>(max_heap) - <span class="built_in">len</span>(min_heap)) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 从大的堆移动元素到小的堆</span></span><br><span class="line">    balance_heaps()</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>setAll哈希表</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+时间戳</td>
</tr>
<tr>
<td>LRU缓存</td>
<td>O(1)</td>
<td>O(capacity)</td>
<td>哈希表+双向链表</td>
</tr>
<tr>
<td>随机数据结构</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+动态数组</td>
</tr>
<tr>
<td>随机数据结构(重复)</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+集合+数组</td>
</tr>
<tr>
<td>中位数查找</td>
<td>O(logN)&#x2F;O(1)</td>
<td>O(N)</td>
<td>双堆</td>
</tr>
<tr>
<td>最大频率栈</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+栈数组</td>
</tr>
<tr>
<td>全O(1)数据结构</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+双向链表+桶</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>理解O(1)的本质</strong>：大多数设计题的核心是利用哈希表的O(1)特性</p>
</li>
<li><p><strong>掌握组合数据结构</strong>：</p>
<ul>
<li>哈希表 + 双向链表（LRU）</li>
<li>哈希表 + 动态数组（随机访问）</li>
<li>双堆（维护极值）</li>
<li>时间戳（懒更新）</li>
</ul>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空数据结构</li>
<li>容量限制</li>
<li>重复元素处理</li>
</ul>
</li>
<li><p><strong>理解权衡取舍</strong>：</p>
<ul>
<li>时间复杂度 vs 空间复杂度</li>
<li>实现复杂度 vs 运行效率</li>
</ul>
</li>
<li><p><strong>多练习组合技巧</strong>：数据结构设计题往往需要组合多种基础数据结构</p>
</li>
</ol>
<p>数据结构设计题考察的是对基础数据结构的深入理解和灵活运用能力。通过掌握这些经典模式和技巧，可以应对大多数设计类问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AgioPan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">AgioPan</p>
  <div class="site-description" itemprop="description">Solving equations, decoding life, exploring minds.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Agio910" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Agio910" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://orcid.org/0009-0005-1485-9515" title="orcid → https:&#x2F;&#x2F;orcid.org&#x2F;0009-0005-1485-9515" rel="noopener" target="_blank"><i class="fab fa-orcid fa-fw"></i>orcid</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:202111079094@mail.bnu.edu.cn" title="E-Mail → mailto:202111079094@mail.bnu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AgioPan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
