<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog of AgioPan">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Blog of AgioPan">
<meta property="og:description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="AgioPan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog of AgioPan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of AgioPan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89-%20%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89-%20%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（15）- 常见经典递归过程解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-09-02 10:30:00 / Modified: 19:59:22" itemprop="dateCreated datePublished" datetime="2025-09-02T10:30:00+08:00">2025-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是 <strong>038【必备】常见经典递归过程解析</strong> 的内容，总结了7道经典递归题目，涵盖了递归的核心思想和技巧，包括带路径的递归、不带路径的递归、回溯算法等重要概念。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习本节内容之前，建议先熟悉以下章节：</p>
<ul>
<li>讲解017、020、021、023、036、037（这些章节都分析过递归）</li>
</ul>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="递归与回溯的关系"><a href="#递归与回溯的关系" class="headerlink" title="递归与回溯的关系"></a>递归与回溯的关系</h3><ul>
<li><strong>任何递归都是DFS且非常灵活</strong></li>
<li><strong>回溯这个术语并不重要</strong>，它只是递归过程中的恢复现场操作</li>
<li><strong>带路径的递归 vs 不带路径的递归</strong>：大部分DP和状态压缩DP可以认为是路径简化了结构</li>
</ul>
<hr>
<h1 id="038【必备】常见经典递归过程解析"><a href="#038【必备】常见经典递归过程解析" class="headerlink" title="038【必备】常见经典递归过程解析"></a>038【必备】常见经典递归过程解析</h1><h2 id="题目一：返回字符串全部子序列（去重）"><a href="#题目一：返回字符串全部子序列（去重）" class="headerlink" title="题目一：返回字符串全部子序列（去重）"></a>题目一：返回字符串全部子序列（去重）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>返回字符串全部子序列，子序列要求去重。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a">https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用递归的方式，对于字符串中的每一个字符，我们都有两种选择：</p>
<ol>
<li>将该字符包含在当前子序列中</li>
<li>不将该字符包含在当前子序列中</li>
</ol>
<p>通过递归遍历所有这些选择，就能得到所有可能的子序列。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E5%AD%90%E5%BA%8F%E5%88%97%E5%8E%BB%E9%87%8D.png" alt="子序列去重"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：使用列表作为路径"><a href="#方法一：使用列表作为路径" class="headerlink" title="方法一：使用列表作为路径"></a>方法一：使用列表作为路径</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generatePermutation1</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数 f1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用集合 set 来自动处理重复的子序列</span></span><br><span class="line">        result_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># path 使用列表来模拟 Java 的 StringBuilder，方便添加和删除字符</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="variable language_">self</span>._f1(s, <span class="number">0</span>, path, result_set)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(result_set))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f1</span>(<span class="params">self, s: <span class="built_in">str</span>, i: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">str</span>], result_set: <span class="type">Set</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，用于生成所有子序列</span></span><br><span class="line"><span class="string">        s[i...]，之前决定的路径path，set收集结果时去重</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 当索引 i 到达字符串末尾时，所有字符都已考虑完毕</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">            result_set.add(<span class="string">&quot;&quot;</span>.join(path))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 决策1: 选择当前字符 s[i]</span></span><br><span class="line">            path.append(s[i])  <span class="comment"># 加到路径中去</span></span><br><span class="line">            <span class="variable language_">self</span>._f1(s, i + <span class="number">1</span>, path, result_set)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 回溯：撤销选择，为下一种决策做准备</span></span><br><span class="line">            path.pop()  <span class="comment"># 从路径中移除，删掉最后一个字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策2: 不选择当前字符 s[i]</span></span><br><span class="line">            <span class="variable language_">self</span>._f1(s, i + <span class="number">1</span>, path, result_set)</span><br></pre></td></tr></table></figure>

<h4 id="方法二：使用固定长度列表和size指针"><a href="#方法二：使用固定长度列表和size指针" class="headerlink" title="方法二：使用固定长度列表和size指针"></a>方法二：使用固定长度列表和size指针</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generatePermutation2</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数 f2</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 预先分配一个与原字符串等长的列表作为路径容器</span></span><br><span class="line">        path = [<span class="string">&#x27;&#x27;</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="variable language_">self</span>._f2(s, <span class="number">0</span>, path, <span class="number">0</span>, result_set)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(result_set))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f2</span>(<span class="params">self, s: <span class="built_in">str</span>, i: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">str</span>], size: <span class="built_in">int</span>, result_set: <span class="type">Set</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        与f1思想相同，但使用不同的方式来维护路径</span></span><br><span class="line"><span class="string">        这方法不用回溯，因为path是固定长度的列表，size指针来表示有效字符长度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># path[:size] 表示路径中的有效部分</span></span><br><span class="line">            result_set.add(<span class="string">&quot;&quot;</span>.join(path[:size]))</span><br><span class="line">            <span class="comment"># path[:size]: 取列表/序列 path 的前 size 个元素（左闭右开，不会越界，超过长度就取到末尾）</span></span><br><span class="line">            <span class="comment"># &quot;&quot;.join(...): 用空字符串作为分隔符，把可迭代对象里的“字符串元素”拼接成一个整体字符串</span></span><br><span class="line">            <span class="comment"># result_set.add(...): 将结果添加到集合中，自动去重</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 决策1: 选择当前字符 s[i]，将其放入 path 的 size 位置</span></span><br><span class="line">            path[size] = s[i]</span><br><span class="line">            <span class="variable language_">self</span>._f2(s, i + <span class="number">1</span>, path, size + <span class="number">1</span>, result_set) <span class="comment">#size+1表明有效字符长度+1，指针后移</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策2: 不选择当前字符 s[i]，直接进入下一层递归</span></span><br><span class="line">            <span class="variable language_">self</span>._f2(s, i + <span class="number">1</span>, path, size, result_set)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n × n)，子序列个数2^n，平均长度O(n)级别</li>
<li><strong>空间复杂度</strong>：O(2^n × n)</li>
<li><strong>核心技巧</strong>：递归选择 + set去重</li>
</ul>
<hr>
<h2 id="题目二：返回数组的所有组合（去重）"><a href="#题目二：返回数组的所有组合（去重）" class="headerlink" title="题目二：返回数组的所有组合（去重）"></a>题目二：返回数组的所有组合（去重）</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums，其中可能包含重复元素，请你返回该数组所有可能的组合。答案不能包含重复的组合。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>与生成子序列（排列）不同，这里通过<strong>一次性决策一组相同数字</strong>的方式来避免重复。</p>
<ol>
<li>先对数组排序。</li>
<li>在递归到位置 <code>i</code> 时，首先找到下一个与 <code>nums[i]</code> 不同的数的位置 <code>j</code>。<br> 这表示从 <code>i</code> 到 <code>j-1</code> 都是相同的数。</li>
<li>决策1：这组相同的数一个都不要。直接从 <code>j</code> 位置继续递归。</li>
<li>决策2：依次决策要1个、2个…直到 <code>j-i</code> 个相同的数。<br> 每做一次选择，就将数加入路径，然后从 <code>j</code> 位置继续递归。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E7%94%9F%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%84%E5%90%88.png" alt="生成不同的组合"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 排序是关键，它使得相同的元素相邻，便于后续去重处理</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        path = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="variable language_">self</span>._f(nums, <span class="number">0</span>, path, <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">int</span>], size: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成不重复的组合</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 当 i 到达数组末尾时，形成一个组合</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(path[:size])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 找到下一个不同于 nums[i] 的元素的位置 j</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[j] == nums[i]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策1: 当前数 nums[i] 一个都不要</span></span><br><span class="line">            <span class="variable language_">self</span>._f(nums, j, path, size, ans)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 决策2: 依次尝试要 1 个、2 个... k 个 nums[i]</span></span><br><span class="line">            <span class="comment"># 从这一段相同数字里，依次选择 1 个、2 个、…、(j-i) 个放入路径，然后递归从 j 开始，即处理下一组数去</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                path[size] = nums[k]</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 每次选择后，都从下一个不同的数 j 开始继续递归</span></span><br><span class="line">                <span class="variable language_">self</span>._f(nums, j, path, size, ans)</span><br></pre></td></tr></table></figure>

<h3 id="区别：set去重-vs-剪枝去重"><a href="#区别：set去重-vs-剪枝去重" class="headerlink" title="区别：set去重 vs 剪枝去重"></a>区别：set去重 vs 剪枝去重</h3><ul>
<li><strong>剪枝去重</strong>：当有相同的元素时，不进入递归，直接跳过，避免重复计算。（本题有用到这方面的考虑）</li>
<li><strong>set去重</strong>：当有相同的元素时，会进入递归，但最终结果会去重。（但是题目1没有）</li>
</ul>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n × n)，所有不重复组合数量≤2^n</li>
<li><strong>空间复杂度</strong>：O(2^n × n)</li>
<li><strong>核心技巧</strong>：排序 + 剪枝去重</li>
</ul>
<hr>
<h2 id="题目三：返回没有重复值数组的全部排列"><a href="#题目三：返回没有重复值数组的全部排列" class="headerlink" title="题目三：返回没有重复值数组的全部排列"></a>题目三：返回没有重复值数组的全部排列</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>没有重复项数字的全排列。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用<strong>交换模型</strong>：</p>
<ol>
<li>递归函数 <code>_f(nums, i)</code> 的任务是确定数组中第 <code>i</code> 个位置应该放哪个数。</li>
<li>我们可以从 <code>i</code> 到 <code>len(nums)-1</code> 的范围内选择一个数，将它与 <code>nums[i]</code> 交换，<br> 这样就确定了第 <code>i</code> 位。</li>
<li>然后递归调用 <code>_f(nums, i+1)</code> 去确定第 <code>i+1</code> 位。</li>
<li>当 <code>i</code> 到达数组末尾时，一个完整的排列就形成了。</li>
<li>递归返回后，必须将之前交换的元素换回来（回溯），以确保不影响其他分支的决策。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%881%EF%BC%89.png" alt="全排列（1）"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%882%EF%BC%89.png" alt="全排列（2）"></p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="variable language_">self</span>._f(nums, <span class="number">0</span>, ans)  <span class="comment"># 复用了原数组做路径</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成全排列</span></span><br><span class="line"><span class="string">        核心思想 (交换模型)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case: 当 i 到达数组长度时，一个完整的排列就形成了</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(nums[:])  <span class="comment"># 将当前排列的副本加入结果列表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 尝试将 i 到 len(nums)-1 的每个数放到 i 位置上</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 将 nums[j] 换到当前要确定的 i 位置</span></span><br><span class="line">                <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line">                <span class="comment"># 递归去确定下一个位置 i+1</span></span><br><span class="line">                <span class="variable language_">self</span>._f(nums, i + <span class="number">1</span>, ans)</span><br><span class="line">                <span class="comment"># 回溯：将数组恢复原样，以便 for 循环下一次迭代能正确执行</span></span><br><span class="line">                <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n! × n)</li>
<li><strong>空间复杂度</strong>：O(n!)</li>
<li><strong>核心技巧</strong>：交换模型 + 回溯</li>
</ul>
<hr>
<h2 id="题目四：返回可能有重复值数组的全部排列（去重）"><a href="#题目四：返回可能有重复值数组的全部排列（去重）" class="headerlink" title="题目四：返回可能有重复值数组的全部排列（去重）"></a>题目四：返回可能有重复值数组的全部排列（去重）</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>有重复项数组的去重全排列。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p>核心思想 (在交换模型基础上增加剪枝逻辑)：<br>与生成无重复数字的全排列思路基本一致，但增加了一个去重机制。</p>
<ol>
<li>在确定第 <code>i</code> 个位置的数时，我们遍历 <code>j</code> from <code>i</code> to <code>len-1</code>。</li>
<li>为了防止产生重复排列，我们规定：在第 <code>i</code> 个位置，一个数只能被放一次。<br> 例如，对于 <code>[1, 2, 2]</code>，在确定第0位时，我们尝试放第一个 <code>2</code>，<br> 就不应该再尝试放第二个 <code>2</code>，因为这两种情况后续会产生完全相同的排列。</li>
<li>使用一个集合 <code>seen</code> (或 <code>set</code>) 来记录在当前位置 <code>i</code> 已经尝试过的数字。<br> 如果 <code>nums[j]</code> 已经被放过，就跳过。</li>
</ol>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化并调用递归函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="variable language_">self</span>._f(nums, <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，生成不重复的全排列</span></span><br><span class="line"><span class="string">        在交换模型基础上增加剪枝逻辑</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(nums[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># seen 集合用于记录在当前 i 位置上已经尝试过的数字</span></span><br><span class="line">            seen: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># nums[j]没有来到过i位置，才会去尝试</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    <span class="comment"># 记录下来，表示 nums[j] 这个值已经在 i 位置上用过了</span></span><br><span class="line">                    seen.add(nums[j])</span><br><span class="line">                    <span class="comment"># 交换，将 nums[j] 放到 i 位置</span></span><br><span class="line">                    <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line">                    <span class="comment"># 递归处理下一个位置</span></span><br><span class="line">                    <span class="variable language_">self</span>._f(nums, i + <span class="number">1</span>, ans)</span><br><span class="line">                    <span class="comment"># 回溯，恢复数组</span></span><br><span class="line">                    <span class="variable language_">self</span>._swap(nums, i, j)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_swap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n! × n)</li>
<li><strong>空间复杂度</strong>：O(n!)</li>
<li><strong>核心技巧</strong>：交换模型 + 集合去重</li>
</ul>
<hr>
<h2 id="题目五：用递归逆序一个栈"><a href="#题目五：用递归逆序一个栈" class="headerlink" title="题目五：用递归逆序一个栈"></a>题目五：用递归逆序一个栈</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>用递归函数逆序栈，不能使用任何额外的数据结构。</p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p>需要两个递归函数：</p>
<ol>
<li><code>bottom_out</code>：移除并返回栈底元素，同时保持其他元素顺序不变</li>
<li><code>reverse</code>：利用bottom_out函数来逆序整个栈</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E9%80%86%E5%BA%8F%E6%A0%88bottom_out%E6%96%B9%E6%B3%95.png" alt="逆序栈bottom_out方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E9%80%86%E5%BA%8F%E6%A0%88reverse%E6%96%B9%E6%B3%95.png" alt="逆序栈reverse方法"></p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主递归函数，用于逆序整个栈。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 假设有一个函数 `_bottom_out` 可以移除并返回栈底元素。</span></span><br><span class="line"><span class="string">        2. `reverse` 函数首先调用 `_bottom_out` 得到栈底元素 `num`。</span></span><br><span class="line"><span class="string">        3. 然后，递归调用 `reverse` 来逆序剩下的 n-1 个元素的栈。</span></span><br><span class="line"><span class="string">        4. 最后，将之前取出的栈底元素 `num` 压入已逆序的栈中，此时它就成了新的栈顶。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归地移除并获取栈底元素</span></span><br><span class="line">        num = <span class="variable language_">self</span>._bottom_out(stack)</span><br><span class="line">        <span class="comment"># 递归地逆序剩余的栈</span></span><br><span class="line">        <span class="variable language_">self</span>.reverse(stack)</span><br><span class="line">        <span class="comment"># 将取出的栈底元素压入栈顶</span></span><br><span class="line">        stack.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bottom_out</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        辅助递归函数，移除并返回栈底元素，同时保持其他元素顺序不变。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        1. 弹出栈顶元素 `ans`。</span></span><br><span class="line"><span class="string">        2. 如果栈空了，说明 `ans` 就是我们想要的栈底元素，返回它。</span></span><br><span class="line"><span class="string">        3. 如果栈不空，递归调用 `_bottom_out` 获取剩下部分的栈底元素 `last`。</span></span><br><span class="line"><span class="string">        4. 在递归返回的过程中，将之前弹出的 `ans` 重新压栈，以恢复栈的状态。</span></span><br><span class="line"><span class="string">        5. 将从递归深处得到的 `last` 一路返回上去。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> ans  <span class="comment"># 如果栈空了，说明ans就是栈底元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = <span class="variable language_">self</span>._bottom_out(stack)  <span class="comment"># 递归获取剩下部分的栈底元素</span></span><br><span class="line">            stack.append(ans)  <span class="comment"># 在递归返回过程中，将之前弹出的ans重新压栈</span></span><br><span class="line">            <span class="keyword">return</span> last  <span class="comment"># 将从递归深处得到的last一路返回上去</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原栈: [1, 2, 3, 4, 5] (5在栈顶)</span><br><span class="line"></span><br><span class="line">第1次reverse调用:</span><br><span class="line">  bottom_out取出栈底1，栈变为[2, 3, 4, 5]</span><br><span class="line">  递归reverse([2, 3, 4, 5])</span><br><span class="line">  返回后将1压入栈顶</span><br><span class="line"></span><br><span class="line">第2次reverse调用:</span><br><span class="line">  bottom_out取出栈底2，栈变为[3, 4, 5]</span><br><span class="line">  递归reverse([3, 4, 5])</span><br><span class="line">  返回后将2压入栈顶</span><br><span class="line"></span><br><span class="line">...以此类推</span><br><span class="line"></span><br><span class="line">最终结果: [1, 2, 3, 4, 5] (1在栈顶)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n²)</li>
<li><strong>空间复杂度</strong>：O(n) (递归栈空间)</li>
<li><strong>核心技巧</strong>：双递归函数配合</li>
</ul>
<hr>
<h2 id="题目六：用递归排序一个栈"><a href="#题目六：用递归排序一个栈" class="headerlink" title="题目六：用递归排序一个栈"></a>题目六：用递归排序一个栈</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>用递归函数排序栈，只能使用栈提供的push、pop、isEmpty三个方法，以及递归函数。要求排完序后，从栈顶到栈底从小到大。</p>
<p>除此之外不能使用任何的容器，数组也不行。就是排序过程中只能用：(1) 栈提供的push、pop、isEmpty三个方法，(2) 递归函数，并且返回值最多为单个整数</p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个类似选择排序的递归实现。</p>
<ol>
<li>整个排序过程分为 <code>deep</code> 轮，<code>deep</code> 是当前未排序部分的栈深度。</li>
<li>在每一轮中，目标是找出这 <code>deep</code> 个元素中的最大值（可能不止一个），并将它们“沉”到这 <code>deep</code> 个元素的最底部。</li>
<li><code>_max()</code> 函数：递归地在 <code>deep</code> 层中找到最大值。</li>
<li><code>_times()</code> 函数：递归地在 <code>deep</code> 层中统计这个最大值出现了几次 <code>k</code>。</li>
<li><code>_down()</code> 函数：递归地将这 <code>k</code> 个最大值移动到 <code>deep</code> 层的底部，同时保持其他 <code>deep-k</code> 个元素的相对顺序。</li>
<li>完成一轮后，未排序的深度减少 <code>k</code> (<code>deep -= k</code>)，然后对剩下的 <code>deep</code> 个元素重复此过程。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6.png" alt="排列栈_整体框架"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_deep%E6%96%B9%E6%B3%95.png" alt="排列栈_deep方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_max%E6%96%B9%E6%B3%95.png" alt="排列栈_max方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_times%E6%96%B9%E6%B3%95.png" alt="排列栈_times方法"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%8E%92%E5%88%97%E6%A0%88_down%E6%96%B9%E6%B3%95.png" alt="排列栈_down方法"></p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort_stack</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        deep = <span class="variable language_">self</span>._deep(stack)</span><br><span class="line">        <span class="keyword">while</span> deep &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 找到当前 deep 范围内的最大值</span></span><br><span class="line">            maximum = <span class="variable language_">self</span>._<span class="built_in">max</span>(stack, deep)</span><br><span class="line">            <span class="comment"># 统计最大值出现的次数</span></span><br><span class="line">            k = <span class="variable language_">self</span>._times(stack, deep, maximum)</span><br><span class="line">            <span class="comment"># 将这 k 个最大值沉底</span></span><br><span class="line">            <span class="variable language_">self</span>._down(stack, deep, maximum, k)</span><br><span class="line">            <span class="comment"># 待排序的深度减少 k</span></span><br><span class="line">            deep -= k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_deep</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈的深度，不改变栈的数据状况&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = stack.pop()</span><br><span class="line">        deep = <span class="variable language_">self</span>._deep(stack) + <span class="number">1</span></span><br><span class="line">        stack.append(num)  <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> deep</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_max</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>], deep: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从栈当前的顶部开始，往下数deep层，返回这deep层里的最大值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 返回一个极小值作为基准</span></span><br><span class="line">        num = stack.pop()</span><br><span class="line">        rest_max = <span class="variable language_">self</span>._<span class="built_in">max</span>(stack, deep - <span class="number">1</span>)</span><br><span class="line">        current_max = <span class="built_in">max</span>(num, rest_max)</span><br><span class="line">        stack.append(num)  <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> current_max</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_times</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>], deep: <span class="built_in">int</span>, maximum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回maximum在deep层中出现的次数，不改变栈的数据状况&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = stack.pop()</span><br><span class="line">        rest_times = <span class="variable language_">self</span>._times(stack, deep - <span class="number">1</span>, maximum)</span><br><span class="line">        times = rest_times + (<span class="number">1</span> <span class="keyword">if</span> num == maximum <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        stack.append(num)  <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_down</span>(<span class="params">self, stack: <span class="type">List</span>[<span class="built_in">int</span>], deep: <span class="built_in">int</span>, maximum: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将k个最大值沉到deep层的底部，剩下的数据状况不变&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 递归到底部时，先把k个最大值压入栈</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                stack.append(maximum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = stack.pop()</span><br><span class="line">            <span class="variable language_">self</span>._down(stack, deep - <span class="number">1</span>, maximum, k)</span><br><span class="line">            <span class="comment"># 在递归返回时，只把非最大值的元素压回去</span></span><br><span class="line">            <span class="keyword">if</span> num != maximum:</span><br><span class="line">                stack.append(num)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n²)</li>
<li><strong>空间复杂度</strong>：O(n) (递归栈空间)</li>
<li><strong>核心技巧</strong>：多递归函数配合 + 选择排序思想</li>
</ul>
<hr>
<h2 id="题目七：打印n层汉诺塔问题的最优移动轨迹"><a href="#题目七：打印n层汉诺塔问题的最优移动轨迹" class="headerlink" title="题目七：打印n层汉诺塔问题的最优移动轨迹"></a>题目七：打印n层汉诺塔问题的最优移动轨迹</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>打印n层汉诺塔问题的最优移动轨迹。</p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p>这是一个经典的递归分治问题。要将 i 个盘子从 A 移动到 C：</p>
<ol>
<li>先将 i-1 个盘子从 A 移动到 B (辅助柱)。</li>
<li>再将第 i 个盘子 (最大的那个) 从 A 移动到 C。</li>
<li>最后将 i-1 个盘子从 B 移动到 C。<br>这个过程完美地将一个大问题分解为两个规模更小的相同问题和一个简单的单步操作。</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.png" alt="汉诺塔问题描述"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E6%9C%80%E4%BC%98%E7%A7%BB%E5%8A%A8%E8%BD%A8%E8%BF%B9.png" alt="汉诺塔的最优移动轨迹"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(15)/class38-%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%B5%81%E7%A8%8B.png" alt="汉诺塔的抽象流程"></p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TowerOfHanoi</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        汉诺塔问题主函数入口</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>._f(n, <span class="string">&quot;左&quot;</span>, <span class="string">&quot;右&quot;</span>, <span class="string">&quot;中&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, i: <span class="built_in">int</span>, start: <span class="built_in">str</span>, end: <span class="built_in">str</span>, other: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，解决将 i 个圆盘从 start 移动到 end 的问题</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case：如果只有一个圆盘，直接移动</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;移动圆盘 1 从 <span class="subst">&#123;start&#125;</span> 到 <span class="subst">&#123;end&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 步骤1: 将 i-1 个圆盘从 start 移动到 other</span></span><br><span class="line">            <span class="variable language_">self</span>._f(i - <span class="number">1</span>, start, other, end)</span><br><span class="line">            <span class="comment"># 步骤2: 移动第 i 个圆盘从 start 到 end</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;移动圆盘 <span class="subst">&#123;i&#125;</span> 从 <span class="subst">&#123;start&#125;</span> 到 <span class="subst">&#123;end&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 步骤3: 将 i-1 个圆盘从 other 移动到 end</span></span><br><span class="line">            <span class="variable language_">self</span>._f(i - <span class="number">1</span>, other, end, start)</span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例（n-3）"><a href="#执行过程示例（n-3）" class="headerlink" title="执行过程示例（n&#x3D;3）"></a>执行过程示例（n&#x3D;3）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决 3 层汉诺塔问题的步骤：</span><br><span class="line">移动圆盘 1 从 左 到 右</span><br><span class="line">移动圆盘 2 从 左 到 中</span><br><span class="line">移动圆盘 1 从 右 到 中</span><br><span class="line">移动圆盘 3 从 左 到 右</span><br><span class="line">移动圆盘 1 从 中 到 左</span><br><span class="line">移动圆盘 2 从 中 到 右</span><br><span class="line">移动圆盘 1 从 左 到 右</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(2^n)</li>
<li><strong>空间复杂度</strong>：O(n) (递归栈空间)</li>
<li><strong>核心技巧</strong>：递归分治</li>
</ul>
<hr>
<h2 id="递归技巧总结"><a href="#递归技巧总结" class="headerlink" title="递归技巧总结"></a>递归技巧总结</h2><h3 id="1-递归模板"><a href="#1-递归模板" class="headerlink" title="1. 递归模板"></a>1. 递归模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_function</span>(<span class="params">parameters</span>):</span><br><span class="line">    <span class="comment"># base case: 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> base_condition:</span><br><span class="line">        <span class="keyword">return</span> base_result</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归调用：分解问题</span></span><br><span class="line">    result = recursive_function(modified_parameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理当前层的逻辑</span></span><br><span class="line">    current_result = process(result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> current_result</span><br></pre></td></tr></table></figure>

<h3 id="2-回溯模板"><a href="#2-回溯模板" class="headerlink" title="2. 回溯模板"></a>2. 回溯模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, choices</span>):</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> satisfied:</span><br><span class="line">        result.append(path[:])  <span class="comment"># 收集结果</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        path.append(choice)</span><br><span class="line">        backtrack(path, remaining_choices)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>

<h3 id="3-常见递归模式"><a href="#3-常见递归模式" class="headerlink" title="3. 常见递归模式"></a>3. 常见递归模式</h3><h4 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对每个元素有选择：要 or 不要</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">i, path</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        process(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 要当前元素</span></span><br><span class="line">    path.append(arr[i])</span><br><span class="line">    choose(i + <span class="number">1</span>, path)</span><br><span class="line">    path.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不要当前元素</span></span><br><span class="line">    choose(i + <span class="number">1</span>, path)</span><br></pre></td></tr></table></figure>

<h4 id="交换模式"><a href="#交换模式" class="headerlink" title="交换模式"></a>交换模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全排列问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">arr, i</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        process(arr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(arr)):</span><br><span class="line">        swap(arr, i, j)</span><br><span class="line">        permute(arr, i + <span class="number">1</span>)</span><br><span class="line">        swap(arr, i, j)  <span class="comment"># 回溯</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心技巧</th>
</tr>
</thead>
<tbody><tr>
<td>字符串子序列</td>
<td>O(2^n × n)</td>
<td>O(2^n × n)</td>
<td>选择模式 + set去重</td>
</tr>
<tr>
<td>数组组合</td>
<td>O(2^n × n)</td>
<td>O(2^n × n)</td>
<td>排序 + 剪枝去重</td>
</tr>
<tr>
<td>无重复全排列</td>
<td>O(n! × n)</td>
<td>O(n!)</td>
<td>交换模式 + 回溯</td>
</tr>
<tr>
<td>有重复全排列</td>
<td>O(n! × n)</td>
<td>O(n!)</td>
<td>交换模式 + 集合去重</td>
</tr>
<tr>
<td>递归逆序栈</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>双递归函数</td>
</tr>
<tr>
<td>递归排序栈</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>多递归函数</td>
</tr>
<tr>
<td>汉诺塔</td>
<td>O(2^n)</td>
<td>O(n)</td>
<td>递归分治</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>理解递归本质</strong>：递归就是函数调用自己，关键在于找到递归关系和base case</p>
</li>
<li><p><strong>掌握常见模式</strong>：</p>
<ul>
<li>选择模式（子集、组合问题）</li>
<li>交换模式（排列问题）</li>
<li>分治模式（汉诺塔、归并排序等）</li>
</ul>
</li>
<li><p><strong>注意回溯时机</strong>：</p>
<ul>
<li>何时需要回溯（恢复现场）</li>
<li>何时不需要回溯（使用额外空间）</li>
</ul>
</li>
<li><p><strong>优化技巧</strong>：</p>
<ul>
<li>剪枝去重 vs set去重</li>
<li>空间复用（固定长度数组 + size指针）</li>
<li>预处理（排序、哈希表等）</li>
</ul>
</li>
<li><p><strong>递归栈深度</strong>：注意递归深度，避免栈溢出</p>
</li>
<li><p><strong>实践建议</strong>：</p>
<ul>
<li>多画递归树理解执行过程</li>
<li>从简单案例开始推导</li>
<li>注意边界条件的处理</li>
</ul>
</li>
</ol>
<p>递归是解决很多复杂问题的有力工具，掌握好递归的思想和常见模式，可以大大提升解决问题的能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（14）- 二叉树高频题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-22 10:30:00 / Modified: 20:53:28" itemprop="dateCreated datePublished" datetime="2025-08-22T10:30:00+08:00">2025-08-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class036→037的内容，总结了二叉树相关的9+7&#x3D;16道高频算法题目。class36涵盖了二叉树的遍历、序列化、构造、验证等核心操作，但不包含树型动态规划的内容。class037算是036的补充，讲了二叉树相关的另外7道高频算法题目，包含了最近公共祖先（LCA）问题、路径搜索、平衡性验证、搜索二叉树相关操作。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习二叉树高频题目之前，需要掌握以下基础知识：</p>
<ul>
<li>队列用数组实现（讲解013）</li>
<li>二叉树入门内容（讲解017~018）</li>
</ul>
<h2 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h2><ul>
<li>本期和下期视频会讲解二叉树高频题目，但不含树型dp的题目</li>
<li>树型dp问题会放在【必备】课程的动态规划大章节部分讲述</li>
<li>树型dp中的换根dp问题会放在【扩展】课程的动态规划大章节部分讲述</li>
<li>AVL树的实现、树的左旋右旋等内容也会在【扩展】课程里讲述</li>
<li>问题1又叫LCA问题，非常重要！Tarjan算法解决LCA的批量查询、树链剖分算法解决LCA的在线查询会在【扩展】课程讲述</li>
<li>数组的打家劫舍问题变形很多，会在【必备】课程的动态规划大章节部分讲述</li>
<li>再次强调树型dp的整体讲解，会在【必备】课程的动态规划大章节部分讲述</li>
</ul>
<hr>
<h1 id="036【必备】二叉树高频题目-上-不含树型dp"><a href="#036【必备】二叉树高频题目-上-不含树型dp" class="headerlink" title="036【必备】二叉树高频题目-上-不含树型dp"></a>036【必备】二叉树高频题目-上-不含树型dp</h1><h2 id="初始化的二叉树类"><a href="#初始化的二叉树类" class="headerlink" title="初始化的二叉树类"></a>初始化的二叉树类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br></pre></td></tr></table></figure>

<h2 id="题目一：二叉树的层序遍历"><a href="#题目一：二叉树的层序遍历" class="headerlink" title="题目一：二叉树的层序遍历"></a>题目一：二叉树的层序遍历</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉树的根节点 root，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用广度优先搜索（BFS）进行层序遍历，有两种实现方式：</p>
<ol>
<li><strong>普通BFS</strong>：使用队列存储节点，用哈希表记录每个节点的层级</li>
<li><strong>优化BFS</strong>：按层处理，每次处理完整一层的所有节点</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="层序遍历的实现"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B02.png" alt="层序遍历的实现2"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：普通BFS"><a href="#方法一：普通BFS" class="headerlink" title="方法一：普通BFS"></a>方法一：普通BFS</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时把方法名改为levelOrder，此方法为普通bfs（宽度/广度优先搜索，叫宽度搜索的原因是层的最大节点数为宽度），此题不推荐</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder1</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 核心思想：标准的广度优先搜索（BFS）。</span></span><br><span class="line">    <span class="comment"># 使用一个队列存储待访问节点，同时用一个哈希表（字典）来记录每个节点所在的层级。</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> root:<span class="comment">#根节点有东西</span></span><br><span class="line">        <span class="comment"># Python的deque是一个高效的双端队列，非常适合用于BFS</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="comment"># 字典用于存储 node -&gt; level 的映射</span></span><br><span class="line">        levels = &#123;root: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:<span class="comment"># 队列不空的时候从队列中取出一个节点</span></span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            level = levels[cur]                </span><br><span class="line">            <span class="comment"># 如果当前层级是第一次遇到，就在ans中创建一个新列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) == level: <span class="comment">#ans 列表的长度总是等于当前已经处理过的层级数量，包括第0层，说明当前节点的层级 level 正好等于已经创建的层级数量，味着这个层级还没有被处理过，需要创建新的列表</span></span><br><span class="line">                ans.append([])               </span><br><span class="line">            <span class="comment"># 将当前节点的值加入对应层级的列表</span></span><br><span class="line">            ans[level].append(cur.val)              </span><br><span class="line">            <span class="comment"># 将子节点加入队列，并记录它们的层级</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append(cur.left)</span><br><span class="line">                levels[cur.left] = level + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append(cur.right)</span><br><span class="line">                levels[cur.right] = level + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    <span class="comment"># 核心思想：标准的广度优先搜索（BFS），使用一个队列存储待访问节点，</span></span><br><span class="line">    <span class="comment"># 同时用一个哈希表（字典）来记录每个节点所在的层级。</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二：优化BFS（推荐）"><a href="#方法二：优化BFS（推荐）" class="headerlink" title="方法二：优化BFS（推荐）"></a>方法二：优化BFS（推荐）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder2</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 核心思想：优化的广度优先搜索（BFS），按层处理。</span></span><br><span class="line">    <span class="comment"># 外层while循环控制层级，内层for循环精确地处理当前层的所有节点。</span></span><br><span class="line">    <span class="comment"># 这样就无需额外的哈希表来存储节点的层级信息。</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment"># 当队列不为空，说明还有节点待处理</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue) <span class="comment"># 当前层的节点数量</span></span><br><span class="line">            level_list = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size): <span class="comment"># 精确处理当前层的所有节点</span></span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level_list.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: <span class="comment"># 将下一层节点入队</span></span><br><span class="line">                    queue.append(cur.left) </span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right) <span class="comment"># append是加在右边的</span></span><br><span class="line">            ans.append(level_list)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以树结构 <code>1-&gt;2,3; 2-&gt;4,5; 3-&gt;6</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始状态：queue = [1], ans = []</span><br><span class="line"></span><br><span class="line">处理第0层：</span><br><span class="line">  size = 1, level_list = []</span><br><span class="line">  取出节点1，level_list = [1]</span><br><span class="line">  将节点2,3入队，queue = [2, 3]</span><br><span class="line">  ans = [[1]]</span><br><span class="line"></span><br><span class="line">处理第1层：</span><br><span class="line">  size = 2, level_list = []</span><br><span class="line">  取出节点2，level_list = [2]，将4,5入队</span><br><span class="line">  取出节点3，level_list = [2, 3]，将6入队</span><br><span class="line">  queue = [4, 5, 6]</span><br><span class="line">  ans = [[1], [2, 3]]</span><br><span class="line"></span><br><span class="line">处理第2层：</span><br><span class="line">  size = 3, level_list = []</span><br><span class="line">  依次取出4,5,6，level_list = [4, 5, 6]</span><br><span class="line">  ans = [[1], [2, 3], [4, 5, 6]]</span><br></pre></td></tr></table></figure>


<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，N为节点数</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：按层BFS遍历</li>
</ul>
<hr>
<h2 id="题目二：二叉树的锯齿形层序遍历"><a href="#题目二：二叉树的锯齿形层序遍历" class="headerlink" title="题目二：二叉树的锯齿形层序遍历"></a>题目二：二叉树的锯齿形层序遍历</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>在按层BFS的基础上，增加一个布尔标记 <code>reverse</code>。每一层遍历结束后，根据 <code>reverse</code> 的值决定是否要将当前层收集到的节点值列表进行反转。</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交以下的方法</span></span><br><span class="line"><span class="comment"># 用每次处理一层的优化bfs就非常容易实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="comment"># 核心思想：在按层BFS的基础上，增加一个布尔标记 `reverse`。</span></span><br><span class="line">    <span class="comment"># 每一层遍历结束后，根据 `reverse` 的值决定是否要将当前层收集到的节点值列表进行反转。</span></span><br><span class="line">    <span class="comment"># 然后切换 `reverse` 的状态，供下一层使用。</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="comment"># false 代表从左往右</span></span><br><span class="line">        <span class="comment"># true 代表从右往左</span></span><br><span class="line">        reverse = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level_list = []</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤1: 像常规的按层BFS一样，先收集当前层的所有节点值</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level_list.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤2: 根据reverse标记决定是否反转当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span> reverse:</span><br><span class="line">                level_list.reverse()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 步骤3: 将处理好的层列表加入结果，并切换reverse标记</span></span><br><span class="line">            ans.append(level_list)</span><br><span class="line">            reverse = <span class="keyword">not</span> reverse</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：层序遍历 + 交替反转</li>
</ul>
<hr>
<h2 id="题目三：二叉树的最大特殊宽度"><a href="#题目三：二叉树的最大特殊宽度" class="headerlink" title="题目三：二叉树的最大特殊宽度"></a>题目三：二叉树的最大特殊宽度</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树的宽度与满二叉树相同，但不一定是满的。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>给每个节点进行编号，就像在一个完全二叉树中一样。根节点编号为1，其左子节点为 2<em>i，右子节点为 2</em>i + 1。每一层的宽度就等于该层最右边节点的编号减去最左边节点的编号，再加1。</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">widthOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 核心思想：给每个节点进行编号，就像在一个完全二叉树中一样。</span></span><br><span class="line">    <span class="comment"># 根节点编号为1，其左子节点为 2*i，右子节点为 2*i + 1。</span></span><br><span class="line">    <span class="comment"># 每一层的宽度就等于该层最右边节点的编号减去最左边节点的编号，再加1。</span></span><br><span class="line">    <span class="comment"># 我们使用按层BFS来遍历，同时在队列中存储 (节点, 编号) 对。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 队列中存储 (节点, 节点编号) 的元组</span></span><br><span class="line">    queue = deque([(root, <span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment"># 记录当前层的起始编号</span></span><br><span class="line">        start_id = queue[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node, node_id = queue.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 在遍历到当前层最后一个节点时，计算宽度，这个是额外的步骤</span></span><br><span class="line">            <span class="keyword">if</span> i == size - <span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, node_id - start_id + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将子节点及其新编号加入队列</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append((node.left, node_id * <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append((node.right, node_id * <span class="number">2</span> + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：完全二叉树编号规则</li>
</ul>
<hr>
<h2 id="题目四：求二叉树的最大深度、最小深度"><a href="#题目四：求二叉树的最大深度、最小深度" class="headerlink" title="题目四：求二叉树的最大深度、最小深度"></a>题目四：求二叉树的最大深度、最小深度</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li>求二叉树的最大深度</li>
<li>求二叉树的最小深度</li>
</ol>
<p><strong>测试链接</strong>：</p>
<ul>
<li>最大深度：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></li>
<li>最小深度：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></li>
</ul>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><h4 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h4><p>核心思想：递归。一棵树的最大深度等于其左、右子树最大深度中的较大者，再加1（根节点本身）。空树的深度为0，这是递归的基准情况，一定要到叶节点底部。</p>
<h4 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h4><p>递归，但需要特殊处理。最小深度是从根节点到最近的”叶子节点”的路径长度。如果一个节点只有一个子树，那么我们必须沿着这个非空的子树继续寻找叶子节点。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%B1%82%E5%AD%90%E6%A0%91%E6%9C%80%E5%A4%A7or%E5%B0%8F%E6%B7%B1%E5%BA%A6.png" alt="求子树最大or小深度"></p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="最大深度-1"><a href="#最大深度-1" class="headerlink" title="最大深度"></a>最大深度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.maxDepth(root.left), <span class="variable language_">self</span>.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="最小深度-1"><a href="#最小深度-1" class="headerlink" title="最小深度"></a>最小深度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="comment"># 当前的树是空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    left_depth = <span class="variable language_">self</span>.minDepth(root.left)</span><br><span class="line">    right_depth = <span class="variable language_">self</span>.minDepth(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># case 1: 如果左子树或右子树为空，我们不能取它为最小值（因为那条路没有叶子）。</span></span><br><span class="line">    <span class="comment"># 此时必须走另一条非空的路。`left_depth + right_depth + 1` 巧妙地处理了</span></span><br><span class="line">    <span class="comment"># (左=0, 右=N) -&gt; N+1 和 (左=N, 右=0) -&gt; N+1 的情况。</span></span><br><span class="line">    <span class="keyword">if</span> left_depth == <span class="number">0</span> <span class="keyword">or</span> right_depth == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> left_depth + right_depth + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># case 2: 如果左右子树都不为空，那么最小深度就是两者中的较小值加1。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(left_depth, right_depth) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：递归分治</li>
</ul>
<hr>
<h2 id="题目五：二叉树先序序列化和反序列化"><a href="#题目五：二叉树先序序列化和反序列化" class="headerlink" title="题目五：二叉树先序序列化和反序列化"></a>题目五：二叉树先序序列化和反序列化</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个算法来序列化和反序列化二叉树。将树转换为字符串（序列化），再将字符串转换为树（反序列化）。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化与反序列化"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="层序遍历反序列化"></p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>使用先序遍历（根-左-右）将树递归地转换成字符串。空节点用特殊字符’#’表示，节点之间用’,’分隔。</p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>利用先序遍历的顺序，递归地重建树。字符串按’,’分割成列表，然后用一个迭代器顺序消费这些值来构建节点。</p>
<h3 id="重要说明-1"><a href="#重要说明-1" class="headerlink" title="重要说明"></a>重要说明</h3><p>二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，但是<strong>无法通过中序遍历</strong>的方式实现序列化和反序列化，因为不同的两棵树可能得到同样的中序序列。</p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中序遍历的反面例子，比如如下两棵树</span></span><br><span class="line"><span class="comment">#         __2</span></span><br><span class="line"><span class="comment">#        /</span></span><br><span class="line"><span class="comment">#       1</span></span><br><span class="line"><span class="comment">#       和</span></span><br><span class="line"><span class="comment">#       1__</span></span><br><span class="line"><span class="comment">#          \</span></span><br><span class="line"><span class="comment">#           2</span></span><br><span class="line"><span class="comment"># 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交这个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用先序遍历（根-左-右）将树递归地转换成字符串。</span></span><br><span class="line">        <span class="comment"># 空节点用特殊字符&#x27;#&#x27;表示，节点之间用&#x27;,&#x27;分隔。 #叫sharp</span></span><br><span class="line">        res = [] <span class="comment">#res是结果列表result</span></span><br><span class="line">        <span class="variable language_">self</span>._f(root, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, root, res</span>): <span class="comment"># 递归函数求先序遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            res.append(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        <span class="variable language_">self</span>._f(root.left, res)</span><br><span class="line">        <span class="variable language_">self</span>._f(root.right, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># 核心思想：利用先序遍历的顺序，递归地重建树。</span></span><br><span class="line">        <span class="comment"># 字符串按&#x27;,&#x27;分割成列表，然后用一个迭代器顺序消费这些值来构建节点。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        vals = <span class="built_in">iter</span>(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._g(vals)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_g</span>(<span class="params">self, vals</span>): <span class="comment"># 递归函数求反序列化</span></span><br><span class="line">        val = <span class="built_in">next</span>(vals) <span class="comment"># 迭代器，next是取下一个值，val是理论上是字符串，next能逐个取值</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先构建根节点，然后递归构建左子树，再递归构建右子树</span></span><br><span class="line">        head = Code05_PreorderSerializeAndDeserialize.TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">        head.left = <span class="variable language_">self</span>._g(vals)</span><br><span class="line">        head.right = <span class="variable language_">self</span>._g(vals)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：先序遍历 + 迭代器</li>
</ul>
<hr>
<h2 id="题目六：二叉树按层序列化和反序列化"><a href="#题目六：二叉树按层序列化和反序列化" class="headerlink" title="题目六：二叉树按层序列化和反序列化"></a>题目六：二叉树按层序列化和反序列化</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用层序遍历的方式实现二叉树的序列化和反序列化。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>使用广度优先搜索（BFS）进行层序遍历。队列中的每个节点，都将其左右子节点（即使是None）的信息加入结果字符串。</p>
<h4 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h4><p>同样使用BFS和队列来重建树。先创建根节点并入队，然后依次出队父节点，并从字符串值列表中读出左右子节点的信息进行构建和连接。</p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交这个类，补点思想即：把所有空节点也序列化/反序列化出来，不遗漏任何节点位置。</span></span><br><span class="line"><span class="comment"># 按层序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用广度优先搜索（BFS）进行层序遍历。</span></span><br><span class="line">        <span class="comment"># 队列中的每个节点，都将其左右子节点（即使是None）的信息加入结果字符串。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>  <span class="comment"># 空树直接返回空字符串</span></span><br><span class="line">        res = []</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                res.append(<span class="built_in">str</span>(cur.val))  <span class="comment"># 记录当前节点值</span></span><br><span class="line">                queue.append(cur.left)    <span class="comment"># 即使是None也加入队列，补点思想</span></span><br><span class="line">                queue.append(cur.right)   <span class="comment"># 即使是None也加入队列，补点思想</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">&quot;#&quot;</span>)  <span class="comment"># 用&#x27;#&#x27;表示空节点，补点思想</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(res)  <span class="comment"># 用逗号连接成字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># 核心思想：同样使用BFS和队列来重建树。</span></span><br><span class="line">        <span class="comment"># 先创建根节点并入队，然后依次出队父节点，并从字符串值列表中读出左右子节点的信息进行构建和连接。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 空字符串返回空树</span></span><br><span class="line">        nodes = data.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># 字符串按逗号分割成列表</span></span><br><span class="line">        root = <span class="variable language_">self</span>.generate(nodes[<span class="number">0</span>])  <span class="comment"># 构建根节点</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        index = <span class="number">1</span>  <span class="comment"># 指向下一个要处理的节点值在nodes中的位置</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            parent = queue.popleft() <span class="comment">#这个循环是按层从顶到下遍历的，parent是父节点</span></span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nodes):</span><br><span class="line">                <span class="comment"># 生成父节点的左孩子，补点思想</span></span><br><span class="line">                parent.left = <span class="variable language_">self</span>.generate(nodes[index])</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nodes):</span><br><span class="line">                <span class="comment"># 生成父节点的右孩子，补点思想</span></span><br><span class="line">                parent.right = <span class="variable language_">self</span>.generate(nodes[index])</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 只将非空子节点入队</span></span><br><span class="line">            <span class="keyword">if</span> parent.left:</span><br><span class="line">                queue.append(parent.left)</span><br><span class="line">            <span class="keyword">if</span> parent.right:</span><br><span class="line">                queue.append(parent.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 空点返回None，补点思想</span></span><br><span class="line">        <span class="keyword">return</span> Code06_LevelorderSerializeAndDeserialize.TreeNode(<span class="built_in">int</span>(val))  <span class="comment"># 普通点返回节点对象</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：层序遍历 + 补点思想</li>
</ul>
<hr>
<h2 id="题目七：利用先序与中序遍历序列构造二叉树"><a href="#题目七：利用先序与中序遍历序列构造二叉树" class="headerlink" title="题目七：利用先序与中序遍历序列构造二叉树"></a>题目七：利用先序与中序遍历序列构造二叉树</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。要求没有重复元素。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%85%88%E5%BA%8F+%E4%B8%AD%E5%BA%8F%E9%87%8D%E6%9E%84%E6%A0%91.png" alt="先序+中序重构树"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%85%88%E5%BA%8F+%E4%B8%AD%E5%BA%8F%E9%87%8D%E6%9E%84%E6%A0%912.png" alt="先序+中序重构树2"></p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p>递归分治。先序遍历的第一个元素是当前子树的根。在中序遍历中找到这个根，其左边的所有元素构成左子树，右边的所有元素构成右子树。根据左子树的元素数量，可以确定先序遍历中左右子树的范围，从而递归构建。</p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交如下的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, pre: <span class="type">List</span>[<span class="built_in">int</span>], tin: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin <span class="keyword">or</span> <span class="built_in">len</span>(pre) != <span class="built_in">len</span>(tin):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 为了快速查找根节点在中序遍历中的位置，预处理成哈希表</span></span><br><span class="line">    in_map = &#123;val: i <span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(tin)&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._f(pre, <span class="number">0</span>, <span class="built_in">len</span>(pre) - <span class="number">1</span>, tin, <span class="number">0</span>, <span class="built_in">len</span>(tin) - <span class="number">1</span>, in_map) <span class="comment">#初始化方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, pre, l1, r1, tin, l2, r2, in_map</span>):</span><br><span class="line">    <span class="keyword">if</span> l1 &gt; r1:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    head = <span class="variable language_">self</span>.TreeNode(pre[l1])</span><br><span class="line">    <span class="keyword">if</span> l1 == r1: <span class="comment"># 如果l1和r1相等，说明只有一个节点，直接返回head</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># k是根节点在中序遍历中的位置</span></span><br><span class="line">    k = in_map[pre[l1]]</span><br><span class="line">    <span class="comment"># 左子树的节点数量</span></span><br><span class="line">    left_size = k - l2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归构建左子树和右子树</span></span><br><span class="line">    <span class="comment"># pre : l1(........)[.......r1] -&gt; l1是根, (l1+1...l1+left_size)是左子树, (...)是右子树</span></span><br><span class="line">    <span class="comment"># in  : (l2......)k[........r2] -&gt; k是根, (l2...k-1)是左子树, [...]是右子树</span></span><br><span class="line">    head.left = <span class="variable language_">self</span>._f(pre, l1 + <span class="number">1</span>, l1 + left_size, tin, l2, k - <span class="number">1</span>, in_map)</span><br><span class="line">    head.right = <span class="variable language_">self</span>._f(pre, l1 + left_size + <span class="number">1</span>, r1, tin, k + <span class="number">1</span>, r2, in_map)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：递归分治 + 哈希表优化</li>
</ul>
<hr>
<h2 id="题目八：验证完全二叉树"><a href="#题目八：验证完全二叉树" class="headerlink" title="题目八：验证完全二叉树"></a>题目八：验证完全二叉树</h2><h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，确定它是否是一个完全二叉树。在一棵完全二叉树中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都要靠左。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">https://leetcode.cn/problems/check-completeness-of-a-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="判断完全二叉树"></p>
<h3 id="核心思想-7"><a href="#核心思想-7" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用BFS进行层序遍历。一棵完全二叉树有两个特点：</p>
<ol>
<li>任何节点不能只有右孩子没有左孩子</li>
<li>在层序遍历中，一旦遇到第一个孩子不双全的节点，之后遇到的所有节点都必须是叶子节点</li>
</ol>
<h3 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交以下的方法，实际上是一个又一个节点的bfs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isCompleteTree</span>(<span class="params">self, h: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> h:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    queue = deque([h])</span><br><span class="line">    <span class="comment"># 是否遇到过左右两个孩子不双全的节点</span></span><br><span class="line">    leaf_stage = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="comment"># case 1: 如果一个节点只有右孩子没有左孩子，必不是完全二叉树</span></span><br><span class="line">        <span class="comment"># case 2: 如果已经遇到了不双全的节点(进入leaf_stage)，后面又出现了孩子节点，也不是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> node.left <span class="keyword">and</span> node.right) <span class="keyword">or</span> \</span><br><span class="line">            (leaf_stage <span class="keyword">and</span> (node.left <span class="keyword">or</span> node.right)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一旦遇到孩子不双全的节点，就进入leaf_stage设为true，下一次循环中进行判断</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            leaf_stage = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：BFS + 状态标记</li>
</ul>
<hr>
<h2 id="题目九：求完全二叉树的节点个数"><a href="#题目九：求完全二叉树的节点个数" class="headerlink" title="题目九：求完全二叉树的节点个数"></a>题目九：求完全二叉树的节点个数</h2><h3 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个完全二叉树，求出该树的节点个数。要求时间复杂度低于O(N)。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9.png" alt="统计完全二叉树节点"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class36-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B92.png" alt="统计完全二叉树节点2"></p>
<h3 id="核心思想-8"><a href="#核心思想-8" class="headerlink" title="核心思想"></a>核心思想</h3><p>利用完全二叉树的性质进行优化。对于任意节点，其左子树和右子树中，至少有一个是满二叉树。通过比较左右子树的高度，可以判断出哪个是满二叉树，从而用公式 (2^h - 1) 快速计算其节点数，然后只需递归计算另一半子树。每次递归都会下降一层，所以递归深度最多是 O(logN)，每次调用 _mostLeft 的时间复杂度是 O(logN)，这使得时间复杂度从O(N)降低到O((logN)^2)。</p>
<h3 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, head: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    h = <span class="variable language_">self</span>._mostLeft(head, <span class="number">1</span>)  <span class="comment"># 计算整棵树的高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._f(head, <span class="number">1</span>, h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params">self, cur, level, h</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    cur: 当前来到的节点</span></span><br><span class="line"><span class="string">    level: 当前cur来到的节点在第几层</span></span><br><span class="line"><span class="string">    h: 整棵树的高度</span></span><br><span class="line"><span class="string">    返回: cur这棵子树上有多少节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> level == h: <span class="comment"># base case: 遍历到了最底层</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果右子树的最左路径能到达整棵树的最后一层</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._mostLeft(cur.right, level + <span class="number">1</span>) == h:</span><br><span class="line">        <span class="comment"># 说明cur的左子树是满二叉树，其节点数可以直接计算</span></span><br><span class="line">        <span class="comment"># 节点总数 = 左子树节点数(2^(h-level)-1) + 根节点(1) + 递归求右子树节点数</span></span><br><span class="line">        <span class="comment"># 合并后就是 (1 &lt;&lt; (h - level)) + 递归求右子树</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level)) + <span class="variable language_">self</span>._f(cur.right, level + <span class="number">1</span>, h) <span class="comment">#1 &lt;&lt; n 表示将数字1向左移动n位</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#if else判断往左递归还是往右递归</span></span><br><span class="line">        <span class="comment"># 否则，说明cur的右子树是比左子树少一层的满二叉树</span></span><br><span class="line">        <span class="comment"># 节点总数 = 右子树节点数(2^(h-level-1)-1) + 根节点(1) + 递归求左子树节点数</span></span><br><span class="line">        <span class="comment"># 合并后就是 (1 &lt;&lt; (h - level - 1)) + 递归求左子树</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level - <span class="number">1</span>)) + <span class="variable language_">self</span>._f(cur.left, level + <span class="number">1</span>, h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_mostLeft</span>(<span class="params">self, cur, level</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    当前节点是cur，并且它在level层</span></span><br><span class="line"><span class="string">    返回从cur开始不停往左，能扎到几层</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">        cur = cur.left</span><br><span class="line">    <span class="keyword">return</span> level - <span class="number">1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O((logN)²)</li>
<li><strong>空间复杂度</strong>：O(logN)</li>
<li><strong>核心技巧</strong>：完全二叉树性质 + 满二叉树公式</li>
</ul>
<hr>
<h2 id="核心技巧总结"><a href="#核心技巧总结" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-BFS层序遍历"><a href="#1-BFS层序遍历" class="headerlink" title="1. BFS层序遍历"></a>1. BFS层序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准BFS模板</span></span><br><span class="line">queue = deque([root])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    size = <span class="built_in">len</span>(queue)  <span class="comment"># 当前层节点数</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):  <span class="comment"># 处理当前层</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="comment"># 处理当前节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br></pre></td></tr></table></figure>

<h3 id="2-树的递归"><a href="#2-树的递归" class="headerlink" title="2. 树的递归"></a>2. 树的递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 处理当前节点</span></span><br><span class="line">    traverse(root.left)   <span class="comment"># 递归左子树</span></span><br><span class="line">    traverse(root.right)  <span class="comment"># 递归右子树</span></span><br></pre></td></tr></table></figure>

<h3 id="3-完全二叉树编号"><a href="#3-完全二叉树编号" class="headerlink" title="3. 完全二叉树编号"></a>3. 完全二叉树编号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根节点编号为1</span></span><br><span class="line"><span class="comment"># 左子节点编号为 2*i</span></span><br><span class="line"><span class="comment"># 右子节点编号为 2*i + 1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-序列化技巧"><a href="#4-序列化技巧" class="headerlink" title="4. 序列化技巧"></a>4. 序列化技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先序序列化：根-左-右</span></span><br><span class="line"><span class="comment"># 层序序列化：逐层BFS + 补点</span></span><br><span class="line"><span class="comment"># 中序无法唯一确定树结构</span></span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心算法</th>
</tr>
</thead>
<tbody><tr>
<td>层序遍历</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS</td>
</tr>
<tr>
<td>锯齿形遍历</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 反转</td>
</tr>
<tr>
<td>最大宽度</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 编号</td>
</tr>
<tr>
<td>最大&#x2F;最小深度</td>
<td>O(N)</td>
<td>O(H)</td>
<td>递归</td>
</tr>
<tr>
<td>先序序列化</td>
<td>O(N)</td>
<td>O(N)</td>
<td>递归 + 迭代器</td>
</tr>
<tr>
<td>层序序列化</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 补点</td>
</tr>
<tr>
<td>构造二叉树</td>
<td>O(N)</td>
<td>O(N)</td>
<td>递归 + 哈希表</td>
</tr>
<tr>
<td>验证完全二叉树</td>
<td>O(N)</td>
<td>O(N)</td>
<td>BFS + 状态</td>
</tr>
<tr>
<td>完全二叉树节点数</td>
<td>O((logN)²)</td>
<td>O(logN)</td>
<td>递归 + 性质</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>掌握BFS和DFS</strong>：这是处理树问题的两大基本方法</p>
</li>
<li><p><strong>理解递归本质</strong>：树的递归结构使得很多问题都可以用递归解决</p>
</li>
<li><p><strong>灵活运用数据结构</strong>：</p>
<ul>
<li>队列（BFS）</li>
<li>哈希表（快速查找）</li>
<li>迭代器（序列化处理）</li>
</ul>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空树处理</li>
<li>叶子节点判断</li>
<li>层级边界</li>
</ul>
</li>
<li><p><strong>理解树的性质</strong>：</p>
<ul>
<li>完全二叉树的特点</li>
<li>满二叉树的节点公式</li>
<li>不同遍历方式的特点</li>
</ul>
</li>
<li><p><strong>练习组合技巧</strong>：很多树的问题需要组合多种基础算法</p>
</li>
</ol>
<p>通过掌握这些经典的二叉树算法，可以为后续学习更复杂的树型动态规划和高级树结构打下坚实的基础。</p>
<h1 id="037【必备】二叉树高频题目-下-不含树型dp"><a href="#037【必备】二叉树高频题目-下-不含树型dp" class="headerlink" title="037【必备】二叉树高频题目-下-不含树型dp"></a>037【必备】二叉树高频题目-下-不含树型dp</h1><h2 id="初始化的二叉树类-1"><a href="#初始化的二叉树类-1" class="headerlink" title="初始化的二叉树类"></a>初始化的二叉树类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br></pre></td></tr></table></figure>

<h2 id="题目一：普通二叉树上寻找两个节点的最近公共祖先"><a href="#题目一：普通二叉树上寻找两个节点的最近公共祖先" class="headerlink" title="题目一：普通二叉树上寻找两个节点的最近公共祖先"></a>题目一：普通二叉树上寻找两个节点的最近公共祖先</h2><h3 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88.png" alt="普通二叉树查找最近共同祖先"></p>
<h3 id="核心思想-9"><a href="#核心思想-9" class="headerlink" title="核心思想"></a>核心思想</h3><p>采用递归的方式深度优先搜索：</p>
<ol>
<li>如果当前节点为空，或者等于p或q中的一个，那么它本身就是其子树中p或q的LCA</li>
<li>否则，递归地在左子树和右子树中寻找p和q</li>
<li>如果左右子树都返回了非空节点，说明p和q分别位于当前节点的两侧，当前节点就是LCA</li>
<li>如果只有一个子树返回了非空节点，说明p和q都在那个子树中，返回那个非空节点即可</li>
<li>如果左右子树都返回空，说明p和q都不在此子树中。</li>
</ol>
<h3 id="算法实现-9"><a href="#算法实现-9" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        寻找最近公共祖先的核心函数</span></span><br><span class="line"><span class="string">        采用递归的方式深度优先搜索</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遇到空，或者p，或者q，直接返回</span></span><br><span class="line">        <span class="comment"># 这是递归的基准情况 (base case)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="comment"># 如果root不空的话，这样从下往上会一直传p或者q</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在左子树和右子树中递归查找 p 和 q</span></span><br><span class="line">        l = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        r = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左树也搜到，右树也搜到，返回root</span></span><br><span class="line">        <span class="comment"># 这意味着p和q分别在root的左右两侧，root是它们的LCA</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> r:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果左右子树的搜索结果都为空，说明p,q不在此子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># l和r一个为空，一个不为空</span></span><br><span class="line">        <span class="comment"># 返回不空的那个，这个非空节点要么是p或q本身，要么已经是p和q的LCA</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> l <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，最坏情况下需要遍历所有节点</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度，递归栈的深度</li>
<li><strong>核心技巧</strong>：递归 + 分情况讨论</li>
</ul>
<hr>
<h2 id="题目二：搜索二叉树上寻找两个节点的最近公共祖先"><a href="#题目二：搜索二叉树上寻找两个节点的最近公共祖先" class="headerlink" title="题目二：搜索二叉树上寻找两个节点的最近公共祖先"></a>题目二：搜索二叉树上寻找两个节点的最近公共祖先</h2><h3 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88.png" alt="搜索二叉树查找最近共同祖先"></p>
<h3 id="核心思想-10"><a href="#核心思想-10" class="headerlink" title="核心思想"></a>核心思想</h3><p>利用BST的特性，可以高效地进行迭代查找：</p>
<ol>
<li>从根节点开始遍历</li>
<li>如果p和q的值都小于当前节点的值，说明LCA必定在左子树，往左走</li>
<li>如果p和q的值都大于当前节点的值，说明LCA必定在右子树，往右走</li>
<li>如果当前节点的值在p和q的值之间（或者等于其中一个），那么当前节点就是第一个”分叉点”，即为LCA</li>
</ol>
<h3 id="算法实现-10"><a href="#算法实现-10" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在二叉搜索树(BST)中寻找最近公共祖先</span></span><br><span class="line"><span class="string">        利用BST的特性，可以高效地进行迭代查找</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确定p和q节点值的范围</span></span><br><span class="line">        min_val = <span class="built_in">min</span>(p.val, q.val)</span><br><span class="line">        max_val = <span class="built_in">max</span>(p.val, q.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历，直到找到LCA</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="comment"># 如果当前节点的值大于p和q的最大值，说明LCA在左子树</span></span><br><span class="line">            <span class="keyword">if</span> root.val &gt; max_val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="comment"># 如果当前节点的值小于p和q的最小值，说明LCA在右子树</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; min_val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="comment"># 否则，当前节点的值在[min_val, max_val]之间，它就是LCA</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 理论上在有效输入下不会到达这里</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-10"><a href="#算法分析-10" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：利用BST性质 + 迭代</li>
</ul>
<hr>
<h2 id="题目三：收集累加和等于aim的所有路径"><a href="#题目三：收集累加和等于aim的所有路径" class="headerlink" title="题目三：收集累加和等于aim的所有路径"></a>题目三：收集累加和等于aim的所有路径</h2><h3 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，返回所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/dfs%E5%9B%9E%E6%BA%AF%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="dfs回溯的概念"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/dfs%E5%9B%9E%E6%BA%AF%E7%9A%84%E6%A6%82%E5%BF%B52.png" alt="dfs回溯的概念2"></p>
<h3 id="核心思想-11"><a href="#核心思想-11" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用DFS + 回溯的方法：</p>
<ol>
<li>维护一个当前路径 <code>path</code> 和当前路径和 <code>current_sum</code></li>
<li>深入遍历树，每经过一个节点，就将其加入 <code>path</code>，并更新 <code>current_sum</code></li>
<li>当到达一个叶子节点时，检查 <code>current_sum + cur.val</code>是否等于目标值，如果是，将当前路径（包括叶子节点）的一个副本添加到最终结果 <code>ans</code> 中</li>
<li>遍历完一个节点的所有子树后，需要回溯，即将该节点从 <code>path</code> 中移除，以便返回到父节点继续搜索其他分支</li>
</ol>
<h3 id="算法实现-11"><a href="#算法实现-11" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，初始化结果列表和路径列表，并启动递归搜索</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            path = []</span><br><span class="line">            <span class="comment"># 调用递归辅助函数 f</span></span><br><span class="line">            <span class="variable language_">self</span>.f(root, targetSum, <span class="number">0</span>, path, ans) <span class="comment"># 一开始sum=0，ans也是空列表，path也是空列表</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, cur: TreeNode, aim: <span class="built_in">int</span>, current_sum: <span class="built_in">int</span>, path: <span class="type">List</span>[<span class="built_in">int</span>], ans: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归辅助函数，用于深度优先搜索所有路径</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前节点值加入路径</span></span><br><span class="line">        path.append(cur.val) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否为叶节点</span></span><br><span class="line">        is_leaf = cur.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cur.right <span class="keyword">is</span> <span class="literal">None</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> is_leaf:</span><br><span class="line">            <span class="comment"># 叶节点</span></span><br><span class="line">            <span class="comment"># 如果当前路径和加上叶节点的值等于目标值，则找到一个有效路径</span></span><br><span class="line">            <span class="keyword">if</span> current_sum + cur.val == aim: </span><br><span class="line">                <span class="comment"># 将路径的副本添加到结果中</span></span><br><span class="line">                <span class="comment"># 必须是副本(path[:])，否则后续的回溯操作会影响已存入的结果</span></span><br><span class="line">                ans.append(path[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不是叶节点</span></span><br><span class="line">            <span class="comment"># 递归探索左子树</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                <span class="variable language_">self</span>.f(cur.left, aim, current_sum + cur.val, path, ans)</span><br><span class="line">            <span class="comment"># 递归探索右子树</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                <span class="variable language_">self</span>.f(cur.right, aim, current_sum + cur.val, path, ans)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 回溯步骤：当一个节点的左右子树都探索完毕后，</span></span><br><span class="line">        <span class="comment"># 将该节点从当前路径中移除，返回到其父节点的递归调用中。</span></span><br><span class="line">        path.pop() <span class="comment"># 用 path.pop() 把刚才加入的那个节点移除，恢复到进入递归前的状态</span></span><br></pre></td></tr></table></figure>

<h3 id="回溯不会死循环的原因"><a href="#回溯不会死循环的原因" class="headerlink" title="回溯不会死循环的原因"></a>回溯不会死循环的原因</h3><ol>
<li><strong>控制流是”递归调用”不是”循环依赖”</strong>：每次调用只会递归左子树、右子树各最多一次</li>
<li><strong>for&#x2F;if 的次数是固定的</strong>：子树递归只发生在固定的分支中，不会因为pop重复触发</li>
<li><strong>pop 只是在撤销路径，不改变遍历指针</strong>：pop 修改的是 path 内容，用于恢复现场；并不改变 cur、cur.left、cur.right 的结构或递归栈帧。可以把它看作：DFS 到底（或到叶&#x2F;路尽）后，撤销上一步选择，然后走兄弟分支；兄弟分支走完，再撤销并上返……直到根。整个过程单调“回退”栈帧，不可能形成死循环。这个调用栈帧的所有工作（检查&#x2F;递归左右）都完成了，撤销现场后，自然结束返回到父调用。</li>
</ol>
<h3 id="算法分析-11"><a href="#算法分析-11" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N²)，最坏情况下每条路径都需要复制</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：DFS + 回溯 + 路径复制</li>
</ul>
<hr>
<h2 id="题目四：验证平衡二叉树"><a href="#题目四：验证平衡二叉树" class="headerlink" title="题目四：验证平衡二叉树"></a>题目四：验证平衡二叉树</h2><h3 id="问题描述-12"><a href="#问题描述-12" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。一个高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5.png" alt="平衡二叉树概念"></p>
<h3 id="核心思想-12"><a href="#核心思想-12" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用后序遍历的思想：</p>
<ol>
<li>要判断当前节点是否平衡，需要先知道其左右子树的高度</li>
<li>这天然地符合后序遍历的顺序（先左、再右、后根）</li>
<li>递归地计算左子树和右子树的高度</li>
<li>在计算完左右子树高度后，检查它们的高度差</li>
<li>使用一个实例变量来记录是否已发现不平衡，一旦发现不平衡，就将此标志设为False，后续的递归调用可以提前终止。</li>
</ol>
<h3 id="算法实现-12"><a href="#算法实现-12" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># balance是实例变量，用于在递归调用中共享状态，所以能够实现全局变量的效果</span></span><br><span class="line">        <span class="comment"># 每次判断开始时，在主函数中将其重置为true</span></span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，用于启动平衡性检查</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 重置平衡标志</span></span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 调用递归函数计算高度并检查平衡性</span></span><br><span class="line">        <span class="variable language_">self</span>.height(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.balance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, cur: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归计算节点高度，并在此过程中检查平衡性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 核心思想（后序遍历）：</span></span><br><span class="line">        <span class="comment"># 1. 要判断当前节点是否平衡，需要先知道其左右子树的高度。</span></span><br><span class="line">        <span class="comment"># 2. 这天然地符合后序遍历的顺序（先左、再右、后根）。</span></span><br><span class="line">        <span class="comment"># 3. 递归地计算左子树和右子树的高度。</span></span><br><span class="line">        <span class="comment"># 4. 在计算完左右子树高度后，检查它们的高度差。如果差值大于1，说明树不平衡。</span></span><br><span class="line">        <span class="comment"># 5. 使用一个全局或实例变量 `self.balance` 来记录是否已发现不平衡。</span></span><br><span class="line">        <span class="comment">#    一旦发现不平衡，就将此标志设为False，后续的递归调用可以提前终止。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一旦发现不平衡，或者当前节点为空，返回0，后续计算已无意义或到达递归边界</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.balance <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归计算左子树的高度</span></span><br><span class="line">        lh = <span class="variable language_">self</span>.height(cur.left)</span><br><span class="line">        <span class="comment"># 递归计算右子树的高度</span></span><br><span class="line">        rh = <span class="variable language_">self</span>.height(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查左右子树的高度差</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(lh - rh) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果高度差大于1，则标记为不平衡</span></span><br><span class="line">            <span class="variable language_">self</span>.balance = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回当前节点的高度，即左右子树中较高者的高度加1</span></span><br><span class="line">        <span class="comment"># 叶子节点的高度为 1，因为它的左右子树高度都是 0，返回 max(0, 0) + 1 = 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lh, rh) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-12"><a href="#算法分析-12" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：后序遍历 + 全局状态</li>
</ul>
<hr>
<h2 id="题目五：验证搜索二叉树"><a href="#题目五：验证搜索二叉树" class="headerlink" title="题目五：验证搜索二叉树"></a>题目五：验证搜索二叉树</h2><h3 id="问题描述-13"><a href="#问题描述-13" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%88%A4%E6%96%AD%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%96%B9%E6%B3%951.png" alt="判断搜索二叉树方法1"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E5%88%A4%E6%96%AD%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%96%B9%E6%B3%952.png" alt="判断搜索二叉树方法2"></p>
<h3 id="核心思想-13"><a href="#核心思想-13" class="headerlink" title="核心思想"></a>核心思想</h3><p>有两种实现方法：</p>
<h4 id="方法一：中序遍历"><a href="#方法一：中序遍历" class="headerlink" title="方法一：中序遍历"></a>方法一：中序遍历</h4><p>一个有效的BST，其中序遍历的结果必然是一个严格递增的序列。</p>
<h4 id="方法二：递归验证"><a href="#方法二：递归验证" class="headerlink" title="方法二：递归验证"></a>方法二：递归验证</h4><p>对任意一个节点，它必须满足：</p>
<ol>
<li>它的左子树是BST，且左子树所有节点的值都小于它自身的值</li>
<li>它的右子树是BST，且右子树所有节点的值都大于它自身的值</li>
</ol>
<h3 id="算法实现-13"><a href="#算法实现-13" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="方法一：迭代实现的中序遍历"><a href="#方法一：迭代实现的中序遍历" class="headerlink" title="方法一：迭代实现的中序遍历"></a>方法一：迭代实现的中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST1</span>(<span class="params">self, head: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过迭代方式进行中序遍历来验证BST。</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    一个有效的BST，其中序遍历的结果必然是一个严格递增的序列。</span></span><br><span class="line"><span class="string">    因此，我们可以在遍历过程中，持续比较当前节点的值和前一个节点的值。</span></span><br><span class="line"><span class="string">    如果发现当前节点值小于或等于前一个节点值，那么它就不是一个BST。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    stack = []</span><br><span class="line">    pre_node = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用cur指针和栈来模拟递归的中序遍历</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            <span class="comment"># 一直向左，将路径上的节点入栈</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 左边到头了，从栈中弹出一个节点，这个就是中序遍历的当前节点</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查中序遍历的有序性，pre_node是当前节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> pre_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> pre_node.val &gt;= cur.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新前一个节点，然后转向右子树</span></span><br><span class="line">            pre_node = cur</span><br><span class="line">            cur = cur.right</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二：递归实现"><a href="#方法二：递归实现" class="headerlink" title="方法二：递归实现"></a>方法二：递归实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 实例变量，用于在递归调用中传递子树的最小值和最大值</span></span><br><span class="line">    <span class="variable language_">self</span>.min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST2</span>(<span class="params">self, head: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过递归方式验证BST。</span></span><br><span class="line"><span class="string">    核心思想：</span></span><br><span class="line"><span class="string">    对任意一个节点，它必须满足：</span></span><br><span class="line"><span class="string">    1. 它的左子树是BST，且左子树所有节点的值都小于它自身的值。</span></span><br><span class="line"><span class="string">    2. 它的右子树是BST，且右子树所有节点的值都大于它自身的值。</span></span><br><span class="line"><span class="string">    这个过程可以通过后序遍历，在返回时收集子树的信息（是否为BST，最大值，最小值）来完成。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Base case是 head is None，即空树的情况，</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 基准情况：空树是有效的BST</span></span><br><span class="line">        <span class="comment"># 初始化min和max，确保不影响上层计算</span></span><br><span class="line">        <span class="variable language_">self</span>.min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归检查左子树是不是有效的BST</span></span><br><span class="line">    is_left_ok = <span class="variable language_">self</span>.isValidBST2(head.left)</span><br><span class="line">    l_min = <span class="variable language_">self</span>.min_val  <span class="comment"># 保存左子树的最小值</span></span><br><span class="line">    l_max = <span class="variable language_">self</span>.max_val  <span class="comment"># 保存左子树的最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归检查右子树是不是有效的BST</span></span><br><span class="line">    is_right_ok = <span class="variable language_">self</span>.isValidBST2(head.right)</span><br><span class="line">    r_min = <span class="variable language_">self</span>.min_val</span><br><span class="line">    r_max = <span class="variable language_">self</span>.max_val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新当前树的min和max值</span></span><br><span class="line">    <span class="variable language_">self</span>.min_val = <span class="built_in">min</span>(l_min, r_min, head.val)</span><br><span class="line">    <span class="variable language_">self</span>.max_val = <span class="built_in">max</span>(l_max, r_max, head.val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 综合判断当前节点是否满足BST的条件</span></span><br><span class="line">    <span class="comment"># 1. 左右子树本身都是BST (is_left_ok and is_right_ok)</span></span><br><span class="line">    <span class="comment"># 2. 左子树的最大值必须小于当前节点值 (l_max &lt; head.val)</span></span><br><span class="line">    <span class="comment"># 3. 右子树的最小值必须大于当前节点值 (head.val &lt; r_min)</span></span><br><span class="line">    <span class="keyword">return</span> is_left_ok <span class="keyword">and</span> is_right_ok <span class="keyword">and</span> l_max &lt; head.val <span class="keyword">and</span> head.val &lt; r_min</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-13"><a href="#算法分析-13" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：中序遍历有序性 &#x2F; 递归验证BST性质</li>
</ul>
<hr>
<h2 id="题目六：修剪搜索二叉树"><a href="#题目六：修剪搜索二叉树" class="headerlink" title="题目六：修剪搜索二叉树"></a>题目六：修剪搜索二叉树</h2><h3 id="问题描述-14"><a href="#问题描述-14" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">https://leetcode.cn/problems/trim-a-binary-search-tree/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E4%BF%AE%E5%89%AA%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="修剪搜索二叉树"></p>
<h3 id="核心思想-14"><a href="#核心思想-14" class="headerlink" title="核心思想"></a>核心思想</h3><p>利用BST的性质进行递归：</p>
<ol>
<li>如果 <code>cur.val &lt; low</code>，那么 <code>cur</code> 和它的整个左子树都应该被删除，修剪后的树必定在右子树中</li>
<li>如果 <code>cur.val &gt; high</code>，那么 <code>cur</code> 和它的整个右子树都应该被删除，修剪后的树必定在左子树中</li>
<li>如果 <code>low &lt;= cur.val &lt;= high</code>，那么当前节点应该被保留，继续递归地修剪左右子树</li>
</ol>
<h3 id="算法实现-14"><a href="#算法实现-14" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, cur: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归地修剪二叉搜索树。</span></span><br><span class="line"><span class="string">        核心思想：</span></span><br><span class="line"><span class="string">        利用BST的性质进行递归。对于当前节点 `cur`：</span></span><br><span class="line"><span class="string">        1. 如果 `cur.val &lt; low`，那么 `cur` 和它的整个左子树都应该被删除。</span></span><br><span class="line"><span class="string">           修剪后的树必定在 `cur` 的右子树中，因此我们返回对右子树的修剪结果。</span></span><br><span class="line"><span class="string">        2. 如果 `cur.val &gt; high`，那么 `cur` 和它的整个右子树都应该被删除。</span></span><br><span class="line"><span class="string">           修剪后的树必定在 `cur` 的左子树中，因此我们返回对左子树的修剪结果。</span></span><br><span class="line"><span class="string">        3. 如果 `low &lt;= cur.val &lt;= high`，那么 `cur` 节点应该被保留。</span></span><br><span class="line"><span class="string">           我们继续递归地修剪它的左子树和右子树，并将返回的结果作为 `cur` 新的左、右孩子。</span></span><br><span class="line"><span class="string">           最后返回 `cur` 本身。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># base case是 cur is None，即空树的情况，返回None</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点值太小，应该在右子树中寻找有效部分</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; low:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.trimBST(cur.right, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点值太大，应该在左子树中寻找有效部分</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; high:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.trimBST(cur.left, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前节点在 [low, high] 范围内，保留该节点</span></span><br><span class="line">        <span class="comment"># 然后递归地处理它的左子树和右子树</span></span><br><span class="line">        cur.left = <span class="variable language_">self</span>.trimBST(cur.left, low, high)</span><br><span class="line">        cur.right = <span class="variable language_">self</span>.trimBST(cur.right, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回处理后的当前节点</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-14"><a href="#算法分析-14" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，最坏情况下访问所有节点</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：利用BST性质 + 递归修剪</li>
</ul>
<hr>
<h2 id="题目七：二叉树打家劫舍问题"><a href="#题目七：二叉树打家劫舍问题" class="headerlink" title="题目七：二叉树打家劫舍问题"></a>题目七：二叉树打家劫舍问题</h2><h3 id="问题描述-15"><a href="#问题描述-15" class="headerlink" title="问题描述"></a>问题描述</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为”根”。除了”根”之外，每栋房子有且只有一个”父”房子与之相连。一番侦察之后，聪明的小偷意识到”这个地方的所有房屋的排列类似于一棵二叉树”。如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的前提下，小偷一晚能够盗取的最高金额。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(14)/class37-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E4%B8%8A/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98.png" alt="打家劫舍问题"></p>
<h3 id="核心思想-15"><a href="#核心思想-15" class="headerlink" title="核心思想"></a>核心思想</h3><p>树形DP问题。对于任意一个节点，我们考虑两种情况：</p>
<ol>
<li>偷当前节点：那么它的左右孩子节点都不能偷</li>
<li>不偷当前节点：那么它的左右孩子可以偷也可以不偷，取两者中的较大值</li>
</ol>
<p>通过后序遍历，我们可以先计算出左右子树的结果，再用来推导当前节点的结果。</p>
<h3 id="算法实现-15"><a href="#算法实现-15" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 实例变量，用于在递归中保存子问题的解</span></span><br><span class="line">        <span class="comment"># yes: 表示在X子树中，偷头节点的情况下能获得的最大收益</span></span><br><span class="line">        <span class="comment"># no: 表示在X子树中，不偷头节点的情况下能获得的最大收益</span></span><br><span class="line">        <span class="variable language_">self</span>.yes = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.no = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        主函数，启动递归计算</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.f(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.yes, <span class="variable language_">self</span>.no)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归函数，采用后序遍历计算以root为根的子树的打劫收益</span></span><br><span class="line"><span class="string">        核心思想 (树形DP):</span></span><br><span class="line"><span class="string">        对于任意一个节点 `root`，我们考虑两种情况：</span></span><br><span class="line"><span class="string">        1. 偷 `root` 节点：那么它的左右孩子节点都不能偷。</span></span><br><span class="line"><span class="string">           最大收益 = `root.val` + 左子树不偷的最大收益 + 右子树不偷的最大收益。</span></span><br><span class="line"><span class="string">        2. 不偷 `root` 节点：那么它的左右孩子可以偷也可以不偷，取两者中的较大值。</span></span><br><span class="line"><span class="string">           最大收益 = max(偷左孩子，不偷左孩子) + max(偷右孩子，不偷右孩子)。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        通过后序遍历，我们可以先计算出左右子树的结果，再用来推导当前节点的结果。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 基准情况：空节点收益为0</span></span><br><span class="line">            <span class="variable language_">self</span>.yes = <span class="number">0</span></span><br><span class="line">            <span class="variable language_">self</span>.no = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 暂存当前节点的收益</span></span><br><span class="line">        current_yes = root.val</span><br><span class="line">        current_no = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先递归处理左子树，再处理右子树</span></span><br><span class="line">        <span class="variable language_">self</span>.f(root.left)</span><br><span class="line">        <span class="comment"># 此时 self.yes 和 self.no 是左子树的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新当前节点的收益：</span></span><br><span class="line">        <span class="comment"># 如果偷当前节点，则不能偷左孩子，所以加上左子树不偷的收益 no</span></span><br><span class="line">        current_yes += <span class="variable language_">self</span>.no </span><br><span class="line">        <span class="comment"># 如果不偷当前节点，则左孩子可偷可不偷，取最大值</span></span><br><span class="line">        current_no += <span class="built_in">max</span>(<span class="variable language_">self</span>.yes, <span class="variable language_">self</span>.no)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归处理右子树</span></span><br><span class="line">        <span class="variable language_">self</span>.f(root.right)</span><br><span class="line">        <span class="comment"># 此时 self.yes 和 self.no 是右子树的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再次更新当前节点的收益：</span></span><br><span class="line">        <span class="comment"># 加上右子树的贡献</span></span><br><span class="line">        current_yes += <span class="variable language_">self</span>.no</span><br><span class="line">        current_no += <span class="built_in">max</span>(<span class="variable language_">self</span>.yes, <span class="variable language_">self</span>.no)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将最终计算出的当前节点的结果，存回实例变量，供上层调用使用</span></span><br><span class="line">        <span class="variable language_">self</span>.yes = current_yes</span><br><span class="line">        <span class="variable language_">self</span>.no = current_no</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-15"><a href="#算法分析-15" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)，每个节点访问一次</li>
<li><strong>空间复杂度</strong>：O(H)，H为树的高度</li>
<li><strong>核心技巧</strong>：树形DP + 后序遍历</li>
</ul>
<hr>
<h2 id="核心技巧总结-1"><a href="#核心技巧总结-1" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-LCA问题模板"><a href="#1-LCA问题模板" class="headerlink" title="1. LCA问题模板"></a>1. LCA问题模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>

<h3 id="2-路径搜索-回溯模板"><a href="#2-路径搜索-回溯模板" class="headerlink" title="2. 路径搜索 + 回溯模板"></a>2. 路径搜索 + 回溯模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, path, target</span>):</span><br><span class="line">    path.append(node.val)  <span class="comment"># 选择</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> is_leaf(node):</span><br><span class="line">        <span class="keyword">if</span> meets_condition():</span><br><span class="line">            result.append(path[:])  <span class="comment"># 记录答案</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dfs(node.left, path, target)   <span class="comment"># 递归</span></span><br><span class="line">        dfs(node.right, path, target)  <span class="comment"># 递归</span></span><br><span class="line">    </span><br><span class="line">    path.pop()  <span class="comment"># 撤销选择（回溯）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-BST性质利用"><a href="#3-BST性质利用" class="headerlink" title="3. BST性质利用"></a>3. BST性质利用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BST中序遍历是有序的</span></span><br><span class="line"><span class="comment"># BST搜索可以利用大小关系剪枝</span></span><br><span class="line"><span class="comment"># BST的LCA在分叉点</span></span><br></pre></td></tr></table></figure>

<h3 id="4-树形DP模板"><a href="#4-树形DP模板" class="headerlink" title="4. 树形DP模板"></a>4. 树形DP模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree_dp</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> base_case</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 后序遍历：先处理子树</span></span><br><span class="line">    left_result = tree_dp(node.left)</span><br><span class="line">    right_result = tree_dp(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据子树结果计算当前节点结果</span></span><br><span class="line">    current_result = combine(node.val, left_result, right_result)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> current_result</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结-1"><a href="#复杂度分析总结-1" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心算法</th>
</tr>
</thead>
<tbody><tr>
<td>普通二叉树LCA</td>
<td>O(N)</td>
<td>O(H)</td>
<td>递归DFS</td>
</tr>
<tr>
<td>BST的LCA</td>
<td>O(H)</td>
<td>O(1)</td>
<td>利用BST性质</td>
</tr>
<tr>
<td>路径和问题</td>
<td>O(N²)</td>
<td>O(H)</td>
<td>DFS + 回溯</td>
</tr>
<tr>
<td>验证平衡二叉树</td>
<td>O(N)</td>
<td>O(H)</td>
<td>后序遍历</td>
</tr>
<tr>
<td>验证BST</td>
<td>O(N)</td>
<td>O(H)</td>
<td>中序遍历&#x2F;递归</td>
</tr>
<tr>
<td>修剪BST</td>
<td>O(N)</td>
<td>O(H)</td>
<td>递归修剪</td>
</tr>
<tr>
<td>打家劫舍III</td>
<td>O(N)</td>
<td>O(H)</td>
<td>树形DP</td>
</tr>
</tbody></table>
<h2 id="学习建议-1"><a href="#学习建议-1" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>掌握LCA问题</strong>：这是树算法中的经典问题，有多种解法和应用</p>
</li>
<li><p><strong>理解BST性质</strong>：</p>
<ul>
<li>中序遍历有序</li>
<li>可以利用大小关系进行搜索优化</li>
<li>左子树 &lt; 根 &lt; 右子树</li>
</ul>
</li>
<li><p><strong>掌握回溯模板</strong>：</p>
<ul>
<li>做选择 → 递归 → 撤销选择</li>
<li>注意保存结果时要使用副本</li>
</ul>
</li>
<li><p><strong>理解树形DP</strong>：</p>
<ul>
<li>后序遍历获取子树信息</li>
<li>根据子树状态计算当前状态</li>
<li>状态定义要考虑所有可能情况</li>
</ul>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空节点处理</li>
<li>叶子节点判断</li>
<li>单节点情况</li>
</ul>
</li>
<li><p><strong>练习状态管理</strong>：</p>
<ul>
<li>实例变量在递归中的使用</li>
<li>多个状态的传递和更新</li>
</ul>
</li>
</ol>
<p>通过掌握这些经典的二叉树问题，可以深入理解树的递归性质，为学习更高级的树算法和动态规划打下基础。这些问题模式在实际编程中经常出现，是算法面试的重点内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（13）- 数据结构设计高频题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-20 10:30:00 / Modified: 13:39:16" itemprop="dateCreated datePublished" datetime="2025-08-20T10:30:00+08:00">2025-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记是class035的内容，总结了数据结构设计类题目的高频考点，包含7道经典数据结构设计题目的详细解析。这些题目主要基于哈希表的O(1)操作时间复杂度特性。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习数据结构设计高频题之前，需要掌握以下基础知识：</p>
<ul>
<li>动态数组和扩容分析（007讲）</li>
<li>链表入门内容（009~012讲）</li>
<li>堆结构（025讲）</li>
<li>哈希表、有序表、比较器的使用（026讲）</li>
</ul>
<h2 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h2><p>本节以数据结构设计高频题为主，并不涉及太难的数据结构设计题目，很多题的原理都是基于哈希表的O(1)时间复杂度。数据结构设计的更难题目，需要学习更多数据结构之后才能解决，如前缀树、并查集、线段树等。</p>
<h1 id="035【必备】数据结构设计高频题"><a href="#035【必备】数据结构设计高频题" class="headerlink" title="035【必备】数据结构设计高频题"></a>035【必备】数据结构设计高频题</h1><h2 id="题目一：setAll功能的哈希表"><a href="#题目一：setAll功能的哈希表" class="headerlink" title="题目一：setAll功能的哈希表"></a>题目一：setAll功能的哈希表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>哈希表常见的三个操作是put、get和containsKey，而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是把所有记录value都设成统一的值。请设计并实现这种有setAll功能的哈希表，并且put、get、containsKey和setAll四个操作的时间复杂度都为O(1)。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967">https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967</a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>采用”懒更新”(Lazy Update)策略，setAll操作只记录一个全局值和当前时间戳，并不实际修改数据。当get一个键时，通过比较该键自身的时间戳和全局setAll的时间戳，来实时决定返回它自己的值还是全局的值。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/%E4%B8%BAhash%E8%A1%A8%E8%AE%BE%E7%BD%AEsetall%E6%96%B9%E6%B3%95.png" alt="为hash表设置setall方法"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetAllHashMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心数据结构，存储键和它对应的值与时间戳</span></span><br><span class="line">        <span class="comment"># 格式为: &#123; key: [value, time] &#125;</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        <span class="comment"># setAll操作设定的统一值</span></span><br><span class="line">        <span class="variable language_">self</span>.set_all_value = <span class="number">0</span></span><br><span class="line">        <span class="comment"># setAll操作发生的时间戳</span></span><br><span class="line">        <span class="variable language_">self</span>.set_all_time = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 全局时间戳，用于记录每次操作的顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, k, v</span>):</span><br><span class="line">        <span class="comment"># 核心思想：为每个put操作记录一个独立的时间戳</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="comment"># 如果键已存在，更新其值和时间戳</span></span><br><span class="line">            value = <span class="variable language_">self</span>.<span class="built_in">map</span>[k]</span><br><span class="line">            value[<span class="number">0</span>] = v</span><br><span class="line">            value[<span class="number">1</span>] = <span class="variable language_">self</span>.cnt</span><br><span class="line">            <span class="variable language_">self</span>.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果键不存在，创建新的条目</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[k] = [v, <span class="variable language_">self</span>.cnt]</span><br><span class="line">            <span class="variable language_">self</span>.cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_all</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="comment"># 核心思想：只记录setAll的值和时间戳，不实际遍历map</span></span><br><span class="line">        <span class="comment"># 这是一个懒更新策略，只有在get的时候才根据时间戳判断</span></span><br><span class="line">        <span class="variable language_">self</span>.set_all_value = v</span><br><span class="line">        <span class="variable language_">self</span>.set_all_time = <span class="variable language_">self</span>.cnt</span><br><span class="line">        <span class="variable language_">self</span>.cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="comment"># 核心思想：比较单个key的更新时间和全局setAll的更新时间</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        value = <span class="variable language_">self</span>.<span class="built_in">map</span>[k]</span><br><span class="line">        <span class="comment"># 如果这个key的最后更新时间晚于setAll的时间，说明它的值是有效的</span></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">1</span>] &gt; <span class="variable language_">self</span>.set_all_time:</span><br><span class="line">            <span class="keyword">return</span> value[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 否则，它的值已经被setAll覆盖了，应返回setAll的值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.set_all_value</span><br></pre></td></tr></table></figure>

<p><strong>高效读写</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建一个SetAllHashMap对象，模拟带有setAll操作的哈希表，模拟牛客网的输入输出处理</span></span><br><span class="line">    solution = SetAllHashMap()</span><br><span class="line">    <span class="comment"># 读取所有输入行（提高输入效率）</span></span><br><span class="line">    lines = sys.stdin.readlines()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(lines): <span class="comment"># 遍历所有行</span></span><br><span class="line">        line = lines[i].strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="comment"># 跳过空行</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取本组操作数n</span></span><br><span class="line">        n = <span class="built_in">int</span>(line)</span><br><span class="line">        <span class="comment"># 每个测试用例开始前重置数据结构</span></span><br><span class="line">        solution.__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连续读取n行操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 解析当前操作的所有参数，map是把字符串转换成列表，int指明了列表的元素类型</span></span><br><span class="line">            parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, lines[i].strip().split()))</span><br><span class="line">            op = parts[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># op=1，put操作，后面有两个参数a, b</span></span><br><span class="line">                a, b = parts[<span class="number">1</span>], parts[<span class="number">2</span>]</span><br><span class="line">                solution.put(a, b)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># op=2，get操作，后面一个参数a</span></span><br><span class="line">                a = parts[<span class="number">1</span>]</span><br><span class="line">                <span class="built_in">print</span>(solution.get(a))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># op=3，setAll操作，后面一个参数a</span></span><br><span class="line">                a = parts[<span class="number">1</span>]</span><br><span class="line">                solution.set_all(a)</span><br><span class="line">        <span class="comment"># 处理完一组数据，i+1进入下一组或结束</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 在提交时，类名需要改为 Main</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)，N为键的数量</li>
<li><strong>核心技巧</strong>：时间戳比较 + 懒更新策略</li>
</ul>
<h2 id="题目二：实现LRU结构"><a href="#题目二：实现LRU结构" class="headerlink" title="题目二：实现LRU结构"></a>题目二：实现LRU结构</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>实现 LRUCache 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量capacity初始化LRU缓存</li>
<li><code>int get(int key)</code> 如果关键字key存在于缓存中，则返回关键字的值，否则返回-1</li>
<li><code>void put(int key, int value)</code> 如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字</li>
</ul>
<p>函数get和put必须以O(1)的平均时间复杂度运行。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
<h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><p>结合了哈希表和双向链表：哈希表提供了对任意键的O(1)快速访问，而双向链表则负责维护数据的访问顺序，使其能在O(1)时间内将最新访问的节点移到队尾，并在容量满时淘汰队首的最久未使用节点。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/lru%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="lru结构的实现"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="comment"># 内部类，定义双向链表节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleNode</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="number">0</span>, val=<span class="number">0</span></span>):</span><br><span class="line">            <span class="variable language_">self</span>.key = key</span><br><span class="line">            <span class="variable language_">self</span>.val = val</span><br><span class="line">            <span class="variable language_">self</span>.last = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 内部类，实现双向链表，用于维护节点的访问顺序</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleList</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 哨兵节点，简化边界条件处理</span></span><br><span class="line">            <span class="variable language_">self</span>.head = <span class="variable language_">self</span>.DoubleNode() <span class="comment">#头节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail = <span class="variable language_">self</span>.DoubleNode() <span class="comment">#尾节点</span></span><br><span class="line">            <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail <span class="comment">#头节点的下一个节点是尾节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail.last = <span class="variable language_">self</span>.head <span class="comment">#尾节点的上一个节点是头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将一个节点添加到链表尾部（表示最近使用）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add_node_to_tail</span>(<span class="params">self, node</span>):</span><br><span class="line">            node.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail <span class="comment"># 将新节点添加到尾节点的前一个位置</span></span><br><span class="line">            node.last = <span class="variable language_">self</span>.tail.last <span class="comment"># 将新节点的上一个节点设置为尾节点的前一个节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail.last.<span class="built_in">next</span> = node <span class="comment"># 将尾节点的前一个节点的下一个节点设置为新节点</span></span><br><span class="line">            <span class="variable language_">self</span>.tail.last = node <span class="comment"># 将尾节点的前一个节点设置为新节点</span></span><br><span class="line">            <span class="comment"># 这样设置是为了把尾节点和前一个节点的两条指针变成四条指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将指定节点移动到链表尾部</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">move_node_to_tail</span>(<span class="params">self, node</span>):</span><br><span class="line">            <span class="comment"># 先将节点从原位置断开</span></span><br><span class="line">            node.last.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>.last = node.last</span><br><span class="line">            <span class="comment"># 再将节点添加到尾部</span></span><br><span class="line">            <span class="variable language_">self</span>.add_node_to_tail(node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移除链表头部节点（最久未使用的节点）并返回</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">remove_head</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 如果链表为空（只有哨兵节点），则无法移除</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.head.<span class="built_in">next</span> == <span class="variable language_">self</span>.tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node_to_remove = <span class="variable language_">self</span>.head.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 从链表中移除</span></span><br><span class="line">            node_to_remove.last.<span class="built_in">next</span> = node_to_remove.<span class="built_in">next</span></span><br><span class="line">            node_to_remove.<span class="built_in">next</span>.last = node_to_remove.last</span><br><span class="line">            <span class="keyword">return</span> node_to_remove</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用哈希表实现O(1)查找，使用双向链表实现O(1)的节点移动（更新访问顺序）</span></span><br><span class="line">        <span class="comment"># 哈希表，存储 key -&gt; DoubleNode 的映射</span></span><br><span class="line">        <span class="variable language_">self</span>.key_node_map = &#123;&#125;</span><br><span class="line">        <span class="comment"># 双向链表实例，维护节点的LRU顺序</span></span><br><span class="line">        <span class="variable language_">self</span>.node_list = <span class="variable language_">self</span>.DoubleList()</span><br><span class="line">        <span class="comment"># 缓存的容量</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果key存在</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.key_node_map:</span><br><span class="line">            <span class="comment"># 获取节点</span></span><br><span class="line">            node = <span class="variable language_">self</span>.key_node_map[key]</span><br><span class="line">            <span class="comment"># 将该节点移动到链表尾部，表示最近被访问</span></span><br><span class="line">            <span class="variable language_">self</span>.node_list.move_node_to_tail(node)</span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="comment"># 如果key不存在，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 如果key已存在</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.key_node_map:</span><br><span class="line">            <span class="comment"># 更新节点的值</span></span><br><span class="line">            node = <span class="variable language_">self</span>.key_node_map[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            <span class="comment"># 将该节点移动到链表尾部</span></span><br><span class="line">            <span class="variable language_">self</span>.node_list.move_node_to_tail(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果缓存已满</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.key_node_map) == <span class="variable language_">self</span>.capacity:</span><br><span class="line">                <span class="comment"># 移除链表头部的最久未使用节点，之后会再把新节点添加到尾部</span></span><br><span class="line">                removed_node = <span class="variable language_">self</span>.node_list.remove_head()</span><br><span class="line">                <span class="comment"># 从哈希表中删除对应的key</span></span><br><span class="line">                <span class="keyword">del</span> <span class="variable language_">self</span>.key_node_map[removed_node.key]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 创建新节点</span></span><br><span class="line">            new_node = <span class="variable language_">self</span>.DoubleNode(key, value)</span><br><span class="line">            <span class="comment"># 存入哈希表</span></span><br><span class="line">            <span class="variable language_">self</span>.key_node_map[key] = new_node</span><br><span class="line">            <span class="comment"># 将新节点添加到链表尾部</span></span><br><span class="line">            <span class="variable language_">self</span>.node_list.add_node_to_tail(new_node)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：get和put操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(capacity)</li>
<li><strong>核心技巧</strong>：哈希表 + 双向链表</li>
</ul>
<h2 id="题目三：插入、删除和获取随机元素O-1-时间的结构"><a href="#题目三：插入、删除和获取随机元素O-1-时间的结构" class="headerlink" title="题目三：插入、删除和获取随机元素O(1)时间的结构"></a>题目三：插入、删除和获取随机元素O(1)时间的结构</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构：</p>
<ul>
<li><code>insert(val)</code>：当元素val不存在时，向集合中插入该项</li>
<li><code>remove(val)</code>：元素val存在时，从集合中移除该项</li>
<li><code>getRandom()</code>：随机返回现有集合中的一项</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">https://leetcode.cn/problems/insert-delete-getrandom-o1/</a></p>
<h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>结合了动态数组与哈希表，数组负责存储元素以实现O(1)的随机获取，哈希表则存储”值到数组索引”的映射以实现O(1)的查找。其remove操作的精髓在于：将待删除元素与数组的最后一个元素交换，然后直接删除数组末尾。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/hash%E8%A1%A8%E5%8A%A0%E5%85%A5%E7%A7%BB%E9%99%A4%E5%92%8C%E5%BE%97%E5%88%B0%E9%9A%8F%E6%9C%BA%E7%B4%A2%E5%BC%95.png" alt="hash表加入移除和得到随机索引"></p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想：</span></span><br><span class="line">        <span class="comment"># 1. 使用哈希表（字典）存储 值 -&gt; 索引 的映射，实现O(1)的查找。</span></span><br><span class="line">        <span class="comment"># 2. 使用动态数组（列表）存储值，实现O(1)的随机访问。</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125;  </span><br><span class="line">        <span class="variable language_">self</span>.arr = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果值已存在，直接返回False</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 将值添加到数组末尾</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.append(val)</span><br><span class="line">        <span class="comment"># 在哈希表中记录新值及其索引,map[val]返回val在数组中的索引</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[val] = <span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果值不存在，直接返回False</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 核心步骤：为了实现O(1)删除，将被删除元素与数组末尾元素交换，然后删除末尾元素。</span></span><br><span class="line">        <span class="comment"># 获取待删除元素的索引</span></span><br><span class="line">        val_index = <span class="variable language_">self</span>.<span class="built_in">map</span>[val]</span><br><span class="line">        <span class="comment"># 获取数组末尾的元素</span></span><br><span class="line">        end_value = <span class="variable language_">self</span>.arr[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将末尾元素放到待删除元素的位置</span></span><br><span class="line">        <span class="variable language_">self</span>.arr[val_index] = end_value</span><br><span class="line">        <span class="comment"># 更新哈希表中末尾元素的索引，只更新索引不更新值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[end_value] = val_index</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从哈希表中删除目标值</span></span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[val]</span><br><span class="line">        <span class="comment"># 从数组中删除末尾元素，两者同步更新</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 利用数组的特性，随机选择一个索引并返回对应的值</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(<span class="variable language_">self</span>.arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：数组末尾交换删除</li>
</ul>
<h2 id="题目四：插入、删除和获取随机元素O-1-时间且允许重复数字的结构"><a href="#题目四：插入、删除和获取随机元素O-1-时间且允许重复数字的结构" class="headerlink" title="题目四：插入、删除和获取随机元素O(1)时间且允许重复数字的结构"></a>题目四：插入、删除和获取随机元素O(1)时间且允许重复数字的结构</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构，且允许有重复数字：</p>
<ul>
<li><code>insert(val)</code>：向集合中插入元素val</li>
<li><code>remove(val)</code>：从集合中移除元素val的一个实例</li>
<li><code>getRandom()</code>：随机返回现有集合中的一项</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/">https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/</a></p>
<h3 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h3><p>与不允许重复的版本类似，但哈希表需要存储一个值所有出现位置的索引集合。</p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedCollection</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想：与不允许重复的版本类似，但哈希表需要存储一个值所有出现位置的索引集合。</span></span><br><span class="line">        <span class="comment"># 注意：字典中每个key指向的是不同的集合(set)，而不是同一个数组</span></span><br><span class="line">        <span class="comment"># 字典：存储 值 -&gt; 索引集合 的映射</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="comment"># 列表：存储所有值</span></span><br><span class="line">        <span class="variable language_">self</span>.arr = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 判断是否是第一次插入该值</span></span><br><span class="line">        is_new = val <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span></span><br><span class="line">        <span class="comment"># 将值添加到数组末尾</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.append(val)</span><br><span class="line">        <span class="comment"># 在哈希表中记录新值的索引</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span>[val].add(<span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> is_new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果值不存在，无法删除</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 核心步骤：同样是与末尾元素交换以实现O(1)删除</span></span><br><span class="line">        <span class="comment"># 获取待删除值的一个索引</span></span><br><span class="line">        val_index = <span class="variable language_">self</span>.<span class="built_in">map</span>[val].pop()</span><br><span class="line">        <span class="comment"># 获取末尾元素的值和索引</span></span><br><span class="line">        end_value = <span class="variable language_">self</span>.arr[-<span class="number">1</span>]</span><br><span class="line">        end_index = <span class="built_in">len</span>(<span class="variable language_">self</span>.arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果待删除的元素恰好是末尾元素，则不需要交换</span></span><br><span class="line">        <span class="keyword">if</span> val_index != end_index:</span><br><span class="line">            <span class="comment"># 用末尾元素覆盖待删除元素的位置</span></span><br><span class="line">            <span class="variable language_">self</span>.arr[val_index] = end_value</span><br><span class="line">            <span class="comment"># 更新末尾元素在哈希表中的索引记录</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[end_value].remove(end_index) </span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[end_value].add(val_index)</span><br><span class="line">            <span class="comment">#这里的 map 是一个存储集合的集合，所以需要通过 map[key] 先获取到集合，然后对集合调用 remove() 和 add() 方法。这是 Python 中嵌套数据结构的常见操作模式。</span></span><br><span class="line">        <span class="comment"># 从数组中移除末尾元素</span></span><br><span class="line">        <span class="variable language_">self</span>.arr.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果移除后，某个值的索引集合为空，则从哈希表中彻底删除该值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[val]:</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[val]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 随机获取一个元素</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(<span class="variable language_">self</span>.arr)</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：索引集合管理</li>
</ul>
<h2 id="题目五：快速获得数据流的中位数的结构"><a href="#题目五：快速获得数据流的中位数的结构" class="headerlink" title="题目五：快速获得数据流的中位数的结构"></a>题目五：快速获得数据流的中位数的结构</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，[2,3,4]的中位数是3，[2,3]的中位数是(2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两个操作的数据结构：</p>
<ul>
<li><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中</li>
<li><code>double findMedian()</code> - 返回目前所有元素的中位数</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<h3 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用两个堆来维护数据流，一个大顶堆和一个小顶堆。大顶堆存储数据流中较小的一半数字，小顶堆存储数据流中较大的一半数字。这样，中位数总是可以通过两个堆的堆顶元素快速得到。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0.png" alt="找中位数"></p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想：使用两个堆来维护数据流，一个大顶堆和一个小顶堆。</span></span><br><span class="line">        <span class="comment"># 大顶堆 (max_heap) 存储数据流中较小的一半数字。</span></span><br><span class="line">        <span class="comment"># 小顶堆 (min_heap) 存储数据流中较大的一半数字。</span></span><br><span class="line">        <span class="comment"># 这样，中位数总是可以通过两个堆的堆顶元素快速得到。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Python的heapq是小顶堆，为了实现大顶堆，我们存入元素的相反数。</span></span><br><span class="line">        <span class="variable language_">self</span>.max_heap = []</span><br><span class="line">        <span class="variable language_">self</span>.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 步骤1: 决定将新元素添加到哪个堆。</span></span><br><span class="line">        <span class="comment"># 如果大顶堆为空，或者新元素小于等于大顶堆的堆顶，则放入大顶堆。</span></span><br><span class="line">        <span class="comment"># 否则，放入小顶堆。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.max_heap <span class="keyword">or</span> -<span class="variable language_">self</span>.max_heap[<span class="number">0</span>] &gt;= num:</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.max_heap, -num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.min_heap, num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2: 平衡两个堆的大小，确保它们的size之差不超过1。</span></span><br><span class="line">        <span class="variable language_">self</span>._balance()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment"># 根据两个堆的大小来计算中位数。</span></span><br><span class="line">        <span class="comment"># 如果大小相等（总元素为偶数），中位数是两个堆顶的平均值。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) == <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap):</span><br><span class="line">            <span class="comment"># 注意从大顶堆取值时要取反，恢复其原始值。</span></span><br><span class="line">            <span class="keyword">return</span> (-<span class="variable language_">self</span>.max_heap[<span class="number">0</span>] + <span class="variable language_">self</span>.min_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">        <span class="comment"># 如果大小不等（总元素为奇数），中位数就是那个size更大的堆的堆顶。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="variable language_">self</span>.max_heap[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap) <span class="keyword">else</span> <span class="variable language_">self</span>.min_heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 私有辅助方法，用于平衡两个堆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_balance</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 当两个堆的大小差距为2时，需要从元素多的堆移动一个到元素少的堆。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) - <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap)) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) &gt; <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap):</span><br><span class="line">                heapq.heappush(<span class="variable language_">self</span>.min_heap, -heapq.heappop(<span class="variable language_">self</span>.max_heap))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(<span class="variable language_">self</span>.max_heap, -heapq.heappop(<span class="variable language_">self</span>.min_heap))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：addNum为O(logN)，findMedian为O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：双堆平衡</li>
</ul>
<h2 id="题目六：最大频率栈"><a href="#题目六：最大频率栈" class="headerlink" title="题目六：最大频率栈"></a>题目六：最大频率栈</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p>
<p>实现 FreqStack 类：</p>
<ul>
<li><code>FreqStack()</code> 构造一个空的堆栈</li>
<li><code>void push(int val)</code> 将一个整数val压入栈顶</li>
<li><code>int pop()</code> 删除并返回堆栈中出现频率最高的元素</li>
</ul>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-frequency-stack/">https://leetcode.cn/problems/maximum-frequency-stack/</a></p>
<h3 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用一个哈希表记录每个值出现的频率，使用另一个哈希表将频率映射到一个栈，这个栈存储了所有出现该频率的数字。使用一个变量实时追踪当前的最大频率。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/%E6%9C%80%E9%AB%98%E9%A2%91%E7%8E%87%E6%A0%88.png" alt="最高频率栈"></p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment">#这个初始化的是hashmap</span></span><br><span class="line">        <span class="comment"># 核心思想:</span></span><br><span class="line">        <span class="comment"># 1. 使用一个哈希表 (value_times) 记录每个值出现的频率。</span></span><br><span class="line">        <span class="comment"># 2. 使用另一个哈希表 (cnt_values) 将频率映射到一个栈（列表），这个栈存储了所有出现该频率的数字。</span></span><br><span class="line">        <span class="comment"># 3. 使用一个变量 (top_times) 实时追踪当前的最大频率。</span></span><br><span class="line">        <span class="comment"># pop操作总是从最大频率对应的栈中弹出元素，这保证了既是最高频也是最“新”的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 出现的最大次数</span></span><br><span class="line">        <span class="variable language_">self</span>.top_times = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每层节点 (每个频率有哪些数)</span></span><br><span class="line">        <span class="comment"># defaultdict(list) 会在key不存在时自动创建一个空列表</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt_values = defaultdict(<span class="built_in">list</span>) </span><br><span class="line">        <span class="comment"># 每一个数出现了几次</span></span><br><span class="line">        <span class="comment"># defaultdict(int) 会在key不存在时自动创建一个0</span></span><br><span class="line">        <span class="variable language_">self</span>.value_times = defaultdict(<span class="built_in">int</span>) </span><br><span class="line">        <span class="comment">#实际上，cnt_values和value_times是两个哈希表，一个存储频率，一个存储频率对应的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 步骤1: 更新该值的频率</span></span><br><span class="line">        <span class="variable language_">self</span>.value_times[val] += <span class="number">1</span></span><br><span class="line">        current_freq = <span class="variable language_">self</span>.value_times[val]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2: 将该值压入其新频率对应的栈中</span></span><br><span class="line">        <span class="variable language_">self</span>.cnt_values[current_freq].append(val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3: 更新全局最大频率</span></span><br><span class="line">        <span class="variable language_">self</span>.top_times = <span class="built_in">max</span>(<span class="variable language_">self</span>.top_times, current_freq)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 步骤1: 从最大频率对应的栈中弹出最近压入的元素</span></span><br><span class="line">        ans = <span class="variable language_">self</span>.cnt_values[<span class="variable language_">self</span>.top_times].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2: 如果弹出后，该频率的栈为空了，说明最大频率需要降低</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.cnt_values[<span class="variable language_">self</span>.top_times]:</span><br><span class="line">            <span class="variable language_">self</span>.top_times -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3: 更新被弹出元素自身的频率记录</span></span><br><span class="line">        <span class="variable language_">self</span>.value_times[ans] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：push和pop操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：频率分层存储</li>
</ul>
<h2 id="题目七：全O-1-的数据结构"><a href="#题目七：全O-1-的数据结构" class="headerlink" title="题目七：全O(1)的数据结构"></a>题目七：全O(1)的数据结构</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>请你实现一个数据结构支持以下操作：</p>
<ul>
<li><code>Inc(key)</code> - 插入一个新的值为1的key，或者使一个存在的key增加一，保证key不为空字符串</li>
<li><code>Dec(key)</code> - 如果这个key的值是1，那么把他从数据结构中移除掉。否则使一个存在的key值减一。如果这个key不存在，这个函数不做任何事情。key保证不为空字符串</li>
<li><code>GetMaxKey()</code> - 返回key中值最大的任意一个。如果没有元素存在，返回一个空字符串””</li>
<li><code>GetMinKey()</code> - 返回key中值最小的任意一个。如果没有元素存在，返回一个空字符串””</li>
</ul>
<p>挑战：以O(1)的时间复杂度实现所有操作。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-oone-data-structure/">https://leetcode.cn/problems/all-oone-data-structure/</a></p>
<h3 id="核心思想-6"><a href="#核心思想-6" class="headerlink" title="核心思想"></a>核心思想</h3><p>使用一个双向链表来组织桶(Bucket)，链表按桶的计数值(cnt)升序排列。每个桶包含一个集合，存储所有计数值等于该桶cnt的key。使用一个哈希表来存储key -&gt; Bucket的映射，实现O(1)的key定位。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(13)/class35-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/all1%E7%B1%BB.png" alt="all1类"></p>
<h3 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllOne</span>:</span><br><span class="line">    <span class="comment"># 内部类，定义双向链表的节点，也叫“桶”</span></span><br><span class="line">    <span class="comment"># 每个桶存储具有相同计数值的所有key</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bucket</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cnt</span>):</span><br><span class="line">            <span class="variable language_">self</span>.cnt = cnt</span><br><span class="line">            <span class="variable language_">self</span>.keys = <span class="built_in">set</span>()</span><br><span class="line">            <span class="variable language_">self</span>.last = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 核心思想:</span></span><br><span class="line">        <span class="comment"># 1. 使用一个双向链表来组织桶(Bucket)，链表按桶的计数值(cnt)升序排列。</span></span><br><span class="line">        <span class="comment"># 2. 每个桶(Bucket)包含一个集合(set)，存储所有计数值等于该桶cnt的key。</span></span><br><span class="line">        <span class="comment"># 3. 使用一个哈希表(map)来存储 key -&gt; Bucket 的映射，实现O(1)的key定位。</span></span><br><span class="line">        <span class="comment"># inc/dec操作本质上是将key从一个桶移动到相邻的下一个/上一个桶。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建头尾哨兵节点，简化边界处理</span></span><br><span class="line">        <span class="variable language_">self</span>.head = <span class="variable language_">self</span>.Bucket(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.tail = <span class="variable language_">self</span>.Bucket(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">        <span class="comment"># 将头节点的下一个指针指向尾节点，尾节点的上一个指针指向头节点，这样操作后，双向链表形成了一个初始的空结构：head &lt;-&gt; tail</span></span><br><span class="line">        <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">        <span class="variable language_">self</span>.tail.last = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="comment"># 存储 key 到其所在 Bucket 的映射</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 辅助函数：在指定位置(prev_bucket)后插入一个新桶(new_bucket)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_insert_after</span>(<span class="params">self, prev_bucket, new_bucket</span>):</span><br><span class="line">        new_bucket.<span class="built_in">next</span> = prev_bucket.<span class="built_in">next</span></span><br><span class="line">        new_bucket.last = prev_bucket</span><br><span class="line">        prev_bucket.<span class="built_in">next</span>.last = new_bucket</span><br><span class="line">        prev_bucket.<span class="built_in">next</span> = new_bucket</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 辅助函数：从链表中移除一个桶，让前后的指针跳过当前桶</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_remove_bucket</span>(<span class="params">self, bucket</span>):</span><br><span class="line">        bucket.last.<span class="built_in">next</span> = bucket.<span class="built_in">next</span></span><br><span class="line">        bucket.<span class="built_in">next</span>.last = bucket.last</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 核心步骤：将key从当前桶移动到cnt+1的桶</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="comment"># case 1: 新key，计数值为1</span></span><br><span class="line">            <span class="comment"># 找到或创建cnt=1的桶</span></span><br><span class="line">            target_bucket = <span class="variable language_">self</span>.head.<span class="built_in">next</span> <span class="comment">#定位到第一个桶</span></span><br><span class="line">            <span class="keyword">if</span> target_bucket.cnt != <span class="number">1</span>:</span><br><span class="line">                target_bucket = <span class="variable language_">self</span>.Bucket(<span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>._insert_after(<span class="variable language_">self</span>.head, target_bucket)</span><br><span class="line">            <span class="comment"># 将key加入桶和map</span></span><br><span class="line">            target_bucket.keys.add(key)</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = target_bucket</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># case 2: key已存在</span></span><br><span class="line">            current_bucket = <span class="variable language_">self</span>.<span class="built_in">map</span>[key] <span class="comment">#map是双向的</span></span><br><span class="line">            new_cnt = current_bucket.cnt + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到或创建cnt=new_cnt的桶</span></span><br><span class="line">            target_bucket = current_bucket.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> target_bucket.cnt != new_cnt:</span><br><span class="line">                target_bucket = <span class="variable language_">self</span>.Bucket(new_cnt)</span><br><span class="line">                <span class="variable language_">self</span>._insert_after(current_bucket, target_bucket)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动key</span></span><br><span class="line">            target_bucket.keys.add(key)</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = target_bucket</span><br><span class="line">            current_bucket.keys.remove(key)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果原桶变空，则移除</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_bucket.keys:</span><br><span class="line">                <span class="variable language_">self</span>._remove_bucket(current_bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.<span class="built_in">map</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 核心步骤：将key从当前桶移动到cnt-1的桶</span></span><br><span class="line">        current_bucket = <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">        current_bucket.keys.remove(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_bucket.cnt &gt; <span class="number">1</span>:</span><br><span class="line">            new_cnt = current_bucket.cnt - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到或创建cnt=new_cnt的桶</span></span><br><span class="line">            target_bucket = current_bucket.last</span><br><span class="line">            <span class="keyword">if</span> target_bucket.cnt != new_cnt:</span><br><span class="line">                target_bucket = <span class="variable language_">self</span>.Bucket(new_cnt)</span><br><span class="line">                <span class="variable language_">self</span>._insert_after(current_bucket.last, target_bucket)</span><br><span class="line">            <span class="comment"># 移动key</span></span><br><span class="line">            target_bucket.keys.add(key)</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">map</span>[key] = target_bucket</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果cnt为1，dec后直接从map中移除</span></span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.<span class="built_in">map</span>[key]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果原桶变空，则移除</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current_bucket.keys:</span><br><span class="line">            <span class="variable language_">self</span>._remove_bucket(current_bucket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMaxKey</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 最大计数值的桶在tail哨兵节点的前面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.tail.last == <span class="variable language_">self</span>.head:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从桶的集合中任意取一个key即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(<span class="built_in">iter</span>(<span class="variable language_">self</span>.tail.last.keys)) </span><br><span class="line">        <span class="comment"># self.tail.last - 获取尾哨兵节点的前一个节点，也就是链表中最后一个实际的桶</span></span><br><span class="line">        <span class="comment"># .keys - 这个桶中存储的键的集合（set）</span></span><br><span class="line">        <span class="comment"># iter(...) - 将集合转换为迭代器</span></span><br><span class="line">        <span class="comment"># next(...) - 从迭代器中获取第一个元</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinKey</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 最小计数值的桶在head哨兵节点的后面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.head.<span class="built_in">next</span> == <span class="variable language_">self</span>.tail:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从桶的集合中任意取一个key即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(<span class="built_in">iter</span>(<span class="variable language_">self</span>.head.<span class="built_in">next</span>.keys))</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：所有操作都是O(1)</li>
<li><strong>空间复杂度</strong>：O(N)</li>
<li><strong>核心技巧</strong>：双向链表 + 桶分组</li>
</ul>
<h2 id="数据结构设计核心技巧总结"><a href="#数据结构设计核心技巧总结" class="headerlink" title="数据结构设计核心技巧总结"></a>数据结构设计核心技巧总结</h2><h3 id="1-哈希表的O-1-特性"><a href="#1-哈希表的O-1-特性" class="headerlink" title="1. 哈希表的O(1)特性"></a>1. 哈希表的O(1)特性</h3><p>大部分设计题都基于哈希表的O(1)查找、插入、删除特性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本哈希表操作</span></span><br><span class="line">hash_map = &#123;&#125;</span><br><span class="line">hash_map[key] = value  <span class="comment"># O(1) 插入</span></span><br><span class="line">val = hash_map[key]    <span class="comment"># O(1) 查找</span></span><br><span class="line"><span class="keyword">del</span> hash_map[key]      <span class="comment"># O(1) 删除</span></span><br></pre></td></tr></table></figure>

<h3 id="2-时间戳技巧"><a href="#2-时间戳技巧" class="headerlink" title="2. 时间戳技巧"></a>2. 时间戳技巧</h3><p>用于实现懒更新策略：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间戳比较</span></span><br><span class="line"><span class="keyword">if</span> operation_time &gt; global_time:</span><br><span class="line">    <span class="keyword">return</span> local_value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> global_value</span><br></pre></td></tr></table></figure>

<h3 id="3-双向链表维护顺序"><a href="#3-双向链表维护顺序" class="headerlink" title="3. 双向链表维护顺序"></a>3. 双向链表维护顺序</h3><p>适用于需要频繁移动元素位置的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双向链表节点移动</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_to_tail</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># 断开原连接</span></span><br><span class="line">    node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">    node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    <span class="comment"># 插入到尾部</span></span><br><span class="line">    node.<span class="built_in">next</span> = tail</span><br><span class="line">    node.prev = tail.prev</span><br><span class="line">    tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">    tail.prev = node</span><br></pre></td></tr></table></figure>

<h3 id="4-数组末尾交换删除"><a href="#4-数组末尾交换删除" class="headerlink" title="4. 数组末尾交换删除"></a>4. 数组末尾交换删除</h3><p>实现O(1)删除的经典技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将待删除元素与末尾元素交换</span></span><br><span class="line">arr[del_index] = arr[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">map</span>[arr[-<span class="number">1</span>]] = del_index  <span class="comment"># 更新索引映射</span></span><br><span class="line">arr.pop()  <span class="comment"># 删除末尾元素</span></span><br></pre></td></tr></table></figure>

<h3 id="5-双堆维护极值"><a href="#5-双堆维护极值" class="headerlink" title="5. 双堆维护极值"></a>5. 双堆维护极值</h3><p>适用于动态维护中位数或其他统计量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 维护两个堆的平衡</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">len</span>(max_heap) - <span class="built_in">len</span>(min_heap)) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 从大的堆移动元素到小的堆</span></span><br><span class="line">    balance_heaps()</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>setAll哈希表</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+时间戳</td>
</tr>
<tr>
<td>LRU缓存</td>
<td>O(1)</td>
<td>O(capacity)</td>
<td>哈希表+双向链表</td>
</tr>
<tr>
<td>随机数据结构</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+动态数组</td>
</tr>
<tr>
<td>随机数据结构(重复)</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+集合+数组</td>
</tr>
<tr>
<td>中位数查找</td>
<td>O(logN)&#x2F;O(1)</td>
<td>O(N)</td>
<td>双堆</td>
</tr>
<tr>
<td>最大频率栈</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+栈数组</td>
</tr>
<tr>
<td>全O(1)数据结构</td>
<td>O(1)</td>
<td>O(N)</td>
<td>哈希表+双向链表+桶</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>理解O(1)的本质</strong>：大多数设计题的核心是利用哈希表的O(1)特性</p>
</li>
<li><p><strong>掌握组合数据结构</strong>：</p>
<ul>
<li>哈希表 + 双向链表（LRU）</li>
<li>哈希表 + 动态数组（随机访问）</li>
<li>双堆（维护极值）</li>
<li>时间戳（懒更新）</li>
</ul>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空数据结构</li>
<li>容量限制</li>
<li>重复元素处理</li>
</ul>
</li>
<li><p><strong>理解权衡取舍</strong>：</p>
<ul>
<li>时间复杂度 vs 空间复杂度</li>
<li>实现复杂度 vs 运行效率</li>
</ul>
</li>
<li><p><strong>多练习组合技巧</strong>：数据结构设计题往往需要组合多种基础数据结构</p>
</li>
</ol>
<p>数据结构设计题考察的是对基础数据结构的深入理解和灵活运用能力。通过掌握这些经典模式和技巧，可以应对大多数设计类问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（12）- 链表高频题目和必备技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-17 08:42:46 / Modified: 17:06:58" itemprop="dateCreated datePublished" datetime="2025-08-17T08:42:46+08:00">2025-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记总结了链表类题目的高频考点和必备技巧，包含6道经典链表题目的详细解析。链表题目主要考察的是编程能力而非算法设计，是class034的内容。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习链表高频题目之前，需要掌握以下基础知识：</p>
<ul>
<li>链表入门内容（009~012讲）</li>
<li>归并排序（021讲）</li>
<li>哈希表的使用（026讲）</li>
<li>排序算法的稳定性（029讲）</li>
</ul>
<h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的指针</span></span><br></pre></td></tr></table></figure>


<h1 id="034【必备】链表高频题目和必备技巧"><a href="#034【必备】链表高频题目和必备技巧" class="headerlink" title="034【必备】链表高频题目和必备技巧"></a>034【必备】链表高频题目和必备技巧</h1><h2 id="链表题目解题要点"><a href="#链表题目解题要点" class="headerlink" title="链表题目解题要点"></a>链表题目解题要点</h2><h3 id="核心注意事项"><a href="#核心注意事项" class="headerlink" title="核心注意事项"></a>核心注意事项</h3><ol>
<li><p><strong>空间复杂度的选择</strong>：</p>
<ul>
<li>如果笔试中空间要求不严格，直接使用容器来解决链表问题</li>
<li>如果笔试中空间要求严格、或者在面试中面试官强调空间的优化，需要使用额外空间复杂度O(1)的方法</li>
</ul>
</li>
<li><p><strong>最常用的技巧</strong>：快慢指针</p>
</li>
<li><p><strong>考察重点</strong>：链表类题目往往都是很简单的算法问题，核心考察点并不是算法设计，而是coding能力</p>
</li>
<li><p><strong>练习建议</strong>：既然练的就是coding，那么不要采取空间上讨巧的方式来练习（容器方法），这些题难就难在要用有限几个变量来解决</p>
</li>
</ol>
<h2 id="题目一：返回两个无环链表相交的第一个节点"><a href="#题目一：返回两个无环链表相交的第一个节点" class="headerlink" title="题目一：返回两个无环链表相交的第一个节点"></a>题目一：返回两个无环链表相交的第一个节点</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个单链表的头节点，判断两个链表是否相交，如果相交返回第一个交点，否则返回None。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="链表相交的概念"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法（空间复杂度O(N)）</strong>：</p>
<ol>
<li>遍历链表1，将每个节点加入哈希表</li>
<li>遍历链表2，检查每个节点是否在哈希表中</li>
<li>如果找到第一个在哈希表中的节点，即为第一个交点</li>
</ol>
<p><strong>最优解法（空间复杂度O(1)）</strong>：<br>核心思想是先判断两条链表是否相交，再找交点。</p>
<p>判断相交的关键：两条链表如果相交，最后一个节点一定是同一个节点（因为链表每个节点只有一个next指针）。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回两个无环链表相交的第一个节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, h1: ListNode, h2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> h1 <span class="keyword">or</span> <span class="keyword">not</span> h2:  <span class="comment"># 任一链表为空，不可能相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    a = h1  <span class="comment"># a指针遍历链表1</span></span><br><span class="line">    b = h2  <span class="comment"># b指针遍历链表2</span></span><br><span class="line">    diff = <span class="number">0</span>  <span class="comment"># 记录两个链表的长度差</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历链表1，计算其长度</span></span><br><span class="line">    <span class="keyword">while</span> a.<span class="built_in">next</span>:</span><br><span class="line">        a = a.<span class="built_in">next</span>  <span class="comment"># a指针后移</span></span><br><span class="line">        diff += <span class="number">1</span>  <span class="comment"># 长度差加1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历链表2，计算其长度</span></span><br><span class="line">    <span class="keyword">while</span> b.<span class="built_in">next</span>:</span><br><span class="line">        b = b.<span class="built_in">next</span>  <span class="comment"># b指针后移</span></span><br><span class="line">        diff -= <span class="number">1</span>  <span class="comment"># 长度差减1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> a != b:  <span class="comment"># 最后一个节点不同，说明不相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 根据长度差的正负，确定哪个是长链表，哪个是短链表</span></span><br><span class="line">    <span class="comment"># a指向长链表的头，b指向短链表的头</span></span><br><span class="line">    <span class="keyword">if</span> diff &gt;= <span class="number">0</span>:</span><br><span class="line">        a = h1  <span class="comment"># a指向长链表</span></span><br><span class="line">        b = h2  <span class="comment"># b指向短链表</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = h2</span><br><span class="line">        b = h1</span><br><span class="line">        </span><br><span class="line">    diff = <span class="built_in">abs</span>(diff)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> diff != <span class="number">0</span>:</span><br><span class="line">        a = a.<span class="built_in">next</span></span><br><span class="line">        diff -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 同时移动直到相遇</span></span><br><span class="line">    <span class="keyword">while</span> a != b:</span><br><span class="line">        a = a.<span class="built_in">next</span></span><br><span class="line">        b = b.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> a  <span class="comment"># 返回交点</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(M + N)，M和N分别是两个链表的长度</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：长度差计算 + 双指针</li>
</ul>
<h2 id="题目二：每k个节点一组翻转链表"><a href="#题目二：每k个节点一组翻转链表" class="headerlink" title="题目二：每k个节点一组翻转链表"></a>题目二：每k个节点一组翻转链表</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，每k个节点一组进行翻转，如果最后剩余节点不够k个，则保持原样。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：把所有节点都放到数组里，然后每k个节点一组进行翻转，但空间复杂度为O(N)。</p>
<p><strong>最优解法</strong>：使用有限变量完成分组翻转。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" alt="每k个节点一组反转链表"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-reverse%E8%BF%87%E7%A8%8B.png" alt="每k个节点一组反转链表-reverse过程"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E6%89%BElastteamend.png" alt="每k个节点一组反转链表-找lastteamend"></p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按k个一组翻转链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    start = head  <span class="comment"># start指向当前组的开始节点</span></span><br><span class="line">    end = <span class="variable language_">self</span>.teamEnd(start, k)  <span class="comment"># 找到第一组的结束节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果第一组的长度不足k，直接返回原链表头节点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一组很特殊因为牵扯到换头的问题</span></span><br><span class="line">    <span class="comment"># 翻转后，第一组的末尾节点end会成为整个链表的新头节点</span></span><br><span class="line">    head = end</span><br><span class="line">    <span class="variable language_">self</span>.reverse(start, end)  <span class="comment"># 翻转第一组节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 翻转之后start变成了上一组的结尾节点</span></span><br><span class="line">    lastTeamEnd = start  <span class="comment"># lastTeamEnd记录上一组翻转后的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环处理剩余的链表</span></span><br><span class="line">    <span class="keyword">while</span> lastTeamEnd.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        start = lastTeamEnd.<span class="built_in">next</span>  <span class="comment"># 下一组的开始节点</span></span><br><span class="line">        end = <span class="variable language_">self</span>.teamEnd(start, k)  <span class="comment"># 找到下一组的结束节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果剩余部分的长度不足k，直接返回头节点，不进行翻转</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.reverse(start, end)  <span class="comment"># 翻转当前组</span></span><br><span class="line">        lastTeamEnd.<span class="built_in">next</span> = end  <span class="comment"># 将上一组的尾节点与当前组翻转后的头节点(即原来的end)连接起来</span></span><br><span class="line">        lastTeamEnd = start  <span class="comment"># 更新lastTeamEnd为当前组翻转后的尾节点(即原来的start)</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回新的头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前组的开始节点是s，往下数k个找到当前组的结束节点返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">teamEnd</span>(<span class="params">self, s: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找到从s开始第k个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从s开始，向后移动k-1次</span></span><br><span class="line">    <span class="keyword">while</span> k - <span class="number">1</span> != <span class="number">0</span> <span class="keyword">and</span> s <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        s = s.<span class="built_in">next</span>  <span class="comment"># s指针后移</span></span><br><span class="line">        k -= <span class="number">1</span>  <span class="comment"># 计数器减1</span></span><br><span class="line">    <span class="keyword">return</span> s  <span class="comment"># 返回第k个节点，如果不足k个则返回None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s -&gt; a -&gt; b -&gt; c -&gt; e -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment"># 上面的链表通过如下的reverse方法调整成 : e -&gt; c -&gt; b -&gt; a -&gt; s -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment"># 翻转从s到e的这一段链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, s: ListNode, e: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;翻转从s到e的链表段&quot;&quot;&quot;</span></span><br><span class="line">    e = e.<span class="built_in">next</span>  <span class="comment"># e是当前组的结尾，e.next指向下一组的开头</span></span><br><span class="line">    pre = <span class="literal">None</span>  <span class="comment"># pre是前一个节点，初值为None</span></span><br><span class="line">    cur = s  <span class="comment"># cur是当前节点，初值为s</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next是下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历当前组，直到cur到达下一组的开头</span></span><br><span class="line">    <span class="keyword">while</span> cur != e:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存当前节点的下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre  <span class="comment"># 将当前节点的next指针指向前一个节点</span></span><br><span class="line">        pre = cur  <span class="comment"># pre, cur向后移动</span></span><br><span class="line">        cur = next_node</span><br><span class="line">    </span><br><span class="line">    s.<span class="built_in">next</span> = e  <span class="comment"># 翻转后，原来的头节点s变成了尾节点，它的next应该指向下一组的开头</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：分组处理 + 局部翻转</li>
</ul>
<h2 id="题目三：复制带随机指针的链表"><a href="#题目三：复制带随机指针的链表" class="headerlink" title="题目三：复制带随机指针的链表"></a>题目三：复制带随机指针的链表</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>复制一个带random指针的链表，random可以指向链表中的任意节点或者null。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：使用哈希表记录原节点和新节点的对应关系，空间复杂度O(N)。</p>
<p><strong>最优解法</strong>：在原链表上直接操作，分三步完成复制。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%8B%B7%E8%B4%9D%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88.png" alt="拷贝随机指针"></p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果头节点为空，直接返回None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    cur = head  <span class="comment"># cur指针用于遍历原链表</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next指针用于暂存下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1 -&gt; 2 -&gt; 3 -&gt; ...变成 : 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; -&gt; ...</span></span><br><span class="line">    <span class="comment"># 第一步：复制每个节点并将其插入到原节点之后</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存原节点的下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = <span class="variable language_">self</span>.Node(cur.val)  <span class="comment"># 创建新节点，值为原节点的值</span></span><br><span class="line">        cur.<span class="built_in">next</span>.<span class="built_in">next</span> = next_node  <span class="comment"># 将新节点的next指向原节点的下一个节点</span></span><br><span class="line">        cur = next_node  <span class="comment"># 移动cur到下一个原节点</span></span><br><span class="line">    </span><br><span class="line">    cur = head  <span class="comment"># cur指针重置回头节点，准备设置新节点的random指针</span></span><br><span class="line">    copy = <span class="literal">None</span>  <span class="comment"># copy指针用于指向复制的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二步：为新节点设置random指针</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 保存下一个原节点的位置</span></span><br><span class="line">        copy = cur.<span class="built_in">next</span>  <span class="comment"># 获取当前节点的复制节点</span></span><br><span class="line">        <span class="comment"># 设置复制节点的random指针</span></span><br><span class="line">        <span class="comment"># 如果原节点的random不为空，则其复制节点的random指向原节点random的下一个节点(即random指向节点的复制品)</span></span><br><span class="line">        copy.random = cur.random.<span class="built_in">next</span> <span class="keyword">if</span> cur.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        cur = next_node  <span class="comment"># 移动cur到下一个原节点</span></span><br><span class="line">        </span><br><span class="line">    ans = head.<span class="built_in">next</span>  <span class="comment"># ans是新链表的头节点，即原头节点的下一个节点</span></span><br><span class="line">    cur = head  <span class="comment"># cur指针重置回头节点，准备分离新旧链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三步：分离原链表和新链表</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 保存下一个原节点的位置</span></span><br><span class="line">        copy = cur.<span class="built_in">next</span>  <span class="comment"># 获取当前节点的复制节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = next_node  <span class="comment"># 恢复原链表的next指针</span></span><br><span class="line">        <span class="comment"># 设置复制节点的next指针</span></span><br><span class="line">        <span class="comment"># 如果下一个原节点不为空，则复制节点的next指向下一个原节点的复制节点</span></span><br><span class="line">        copy.<span class="built_in">next</span> = next_node.<span class="built_in">next</span> <span class="keyword">if</span> next_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        cur = next_node  <span class="comment"># 移动cur到下一个原节点</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans  <span class="comment"># 返回新链表的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：节点插入 + 关系复制 + 链表分离</li>
</ul>
<h2 id="题目四：判断链表是否是回文结构"><a href="#题目四：判断链表是否是回文结构" class="headerlink" title="题目四：判断链表是否是回文结构"></a>题目四：判断链表是否是回文结构</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断链表是否是回文结构，一个链表节点视为一个字符。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：使用栈存储所有节点，然后比较压栈过程和弹栈过程的数字是不是一致的，空间复杂度O(N)。</p>
<p><strong>最优解法</strong>：使用快慢指针找中点，翻转后半部分，然后比较。</p>
<h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交如下的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空链表或只有一个节点的链表是回文结构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    slow = head  <span class="comment"># slow指针每次走一步，fast指针每次走两步</span></span><br><span class="line">    fast = head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找中点，当fast到达链表末尾时，slow正好在中间位置</span></span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>  <span class="comment"># slow指针后移一步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># fast指针后移两步</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 现在中点就是slow，从中点开始往后的节点逆序</span></span><br><span class="line">    pre = slow  <span class="comment"># pre是反转后的链表的头节点，初始是slow</span></span><br><span class="line">    cur = pre.<span class="built_in">next</span>  <span class="comment"># cur是当前要处理的节点，初始是slow的下一个</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next_node用于保存cur的下一个节点</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 断开前半部分和后半部分的连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环反转后半部分链表</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre  <span class="comment"># 当前节点的next指向前一个节点(pre)</span></span><br><span class="line">        pre = cur  <span class="comment"># pre和cur指针后移</span></span><br><span class="line">        cur = next_node</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 上面的过程已经把链表调整成从左右两侧往中间指</span></span><br><span class="line">    <span class="comment"># head -&gt; ... -&gt; slow &lt;- ... &lt;- pre</span></span><br><span class="line">    ans = <span class="literal">True</span>  <span class="comment"># ans默认为True，即假设是回文</span></span><br><span class="line">    left = head  <span class="comment"># left指针从头开始</span></span><br><span class="line">    right = pre  <span class="comment"># right指针从后半部分的头（即反转前的尾）开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># left往右、right往左，每一步比对值是否一样，如果某一步不一样答案就是false</span></span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:  <span class="comment"># 如果左右两边的值不相等</span></span><br><span class="line">            ans = <span class="literal">False</span>  <span class="comment"># 那么不是回文</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 退出循环</span></span><br><span class="line">        left = left.<span class="built_in">next</span>  <span class="comment"># 移动指针</span></span><br><span class="line">        right = right.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 本着不坑的原则，把链表调整回原来的样子再返回判断结果</span></span><br><span class="line">    <span class="comment"># 再次反转后半部分，恢复原链表结构</span></span><br><span class="line">    cur = pre.<span class="built_in">next</span>  <span class="comment"># cur是当前要处理的节点，初始是pre的下一个</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 断开连接</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next_node用于保存cur的下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环将后半部分链表反转回来</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre  <span class="comment"># 当前节点的next指向前一个节点(pre)</span></span><br><span class="line">        pre = cur  <span class="comment"># pre和cur指针后移</span></span><br><span class="line">        cur = next_node</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans  <span class="comment"># 返回最终的判断结果</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：快慢指针找中点 + 链表翻转</li>
</ul>
<h2 id="题目五：返回链表的第一个入环节点"><a href="#题目五：返回链表的第一个入环节点" class="headerlink" title="题目五：返回链表的第一个入环节点"></a>题目五：返回链表的第一个入环节点</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断链表是否有环，如果有环，返回入环节点，否则返回None。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：用哈希表记录每个节点，如果某个节点再次出现，则该节点就是入环节点。</p>
<p><strong>最优解法</strong>：使用快慢指针，分两阶段找环。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%BC%9A%E5%9C%A8%E5%85%A5%E7%8E%AF%E5%A4%84%E7%9B%B8%E9%81%87.png" alt="快慢指针会在入环处相遇"></p>
<h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>设链表头到入环点距离为a，入环点到相遇点距离为b，相遇点到入环点距离为c。</p>
<p>当快慢指针相遇时：</p>
<ul>
<li>慢指针走过距离：a + b</li>
<li>快指针走过距离：a + b + c + b &#x3D; a + 2b + c</li>
</ul>
<p>由于快指针速度是慢指针的2倍：<br>2(a + b) &#x3D; a + 2b + c<br>解得：a &#x3D; c</p>
<h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    slow = head.<span class="built_in">next</span>  <span class="comment"># 慢指针slow每次走一步</span></span><br><span class="line">    fast = head.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 快指针fast每次走两步</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一阶段：快慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        <span class="keyword">if</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果快指针或其下一个节点为空，说明没有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span>  <span class="comment"># 慢指针走一步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 快指针走两步</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 第二阶段：快指针回到头部，同步移动</span></span><br><span class="line">    fast = head  <span class="comment"># 当快慢指针相遇后，将快指针重置到链表头</span></span><br><span class="line">    <span class="comment"># 此时，慢指针和快指针同时以每次一步的速度前进</span></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>  <span class="comment"># 慢指针后移</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>  <span class="comment"># 快指针后移</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> slow  <span class="comment"># 相遇点即为入环点</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：快慢指针 + 数学推导</li>
</ul>
<h2 id="题目六：链表排序"><a href="#题目六：链表排序" class="headerlink" title="题目六：链表排序"></a>题目六：链表排序</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>在链表上排序，要求时间复杂度O(n*logn)，额外空间复杂度O(1)，还要求排序有稳定性。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>链表由于有指针存在可以做到这个指标，但是数组排序不行。使用自底向上的归并排序，采用非递归方法避免O(logn)的递归空间。</p>
<h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findEnd</span>(<span class="params">self, s: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从s开始找第k个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> s.<span class="built_in">next</span> <span class="keyword">and</span> k - <span class="number">1</span> &gt; <span class="number">0</span>:</span><br><span class="line">        s = s.<span class="built_in">next</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># l1...r1 -&gt; null : 有序的左部分 (在Python实现中r1,r2参数是不必要的)</span></span><br><span class="line"><span class="comment"># l2...r2 -&gt; null : 有序的右部分</span></span><br><span class="line"><span class="comment"># 整体merge在一起，保证有序</span></span><br><span class="line"><span class="comment"># 并且返回整体的头和尾</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; (ListNode, ListNode):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并两个有序链表，返回头和尾&quot;&quot;&quot;</span></span><br><span class="line">    dummy = <span class="variable language_">self</span>.ListNode(<span class="number">0</span>)  <span class="comment"># dummy是哨兵节点，方便处理</span></span><br><span class="line">    pre = dummy  <span class="comment"># pre指针用于构建新链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当两个链表都不为空时</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="comment"># 比较两个链表节点的值</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            pre.<span class="built_in">next</span> = l1  <span class="comment"># 将较小的节点连接到新链表</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span>  <span class="comment"># 移动l1指针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre.<span class="built_in">next</span> = l2  <span class="comment"># 将较小的节点连接到新链表</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span>  <span class="comment"># 移动l2指针</span></span><br><span class="line">        pre = pre.<span class="built_in">next</span>  <span class="comment"># 移动pre指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果l1还有剩余，直接连接</span></span><br><span class="line">    <span class="keyword">if</span> l1:</span><br><span class="line">        pre.<span class="built_in">next</span> = l1</span><br><span class="line">    <span class="keyword">elif</span> l2:  <span class="comment"># 如果l2还有剩余，直接连接</span></span><br><span class="line">        pre.<span class="built_in">next</span> = l2</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 找到合并后链表的尾部</span></span><br><span class="line">    <span class="keyword">while</span> pre.<span class="built_in">next</span>:</span><br><span class="line">        pre = pre.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>, pre  <span class="comment"># 返回新链表的头和尾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;正式排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:  <span class="comment"># 如果链表为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="number">0</span>  <span class="comment"># n用于存储链表长度</span></span><br><span class="line">    cur = head  <span class="comment"># cur用于遍历链表</span></span><br><span class="line">    <span class="comment"># 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># l1...r1 每组的左部分</span></span><br><span class="line">    <span class="comment"># l2...r2 每组的右部分</span></span><br><span class="line">    <span class="comment"># next_group_head 下一组的开头</span></span><br><span class="line">    <span class="comment"># last_team_end 上一组的结尾</span></span><br><span class="line">    </span><br><span class="line">    step = <span class="number">1</span>  <span class="comment"># step是每次合并的子链表长度，从1开始，每次翻倍</span></span><br><span class="line">    <span class="keyword">while</span> step &lt; n:</span><br><span class="line">        <span class="comment"># 每一轮归并开始时，重新从头开始，dummy是一个哨兵节点，方便处理头节点</span></span><br><span class="line">        dummy = <span class="variable language_">self</span>.ListNode(<span class="number">0</span>, head)</span><br><span class="line">        last_team_end = dummy  <span class="comment"># last_team_end指向上一次合并后的尾部</span></span><br><span class="line">        cur = dummy.<span class="built_in">next</span>  <span class="comment"># cur指向当前处理的链表的头部</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:       </span><br><span class="line">            l1 = cur  <span class="comment"># l1是第一部分的头</span></span><br><span class="line">            r1 = <span class="variable language_">self</span>.findEnd(l1, step)  <span class="comment"># r1是第一部分的尾</span></span><br><span class="line">            l2 = r1.<span class="built_in">next</span> <span class="keyword">if</span> r1 <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># l2是第二部分的头</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l2:  <span class="comment"># 如果没有第二部分，就结束这一轮的合并</span></span><br><span class="line">                last_team_end.<span class="built_in">next</span> = l1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            r2 = <span class="variable language_">self</span>.findEnd(l2, step)  <span class="comment"># r2是第二部分的尾</span></span><br><span class="line">            </span><br><span class="line">            next_group_head = r2.<span class="built_in">next</span> <span class="keyword">if</span> r2 <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># next_group_head是下一组的头</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 断开链表，准备合并</span></span><br><span class="line">            r1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            r2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            merged_head, merged_end = <span class="variable language_">self</span>.merge(l1, l2)  <span class="comment"># 合并l1和l2两个有序链表</span></span><br><span class="line">            </span><br><span class="line">            last_team_end.<span class="built_in">next</span> = merged_head  <span class="comment"># 将合并后的链表接在上一组的后面</span></span><br><span class="line">            last_team_end = merged_end  <span class="comment"># 更新last_team_end为当前合并后的尾部</span></span><br><span class="line">            </span><br><span class="line">            cur = next_group_head  <span class="comment"># cur指向下一组的开头</span></span><br><span class="line">        </span><br><span class="line">        head = dummy.<span class="built_in">next</span>  <span class="comment"># 更新整个链表的头</span></span><br><span class="line">        step &lt;&lt;= <span class="number">1</span>  <span class="comment"># 步长翻倍</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N*logN)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：是</li>
<li><strong>核心技巧</strong>：自底向上归并 + 非递归实现</li>
</ul>
<h2 id="链表问题核心技巧总结"><a href="#链表问题核心技巧总结" class="headerlink" title="链表问题核心技巧总结"></a>链表问题核心技巧总结</h2><h3 id="1-快慢指针技巧"><a href="#1-快慢指针技巧" class="headerlink" title="1. 快慢指针技巧"></a>1. 快慢指针技巧</h3><p>快慢指针是链表问题中最重要的技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找链表中点</span></span><br><span class="line">slow = fast = head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># slow指向中点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断链表是否有环</span></span><br><span class="line">slow = fast = head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> slow == fast:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 有环</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="2-虚拟头节点技巧"><a href="#2-虚拟头节点技巧" class="headerlink" title="2. 虚拟头节点技巧"></a>2. 虚拟头节点技巧</h3><p>当需要修改头节点时，使用虚拟头节点简化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">dummy.<span class="built_in">next</span> = head</span><br><span class="line"><span class="comment"># 对dummy.next进行操作</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="3-双指针技巧"><a href="#3-双指针技巧" class="headerlink" title="3. 双指针技巧"></a>3. 双指针技巧</h3><p>用于处理需要同时操作两个位置的问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除倒数第n个节点</span></span><br><span class="line">dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">first = second = dummy</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">    first = first.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">while</span> first:</span><br><span class="line">    first = first.<span class="built_in">next</span></span><br><span class="line">    second = second.<span class="built_in">next</span></span><br><span class="line">second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="4-链表翻转技巧"><a href="#4-链表翻转技巧" class="headerlink" title="4. 链表翻转技巧"></a>4. 链表翻转技巧</h3><p>翻转是链表的基础操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">head</span>):</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next_node</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心技巧</th>
</tr>
</thead>
<tbody><tr>
<td>链表相交</td>
<td>O(M+N)</td>
<td>O(1)</td>
<td>长度差+双指针</td>
</tr>
<tr>
<td>K组翻转</td>
<td>O(N)</td>
<td>O(1)</td>
<td>分组+局部翻转</td>
</tr>
<tr>
<td>复制随机链表</td>
<td>O(N)</td>
<td>O(1)</td>
<td>节点插入+分离</td>
</tr>
<tr>
<td>回文判断</td>
<td>O(N)</td>
<td>O(1)</td>
<td>快慢指针+翻转</td>
</tr>
<tr>
<td>环检测</td>
<td>O(N)</td>
<td>O(1)</td>
<td>快慢指针+数学</td>
</tr>
<tr>
<td>链表排序</td>
<td>O(N*logN)</td>
<td>O(1)</td>
<td>自底向上归并</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>重视编程能力</strong>：链表题目主要考察coding能力，要多练习用有限变量解决问题</p>
</li>
<li><p><strong>掌握核心技巧</strong>：</p>
<ul>
<li>快慢指针（最重要）</li>
<li>虚拟头节点</li>
<li>双指针</li>
<li>链表翻转</li>
</ul>
</li>
<li><p><strong>避免容器方法</strong>：在练习时尽量使用O(1)空间的方法，提升编程能力</p>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空链表</li>
<li>单节点链表</li>
<li>链表长度不足的情况</li>
</ul>
</li>
<li><p><strong>保持链表结构</strong>：某些题目要求恢复原链表结构，要特别注意</p>
</li>
</ol>
<p>链表问题虽然算法相对简单，但对编程能力要求较高。通过大量练习和对核心技巧的熟练掌握，可以有效提升解题能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89-%20%E4%BD%8D%E5%9B%BE&%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89-%20%E4%BD%8D%E5%9B%BE&%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（11）- 位图&位运算实现加减乘除</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-16 08:42:46 / Modified: 17:27:38" itemprop="dateCreated datePublished" datetime="2025-08-16T08:42:46+08:00">2025-08-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记包括了位图数据结构的原理、实现和应用，以及如何用位运算实现加减乘除（完全不依赖任何算术运算符）。涵盖了class032 and class033的内容</p>
<h1 id="032【必备】位图"><a href="#032【必备】位图" class="headerlink" title="032【必备】位图"></a>032【必备】位图</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习位图之前，需要掌握以下基础知识：</p>
<ul>
<li>二进制和位运算操作</li>
<li>对数器的使用方法</li>
</ul>
<p><strong>Python特别提醒</strong>：在实现位运算题目时需要特别注意溢出和符号扩展问题，通常需要手动处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中处理溢出的常见方法</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h2 id="位图的核心概念"><a href="#位图的核心概念" class="headerlink" title="位图的核心概念"></a>位图的核心概念</h2><h3 id="什么是位图"><a href="#什么是位图" class="headerlink" title="什么是位图"></a>什么是位图</h3><p>位图（Bitset）是一种极其节省空间的数据结构，用于存储大量布尔值。相比传统哈希表，位图具有显著的空间优势：</p>
<ul>
<li><strong>哈希表</strong>：每存储一个数字需要32个bit的空间</li>
<li><strong>位图</strong>：每存储一个数字只需要1个bit的空间</li>
</ul>
<h3 id="位图的基本原理"><a href="#位图的基本原理" class="headerlink" title="位图的基本原理"></a>位图的基本原理</h3><p>位图本质上是用bit组成的数组来存放值，使用bit的状态（1和0）来表示元素的存在性：</p>
<ul>
<li><strong>bit位为1</strong>：表示该数字存在于集合中</li>
<li><strong>bit位为0</strong>：表示该数字不存在于集合中</li>
</ul>
<p><strong>基本思想</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用一个很长的二进制位数组，每一位（bit）对应一个整数的&quot;有无&quot;状态</span><br><span class="line">第0位代表数字0，第1位代表数字1，第2位代表数字2，依此类推</span><br></pre></td></tr></table></figure>

<h3 id="位图的适用场景"><a href="#位图的适用场景" class="headerlink" title="位图的适用场景"></a>位图的适用场景</h3><p><strong>优势</strong>：</p>
<ul>
<li>极大节省空间（1个数字仅占1个bit）</li>
<li>查询和修改操作都是O(1)时间复杂度</li>
<li>支持高效的批量操作</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>必须是连续范围的整数</li>
<li>范围不能过大（适合0到几百万，不适合到几十亿）</li>
<li>只能表示元素的存在性，不能存储额外信息</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>判断大量整数是否存在</li>
<li>统计范围内数字的出现情况</li>
<li>实现简单的集合操作</li>
</ul>
<h2 id="位图的实现"><a href="#位图的实现" class="headerlink" title="位图的实现"></a>位图的实现</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(11)/class32-%E4%BD%8D%E5%9B%BE/%E4%BD%8D%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="位图实现原理"></p>
<h3 id="类设计接口"><a href="#类设计接口" class="headerlink" title="类设计接口"></a>类设计接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitset</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):          <span class="comment"># 初始化位图，支持0~n-1所有数字</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num</span>):             <span class="comment"># 把num加入到位图</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, num</span>):          <span class="comment"># 把num从位图中删除</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, num</span>):         <span class="comment"># 翻转num的状态（存在则删除，不存在则添加）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, num</span>):        <span class="comment"># 查询num是否在位图中</span></span><br></pre></td></tr></table></figure>

<h3 id="完整实现代码"><a href="#完整实现代码" class="headerlink" title="完整实现代码"></a>完整实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitset</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化位图，支持0~n-1范围内的数字</span></span><br><span class="line"><span class="string">        n个数字需要 (n + 31) // 32 个32位整数来存储</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 计算需要多少个32位整数</span></span><br><span class="line">        <span class="comment"># 使用 (n + 31) // 32 实现向上取整</span></span><br><span class="line">        <span class="comment"># 例如：32个数字需要1个整数，33个数字需要2个整数</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span> = [<span class="number">0</span>] * ((n + <span class="number">31</span>) // <span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将num添加到位图中（将对应位设置为1）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># num // 32：确定数字在第几个32位整数中</span></span><br><span class="line">        <span class="comment"># num % 32：确定在该32位整数中的第几位</span></span><br><span class="line">        <span class="comment"># 1 &lt;&lt; (num % 32)：创建掩码，将1左移到对应位置</span></span><br><span class="line">        <span class="comment"># |=：按位或赋值，将对应位设置为1</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (num % <span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将num从位图中删除（将对应位设置为0）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ~(1 &lt;&lt; (num % 32))：创建掩码并取反，除了目标位其他位都是1</span></span><br><span class="line">        <span class="comment"># &amp;=：按位与赋值，将对应位清除为0</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (num % <span class="number">32</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻转num在位图中的状态</span></span><br><span class="line"><span class="string">        如果存在则删除，如果不存在则添加</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ^=：按位异或赋值</span></span><br><span class="line">        <span class="comment"># 如果位是0，异或1后变成1</span></span><br><span class="line">        <span class="comment"># 如果位是1，异或1后变成0</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] ^= <span class="number">1</span> &lt;&lt; (num % <span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断num是否存在于位图中</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># &gt;&gt; (num % 32)：将目标位移动到最低位</span></span><br><span class="line">        <span class="comment"># &amp; 1：提取最低位的值</span></span><br><span class="line">        <span class="comment"># == 1：判断是否为1</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] &gt;&gt; (num % <span class="number">32</span>)) &amp; <span class="number">1</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="关键实现细节"><a href="#关键实现细节" class="headerlink" title="关键实现细节"></a>关键实现细节</h3><h4 id="1-空间分配策略"><a href="#1-空间分配策略" class="headerlink" title="1. 空间分配策略"></a>1. 空间分配策略</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向上取整的巧妙实现</span></span><br><span class="line"><span class="comment"># 对于n个数字，需要的32位整数个数</span></span><br><span class="line">array_size = (n + <span class="number">31</span>) // <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原理：</span></span><br><span class="line"><span class="comment"># - 如果n=32，则(32+31)//32 = 63//32 = 1（正好1个整数）</span></span><br><span class="line"><span class="comment"># - 如果n=33，则(33+31)//32 = 64//32 = 2（需要2个整数）</span></span><br></pre></td></tr></table></figure>

<h4 id="2-位置计算"><a href="#2-位置计算" class="headerlink" title="2. 位置计算"></a>2. 位置计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_position</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算数字num在位图中的位置&quot;&quot;&quot;</span></span><br><span class="line">    array_index = num // <span class="number">32</span>    <span class="comment"># 在第几个32位整数中</span></span><br><span class="line">    bit_index = num % <span class="number">32</span>       <span class="comment"># 在该整数的第几位</span></span><br><span class="line">    <span class="keyword">return</span> array_index, bit_index</span><br></pre></td></tr></table></figure>

<h4 id="3-位运算技巧总结"><a href="#3-位运算技巧总结" class="headerlink" title="3. 位运算技巧总结"></a>3. 位运算技巧总结</h4><table>
<thead>
<tr>
<th>操作</th>
<th>位运算实现</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>设置位为1</td>
<td><code>x |= (1 &lt;&lt; i)</code></td>
<td>按位或运算</td>
</tr>
<tr>
<td>清除位为0</td>
<td><code>x &amp;= ~(1 &lt;&lt; i)</code></td>
<td>按位与运算（掩码取反）</td>
</tr>
<tr>
<td>翻转位</td>
<td><code>x ^= (1 &lt;&lt; i)</code></td>
<td>按位异或运算</td>
</tr>
<tr>
<td>检查位</td>
<td><code>(x &gt;&gt; i) &amp; 1</code></td>
<td>右移后提取最低位</td>
</tr>
</tbody></table>
<h2 id="对数器测试"><a href="#对数器测试" class="headerlink" title="对数器测试"></a>对数器测试</h2><h3 id="测试设计思路"><a href="#测试设计思路" class="headerlink" title="测试设计思路"></a>测试设计思路</h3><p>使用Python内置的<code>set</code>作为参照标准，对位图的所有操作进行验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_bitset</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用对数器验证位图实现的正确性&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="number">1000</span>          <span class="comment"># 位图大小</span></span><br><span class="line">    testTimes = <span class="number">10000</span> <span class="comment"># 测试次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试开始&quot;</span>)</span><br><span class="line">    bitSet = Bitset(n)      <span class="comment"># 被测试的位图结构</span></span><br><span class="line">    hashSet = <span class="built_in">set</span>()         <span class="comment"># 参照标准（Python内置set）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用阶段开始&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(testTimes):</span><br><span class="line">        decide = random.random()                    <span class="comment"># 随机决定操作类型</span></span><br><span class="line">        number = <span class="built_in">int</span>(random.random() * n)          <span class="comment"># 随机生成0~n-1的数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> decide &lt; <span class="number">0.333</span>:                         <span class="comment"># 33%概率执行add操作</span></span><br><span class="line">            bitSet.add(number)</span><br><span class="line">            hashSet.add(number)</span><br><span class="line">        <span class="keyword">elif</span> decide &lt; <span class="number">0.666</span>:                       <span class="comment"># 33%概率执行remove操作</span></span><br><span class="line">            bitSet.remove(number)</span><br><span class="line">            hashSet.discard(number)                <span class="comment"># 使用discard避免KeyError</span></span><br><span class="line">        <span class="keyword">else</span>:                                      <span class="comment"># 34%概率执行reverse操作</span></span><br><span class="line">            bitSet.reverse(number)</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">in</span> hashSet:</span><br><span class="line">                hashSet.remove(number)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashSet.add(number)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用阶段结束&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证阶段开始&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证所有数字的存在性是否一致</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> bitSet.contains(i) != (i <span class="keyword">in</span> hashSet):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;出错了!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证阶段结束&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试结束&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="测试覆盖的场景"><a href="#测试覆盖的场景" class="headerlink" title="测试覆盖的场景"></a>测试覆盖的场景</h3><ol>
<li><strong>随机操作序列</strong>：大量随机的增删改查操作</li>
<li><strong>边界条件</strong>：0和n-1等边界值</li>
<li><strong>重复操作</strong>：对同一个数字的重复操作</li>
<li><strong>状态一致性</strong>：每次操作后验证状态的一致性</li>
</ol>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>O(n&#x2F;32)</td>
<td>需要初始化数组</td>
</tr>
<tr>
<td>add</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
<tr>
<td>remove</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
<tr>
<td>reverse</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
<tr>
<td>contains</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
</tbody></table>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>位图空间</strong>：O(n&#x2F;32) &#x3D; O(n)</li>
<li><strong>相比哈希表</strong>：空间节省约32倍</li>
</ul>
<h3 id="实际空间对比"><a href="#实际空间对比" class="headerlink" title="实际空间对比"></a>实际空间对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储1000万个数字的空间对比</span></span><br><span class="line">numbers = <span class="number">10_000_000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希表（假设每个数字32位）</span></span><br><span class="line">hash_space = numbers * <span class="number">32</span>  <span class="comment"># 320,000,000 bits</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位图</span></span><br><span class="line">bitset_space = numbers * <span class="number">1</span>  <span class="comment"># 10,000,000 bits</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空间节省比例</span></span><br><span class="line">space_saving = hash_space / bitset_space  <span class="comment"># 32倍</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景与扩展"><a href="#应用场景与扩展" class="headerlink" title="应用场景与扩展"></a>应用场景与扩展</h2><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ol>
<li><strong>大数据去重</strong>：判断海量数据中的重复元素</li>
<li><strong>布隆过滤器基础</strong>：位图是布隆过滤器的核心组件</li>
<li><strong>状态压缩</strong>：在动态规划中压缩状态空间</li>
<li><strong>集合运算</strong>：高效实现并集、交集、差集运算</li>
</ol>
<h3 id="位图的集合运算"><a href="#位图的集合运算" class="headerlink" title="位图的集合运算"></a>位图的集合运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bitset_union</span>(<span class="params">bitset1, bitset2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位图并集运算&quot;&quot;&quot;</span></span><br><span class="line">    result = Bitset(<span class="built_in">max</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>)) * <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>))):</span><br><span class="line">        result.<span class="built_in">set</span>[i] = bitset1.<span class="built_in">set</span>[i] | bitset2.<span class="built_in">set</span>[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bitset_intersection</span>(<span class="params">bitset1, bitset2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位图交集运算&quot;&quot;&quot;</span></span><br><span class="line">    result = Bitset(<span class="built_in">max</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>)) * <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>))):</span><br><span class="line">        result.<span class="built_in">set</span>[i] = bitset1.<span class="built_in">set</span>[i] &amp; bitset2.<span class="built_in">set</span>[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_missing_numbers</span>(<span class="params">arr, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找出0到n-1范围内缺失的所有数字&quot;&quot;&quot;</span></span><br><span class="line">    bitset = Bitset(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 标记存在的数字</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= num &lt; n:</span><br><span class="line">            bitset.add(num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找出缺失的数字</span></span><br><span class="line">    missing = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bitset.contains(i):</span><br><span class="line">            missing.append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> missing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">missing = find_missing_numbers(arr, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;缺失的数字: <span class="subst">&#123;missing&#125;</span>&quot;</span>)  <span class="comment"># 输出: [2, 4, 5, 8]</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位图是一种非常实用的数据结构，特别适合处理大量整数的存在性判断问题。它的核心优势在于：</p>
<ol>
<li><strong>极致的空间效率</strong>：相比传统数据结构节省32倍空间</li>
<li><strong>优秀的时间性能</strong>：所有基本操作都是O(1)时间复杂度</li>
<li><strong>简单的实现逻辑</strong>：基于基础位运算，易于理解和实现</li>
</ol>
<p>在大数据处理、系统设计等场景中，位图都是一个非常有价值的工具。</p>
<h1 id="033【必备】位运算实现加减乘除"><a href="#033【必备】位运算实现加减乘除" class="headerlink" title="033【必备】位运算实现加减乘除"></a>033【必备】位运算实现加减乘除</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>位运算实现四则运算的核心在于模拟计算机底层的运算逻辑：</p>
<ul>
<li><strong>加法</strong>：基于异或（无进位相加）和与运算（进位处理）</li>
<li><strong>减法</strong>：通过加法和取反实现</li>
<li><strong>乘法</strong>：基于移位和加法的重复运算</li>
<li><strong>除法</strong>：基于减法和移位的优化算法</li>
</ul>
<h2 id="Python中的特殊处理"><a href="#Python中的特殊处理" class="headerlink" title="Python中的特殊处理"></a>Python中的特殊处理</h2><p>在实现过程中，需要特别注意Python与Java的差异：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Java中的整数范围限制</span></span><br><span class="line">MIN = -<span class="number">2</span>**<span class="number">31</span>      <span class="comment"># -2147483648</span></span><br><span class="line">MAX = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>   <span class="comment"># 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python中需要手动处理32位整数溢出</span></span><br><span class="line">result &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保持32位</span></span><br><span class="line"><span class="keyword">if</span> result &gt; <span class="number">0x7FFFFFFF</span>:</span><br><span class="line">    result = ~(result ^ <span class="number">0xFFFFFFFF</span>)  <span class="comment"># 转换为有符号整数</span></span><br></pre></td></tr></table></figure>

<h2 id="1-加法实现（核心基础）"><a href="#1-加法实现（核心基础）" class="headerlink" title="1. 加法实现（核心基础）"></a>1. 加法实现（核心基础）</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>加法的位运算实现基于两个关键概念：</p>
<ol>
<li><strong>无进位相加</strong>：使用异或运算（XOR）</li>
<li><strong>进位信息</strong>：使用与运算（AND）后左移</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位运算实现加法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#单次相加的结果为：无进位相加的结果+进位信息</span></span><br><span class="line">    ans = a</span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>: <span class="comment"># 当b为0时，说明没有进位了，加法结束</span></span><br><span class="line">        <span class="comment"># 单次进位只能把当前位的进位信息加到下一高位，但新一位的进位可能和更高位产生新的进位冲突，需要继续处理。</span></span><br><span class="line">        <span class="comment"># 只有所有进位都为0，结果才是完整无误的。</span></span><br><span class="line">        <span class="comment"># ans : a和b无进位相加的结果</span></span><br><span class="line">        ans = a ^ b</span><br><span class="line">        <span class="comment"># b : a和b相加时的进位信息</span></span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># Python中int无限大，为了模拟int32，需要对超出部分进行处理</span></span><br><span class="line">        <span class="comment"># 下面两行确保ans和b都保持32位</span></span><br><span class="line">        ans &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        b &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        a = ans</span><br><span class="line">    <span class="comment"># 处理负数转为补码</span></span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(ans ^ <span class="number">0xFFFFFFFF</span>)  <span class="comment">#结果超过最大值时，需要将无符号32位结果转换为有符号，当加法结果超过0x7FFFFFFF时，实际上表示的是负数，需要转换为对应的有符号表示</span></span><br><span class="line">    <span class="comment">#将ans与全1进行异或，相当于按位取反，~(...)：再次取反，相当于恢复原值</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以 <code>5 + 3</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第1轮：a=5(101), b=3(011)</span><br><span class="line">  无进位：5^3 = 101^011 = 110 = 6</span><br><span class="line">  进位：(5&amp;3)&lt;&lt;1 = (001)&lt;&lt;1 = 010 = 2</span><br><span class="line">  </span><br><span class="line">第2轮：a=6(110), b=2(010)  </span><br><span class="line">  无进位：6^2 = 110^010 = 100 = 4</span><br><span class="line">  进位：(6&amp;2)&lt;&lt;1 = (010)&lt;&lt;1 = 100 = 4</span><br><span class="line">  </span><br><span class="line">第3轮：a=4(100), b=4(100)</span><br><span class="line">  无进位：4^4 = 100^100 = 000 = 0</span><br><span class="line">  进位：(4&amp;4)&lt;&lt;1 = (100)&lt;&lt;1 = 1000 = 8</span><br><span class="line">  </span><br><span class="line">第4轮：a=0(000), b=8(1000)</span><br><span class="line">  无进位：0^8 = 1000 = 8</span><br><span class="line">  进位：(0&amp;8)&lt;&lt;1 = 0</span><br><span class="line">  </span><br><span class="line">结果：8</span><br></pre></td></tr></table></figure>

<h2 id="2-取反运算"><a href="#2-取反运算" class="headerlink" title="2. 取反运算"></a>2. 取反运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">neg</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;取相反数：~n + 1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.add(~n, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>基于补码的性质：一个数的相反数等于该数按位取反后加1。</p>
<ul>
<li>正数：直接按位取反加1</li>
<li>负数：同样规则，利用补码特性</li>
</ul>
<h2 id="3-减法实现"><a href="#3-减法实现" class="headerlink" title="3. 减法实现"></a>3. 减法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minus</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;减法就是加上-b&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.add(a, BitOperationAddMinusMultiplyDivide.neg(b))</span><br></pre></td></tr></table></figure>

<p>减法的实现非常简洁：<code>a - b = a + (-b)</code></p>
<h2 id="4-乘法实现（龟速乘）"><a href="#4-乘法实现（龟速乘）" class="headerlink" title="4. 乘法实现（龟速乘）"></a>4. 乘法实现（龟速乘）</h2><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><p>基于二进制乘法的原理，将乘法转换为多次加法和移位运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位运算实现乘法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把乘法拆成若干次加法，用位运算（移位）和加法实现，不直接用乘号，适合大数和防溢出场合。</span></span><br><span class="line">    <span class="comment"># 二进制的乘法也是像十进制一样，从右到左，一位一位的乘，然后错位相加</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 为了模拟int32，确保a, b, ans都在32位内</span></span><br><span class="line">    a &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">    b &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>: <span class="comment">#说明乘数没有耗尽，继续乘</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) != <span class="number">0</span>: <span class="comment">#说明当前位是1，需要加到结果上</span></span><br><span class="line">            <span class="comment"># 考察b当前最右的状态！</span></span><br><span class="line">            ans = BitOperationAddMinusMultiplyDivide.add(ans, a)</span><br><span class="line">            ans &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保持32位</span></span><br><span class="line">        a = (a &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>  <span class="comment"># 左移并保持32位</span></span><br><span class="line">        <span class="comment"># Java中的 &gt;&gt;&gt; 表示无符号右移，Python没有，需特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> b &gt;= <span class="number">0</span>:</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#在Java中，&gt;&gt;&gt; 是无符号右移操作，无论原数是正数还是负数，右移时都在高位补0。但在Python中，&gt;&gt; 是有符号右移，对于负数会补1</span></span><br><span class="line">            <span class="comment">#内存中：b + 0x100000000和b的位模式完全相同，这时候又该告诉python该改变语义理解了</span></span><br><span class="line">            b = (b + <span class="number">0x100000000</span>) &gt;&gt; <span class="number">1</span> <span class="comment">#0x100000000等于2^32</span></span><br><span class="line">        b &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保持32位</span></span><br><span class="line">    <span class="comment"># 处理负数转为补码</span></span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(ans ^ <span class="number">0xFFFFFFFF</span>) <span class="comment"># 0xFFFFFFFF是全1，保证结果是32位，</span></span><br><span class="line">    <span class="comment"># 如果结果超过0x7FFFFFFF，说明发生了溢出</span></span><br><span class="line">    <span class="comment"># 使用~(ans ^ 0xFFFFFFFF)将结果&quot;包装&quot;到32位范围内</span></span><br><span class="line">    <span class="comment"># 这样就能得到正确的有符号32位整数结果</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例-1"><a href="#执行过程示例-1" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以 <code>5 × 3</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3的二进制：011</span><br><span class="line">第1轮：b=011, b&amp;1=1, ans += 5×2^0 = 5</span><br><span class="line">第2轮：b=001, b&amp;1=1, ans += 5×2^1 = 5+10 = 15</span><br><span class="line">第3轮：b=000, 结束</span><br><span class="line">结果：15</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种”龟速乘”在以下场景特别有用：</p>
<ul>
<li>大数乘法防溢出</li>
<li>模运算：<code>(a × b) % m</code></li>
<li>快速幂运算的基础</li>
</ul>
<h2 id="5-除法实现（最复杂）"><a href="#5-除法实现（最复杂）" class="headerlink" title="5. 除法实现（最复杂）"></a>5. 除法实现（最复杂）</h2><h3 id="核心挑战"><a href="#核心挑战" class="headerlink" title="核心挑战"></a>核心挑战</h3><p>除法是四则运算中最复杂的，需要处理多种边界情况：</p>
<ol>
<li>除数为0的情况</li>
<li>整数最小值的特殊处理</li>
<li>溢出预防</li>
<li>符号处理</li>
</ol>
<h3 id="主要函数结构"><a href="#主要函数结构" class="headerlink" title="主要函数结构"></a>主要函数结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主除法函数，处理各种边界情况&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 处理 a 和 b 都为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> a == BitOperationAddMinusMultiplyDivide.MIN <span class="keyword">and</span> b == BitOperationAddMinusMultiplyDivide.MIN:</span><br><span class="line">        <span class="comment"># a和b都是整数最小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 处理 a 和 b 都不是最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> a != BitOperationAddMinusMultiplyDivide.MIN <span class="keyword">and</span> b != BitOperationAddMinusMultiplyDivide.MIN:</span><br><span class="line">        <span class="comment"># a和b都不是整数最小，那么正常去除</span></span><br><span class="line">        <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.div(a, b)</span><br><span class="line">    <span class="comment"># 处理 b 为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> b == BitOperationAddMinusMultiplyDivide.MIN: </span><br><span class="line">        <span class="comment"># a不是整数最小，b是整数最小，整数最小值是负数，而且整数最小值无法转成相反数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 处理 a 为最小值，b 为 -1 的情况（防止溢出）</span></span><br><span class="line">    <span class="comment"># 第1个if不成立：a 和 b 不都是最小值；第2个if不成立：a 和 b 不都不是最小值；第3个if不成立：b 不是最小值，则排除完b，a就是最小值</span></span><br><span class="line">    <span class="keyword">if</span> b == BitOperationAddMinusMultiplyDivide.neg(<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了</span></span><br><span class="line">        <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.MAX</span><br><span class="line">    <span class="comment"># a是整数最小，b不是整数最小，b也不是-1</span></span><br><span class="line">    a = BitOperationAddMinusMultiplyDivide.add(a, b <span class="keyword">if</span> b &gt; <span class="number">0</span> <span class="keyword">else</span> BitOperationAddMinusMultiplyDivide.neg(b)) <span class="comment">#让 a 不再是最小值，这样就可以安全地调用 div 函数了，如果 b &gt; 0：a = a + b；如果 b &lt; 0：a = a + (-b)</span></span><br><span class="line">    ans = BitOperationAddMinusMultiplyDivide.div(a, b) <span class="comment"># 现在 a 不再是最小值，可以安全地调用 div 函数</span></span><br><span class="line">    offset = BitOperationAddMinusMultiplyDivide.neg(<span class="number">1</span>) <span class="keyword">if</span> b &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="comment"># 如果 b &gt; 0，则 offset = -1；如果 b &lt; 0，则 offset = 1</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.add(ans, offset) <span class="comment"># 最后把 offset 加回去</span></span><br></pre></td></tr></table></figure>

<h3 id="核心除法算法"><a href="#核心除法算法" class="headerlink" title="核心除法算法"></a>核心除法算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a, b</span>): <span class="comment">#向下取整，但是不返回余数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;核心除法实现，要求a和b都不是整数最小值&quot;&quot;&quot;</span></span><br><span class="line">    x = BitOperationAddMinusMultiplyDivide.neg(a) <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">else</span> a  <span class="comment"># 取绝对值</span></span><br><span class="line">    y = BitOperationAddMinusMultiplyDivide.neg(b) <span class="keyword">if</span> b &lt; <span class="number">0</span> <span class="keyword">else</span> b  <span class="comment"># 取绝对值</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    i = <span class="number">30</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># (x &gt;&gt; i) &gt;= y 时，说明y &lt;&lt; i 还能减掉</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;&gt; i) &gt;= y: <span class="comment">#判断x右移i位后是否大于等于y，若大于则记录1</span></span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i)  <span class="comment"># 记录这个位</span></span><br><span class="line">            x = BitOperationAddMinusMultiplyDivide.minus(x, y &lt;&lt; i)  <span class="comment"># x 减去 y &lt;&lt; i，即y*2^i</span></span><br><span class="line">        i = BitOperationAddMinusMultiplyDivide.minus(i, <span class="number">1</span>)  <span class="comment"># 相当于 i--</span></span><br><span class="line">    <span class="comment"># 最后根据正负判断符号</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.neg(ans) <span class="keyword">if</span> (a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>) <span class="keyword">else</span> ans <span class="comment">#当两个数的符号不同时，结果取负；当符号相同时，结果保持正。</span></span><br></pre></td></tr></table></figure>

<h3 id="算法原理解析"><a href="#算法原理解析" class="headerlink" title="算法原理解析"></a>算法原理解析</h3><p>除法算法本质上是<strong>二分查找的变种</strong>：</p>
<ol>
<li><strong>从高位到低位</strong>：尝试每一位是否能为1</li>
<li><strong>位移优化</strong>：<code>y &lt;&lt; i</code> 相当于 <code>y × 2^i</code></li>
<li><strong>贪心策略</strong>：能减就减，记录对应的位</li>
</ol>
<h3 id="执行过程示例-2"><a href="#执行过程示例-2" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以 <code>10 ÷ 3</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=10, y=3</span><br><span class="line">i=30: (10&gt;&gt;30)=0 &lt; 3, 跳过</span><br><span class="line">...</span><br><span class="line">i=2: (10&gt;&gt;2)=2 &lt; 3, 跳过  </span><br><span class="line">i=1: (10&gt;&gt;1)=5 &gt;= 3, ans|=(1&lt;&lt;1), x=10-6=4</span><br><span class="line">i=0: (4&gt;&gt;0)=4 &gt;= 3, ans|=(1&lt;&lt;0), x=4-3=1</span><br><span class="line">结果：ans = 11(二进制) = 3(十进制)</span><br></pre></td></tr></table></figure>

<h2 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h2><h3 id="整数最小值的特殊性"><a href="#整数最小值的特殊性" class="headerlink" title="整数最小值的特殊性"></a>整数最小值的特殊性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MIN = -<span class="number">2</span>**<span class="number">31</span>  <span class="comment"># -2147483648</span></span><br><span class="line">MAX = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>  <span class="comment"># 2147483647</span></span><br></pre></td></tr></table></figure>

<p>整数最小值的特殊性在于它<strong>没有对应的正数</strong>，因为：</p>
<ul>
<li>最小值的绝对值是 <code>2^31</code></li>
<li>最大正整数只有 <code>2^31 - 1</code></li>
</ul>
<h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><ol>
<li><strong>预处理</strong>：将最小值调整为非最小值</li>
<li><strong>后处理</strong>：补偿调整造成的误差</li>
<li><strong>特殊返回</strong>：<code>MIN ÷ (-1)</code> 返回 <code>MAX</code></li>
</ol>
<h2 id="完整实现的使用示例"><a href="#完整实现的使用示例" class="headerlink" title="完整实现的使用示例"></a>完整实现的使用示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类实例</span></span><br><span class="line">calc = BitOperationAddMinusMultiplyDivide()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试各种运算</span></span><br><span class="line"><span class="built_in">print</span>(calc.add(<span class="number">15</span>, <span class="number">27</span>))        <span class="comment"># 42</span></span><br><span class="line"><span class="built_in">print</span>(calc.minus(<span class="number">50</span>, <span class="number">18</span>))      <span class="comment"># 32  </span></span><br><span class="line"><span class="built_in">print</span>(calc.multiply(<span class="number">6</span>, <span class="number">7</span>))     <span class="comment"># 42</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(<span class="number">84</span>, <span class="number">2</span>))      <span class="comment"># 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试边界情况</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(-<span class="number">2</span>**<span class="number">31</span>, -<span class="number">1</span>)) <span class="comment"># 2**31-1 (MAX)</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(<span class="number">10</span>, <span class="number">3</span>))      <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(-<span class="number">10</span>, <span class="number">3</span>))     <span class="comment"># -3</span></span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><table>
<thead>
<tr>
<th>运算</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>加法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>最多32次循环</td>
</tr>
<tr>
<td>减法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>调用加法和取反</td>
</tr>
<tr>
<td>乘法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>最多32次循环</td>
</tr>
<tr>
<td>除法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>固定31次循环</td>
</tr>
</tbody></table>
<p>虽然有循环，但循环次数是固定的（最多32次），所以时间复杂度为常数。</p>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul>
<li><ol>
<li>底层系统编程<br>在某些嵌入式系统或底层驱动中，可能需要在没有算术运算单元的情况下实现运算。</li>
</ol>
</li>
<li><ol start="2">
<li>大数运算<br>在实现大整数库时，这些技巧是基础构建块。</li>
</ol>
</li>
<li><ol start="3">
<li>密码学应用<br>在某些密码学算法中，需要避免使用标准库的运算函数。</li>
</ol>
</li>
<li><ol start="4">
<li>算法竞赛<br>某些特殊题目可能限制算术运算的使用。</li>
</ol>
</li>
<li><ol start="5">
<li>教学演示<br>帮助理解计算机底层运算原理。</li>
</ol>
</li>
</ul>
<h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>位运算实现四则运算展示了计算机底层运算的本质。虽然在实际开发中很少直接使用，但理解这些原理对于：</p>
<ol>
<li><strong>加深对计算机原理的理解</strong></li>
<li><strong>提升位运算技巧</strong>  </li>
<li><strong>应对特殊场景需求</strong></li>
<li><strong>算法思维的训练</strong></li>
</ol>
<p>都具有重要意义。特别是除法的实现，体现了二分思想和贪心策略的完美结合，是位运算技巧的集大成者。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89-%20%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89-%20%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（10）- 异或运算和位运算的骚操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-14 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-14T08:42:46+08:00">2025-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-16 17:19:15" itemprop="dateModified" datetime="2025-08-16T17:19:15+08:00">2025-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了异或运算和位运算的高效技巧与应用，包括了class030 -&gt; class031的内容</p>
<h1 id="030【必备】异或运算的骚操作"><a href="#030【必备】异或运算的骚操作" class="headerlink" title="030【必备】异或运算的骚操作"></a>030【必备】异或运算的骚操作</h1><h2 id="异或运算的核心性质"><a href="#异或运算的核心性质" class="headerlink" title="异或运算的核心性质"></a>异或运算的核心性质</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>异或运算是计算机科学中一种重要的位运算，符号为<code>^</code>。在Python中实现位运算题目时需要特别注意溢出和符号扩展问题，通常需要手动处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中处理溢出的常见方法</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h3 id="异或运算的四大核心性质"><a href="#异或运算的四大核心性质" class="headerlink" title="异或运算的四大核心性质"></a>异或运算的四大核心性质</h3><h4 id="1-异或运算就是无进位相加"><a href="#1-异或运算就是无进位相加" class="headerlink" title="1. 异或运算就是无进位相加"></a>1. 异或运算就是无进位相加</h4><p>这是理解异或运算最重要的性质，其他所有性质都可以由此推导得出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：5 ^ 3</span><br><span class="line">5: 101</span><br><span class="line">3: 011</span><br><span class="line">   ---</span><br><span class="line">   110  (结果为6)</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(10)/class30-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/%E5%BC%82%E6%88%96%E9%A2%84%E7%AE%97%E5%8F%96%E4%B8%8B%E6%A0%87.png" alt="异或预算取下标"></p>
<h4 id="2-异或运算满足交换律和结合律"><a href="#2-异或运算满足交换律和结合律" class="headerlink" title="2. 异或运算满足交换律和结合律"></a>2. 异或运算满足交换律和结合律</h4><p>同一批数字，不管异或顺序如何，最终结果都相同：</p>
<ul>
<li>a ^ b &#x3D; b ^ a（交换律）</li>
<li>(a ^ b) ^ c &#x3D; a ^ (b ^ c)（结合律）</li>
</ul>
<h4 id="3-特殊值性质"><a href="#3-特殊值性质" class="headerlink" title="3. 特殊值性质"></a>3. 特殊值性质</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任何数与0异或等于自己</span></span><br><span class="line"><span class="number">0</span> ^ n = n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任何数与自己异或等于0</span></span><br><span class="line">n ^ n = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(10)/class30-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/n%E6%88%96n.png" alt="n或n"></p>
<h4 id="4-整体异或和性质"><a href="#4-整体异或和性质" class="headerlink" title="4. 整体异或和性质"></a>4. 整体异或和性质</h4><p>如果整体异或和为x，其中某部分异或和为y，那么剩余部分的异或和为<code>x ^ y</code>。</p>
<p>这个性质在很多题目中都有应用，特别是区间异或和相关的问题。</p>
<h3 id="有趣的数学问题"><a href="#有趣的数学问题" class="headerlink" title="有趣的数学问题"></a>有趣的数学问题</h3><p>让我们从一个有趣的概率问题开始：</p>
<p><strong>问题</strong>：袋子里有a个白球，b个黑球。每次取2个球：</p>
<ul>
<li>取出2个白球或2个黑球 → 放回1个白球</li>
<li>取出1白1黑 → 放回1个黑球</li>
</ul>
<p>最终袋子里剩1个球，问这个球是黑球的概率？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>如果黑球数量为偶数，最终是黑球的概率为0%</li>
<li>如果黑球数量为奇数，最终是黑球的概率为100%</li>
<li>完全与白球数量无关！</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(10)/class30-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/%E9%BB%91%E7%99%BD%E7%90%83%E7%BB%93%E6%9E%9C.png" alt="黑白球结果"></p>
<p>这个结果与异或运算的性质有关：黑球数量的奇偶性在整个过程中保持不变。</p>
<h2 id="经典应用题目"><a href="#经典应用题目" class="headerlink" title="经典应用题目"></a>经典应用题目</h2><h3 id="题目1：用异或运算交换两数的值"><a href="#题目1：用异或运算交换两数的值" class="headerlink" title="题目1：用异或运算交换两数的值"></a>题目1：用异或运算交换两数的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">    <span class="comment"># 注意：当i==j时会出错，实际开发中不推荐使用</span></span><br><span class="line">    <span class="keyword">if</span> i != j:  <span class="comment"># 添加安全检查</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j]  <span class="comment"># 第一步</span></span><br><span class="line">        arr[j] = arr[i] ^ arr[j]  <span class="comment"># 第二步：arr[j]变成原arr[i]</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j]  <span class="comment"># 第三步：arr[i]变成原arr[j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更简洁的变量交换</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap_variables</span>():</span><br><span class="line">    a, b = -<span class="number">2323</span>, <span class="number">10</span></span><br><span class="line">    a = a ^ b  <span class="comment"># a现在是原a^原b</span></span><br><span class="line">    b = a ^ b  <span class="comment"># b现在是原a^原b^原b = 原a</span></span><br><span class="line">    a = a ^ b  <span class="comment"># a现在是原a^原b^原a = 原b</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = -<span class="number">2323</span>  <span class="comment"># 定义a</span></span><br><span class="line">    b = <span class="number">10</span>     <span class="comment"># 定义b  因为a^b=b^a ，这么操作的前提是a和b都有自己的内存空间</span></span><br><span class="line">    a = a ^ b  <span class="comment"># 第一步，a和b异或后的结果给a</span></span><br><span class="line">    b = a ^ b  <span class="comment"># 第二步，a和b再次异或的结果赋给b，b&#x27;=(a^b)^b</span></span><br><span class="line">    a = a ^ b  <span class="comment"># 第三步，a和b再次异或的结果赋给a,a&#x27;&#x27;=a^b^((a^b)^b)=a^b^a^b^b=a^b^a，根据交换律，a^b^a=a^a^b=b</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment"># 输出此时的a</span></span><br><span class="line">    <span class="built_in">print</span>(b)   <span class="comment"># 输出此时的b</span></span><br><span class="line"></span><br><span class="line">    arr = [<span class="number">3</span>, <span class="number">5</span>]          <span class="comment"># 定义一个数组</span></span><br><span class="line">    swap(arr, <span class="number">0</span>, <span class="number">1</span>)       <span class="comment"># 交换arr[0]和arr[1]</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">0</span>])         <span class="comment"># 输出交换后的arr[0],输出3</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">1</span>])         <span class="comment"># 输出交换后的arr[1],输出5</span></span><br><span class="line">    swap(arr, <span class="number">0</span>, <span class="number">0</span>)       <span class="comment"># 交换同一个元素（java会出错，需谨慎，但是python不会） Python的整数对象是不可变的，每次赋值都会创建新的整数对象。更重要的是，Python的异或运算对于相同值的结果是 0，这是数学上正确的，内存模型不同：Java：直接操作内存中的值Python：操作的是对象的引用，整数是不可变对象</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">0</span>])         <span class="comment"># 输出arr[0]，输出3</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">1</span>])         <span class="comment"># 输出arr[1]，输出5</span></span><br></pre></td></tr></table></figure>

<p><strong>原理分析</strong>：</p>
<ol>
<li>第一步：<code>a = a ^ b</code>，a存储了原始a和b的异或结果</li>
<li>第二步：<code>b = a ^ b ，则 b&#39;=(a^b)^b</code></li>
<li>第三步：<code>a = a ^ b ，则 a&#39;&#39;=a^b^((a^b)^b)=a^b^a^b^b=a^b^a，根据交换律，a^b^a=a^a^b=b</code></li>
</ol>
<h3 id="题目2：不用判断语句返回两数最大值"><a href="#题目2：不用判断语句返回两数最大值" class="headerlink" title="题目2：不用判断语句返回两数最大值"></a>题目2：不用判断语句返回两数最大值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;翻转0和1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> n ^ <span class="number">1</span>  <span class="comment"># 0变1，1变0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;非负数返回1，负数返回0&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flip((n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#因为负数符号位为1，正数符号位为0，所以负数右移31位后符号位为1，正数右移31位后符号位为0</span></span><br><span class="line">    <span class="comment"># 右移后得到的值，可能不是严格的0或1，尤其在Python里，负数右移得到的是全1（二进制全是1，对应十进制-1）。</span></span><br><span class="line">    <span class="comment"># 所以为了保证只取最低1位（也就是现在的符号位），要 &amp; 1。</span></span><br><span class="line">    <span class="comment"># 如果结果是0，0 &amp; 1 = 0。</span></span><br><span class="line">    <span class="comment"># 如果结果是-1，-1 &amp; 1 = 1（因为-1的二进制补码是全1)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMax1</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 有溢出风险的实现，若c溢出了的话会出错</span></span><br><span class="line">    c = a - b                    <span class="comment"># 计算差值</span></span><br><span class="line">    returnA = sign(c)            <span class="comment"># 差值非负则返回a</span></span><br><span class="line">    returnB = flip(returnA)      <span class="comment"># 差值负则返回b</span></span><br><span class="line">    <span class="keyword">return</span> a * returnA + b * returnB  <span class="comment"># 保证互斥就行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMax2</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 没有溢出风险的实现，增加了一个判断a、b符号的逻辑</span></span><br><span class="line">    c = a - b                    <span class="comment"># 差值</span></span><br><span class="line">    sa = sign(a)                 <span class="comment"># a的符号，非负返回1，负数返回0</span></span><br><span class="line">    sb = sign(b)                 <span class="comment"># b的符号</span></span><br><span class="line">    sc = sign(c)                 <span class="comment"># 差值的符号</span></span><br><span class="line">    diffAB = sa ^ sb             <span class="comment"># 判断a和b的符号是否一样，如果符号不同，则为1；符号一样，则为0</span></span><br><span class="line">    sameAB = flip(diffAB)        <span class="comment"># 符号相同，则为1</span></span><br><span class="line">    returnA = diffAB * sa + sameAB * sc  <span class="comment"># 决定返回哪个，diffAB和sameAB只有一个能为1，a和b的符号不同，且a非负，则返回1；a和b的符号相同，且c非负，则返回1，整合起来就是判断a</span></span><br><span class="line">    returnB = flip(returnA)                <span class="comment"># 另一个</span></span><br><span class="line">    <span class="keyword">return</span> a * returnA + b * returnB       <span class="comment"># 返回最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例用法</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = -<span class="number">2</span>**<span class="number">31</span>                <span class="comment"># Integer.MIN_VALUE</span></span><br><span class="line">    b = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>             <span class="comment"># Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment"># getMax1方法会错误，因为溢出</span></span><br><span class="line">    <span class="built_in">print</span>(getMax1(a, b))      <span class="comment"># 可能错误</span></span><br><span class="line">    <span class="comment"># getMax2方法永远正确</span></span><br><span class="line">    <span class="built_in">print</span>(getMax2(a, b))      <span class="comment"># 永远正确</span></span><br></pre></td></tr></table></figure>

<p><strong>核心思想</strong>：</p>
<ul>
<li>通过位运算判断数字符号</li>
<li>用乘法实现条件选择，避免if语句</li>
<li>处理溢出情况，确保算法的鲁棒性</li>
</ul>
<h3 id="题目3：找到缺失的数字"><a href="#题目3：找到缺失的数字" class="headerlink" title="题目3：找到缺失的数字"></a>题目3：找到缺失的数字</h3><p><strong>题目</strong>：给定包含n个不同数字的数组，数字范围为[0,n]，找出缺失的那个数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://leetcode.cn/problems/missing-number/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># eorAll用于异或0~n，0到10之间的数字缺了一个</span></span><br><span class="line">    <span class="comment"># eorHas用于异或数组内所有数</span></span><br><span class="line">    eorAll = <span class="number">0</span>                  <span class="comment"># 初始化eorAll</span></span><br><span class="line">    eorHas = <span class="number">0</span>                  <span class="comment"># 初始化eorHas</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):  <span class="comment"># 遍历数组</span></span><br><span class="line">        eorAll ^= i             <span class="comment"># 累计异或0~n-1，把下标0-n-1全都异或起来</span></span><br><span class="line">        eorHas ^= nums[i]       <span class="comment"># 累计异或数组元素，</span></span><br><span class="line">    eorAll ^= <span class="built_in">len</span>(nums)         <span class="comment"># 最后再异或n</span></span><br><span class="line">    <span class="keyword">return</span> eorAll ^ eorHas      <span class="comment"># 缺失的数即为两者异或结果，这是由于交换律，所有出现两次的数字会相互抵消，最后只剩下缺失的数字</span></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(missingNumber([3,0,1]))  # 输出2</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong>：</p>
<ul>
<li>完整序列：0,1,2,…,n</li>
<li>给定数组：缺少一个数字</li>
<li>两者异或后，相同数字抵消，剩下的就是缺失数字</li>
</ul>
<h3 id="题目4：找到出现奇数次的数字"><a href="#题目4：找到出现奇数次的数字" class="headerlink" title="题目4：找到出现奇数次的数字"></a>题目4：找到出现奇数次的数字</h3><p><strong>题目</strong>：数组中只有一种数出现奇数次，其他数都出现偶数次，找到这个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://leetcode.cn/problems/single-number/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    eor = <span class="number">0</span>                     <span class="comment"># 初始化eor</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 遍历数组</span></span><br><span class="line">        eor ^= num              <span class="comment"># 累计异或</span></span><br><span class="line">    <span class="keyword">return</span> eor                  <span class="comment"># 返回结果，原理同code03</span></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(singleNumber([2,2,1]))  # 输出1</span></span><br></pre></td></tr></table></figure>


<h3 id="题目5：找到两个出现奇数次的数字"><a href="#题目5：找到两个出现奇数次的数字" class="headerlink" title="题目5：找到两个出现奇数次的数字"></a>题目5：找到两个出现奇数次的数字</h3><p><strong>题目</strong>：数组中有2种数出现奇数次，其他数都出现偶数次，返回这2种数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode.cn/problems/single-number-iii/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    eor1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次</span></span><br><span class="line">        eor1 ^= num                        <span class="comment"># 累计异或所有数，得到a^b</span></span><br><span class="line">    <span class="comment"># eor1 : a ^ b</span></span><br><span class="line">    <span class="comment"># Brian Kernighan算法</span></span><br><span class="line">    <span class="comment"># 提取出二进制里最右侧的1</span></span><br><span class="line">    rightOne = eor1 &amp; -eor1                <span class="comment"># &amp;是与运算，返回1和1相与为1，0和0相与为0，1和0相与为0；</span></span><br><span class="line">    <span class="comment"># n 的二进制表示中，最右边的 1 之前可能有若干个 0。</span></span><br><span class="line">    <span class="comment"># -n 的二进制表示会反转所有位，然后加1，相当于把最右边的 1 及其右边的 0 都翻转了。</span></span><br><span class="line">    <span class="comment"># 这样，n &amp; -n 只会留下最右边的 1，其余位都变成0。</span></span><br><span class="line">    <span class="comment"># 因为~n= n的取反+1，所以能够提取最右侧的1，所以就拿这个最右侧的1来分组</span></span><br><span class="line">    eor2 = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 此外因为a^b不尽相同，则从左到右，a和b的二进制状态中，必然有一位不同（能找到一个位置上是1，假设是第k位），则可以利用这个不同进行分组</span></span><br><span class="line">    <span class="comment"># 分成两组，一组是第k位为0的数，另一组是第k位为1的数，而q，b一定分别落在不同的组里</span></span><br><span class="line">    <span class="comment"># 所以额外引入一个变量eor2来得到a或者b</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> (num &amp; rightOne) == <span class="number">0</span>:          <span class="comment"># 分组，最后返回，</span></span><br><span class="line">            eor2 ^= num                    <span class="comment"># 分组后累加异或，对分到“那一位为0”这一组的数进行异或。</span></span><br><span class="line">    <span class="comment"># 这组里除了 a 或 b 以外，其他数都成对出现（偶数次），异或后消掉了，只剩下一个（假设是 a）。</span></span><br><span class="line">    <span class="keyword">return</span> [eor2, eor1 ^ eor2]             <span class="comment"># 返回那两个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(singleNumber([1,2,1,3,2,5]))  # 输出[3,5]（顺序无关）</span></span><br></pre></td></tr></table></figure>

<p><strong>关键技巧</strong>：</p>
<ul>
<li><code>n &amp; -n</code>：提取最右侧的1</li>
<li>用这个位进行分组，将a和b分到不同组</li>
<li>每组内除了a或b，其他数都成对出现</li>
</ul>
<p><strong>Brian Kernighan算法原理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设 eor1 = 6 (二进制: 110)</span><br><span class="line">-eor1 = -6 (二进制: ...11111010)  // 补码表示</span><br><span class="line">eor1 &amp; -eor1 = 110 &amp; ...11111010 = 010 = 2</span><br></pre></td></tr></table></figure>

<h3 id="题目6：通用的k次方法"><a href="#题目6：通用的k次方法" class="headerlink" title="题目6：通用的k次方法"></a>题目6：通用的k次方法</h3><p><strong>题目</strong>：数组中只有1种数出现次数少于m次，其他数都出现m次，找到这个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://leetcode.cn/problems/single-number-ii/</span></span><br><span class="line"><span class="comment"># 注意 : 测试题目只是通用方法的一个特例，课上讲了更通用的情况</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">return</span> find(nums, <span class="number">3</span>)  <span class="comment"># 调用更通用的方法，m=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更通用的方法</span></span><br><span class="line"><span class="comment"># 已知数组中只有1种数出现次数少于m次，其他数都出现了m次</span></span><br><span class="line"><span class="comment"># 返回出现次数小于m次的那种数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">arr, m</span>):</span><br><span class="line">    <span class="comment"># 统计每个位有多少个1，如果一个位置的1的个数不是m的整数倍，说明该位属于出现次数小于m次的数</span></span><br><span class="line">    <span class="comment"># cnts[0] : 0位上有多少个1</span></span><br><span class="line">    <span class="comment"># cnts[i] : i位上有多少个1</span></span><br><span class="line">    <span class="comment"># cnts[31] : 31位上有多少个1</span></span><br><span class="line">    cnts = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            cnts[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>   <span class="comment"># 统计每个位有多少个1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">if</span> cnts[i] % m != <span class="number">0</span>:            <span class="comment"># 如果不是m的整数倍，说明该位属于少于m次的数</span></span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i               <span class="comment"># 把该位设置为1，|= 是“按位或赋值”运算符，相当于 ans = ans | (1 &lt;&lt; i)</span></span><br><span class="line">    <span class="comment"># 处理负数</span></span><br><span class="line">    <span class="keyword">if</span> (ans &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) != <span class="number">0</span>:          <span class="comment"># 如果最高位是1，说明是负数</span></span><br><span class="line">        <span class="comment"># 检查ans的第31位（最高位）是否为1。在32位整数里，第31位是符号位，1表示负数（补码）</span></span><br><span class="line">        ans -= <span class="number">1</span> &lt;&lt; <span class="number">32</span>                  <span class="comment"># 当检测到ans的第31位（最高位）为1时，把它转化为Python中的负数表示</span></span><br><span class="line">        <span class="comment">#在32位二进制补码表示中，负数的真实值等于它的二进制表示减去2^32，而Python的int没有溢出，补码负数要手动转换</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(singleNumber([2,2,3,2]))  # 输出3</span></span><br></pre></td></tr></table></figure>

<p><strong>算法思路</strong>：</p>
<ol>
<li>统计每一位上1的个数</li>
<li>如果某位上1的个数不是m的整数倍，说明目标数字在该位为1</li>
<li>重新构造答案</li>
</ol>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明度</th>
</tr>
</thead>
<tbody><tr>
<td>交换两数</td>
<td>O(1)</td>
<td>O(1)</td>
<td>常数时间操作</td>
</tr>
<tr>
<td>找最大值</td>
<td>O(1)</td>
<td>O(1)</td>
<td>位运算替代条件判断</td>
</tr>
<tr>
<td>找缺失数字</td>
<td>O(n)</td>
<td>O(1)</td>
<td>遍历数组一次</td>
</tr>
<tr>
<td>找一个奇数次数字</td>
<td>O(n)</td>
<td>O(1)</td>
<td>异或运算线性时间</td>
</tr>
<tr>
<td>找两个奇数次数字</td>
<td>O(n)</td>
<td>O(1)</td>
<td>两次遍历，分组处理</td>
</tr>
<tr>
<td>通用k次方法</td>
<td>O(n)</td>
<td>O(1)</td>
<td>虽然有32层循环但32是常数</td>
</tr>
</tbody></table>
<h2 id="核心技巧总结"><a href="#核心技巧总结" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-位运算技巧"><a href="#1-位运算技巧" class="headerlink" title="1. 位运算技巧"></a>1. 位运算技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最右侧的1</span></span><br><span class="line">rightOne = n &amp; -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断数字符号</span></span><br><span class="line">sign = (n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转0和1</span></span><br><span class="line">flip = n ^ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某位为1</span></span><br><span class="line">ans |= <span class="number">1</span> &lt;&lt; i</span><br></pre></td></tr></table></figure>

<h3 id="2-异或运算应用模式"><a href="#2-异或运算应用模式" class="headerlink" title="2. 异或运算应用模式"></a>2. 异或运算应用模式</h3><ol>
<li><strong>消除配对</strong>：相同数字异或为0，利用这个性质找到不配对的数字</li>
<li><strong>分组策略</strong>：根据某一位的不同将数组分成两组</li>
<li><strong>位统计</strong>：统计每一位上1的个数，重构答案</li>
</ol>
<h3 id="3-Python特有注意事项"><a href="#3-Python特有注意事项" class="headerlink" title="3. Python特有注意事项"></a>3. Python特有注意事项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理负数</span></span><br><span class="line"><span class="keyword">if</span> (ans &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) != <span class="number">0</span>:</span><br><span class="line">    ans -= <span class="number">1</span> &lt;&lt; <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理溢出</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<p>异或运算虽然看起来简单，但在算法设计中有着广泛而巧妙的应用。掌握这些核心性质和应用模式，能够帮助我们解决很多看似困难的问题。特别是在处理数组中的配对、查找问题时，异或运算往往能提供O(1)空间复杂度的优雅解法。</p>
<h1 id="031【必备】位运算的骚操作"><a href="#031【必备】位运算的骚操作" class="headerlink" title="031【必备】位运算的骚操作"></a>031【必备】位运算的骚操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>位运算有很多奇技淫巧，位运算的速度非常快，仅次于赋值操作，常数时间极好！<br>属于是大佬骚解，左神讲解，苯人copy就对了。</p>
<p><strong>特别提醒</strong>：Python实现位运算的题目需要特别注意，需要自己去手动处理溢出和符号扩展等问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中处理溢出的常见方法</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h2 id="核心算法：Brian-Kernighan算法"><a href="#核心算法：Brian-Kernighan算法" class="headerlink" title="核心算法：Brian Kernighan算法"></a>核心算法：Brian Kernighan算法</h2><p>Brian Kernighan算法是位运算中的经典算法，用于提取二进制数中最右侧的1。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最右侧的1</span></span><br><span class="line">rightOne = n &amp; -n</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>：</p>
<ol>
<li><code>n</code>的二进制表示中，最右边的1右边可能有若干个0</li>
<li><code>-n</code>是n的补码表示（所有位取反后加1），所以可以进位到最右边的1，这个1左边的和<code>n</code> 的左边也都是完全相反的</li>
<li><code>n &amp; -n</code>只会保留最右边的1，其余位都变成0</li>
</ol>
<p><strong>示例演示</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设 n = 12 (二进制: 1100)</span><br><span class="line">-n = -12 (二进制: ...11110100)  // 补码表示</span><br><span class="line">n &amp; -n = 1100 &amp; ...11110100 = 0100 = 4</span><br></pre></td></tr></table></figure>

<p>这个算法在很多高级位运算技巧中都有应用，是理解后续算法的基础。</p>
<h2 id="经典应用题目-1"><a href="#经典应用题目-1" class="headerlink" title="经典应用题目"></a>经典应用题目</h2><h3 id="题目1：判断一个整数是不是2的幂"><a href="#题目1：判断一个整数是不是2的幂" class="headerlink" title="题目1：判断一个整数是不是2的幂"></a>题目1：判断一个整数是不是2的幂</h3><p><strong>问题描述</strong>：给定一个整数n，判断它是否为2的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/power-of-two/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># n &gt; 0 确保正数</span></span><br><span class="line">    <span class="comment"># n &amp; -n 提取最右侧的1，如果n是2的幂，只会有一个1</span></span><br><span class="line">    <span class="comment"># n == (n &amp; -n) 则说明n只有一个1</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n == (n &amp; -n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfTwo(<span class="number">4</span>))   <span class="comment"># True (4 = 2^2)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfTwo(<span class="number">6</span>))   <span class="comment"># False (6的二进制是110，有两个1)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfTwo(<span class="number">16</span>))  <span class="comment"># True (16 = 2^4)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理</strong>：</p>
<ul>
<li>2的幂的特点：二进制表示中只有一个1</li>
<li>例如：1(1), 2(10), 4(100), 8(1000), 16(10000)</li>
<li>利用Brian Kernighan算法提取最右侧的1</li>
<li>如果提取的结果等于原数，说明只有一个1</li>
</ul>
<p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="题目2：判断一个整数是不是3的幂"><a href="#题目2：判断一个整数是不是3的幂" class="headerlink" title="题目2：判断一个整数是不是3的幂"></a>题目2：判断一个整数是不是3的幂</h3><p><strong>问题描述</strong>：给定一个整数n，判断它是否为3的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/power-of-three/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPowerOfThree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子</span></span><br><span class="line">    <span class="comment"># 1162261467是int型范围内，最大的3的幂，它是3的19次方</span></span><br><span class="line">    <span class="comment"># 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么</span></span><br><span class="line">    <span class="comment"># 1162261467 % n == 0</span></span><br><span class="line">    <span class="comment"># 反之如果1162261467 % n != 0 说明n一定含有其他因子</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="number">1162261467</span> % n == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfThree(<span class="number">27</span>))  <span class="comment"># True (27 = 3^3)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfThree(<span class="number">45</span>))  <span class="comment"># False (45 = 3^2 * 5)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfThree(<span class="number">81</span>))  <span class="comment"># True (81 = 3^4)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理</strong>：</p>
<ul>
<li>利用数论知识：如果n是3的幂，那么n只含有质数因子3</li>
<li>1162261467 &#x3D; 3^19，是32位整数范围内最大的3的幂</li>
<li>如果n也只含有质数因子3，那么1162261467一定能被n整除</li>
<li>这种方法引入了额外的先验知识，是一种巧妙的数学技巧</li>
</ul>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>3^19 &#x3D; 1162261467 (32位int范围内最大的3的幂)</li>
<li>如果n是3的幂，则n只有质数因子3</li>
<li>因此最大的3的幂能被所有较小的3的幂整除</li>
</ul>
<p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="题目3：返回大于等于n的最小的2的幂"><a href="#题目3：返回大于等于n的最小的2的幂" class="headerlink" title="题目3：返回大于等于n的最小的2的幂"></a>题目3：返回大于等于n的最小的2的幂</h3><p><strong>问题描述</strong>：给定一个非负整数n，返回大于等于n的最小的2的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">near2power</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 非正数直接返回1</span></span><br><span class="line">    n -= <span class="number">1</span>        <span class="comment"># 先减1，保证等于2的幂时不变，这样处理可以保证：如果 n 本身就是 2 的幂，返回的还是 n 本身。</span></span><br><span class="line">    <span class="comment"># 例如 n = 8，n-1 = 7 (0111)，后面填充后再加1，结果还是 8</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">1</span>   <span class="comment">#这个是或逻辑，右移1位再取或可以保证用1填充右边</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">2</span>  </span><br><span class="line">    n |= n &gt;&gt; <span class="number">4</span>   </span><br><span class="line">    n |= n &gt;&gt; <span class="number">8</span>   </span><br><span class="line">    n |= n &gt;&gt; <span class="number">16</span>  <span class="comment"># 这一坨代码的作用是把左边第一个1开始，往右的1都变成1</span></span><br><span class="line">    n += <span class="number">1</span>        <span class="comment"># 再加1得到最小2的幂</span></span><br><span class="line">    <span class="comment"># Python没有int溢出，可以直接返回</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0x7fffffff</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0x80000000</span>  <span class="comment"># 超过int范围，返回整数最小值</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(near2power(<span class="number">100</span>))  <span class="comment"># 128 (2^7)</span></span><br><span class="line"><span class="built_in">print</span>(near2power(<span class="number">16</span>))   <span class="comment"># 16 (本身就是2的幂)</span></span><br><span class="line"><span class="built_in">print</span>(near2power(<span class="number">33</span>))   <span class="comment"># 64 (2^6)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理详解</strong>：</p>
<p>让我们以<code>n = 100</code>为例，详细演示算法过程：</p>
<p><strong>Step 1</strong>：<code>n = 100</code>，先减1得到<code>n = 99</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 的二进制：01100011</span><br></pre></td></tr></table></figure>

<p><strong>Step 2</strong>：逐步填充最高位右边的所有位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = 99        : 01100011</span><br><span class="line">n &gt;&gt; 1        : 00110001</span><br><span class="line">n |= n &gt;&gt; 1   : 01110011  (把最高位向右扩展1位)</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 2        : 00011100</span><br><span class="line">n |= n &gt;&gt; 2   : 01111111  (继续向右扩展2位)</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 4        : 00000111</span><br><span class="line">n |= n &gt;&gt; 4   : 01111111  (继续向右扩展4位)</span><br><span class="line"></span><br><span class="line">... (8位和16位移动不会改变结果，因为数字较小)</span><br></pre></td></tr></table></figure>

<p><strong>Step 3</strong>：<code>n + 1 = 01111111 + 1 = 10000000 = 128</code></p>
<p><strong>核心思想</strong>：</p>
<ol>
<li>先减1：确保如果n本身是2的幂，结果仍然是n</li>
<li>逐步填充：将最高位1右边的所有位都填充为1</li>
<li>加1：得到下一个2的幂</li>
</ol>
<p><strong>为什么先减1？</strong></p>
<ul>
<li>如果n&#x3D;16(10000)，我们希望结果是16而不是32</li>
<li>减1后：15(01111)</li>
<li>填充后：15(01111)</li>
<li>加1后：16(10000) ✓</li>
</ul>
<p><strong>位运算技巧解析</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过连续的右移和或运算，将最高位的1向右&quot;传播&quot;</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">1</span>   <span class="comment"># 传播1位</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">2</span>   <span class="comment"># 传播2位  </span></span><br><span class="line">n |= n &gt;&gt; <span class="number">4</span>   <span class="comment"># 传播4位</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">8</span>   <span class="comment"># 传播8位</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">16</span>  <span class="comment"># 传播16位（覆盖32位整数的所有位）</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(1) - 固定数量的位运算<br><strong>空间复杂度</strong>：O(1) - 只使用常数额外空间</p>
<h3 id="题目4：区间-left-right-内所有数字按位与的结果"><a href="#题目4：区间-left-right-内所有数字按位与的结果" class="headerlink" title="题目4：区间[left, right]内所有数字按位与的结果"></a>题目4：区间[left, right]内所有数字按位与的结果</h3><p><strong>问题描述</strong>：给定两个整数left和right，返回区间[left, right]内所有数字按位与的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/bitwise-and-of-numbers-range/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rangeBitwiseAnd</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        right -= right &amp; -right  <span class="comment"># 每次消掉right最右边的1</span></span><br><span class="line">    <span class="keyword">return</span> right <span class="comment">#当 left == right 时，区间内只有1个数，直接返回即可；若left&gt;right, 也照样返回right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(rangeBitwiseAnd(<span class="number">5</span>, <span class="number">7</span>))   <span class="comment"># 输出4</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理</strong>：</p>
<p><strong>按位与的关键特性</strong>：</p>
<ul>
<li>如果区间[left, right]内某一位在这段区间内经历了从0到1的变化，那么最终结果这一位一定为0</li>
<li>只有left和right的公共前缀部分才可能保留为1</li>
</ul>
<p><strong>消去变化的位</strong>：</p>
<ul>
<li><code>right &amp; -right</code>取出right的最右侧的1（最低位的1）</li>
<li>每次把right的最右边的1消掉，right变小，靠近left</li>
<li>只要left &lt; right，说明区间还有变化，继续消掉最低位的1</li>
</ul>
<p><strong>详细示例分析</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">区间[5, 7]的按位与：</span><br><span class="line">5: 101</span><br><span class="line">6: 110  </span><br><span class="line">7: 111</span><br><span class="line">-----</span><br><span class="line">结果: 100 = 4</span><br><span class="line"></span><br><span class="line">分析过程：</span><br><span class="line">- 最低位：5(1), 6(0), 7(1) → 有0有1 → 结果为0</span><br><span class="line">- 第2位：5(0), 6(1), 7(1) → 有0有1 → 结果为0  </span><br><span class="line">- 第3位：5(1), 6(1), 7(1) → 全为1 → 结果为1</span><br></pre></td></tr></table></figure>

<p><strong>算法执行过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">left=5(101), right=7(111)</span><br><span class="line">第1次：right &amp; -right = 111 &amp; 001 = 001</span><br><span class="line">       right = 111 - 001 = 110</span><br><span class="line">       left=5, right=6，继续</span><br><span class="line">第2次：right &amp; -right = 110 &amp; 010 = 010  </span><br><span class="line">       right = 110 - 010 = 100</span><br><span class="line">       left=5, right=4，left &gt; right，结束</span><br><span class="line">返回right=4</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(log n) - 最多执行log(right)次循环<br><strong>空间复杂度</strong>：O(1)</p>
<p><strong>看题目5和题目6前的提醒</strong></p>
<ul>
<li>题目5和题目6代码看着跟脑子有大病一样，承认很强但似乎有点太嘚瑟了，是这样吗？</li>
<li>不是的，条件判断相比于赋值、位运算、算术运算是稍慢的，所以其实有现实意义</li>
<li>但是不需要追求在练算法过程中尽量少写条件判断，</li>
<li>那样会带来很多不必要的困扰，还是要写尽量直白、尤其是自己能理解的代码最好</li>
<li>大牛的实现欣赏完理解就好，下次当模版直接用</li>
<li>还是那句话：属于是大佬骚解，左神讲解，苯人copy就对了</li>
</ul>
<h3 id="题目5：反转二进制位（超自然版）"><a href="#题目5：反转二进制位（超自然版）" class="headerlink" title="题目5：反转二进制位（超自然版）"></a>题目5：反转二进制位（超自然版）</h3><p><strong>问题描述</strong>：将一个32位无符号整数的二进制位完全反转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/reverse-bits/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 逆序二进制的状态，分治思想：1v1 → 2v2 → 4v4 → 8v8 → 16v16</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)   <span class="comment"># 交换奇偶位</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)   <span class="comment"># 交换每两位</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)   <span class="comment"># 交换每四位</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)   <span class="comment"># 交换每八位</span></span><br><span class="line">    n = (n &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>)                    <span class="comment"># 交换高低16位</span></span><br><span class="line">    <span class="keyword">return</span> n &amp; <span class="number">0xffffffff</span>  <span class="comment"># 保证结果32位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(reverseBits(<span class="number">43261596</span>))  <span class="comment"># 输出964176192</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理深度解析</strong>：</p>
<p>这是著名的<strong>位分组逆序法（Bitwise reversal by mask）</strong>，采用分治思想：</p>
<p><strong>第1步：交换奇偶位</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0xaaaaaaaa = 10101010...10101010 (偶数位为1)</span></span><br><span class="line"><span class="comment"># 0x55555555 = 01010101...01010101 (奇数位为1)</span></span><br><span class="line"></span><br><span class="line">例如：n = <span class="number">11010110</span></span><br><span class="line">奇数位(从右数第<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>位): 1_1_1_1_ = <span class="number">1111</span></span><br><span class="line">偶数位(从右数第<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>位): _1_0_0_0 = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">交换后：01101101</span><br></pre></td></tr></table></figure>

<p><strong>第2步：交换每两位</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0xcccccccc = 11001100...11001100 (每两位的高位)</span></span><br><span class="line"><span class="comment"># 0x33333333 = 00110011...00110011 (每两位的低位)</span></span><br><span class="line"></span><br><span class="line">例如：n = 01101101</span><br><span class="line">分组：01|<span class="number">10</span>|<span class="number">11</span>|01</span><br><span class="line">交换：<span class="number">10</span>|01|<span class="number">11</span>|<span class="number">10</span> = <span class="number">10011110</span></span><br></pre></td></tr></table></figure>

<p><strong>第3步-5步：类似地交换4位、8位、16位</strong></p>
<p><strong>完整示例演示</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数：11010110 (从左到右)</span><br><span class="line">目标：01101011 (反转后)</span><br><span class="line"></span><br><span class="line">Step1(交换奇偶位)：01101101</span><br><span class="line">Step2(交换每2位)：  10011110  </span><br><span class="line">Step3(交换每4位)：  11101001</span><br><span class="line">Step4(交换每8位)：  01101011 ✓</span><br></pre></td></tr></table></figure>

<p><strong>为什么效率极高？</strong></p>
<ul>
<li>没有任何条件判断和循环</li>
<li>全部是位操作：按位与、或、移位</li>
<li>5次操作完成32位反转，而传统方法需要32次循环</li>
</ul>
<p><strong>时间复杂度</strong>：O(1) - 固定5次位运算<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="题目6：统计二进制中1的个数（超自然版）"><a href="#题目6：统计二进制中1的个数（超自然版）" class="headerlink" title="题目6：统计二进制中1的个数（超自然版）"></a>题目6：统计二进制中1的个数（超自然版）</h3><p><strong>问题描述</strong>：计算两个整数的汉明距离（二进制位不同的位置数目）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/hamming-distance/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> cntOnes(x ^ y)  <span class="comment"># 先异或，统计不同位数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cntOnes</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 分组统计法：每次合并相邻组的1的个数</span></span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>)     <span class="comment"># 每两位一组</span></span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>)     <span class="comment"># 每四位一组  </span></span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>)     <span class="comment"># 每八位一组</span></span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>)     <span class="comment"># 每十六位一组</span></span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>)    <span class="comment"># 全部加起来</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(hammingDistance(<span class="number">1</span>, <span class="number">4</span>))  <span class="comment"># 输出2 (1:001, 4:100, 异或:101, 有2个1)</span></span><br><span class="line"><span class="built_in">print</span>(cntOnes(<span class="number">13</span>))           <span class="comment"># 输出3 (13:1101, 有3个1)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理深度解析</strong>：</p>
<p>这是<strong>分组统计法</strong>，核心思想是逐步合并局部的1的个数：</p>
<p><strong>详细示例（n &#x3D; 13 &#x3D; 1101）</strong>：</p>
<p><strong>初始状态</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 1101 (二进制)</span><br></pre></td></tr></table></figure>

<p><strong>第1步：每两位统计1的个数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x55555555 = 01010101...01010101</span></span><br><span class="line">n &amp; <span class="number">0x55555555</span>     = <span class="number">1101</span> &amp; <span class="number">0</span>101 = <span class="number">0</span>101  <span class="comment"># 保留奇数位</span></span><br><span class="line">(n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span> = 0110 &amp; <span class="number">0</span>101 = <span class="number">0</span>100  <span class="comment"># 保留偶数位(右移后)</span></span><br><span class="line"></span><br><span class="line">相加：<span class="number">0</span>101 + <span class="number">0</span>100 = <span class="number">1001</span></span><br></pre></td></tr></table></figure>
<p>此时n的每2位表示该2位内1的个数：</p>
<ul>
<li>10（二进制）&#x3D; 2（十进制）：前2位有2个1</li>
<li>01（二进制）&#x3D; 1（十进制）：后2位有1个1</li>
</ul>
<p><strong>第2步：每四位统计1的个数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x33333333 = 00110011...00110011  </span></span><br><span class="line">n &amp; <span class="number">0x33333333</span>     = <span class="number">1001</span> &amp; 0011 = 0001</span><br><span class="line">(n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span> = <span class="number">00</span>10 &amp; 0011 = <span class="number">00</span>10</span><br><span class="line"></span><br><span class="line">相加：0001 + <span class="number">00</span>10 = 0011</span><br></pre></td></tr></table></figure>
<p>此时n&#x3D;0011，表示整个4位中有3个1。</p>
<p><strong>后续步骤</strong>类似，最终得到总的1的个数，更高位依此类推，每一步后，n的每2^k位表示这2^k位内1的总个数，最终全加到最低位</p>
<p><strong>状态变化图解</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始：  1101 (每位表示原始位值)</span><br><span class="line">Step1： 1001 (每2位表示该2位内1的个数)  </span><br><span class="line">Step2： 0011 (每4位表示该4位内1的个数)</span><br><span class="line">Step3： 0011 (8位内1的个数，但只有4位所以不变)</span><br><span class="line">...</span><br><span class="line">最终：  3 (总共3个1)</span><br></pre></td></tr></table></figure>

<p><strong>为什么叫”分组统计”？</strong></p>
<ol>
<li>不是独立统计每组，而是累加合并</li>
<li>每步都使用上一步的统计结果</li>
<li>最终所有1的个数聚合到最低位</li>
</ol>
<p><strong>核心技巧总结</strong>：</p>
<ul>
<li>利用掩码分离不同位置的位</li>
<li>用加法累积局部统计结果  </li>
<li>分治思想：部分→整体</li>
</ul>
<p><strong>时间复杂度</strong>：O(1) - 固定5次位运算<br><strong>空间复杂度</strong>：O(1)</p>
<h2 id="算法性能对比与应用场景"><a href="#算法性能对比与应用场景" class="headerlink" title="算法性能对比与应用场景"></a>算法性能对比与应用场景</h2><h3 id="性能对比表"><a href="#性能对比表" class="headerlink" title="性能对比表"></a>性能对比表</h3><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心技巧</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>判断2的幂</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Brian Kernighan算法</td>
<td>内存分配、哈希表大小</td>
</tr>
<tr>
<td>判断3的幂</td>
<td>O(1)</td>
<td>O(1)</td>
<td>数论+预计算</td>
<td>数学问题、特殊判断</td>
</tr>
<tr>
<td>最小2的幂</td>
<td>O(1)</td>
<td>O(1)</td>
<td>位填充技术</td>
<td>内存对齐、缓存优化</td>
</tr>
<tr>
<td>区间按位与</td>
<td>O(log n)</td>
<td>O(1)</td>
<td>公共前缀</td>
<td>区间查询、数据结构</td>
</tr>
<tr>
<td>反转二进制</td>
<td>O(1)</td>
<td>O(1)</td>
<td>分治+掩码</td>
<td>图像处理、编码转换</td>
</tr>
<tr>
<td>统计1的个数</td>
<td>O(1)</td>
<td>O(1)</td>
<td>分组统计</td>
<td>数据压缩、校验算法</td>
</tr>
</tbody></table>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p><strong>1. 系统编程中的应用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存对齐检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isAligned</span>(<span class="params">address, alignment</span>):</span><br><span class="line">    <span class="keyword">return</span> isPowerOfTwo(alignment) <span class="keyword">and</span> (address &amp; (alignment - <span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速向上对齐到2的幂</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alignUp</span>(<span class="params">size, alignment</span>):</span><br><span class="line">    <span class="keyword">return</span> (size + alignment - <span class="number">1</span>) &amp; ~(alignment - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2. 数据结构优化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表大小优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.size = near2power(initial_size)  <span class="comment"># 确保是2的幂</span></span><br><span class="line">        <span class="variable language_">self</span>.table = [<span class="literal">None</span>] * <span class="variable language_">self</span>.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) &amp; (<span class="variable language_">self</span>.size - <span class="number">1</span>)  <span class="comment"># 快速取模</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 图像处理应用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图像位操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mirrorImage</span>(<span class="params">pixel_data</span>):</span><br><span class="line">    <span class="keyword">return</span> [reverseBits(pixel) <span class="keyword">for</span> pixel <span class="keyword">in</span> pixel_data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像特征提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">img1, img2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(cntOnes(p1 ^ p2) <span class="keyword">for</span> p1, p2 <span class="keyword">in</span> <span class="built_in">zip</span>(img1, img2))</span><br></pre></td></tr></table></figure>

<h2 id="核心技巧模板总结"><a href="#核心技巧模板总结" class="headerlink" title="核心技巧模板总结"></a>核心技巧模板总结</h2><h3 id="1-Brian-Kernighan系列"><a href="#1-Brian-Kernighan系列" class="headerlink" title="1. Brian Kernighan系列"></a>1. Brian Kernighan系列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础：提取最右侧的1</span></span><br><span class="line">rightOne = n &amp; -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用1：判断2的幂</span></span><br><span class="line">isPowerOfTwo = n &gt; <span class="number">0</span> <span class="keyword">and</span> n == (n &amp; -n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用2：清除最右侧的1  </span></span><br><span class="line">n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用3：计算1的个数（朴素版）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countOnes</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>)  <span class="comment"># 每次清除最右侧的1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="2-位填充技术模板"><a href="#2-位填充技术模板" class="headerlink" title="2. 位填充技术模板"></a>2. 位填充技术模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准位填充（用于找下一个2的幂）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fillBits</span>(<span class="params">n</span>):</span><br><span class="line">    n |= n &gt;&gt; <span class="number">1</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">2</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">4</span>  </span><br><span class="line">    n |= n &gt;&gt; <span class="number">8</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextPowerOfTwo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fillBits(n - <span class="number">1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-分治-掩码模板"><a href="#3-分治-掩码模板" class="headerlink" title="3. 分治+掩码模板"></a>3. 分治+掩码模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反转二进制位模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">n, bits=<span class="number">32</span></span>):</span><br><span class="line">    <span class="keyword">if</span> bits == <span class="number">32</span>:</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组统计模板  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countOnes</span>(<span class="params">n</span>):</span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>

<h3 id="4-Python位运算注意事项"><a href="#4-Python位运算注意事项" class="headerlink" title="4. Python位运算注意事项"></a>4. Python位运算注意事项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleSign</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) != <span class="number">0</span>:  <span class="comment"># 检查符号位</span></span><br><span class="line">        n -= <span class="number">1</span> &lt;&lt; <span class="number">32</span>          <span class="comment"># 转换为Python负数</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 溢出检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkOverflow</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">0x80000000</span> &lt;= n &lt;= <span class="number">0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 掩码应用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mask32bit</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n &amp; <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><h3 id="1-为什么位运算如此高效？"><a href="#1-为什么位运算如此高效？" class="headerlink" title="1. 为什么位运算如此高效？"></a>1. 为什么位运算如此高效？</h3><ul>
<li><strong>CPU层面</strong>：位运算是最接近硬件的操作，执行速度极快</li>
<li><strong>并行性</strong>：现代CPU可以并行处理多个位</li>
<li><strong>无条件判断</strong>：避免了分支预测失误的性能损失</li>
</ul>
<h3 id="2-什么时候不应该使用这些技巧？"><a href="#2-什么时候不应该使用这些技巧？" class="headerlink" title="2. 什么时候不应该使用这些技巧？"></a>2. 什么时候不应该使用这些技巧？</h3><ul>
<li><strong>代码可读性</strong>：团队协作时，清晰比技巧更重要</li>
<li><strong>过度优化</strong>：在非性能关键路径上使用可能得不偿失</li>
<li><strong>平台差异</strong>：某些技巧在不同架构上表现可能不同</li>
</ul>
<h3 id="3-如何掌握位运算？"><a href="#3-如何掌握位运算？" class="headerlink" title="3. 如何掌握位运算？"></a>3. 如何掌握位运算？</h3><ol>
<li><strong>理解原理</strong>：每个技巧背后的数学&#x2F;逻辑基础</li>
<li><strong>动手实践</strong>：在纸上画出二进制变化过程</li>
<li><strong>模板化</strong>：将常用技巧整理成模板</li>
<li><strong>适度应用</strong>：在合适的场景使用，不要炫技</li>
</ol>
<p>位运算虽然看起来神秘，但其本质是对二进制数据的高效操作。掌握了这些核心技巧后，不仅能解决特定的算法问题，更能在系统编程、性能优化等场景中发挥重要作用。关键是要在”技巧性”和”可读性”之间找到平衡，让代码既高效又易维护。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89-%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89-%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（9）- 基数排序&排序算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-10 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-10T08:42:46+08:00">2025-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-16 17:19:16" itemprop="dateModified" datetime="2025-08-16T17:19:16+08:00">2025-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了基数排序的原理与实现，以及重要排序算法的性能总结与选择策略，包括了class028 -&gt; class029的内容</p>
<h1 id="028【必备】基数排序"><a href="#028【必备】基数排序" class="headerlink" title="028【必备】基数排序"></a>028【必备】基数排序</h1><h2 id="基数排序概述"><a href="#基数排序概述" class="headerlink" title="基数排序概述"></a>基数排序概述</h2><p>基数排序是一种<strong>非基于比较</strong>的排序算法，它通过对数字的每一位进行排序来实现整体排序。与其他基于比较的排序算法不同，基数排序对数据类型有特定要求。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(9)/class28-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90.png" alt="基数排序例子"></p>
<h3 id="基于比较-vs-非基于比较的排序"><a href="#基于比较-vs-非基于比较的排序" class="headerlink" title="基于比较 vs 非基于比较的排序"></a>基于比较 vs 非基于比较的排序</h3><p><strong>基于比较的排序</strong>：</p>
<ul>
<li>只需要定义好两个对象之间怎么比较即可</li>
<li>对象的数据特征并不关心，很通用</li>
<li>例如：快速排序、归并排序、堆排序等</li>
</ul>
<p><strong>非基于比较的排序</strong>：</p>
<ul>
<li>和比较无关的排序，对于对象的数据特征有要求</li>
<li>并不通用，但在特定条件下效率极高</li>
<li>例如：计数排序、桶排序、基数排序</li>
</ul>
<h2 id="从计数排序到基数排序"><a href="#从计数排序到基数排序" class="headerlink" title="从计数排序到基数排序"></a>从计数排序到基数排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是最简单的非比较排序算法：</p>
<ul>
<li>用一个数组或哈希表来记录每个数字出现的次数</li>
<li>遍历数组统计，然后按顺序输出</li>
<li><strong>限制</strong>：数值范围比较大时就不实用了</li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版：</p>
<ul>
<li>将数据分到有限数量的桶里，然后对每个桶再分别排序，最后合并</li>
<li>计数排序可以看成每个桶只存储相同元素</li>
<li>桶排序每个桶存储一定范围的元素</li>
<li>需要确定两个信息：桶的数量和每个桶的区间范围</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(9)/class28-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90.png" alt="桶排序例子"></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序进一步优化了桶的使用：</p>
<ul>
<li>按位进行排序，比如先按个位数字放进桶里再倒出，再按十位数字放进桶里再倒出</li>
<li>这样就得到一个有序的序列</li>
</ul>
<h2 id="基数排序的核心思想"><a href="#基数排序的核心思想" class="headerlink" title="基数排序的核心思想"></a>基数排序的核心思想</h2><p>基数排序采用**LSD（Least Significant Digit）**策略，从最低位开始排序：</p>
<ol>
<li><strong>从个位开始</strong>：按个位数字进行计数排序</li>
<li><strong>依次向高位</strong>：按十位、百位、千位…依次排序</li>
<li><strong>保持稳定性</strong>：每次排序都要保持之前排序的相对顺序</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>前缀数量分区的技巧</li>
<li>数字提取某一位的技巧</li>
<li>时间复杂度O(n)，额外空间复杂度O(m)</li>
</ul>
<h2 id="基数排序实现详解"><a href="#基数排序实现详解" class="headerlink" title="基数排序实现详解"></a>基数排序实现详解</h2><h3 id="核心代码结构"><a href="#核心代码结构" class="headerlink" title="核心代码结构"></a>核心代码结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以设置进制，不一定10进制</span></span><br><span class="line">BASE = <span class="number">10</span>  <span class="comment"># 基数，当前设置为10进制</span></span><br><span class="line"></span><br><span class="line">MAXN = <span class="number">100001</span>  <span class="comment"># 最大数据量</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN      <span class="comment"># 存储待排序数组</span></span><br><span class="line">help_arr = [<span class="number">0</span>] * MAXN <span class="comment"># 辅助数组</span></span><br><span class="line">cnts = [<span class="number">0</span>] * BASE     <span class="comment"># 计数数组</span></span><br><span class="line">n = <span class="number">0</span>                 <span class="comment"># 元素数量</span></span><br></pre></td></tr></table></figure>

<h3 id="处理负数的技巧"><a href="#处理负数的技巧" class="headerlink" title="处理负数的技巧"></a>处理负数的技巧</h3><p>由于基数排序要求非负整数，需要特殊处理负数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort</span>():</span><br><span class="line">    <span class="comment"># 找到数组中的最小值</span></span><br><span class="line">    min_val = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        min_val = <span class="built_in">min</span>(min_val, arr[i])</span><br><span class="line">    </span><br><span class="line">    max_val = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] -= min_val  <span class="comment"># 全部减去最小值，转为非负数</span></span><br><span class="line">        max_val = <span class="built_in">max</span>(max_val, arr[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据最大值在BASE进制下的位数，决定基数排序做多少轮</span></span><br><span class="line">    radixSort(bits(max_val))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数组中所有数都减去了最小值，所以最后不要忘了还原</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] += min_val</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(9)/class28-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/%E8%BF%9B%E4%BD%8D%E5%BE%97%E5%88%B0%E6%95%B0%E5%AD%97.png" alt="进位得到数字"></p>
<h3 id="计算位数"><a href="#计算位数" class="headerlink" title="计算位数"></a>计算位数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bits</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回number在BASE进制下有几位&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">        number //= BASE</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="基数排序核心算法"><a href="#基数排序核心算法" class="headerlink" title="基数排序核心算法"></a>基数排序核心算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radixSort</span>(<span class="params">bits_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基数排序核心代码</span></span><br><span class="line"><span class="string">    arr内要保证没有负数</span></span><br><span class="line"><span class="string">    bits_是arr中最大值在BASE进制下有几位</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    offset = <span class="number">1</span>  <span class="comment"># 当前位权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bits_):</span><br><span class="line">        <span class="comment"># 每一轮针对某一位排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 计数数组清零</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(BASE):</span><br><span class="line">            cnts[i] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 统计该位各数字出现次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cnts[(arr[i] // offset) % BASE] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 转换为前缀和（确定位置）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, BASE):</span><br><span class="line">            cnts[i] += cnts[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 从后往前放入辅助数组（保证稳定性）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            idx = (arr[i] // offset) % BASE  <span class="comment"># 该位的值</span></span><br><span class="line">            cnts[idx] -= <span class="number">1</span></span><br><span class="line">            help_arr[cnts[idx]] = arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 拷回原数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            arr[i] = help_arr[i]</span><br><span class="line">        </span><br><span class="line">        offset *= BASE  <span class="comment"># 下一位</span></span><br></pre></td></tr></table></figure>

<h2 id="算法详细步骤演示"><a href="#算法详细步骤演示" class="headerlink" title="算法详细步骤演示"></a>算法详细步骤演示</h2><p>以数组 <code>[170, 45, 75, 90, 2, 802, 24, 66]</code> 为例：</p>
<p><strong>初始数组</strong>：<code>[170, 45, 75, 90, 2, 802, 24, 66]</code></p>
<h3 id="第一轮（个位排序）"><a href="#第一轮（个位排序）" class="headerlink" title="第一轮（个位排序）"></a>第一轮（个位排序）</h3><p><strong>Step 1 - 统计个位数字</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个位: [0, 5, 5, 0, 2, 2, 4, 6]</span><br><span class="line">cnts: [2, 0, 2, 0, 1, 2, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p><strong>Step 2 - 计算前缀和</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnts: [2, 2, 4, 4, 5, 7, 8, 8, 8, 8]</span><br></pre></td></tr></table></figure>

<p><strong>Step 3 - 从后往前放置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果: [170, 90, 2, 802, 24, 45, 75, 66]</span><br></pre></td></tr></table></figure>

<h3 id="第二轮（十位排序）"><a href="#第二轮（十位排序）" class="headerlink" title="第二轮（十位排序）"></a>第二轮（十位排序）</h3><p><strong>Step 1 - 统计十位数字</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">十位: [7, 9, 0, 0, 2, 4, 7, 6]</span><br><span class="line">cnts: [2, 0, 1, 0, 1, 0, 1, 2, 0, 1]</span><br></pre></td></tr></table></figure>

<p><strong>Step 2 - 计算前缀和并放置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果: [2, 802, 24, 45, 66, 170, 75, 90]</span><br></pre></td></tr></table></figure>

<h3 id="第三轮（百位排序）"><a href="#第三轮（百位排序）" class="headerlink" title="第三轮（百位排序）"></a>第三轮（百位排序）</h3><p>最终结果：<code>[2, 24, 45, 66, 75, 90, 170, 802]</code></p>
<h2 id="稳定性保证"><a href="#稳定性保证" class="headerlink" title="稳定性保证"></a>稳定性保证</h2><p>基数排序的稳定性通过以下方式保证：</p>
<ol>
<li><strong>从后往前处理</strong>：在放入辅助数组时从后往前遍历原数组</li>
<li><strong>前缀和技巧</strong>：使用前缀和确定每个元素在结果数组中的准确位置</li>
<li><strong>逐位处理</strong>：每一位的排序都保持前一位排序的相对顺序</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键：从后往前，确保稳定性</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    idx = (arr[i] // offset) % BASE</span><br><span class="line">    cnts[idx] -= <span class="number">1</span></span><br><span class="line">    help_arr[cnts[idx]] = arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：O(n)</strong></p>
<ul>
<li>设最大数有d位，需要进行d轮排序</li>
<li>每轮排序需要O(n + k)时间，其中k是基数（通常k&#x3D;10）</li>
<li>总时间复杂度：O(d × (n + k)) ≈ O(n)</li>
</ul>
<p><strong>空间复杂度：O(m)</strong></p>
<ul>
<li>m为基数大小，需要辅助空间做类似桶的作用</li>
<li>包括辅助数组help_arr和计数数组cnts</li>
</ul>
<h2 id="应用限制"><a href="#应用限制" class="headerlink" title="应用限制"></a>应用限制</h2><p><strong>一般来讲，基数排序要求</strong>：</p>
<ul>
<li>样本是10进制的非负整数</li>
<li>如果不是就需要转化（如代码中处理负数的方式）</li>
<li>可以设置任何进制来进行排序</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>一旦比较的对象不再是常规数字，改写代价显著增加</li>
<li>不基于比较的排序并不通用</li>
</ul>
<h1 id="029【必备】重要排序算法的总结"><a href="#029【必备】重要排序算法的总结" class="headerlink" title="029【必备】重要排序算法的总结"></a>029【必备】重要排序算法的总结</h1><h2 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h2><h3 id="稳定性定义"><a href="#稳定性定义" class="headerlink" title="稳定性定义"></a>稳定性定义</h3><p><strong>排序算法的稳定性</strong>是指：同样大小的样本在排序之后不会改变原始的相对次序。</p>
<p><strong>重要性</strong>：</p>
<ul>
<li>稳定性对基础类型对象来说毫无意义</li>
<li>稳定性对非基础类型对象有意义，可以保留之前的相对次序</li>
</ul>
<h2 id="主要排序算法性能总结"><a href="#主要排序算法性能总结" class="headerlink" title="主要排序算法性能总结"></a>主要排序算法性能总结</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SelectionSort</strong><br/>选择排序</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>❌</td>
<td>因为是随机的交换</td>
</tr>
<tr>
<td><strong>BubbleSort</strong><br/>冒泡排序</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>✅</td>
<td>数学归纳法可以保证</td>
</tr>
<tr>
<td><strong>InsertionSort</strong><br/>插入排序</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>✅</td>
<td>相等会直接停，能够保证稳定性</td>
</tr>
<tr>
<td><strong>MergeSort</strong><br/>归并排序</td>
<td>O(N log N)</td>
<td>O(N)</td>
<td>✅</td>
<td>左右两边的区域满足偏序性</td>
</tr>
<tr>
<td><strong>QuickSort</strong><br/>快速排序</td>
<td>O(N log N)</td>
<td>O(log N)</td>
<td>❌</td>
<td>普通的是固定选择，随机的随机选择</td>
</tr>
<tr>
<td><strong>HeapSort</strong><br/>堆排序</td>
<td>O(N log N)</td>
<td>O(1)</td>
<td>❌</td>
<td>建堆的过程根本不在乎稳不稳定</td>
</tr>
<tr>
<td><strong>CountSort</strong><br/>计数排序</td>
<td>O(N)</td>
<td>O(M)</td>
<td>✅</td>
<td>入桶和出桶的过程是按次序的</td>
</tr>
<tr>
<td><strong>RadixSort</strong><br/>基数排序</td>
<td>O(N)</td>
<td>O(M)</td>
<td>✅</td>
<td>同计数排序</td>
</tr>
</tbody></table>
<h3 id="关键说明"><a href="#关键说明" class="headerlink" title="关键说明"></a>关键说明</h3><p><strong>随机快速排序的复杂度</strong>：</p>
<ul>
<li>一定要按照概率上的期望指标来估计</li>
<li>用最差的复杂度估计无意义</li>
<li>随机快排的详细说明在之前的视频中已有详细解释</li>
</ul>
<p><strong>重要结论</strong>：</p>
<blockquote>
<p>基于比较的排序，时间复杂度O(n log n)，空间复杂度低于O(n)，还具有稳定性的排序算法目前没有找到</p>
</blockquote>
<p><strong>TimSort说明</strong>：</p>
<ul>
<li>TimSort也不行，虽然在实际应用中通常不需要这么多的额外空间</li>
<li>但空间复杂度指标就是O(n)</li>
<li>在算法面试、笔试、比赛中都很少用到</li>
</ul>
<p><strong>希尔排序（ShellSort）</strong>：</p>
<ul>
<li>也不常用，就是加入步长调整的插入排序</li>
<li>有兴趣的同学可以研究一下</li>
</ul>
<h2 id="排序算法选择策略"><a href="#排序算法选择策略" class="headerlink" title="排序算法选择策略"></a>排序算法选择策略</h2><p>排序算法的选择完全取决于你在排序过程中在乎什么：</p>
<h3 id="1-数据量非常小的情况"><a href="#1-数据量非常小的情况" class="headerlink" title="1. 数据量非常小的情况"></a>1. 数据量非常小的情况</h3><p><strong>推荐：插入排序</strong></p>
<ul>
<li>可以做到非常迅速</li>
<li>实现简单，常数项小</li>
<li>很多高级排序算法在小数据量时会切换到插入排序</li>
</ul>
<h3 id="2-性能优异-实现简单-不在乎稳定性"><a href="#2-性能优异-实现简单-不在乎稳定性" class="headerlink" title="2. 性能优异 + 实现简单 + 不在乎稳定性"></a>2. 性能优异 + 实现简单 + 不在乎稳定性</h3><p><strong>推荐：随机快速排序</strong></p>
<ul>
<li>性能优异，期望时间复杂度O(n log n)</li>
<li>实现简单且利于改进</li>
<li>面对不同业务可以选择不同划分策略</li>
<li>空间复杂度较小O(log n)</li>
</ul>
<h3 id="3-性能优异-需要稳定性-不在乎额外空间"><a href="#3-性能优异-需要稳定性-不在乎额外空间" class="headerlink" title="3. 性能优异 + 需要稳定性 + 不在乎额外空间"></a>3. 性能优异 + 需要稳定性 + 不在乎额外空间</h3><p><strong>推荐：归并排序</strong></p>
<ul>
<li>性能优异，稳定的O(n log n)时间复杂度</li>
<li>具有稳定性</li>
<li>适合外部排序（大数据量）</li>
<li>空间复杂度O(n)</li>
</ul>
<h3 id="4-性能优异-额外空间要求O-1-不在乎稳定性"><a href="#4-性能优异-额外空间要求O-1-不在乎稳定性" class="headerlink" title="4. 性能优异 + 额外空间要求O(1) + 不在乎稳定性"></a>4. 性能优异 + 额外空间要求O(1) + 不在乎稳定性</h3><p><strong>推荐：堆排序</strong></p>
<ul>
<li>性能优异，稳定的O(n log n)时间复杂度</li>
<li>额外空间占用O(1)</li>
<li>最坏情况下性能依然稳定</li>
<li>不具有稳定性</li>
</ul>
<h3 id="5-特定数据特征-追求极致性能"><a href="#5-特定数据特征-追求极致性能" class="headerlink" title="5. 特定数据特征 + 追求极致性能"></a>5. 特定数据特征 + 追求极致性能</h3><p><strong>推荐：基数排序&#x2F;计数排序</strong></p>
<ul>
<li>在特定条件下可以达到O(n)时间复杂度</li>
<li>对数据类型有严格要求</li>
<li>适用于整数排序且范围有限的场景</li>
</ul>
<h2 id="实际应用建议"><a href="#实际应用建议" class="headerlink" title="实际应用建议"></a>实际应用建议</h2><h3 id="编程竞赛-面试"><a href="#编程竞赛-面试" class="headerlink" title="编程竞赛&#x2F;面试"></a>编程竞赛&#x2F;面试</h3><ol>
<li><strong>快速排序</strong>：最常考查，需要熟练掌握</li>
<li><strong>归并排序</strong>：稳定性要求时的首选</li>
<li><strong>堆排序</strong>：空间复杂度有严格限制时</li>
</ol>
<h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><ol>
<li><strong>小数组</strong>：插入排序</li>
<li><strong>大数组</strong>：快速排序（随机化）</li>
<li><strong>需要稳定性</strong>：归并排序</li>
<li><strong>内存敏感</strong>：堆排序</li>
<li><strong>特殊数据</strong>：计数排序&#x2F;基数排序</li>
</ol>
<h3 id="语言内置排序"><a href="#语言内置排序" class="headerlink" title="语言内置排序"></a>语言内置排序</h3><p>大多数编程语言的内置排序算法都是混合算法：</p>
<ul>
<li><strong>Python</strong>：Timsort（归并+插入的混合）</li>
<li><strong>Java</strong>：双轴快排（小数组时用插入排序）</li>
<li><strong>C++</strong>：通常是内省排序（快排+堆排序+插入排序的混合）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解各种排序算法的特点和适用场景比单纯记忆算法更重要。在实际应用中，需要根据具体需求（数据规模、稳定性要求、空间限制等）来选择合适的排序算法。基数排序作为非比较排序的代表，在特定场景下能够突破O(n log n)的理论下界，达到线性时间复杂度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89-%20%E5%A0%86%E7%BB%93%E6%9E%84&%E5%93%88%E5%B8%8C%E8%A1%A8&%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89-%20%E5%A0%86%E7%BB%93%E6%9E%84&%E5%93%88%E5%B8%8C%E8%A1%A8&%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（8）- 堆结构&哈希表&堆结构相关习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-09 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-09T08:42:46+08:00">2025-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-10 15:44:22" itemprop="dateModified" datetime="2025-08-10T15:44:22+08:00">2025-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记涵盖了堆的基本概念与堆排序、哈希表的实现以及堆结构的一些相关习题，包括了class025→027的内容。</p>
<h1 id="025【必备】堆结构和堆排序"><a href="#025【必备】堆结构和堆排序" class="headerlink" title="025【必备】堆结构和堆排序"></a>025【必备】堆结构和堆排序</h1><h2 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h2><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种特殊的<strong>完全二叉树</strong>结构，通常用数组来实现存储。堆有以下特性：</p>
<ol>
<li><strong>结构性质</strong>：堆是完全二叉树，即除了最后一层，其他层都是满的，最后一层从左到右连续填充</li>
<li><strong>堆序性质</strong>：<ul>
<li><strong>大根堆</strong>：任何一个子树内部的最大值一定在顶部（父节点 ≥ 子节点）</li>
<li><strong>小根堆</strong>：任何一个子树内部的最小值一定在顶部（父节点 ≤ 子节点）</li>
</ul>
</li>
</ol>
<h3 id="堆的数组表示"><a href="#堆的数组表示" class="headerlink" title="堆的数组表示"></a>堆的数组表示</h3><p>堆使用数组实现，通过下标关系来表示父子关系：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于下标为 i 的节点：</span></span><br><span class="line">parent = (i - <span class="number">1</span>) // <span class="number">2</span>    <span class="comment"># 父节点下标</span></span><br><span class="line">left_child = i * <span class="number">2</span> + <span class="number">1</span>   <span class="comment"># 左孩子下标  </span></span><br><span class="line">right_child = i * <span class="number">2</span> + <span class="number">2</span>  <span class="comment"># 右孩子下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否有孩子节点：</span></span><br><span class="line"><span class="comment"># 如果 left_child &gt;= size，则没有左孩子</span></span><br><span class="line"><span class="comment"># 如果 right_child &gt;= size，则没有右孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E5%A0%86%E7%BB%93%E6%9E%84%E2%86%92%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="堆结构→完全二叉树"></p>
<h3 id="堆的核心操作"><a href="#堆的核心操作" class="headerlink" title="堆的核心操作"></a>堆的核心操作</h3><p>堆有两个核心调整操作，时间复杂度都是 <strong>O(log n)</strong>：</p>
<ol>
<li><strong>heapInsert（向上调整）</strong>：新元素插入后向上调整维持堆性质</li>
<li><strong>heapify（向下调整）</strong>：删除堆顶后向下调整维持堆性质</li>
</ol>
<h2 id="堆的核心算法实现"><a href="#堆的核心算法实现" class="headerlink" title="堆的核心算法实现"></a>堆的核心算法实现</h2><h3 id="heapInsert-向上调整"><a href="#heapInsert-向上调整" class="headerlink" title="heapInsert - 向上调整"></a>heapInsert - 向上调整</h3><p>当在堆的末尾插入新元素时，需要向上调整以维持堆的性质：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapInsert</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    i位置的数，向上调整大根堆</span></span><br><span class="line"><span class="string">    时间复杂度：O(logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> arr[i] &gt; arr[(i - <span class="number">1</span>) // <span class="number">2</span>]:  <span class="comment"># 当前节点大于父节点时</span></span><br><span class="line">        swap(i, (i - <span class="number">1</span>) // <span class="number">2</span>)          <span class="comment"># 与父节点交换</span></span><br><span class="line">        i = (i - <span class="number">1</span>) // <span class="number">2</span>               <span class="comment"># 更新当前位置为父节点位置</span></span><br></pre></td></tr></table></figure>

<p><strong>算法流程</strong>：</p>
<ol>
<li>比较当前节点与其父节点的值</li>
<li>如果当前节点更大（大根堆），则交换</li>
<li>向上移动到父节点位置，重复过程</li>
<li>直到满足堆性质或到达根节点</li>
</ol>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E5%A4%A7%E6%A0%B9%E5%A0%86%E7%9A%84%E5%A0%86%E6%8F%92%E5%85%A5.png" alt="大根堆的堆插入"></p>
<h3 id="heapify-向下调整"><a href="#heapify-向下调整" class="headerlink" title="heapify - 向下调整"></a>heapify - 向下调整</h3><p>当删除堆顶元素后，需要向下调整以维持堆的性质：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">i, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    i位置的数，向下调整大根堆</span></span><br><span class="line"><span class="string">    当前堆的大小为size</span></span><br><span class="line"><span class="string">    时间复杂度：O(logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    l = i * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 左孩子</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:  <span class="comment"># 如果左孩子存在</span></span><br><span class="line">        <span class="comment"># 选出左右孩子中更大的那个</span></span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> (l + <span class="number">1</span> &lt; size <span class="keyword">and</span> arr[l + <span class="number">1</span>] &gt; arr[l]) <span class="keyword">else</span> l</span><br><span class="line">        <span class="comment"># 当前节点和最强孩子之间，选出最强的</span></span><br><span class="line">        best = best <span class="keyword">if</span> arr[best] &gt; arr[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:  <span class="comment"># 如果当前节点最大，调整完成</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(best, i)  <span class="comment"># 交换</span></span><br><span class="line">        i = best       <span class="comment"># 移动到交换后的位置</span></span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 更新左孩子</span></span><br><span class="line"><span class="comment"># 1.找到更大的子节点：比较左右子节点，选出值更大的那个</span></span><br><span class="line"><span class="comment"># 2.与父节点比较：将较大的子节点与当前父节点比较</span></span><br><span class="line"><span class="comment"># 3.决定是否交换：如果子节点更大就交换，否则停止调整</span></span><br><span class="line"><span class="comment"># 4.继续向下：交换后继续对新位置进行同样的操作</span></span><br></pre></td></tr></table></figure>

<p><strong>算法流程</strong>：</p>
<ol>
<li>找到更大的子节点：比较左右子节点，选出值更大的那个</li>
<li>与父节点比较：将较大的子节点与当前父节点比较</li>
<li>决定是否交换：如果子节点更大就交换，否则停止调整</li>
<li>继续向下：交换后继续对新位置进行同样的操作</li>
</ol>
<h2 id="堆排序的两种实现"><a href="#堆排序的两种实现" class="headerlink" title="堆排序的两种实现"></a>堆排序的两种实现</h2><h3 id="方法一：从顶到底建堆（经典版本）"><a href="#方法一：从顶到底建堆（经典版本）" class="headerlink" title="方法一：从顶到底建堆（经典版本）"></a>方法一：从顶到底建堆（经典版本）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    完全二叉树的节点为N的话，高度是log_2(N)的水平</span></span><br><span class="line"><span class="string">    从顶到底建立大根堆，从顶到底建立大根堆，O(n * logn)，每次排好一个数，排n个数要n次，每排一个数时间复杂度是logn，排n个数当然是nlogn</span></span><br><span class="line"><span class="string">    依次弹出堆内最大值并排好序，O(n * logn)</span></span><br><span class="line"><span class="string">    整体时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆阶段：从第一个元素开始，依次插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heapInsert(i)  <span class="comment"># 每个元素向上调整</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 排序阶段：不断取出最大值</span></span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)  <span class="comment"># 将最大值（堆顶）放到数组末尾</span></span><br><span class="line">        size -= <span class="number">1</span>          <span class="comment"># 减少堆的大小</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)   <span class="comment"># 对新的堆顶进行向下调整</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>建堆阶段：<code>log₁ + log₂ + log₃ + ... + logₙ =（收敛于） O(n logn)</code></li>
<li>排序阶段：每次调整 <code>O(log n)</code>，共 <code>n-1</code> 次，总计 <code>O(n logn)</code></li>
<li><strong>总时间复杂度：O(n logn)</strong></li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E4%BB%8E%E5%BA%95%E9%83%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="从底部到顶部的堆排序"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E4%BB%8E%E4%BB%8E%E5%BA%95%E9%83%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="从底部到顶部的堆排序-复杂度分析"></p>
<h3 id="方法二：从底到顶建堆（优化版本）"><a href="#方法二：从底到顶建堆（优化版本）" class="headerlink" title="方法二：从底到顶建堆（优化版本）"></a>方法二：从底到顶建堆（优化版本）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从底到顶建立大根堆，O(n) </span></span><br><span class="line"><span class="string">    依次弹出堆内最大值并排好序，O(n * logn)</span></span><br><span class="line"><span class="string">    整体时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆阶段：从最后一个非叶子节点开始，向前调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(i, n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 排序阶段：与方法一相同</span></span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)</span><br><span class="line"><span class="comment"># 这种方法更像修理一栋破房子，从最下面的楼层开始修。建堆阶段只需要O(n)时间，具体是从最后一个非叶子节点开始逐个向前调整，每个节点只需要&quot;向下看&quot;把不合格的子节点换上来，由于采用从底向上的策略效率更高。</span></span><br><span class="line"><span class="comment"># 排序阶段的做法与方法1相同，先取堆顶元素放到合适位置，然后重新调整剩余元素成堆并重复进行。整体而言方法2更优，因为它的建堆过程比方法1快了一个数量级，从O(n logn)优化到了O(n)</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E4%BB%8E%E4%BB%8E%E5%BA%95%E9%83%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="两种排序方法对比"><br><strong>为什么从底到顶建堆更快？</strong></p>
<p>从底到顶建堆的时间复杂度是 <strong>O(n)</strong>，这是因为：</p>
<ol>
<li><strong>叶子节点无需调整</strong>：完全二叉树中约有 n&#x2F;2 个叶子节点，它们天然满足堆性质</li>
<li><strong>调整距离递减</strong>：越靠近叶子的节点，需要向下调整的最大距离越小</li>
<li><strong>数学分析</strong>：可以证明总的调整代价是一个等比数列，收敛到 O(n)</li>
</ol>
<p><strong>两种方法的对比</strong>：</p>
<table>
<thead>
<tr>
<th>建堆方法</th>
<th>建堆复杂度</th>
<th>排序复杂度</th>
<th>总复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>从顶到底</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>逐个插入元素”爬楼梯”</td>
</tr>
<tr>
<td>从底到顶</td>
<td>O(n)</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>从下往上”修房子”</td>
</tr>
</tbody></table>
<h2 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    data = sys.stdin.read().split()</span><br><span class="line">    n = <span class="built_in">int</span>(data[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] = <span class="built_in">int</span>(data[i + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    heapSort2()  <span class="comment"># 使用优化版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 高效输出</span></span><br><span class="line">    sys.stdout.write(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">str</span>(arr[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>)))</span><br><span class="line">    sys.stdout.write(<span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(arr[n - <span class="number">1</span>]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapInsert</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">while</span> arr[i] &gt; arr[(i - <span class="number">1</span>) // <span class="number">2</span>]:</span><br><span class="line">        swap(i, (i - <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        i = (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">i, size</span>):</span><br><span class="line">    l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:</span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> (l + <span class="number">1</span> &lt; size <span class="keyword">and</span> arr[l + <span class="number">1</span>] &gt; arr[l]) <span class="keyword">else</span> l</span><br><span class="line">        best = best <span class="keyword">if</span> arr[best] &gt; arr[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(best, i)</span><br><span class="line">        i = best</span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heapInsert(i)</span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort2</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(i, n)</span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="堆排序的特点总结"><a href="#堆排序的特点总结" class="headerlink" title="堆排序的特点总结"></a>堆排序的特点总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>时间复杂度稳定</strong>：无论什么数据，时间复杂度都是 O(n logn)</li>
<li><strong>原地排序</strong>：额外空间复杂度 O(1)，直接在原数组上建堆</li>
<li><strong>不稳定但可预测</strong>：虽然不是稳定排序，但性能可预测</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>不稳定</strong>：相同元素的相对位置可能改变</li>
<li><strong>常数因子较大</strong>：虽然渐进复杂度优秀，但实际运行时常数因子比快排大</li>
<li><strong>缓存友好性差</strong>：堆调整过程中的访问模式对CPU缓存不太友好</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><strong>优先队列</strong>：堆是实现优先队列的最佳数据结构</li>
<li><strong>Top-K 问题</strong>：找出最大或最小的K个元素</li>
<li><strong>实时数据流</strong>：需要实时维护最值的场景</li>
<li><strong>任务调度</strong>：按优先级处理任务</li>
</ol>
<h2 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h2><p><strong>堆结构比堆排序有用得多，尤其是和比较器结合之后</strong>。堆排序只是堆数据结构的一个应用，堆在实际开发中更多用于实现优先队列、解决Top-K问题等场景。</p>
<h1 id="026【必备】哈希表、有序表和比较器的用法"><a href="#026【必备】哈希表、有序表和比较器的用法" class="headerlink" title="026【必备】哈希表、有序表和比较器的用法"></a>026【必备】哈希表、有序表和比较器的用法</h1><h2 id="哈希表（Hash-Table）的基本概念"><a href="#哈希表（Hash-Table）的基本概念" class="headerlink" title="哈希表（Hash Table）的基本概念"></a>哈希表（Hash Table）的基本概念</h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h3><p>哈希表是一种数据结构，它通过键（key）来直接访问存储在值（value）中的数据，实现快速查找、插入和删除操作。</p>
<p>大概约等于python中的字典啦</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li><strong>将数据存储在数组中</strong></li>
<li><strong>通过哈希函数将key转换为数组索引</strong></li>
<li><strong>理想情况下，查找、插入、删除的时间复杂度都是O(1)</strong></li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key → 哈希函数 → 数组索引 → 存储位置</span><br></pre></td></tr></table></figure>

<h3 id="哈希表的特点"><a href="#哈希表的特点" class="headerlink" title="哈希表的特点"></a>哈希表的特点</h3><ul>
<li><strong>时间复杂度</strong>：增、删、改、查时间为O(1)，但是大常数</li>
<li><strong>空间换时间</strong>：用额外的空间来换取时间效率</li>
<li><strong>两种形式</strong>：<ul>
<li><strong>HashSet</strong>：只存储键，用于判断元素是否存在</li>
<li><strong>HashMap</strong>：存储键值对，根据键快速找到对应的值</li>
</ul>
</li>
</ul>
<h2 id="Python中的哈希表实现"><a href="#Python中的哈希表实现" class="headerlink" title="Python中的哈希表实现"></a>Python中的哈希表实现</h2><h3 id="字符串的比较机制"><a href="#字符串的比较机制" class="headerlink" title="字符串的比较机制"></a>字符串的比较机制</h3><p>Python中字符串有特殊的驻留机制，需要注意<code>is</code>和<code>==</code>的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串比较</span></span><br><span class="line">str1 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>) </span><br><span class="line">str2 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 不同内存地址，但是内容都是Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较对象身份（内存地址）</span></span><br><span class="line"><span class="built_in">print</span>(str1 <span class="keyword">is</span> str2)   <span class="comment"># 可能是True（驻留机制）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较值（内容）</span></span><br><span class="line"><span class="built_in">print</span>(str1 == str2)   <span class="comment"># True，内容一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态生成的字符串</span></span><br><span class="line">s3 = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s1 == s3)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">is</span> s3)  <span class="comment"># False，复杂或动态生成的字符串，is一般是False</span></span><br></pre></td></tr></table></figure>

<p><strong>重要概念</strong>：</p>
<ul>
<li><strong>字符串驻留</strong>：Python对于短小、常用的字符串可能会优化，放到同一个内存地址</li>
<li><strong>内容比较 vs 身份比较</strong>：<code>==</code>比较内容，<code>is</code>比较内存地址</li>
</ul>
<h3 id="set操作（HashSet）"><a href="#set操作（HashSet）" class="headerlink" title="set操作（HashSet）"></a>set操作（HashSet）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set判断元素是否相等靠内容，不看对象id</span></span><br><span class="line">str1 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>) </span><br><span class="line">str2 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 不同内存地址，但是内容都是Hello</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(str1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span> <span class="keyword">in</span> s)     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(str2 <span class="keyword">in</span> s)        <span class="comment"># True</span></span><br><span class="line">s.add(str2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))           <span class="comment"># 1，因为set里不会存储重复元素</span></span><br><span class="line">s.discard(str1)         <span class="comment"># 删除等价元素（内容相等的字符串都会被删掉）</span></span><br><span class="line">s.clear()               <span class="comment"># 清空所有元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s) == <span class="number">0</span>)      <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="dict操作（HashMap）"><a href="#dict操作（HashMap）" class="headerlink" title="dict操作（HashMap）"></a>dict操作（HashMap）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dict操作</span></span><br><span class="line">map1 = <span class="built_in">dict</span>()</span><br><span class="line">map1[str1] = <span class="string">&quot;World&quot;</span>    <span class="comment"># str1是key，&quot;World&quot;是value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span> <span class="keyword">in</span> map1)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(str2 <span class="keyword">in</span> map1)     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(map1.get(str2))   <span class="comment"># World</span></span><br><span class="line"><span class="built_in">print</span>(map1.get(<span class="string">&quot;你好&quot;</span>) <span class="keyword">is</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;Hello&quot;</span> <span class="keyword">in</span> map1:</span><br><span class="line">    <span class="keyword">del</span> map1[<span class="string">&quot;Hello&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(map1))        <span class="comment"># 0</span></span><br><span class="line">map1.clear()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(map1) == <span class="number">0</span>)   <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="哈希表的优化策略"><a href="#哈希表的优化策略" class="headerlink" title="哈希表的优化策略"></a>哈希表的优化策略</h2><h3 id="数组替代哈希表"><a href="#数组替代哈希表" class="headerlink" title="数组替代哈希表"></a>数组替代哈希表</h3><p>当key的范围是固定的、可控的情况下，可以用数组结构替代哈希表结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表实现</span></span><br><span class="line">map2 = <span class="built_in">dict</span>()</span><br><span class="line">map2[<span class="number">56</span>] = <span class="number">7285</span></span><br><span class="line">map2[<span class="number">34</span>] = <span class="number">3671263</span></span><br><span class="line">map2[<span class="number">17</span>] = <span class="number">716311</span></span><br><span class="line">map2[<span class="number">24</span>] = <span class="number">1263161</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组替代实现（速度更快）</span></span><br><span class="line">arr = [<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">arr[<span class="number">56</span>] = <span class="number">7285</span></span><br><span class="line">arr[<span class="number">34</span>] = <span class="number">3671263</span></span><br><span class="line">arr[<span class="number">17</span>] = <span class="number">716311</span></span><br><span class="line">arr[<span class="number">24</span>] = <span class="number">1263161</span></span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：</p>
<ul>
<li><strong>速度更快</strong>：直接数组访问，无需哈希计算</li>
<li><strong>空间可控</strong>：预知范围，精确分配空间</li>
<li><strong>无哈希冲突</strong>：避免了哈希表的冲突处理</li>
</ul>
<h3 id="自定义对象作为Key"><a href="#自定义对象作为Key" class="headerlink" title="自定义对象作为Key"></a>自定义对象作为Key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="number">17</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">s2 = Student(<span class="number">17</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">map3 = <span class="built_in">dict</span>()</span><br><span class="line">map3[s1] = <span class="string">&quot;这是张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">in</span> map3)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2 <span class="keyword">in</span> map3)  <span class="comment"># False，Python默认不同对象hash不同</span></span><br><span class="line">map3[s2] = <span class="string">&quot;这是另一个张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(map3))   <span class="comment"># 2，s1和s2是不同的对象，字典中有两个键值对</span></span><br></pre></td></tr></table></figure>

<p><strong>重要提示</strong>：Python自定义对象没有实现<code>__eq__</code>和<code>__hash__</code>时，默认按对象id判定。</p>
<h2 id="有序表（TreeMap-TreeSet）"><a href="#有序表（TreeMap-TreeSet）" class="headerlink" title="有序表（TreeMap&#x2F;TreeSet）"></a>有序表（TreeMap&#x2F;TreeSet）</h2><h3 id="Python中的有序表模拟"><a href="#Python中的有序表模拟" class="headerlink" title="Python中的有序表模拟"></a>Python中的有序表模拟</h3><p>Python没有内置的TreeMap，需要用其他方式模拟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用dict+排序模拟TreeMap</span></span><br><span class="line">tree_map = <span class="built_in">dict</span>()</span><br><span class="line">tree_map[<span class="number">5</span>] = <span class="string">&quot;这是5&quot;</span></span><br><span class="line">tree_map[<span class="number">7</span>] = <span class="string">&quot;这是7&quot;</span></span><br><span class="line">tree_map[<span class="number">1</span>] = <span class="string">&quot;这是1&quot;</span></span><br><span class="line">tree_map[<span class="number">2</span>] = <span class="string">&quot;这是2&quot;</span></span><br><span class="line">tree_map[<span class="number">3</span>] = <span class="string">&quot;这是3&quot;</span></span><br><span class="line">tree_map[<span class="number">4</span>] = <span class="string">&quot;这是4&quot;</span></span><br><span class="line">tree_map[<span class="number">8</span>] = <span class="string">&quot;这是8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> tree_map)        <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> tree_map)       <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(tree_map.get(<span class="number">4</span>))      <span class="comment"># 这是4</span></span><br><span class="line">tree_map[<span class="number">4</span>] = <span class="string">&quot;张三是4&quot;</span></span><br><span class="line"><span class="built_in">print</span>(tree_map.get(<span class="number">4</span>))      <span class="comment"># 张三是4</span></span><br><span class="line"></span><br><span class="line">tree_map.pop(<span class="number">4</span>, <span class="literal">None</span>)       <span class="comment"># 删除key为4的键值对</span></span><br><span class="line"><span class="built_in">print</span>(tree_map.get(<span class="number">4</span>) <span class="keyword">is</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="有序表的特殊操作"><a href="#有序表的特殊操作" class="headerlink" title="有序表的特殊操作"></a>有序表的特殊操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firstKey 和 lastKey 需要排序</span></span><br><span class="line">keys = <span class="built_in">sorted</span>(tree_map.keys())</span><br><span class="line"><span class="built_in">print</span>(keys[<span class="number">0</span>])      <span class="comment"># firstKey: 1</span></span><br><span class="line"><span class="built_in">print</span>(keys[-<span class="number">1</span>])     <span class="comment"># lastKey: 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># floorKey: 所有的key，&lt;= 4且最近的key是什么</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">floor_key</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> tree_map <span class="keyword">if</span> x &lt;= k], default=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ceilingKey: 所有的key，&gt;= 4且最近的key是什么</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ceiling_key</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> tree_map <span class="keyword">if</span> x &gt;= k], default=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(floor_key(<span class="number">4</span>))    <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(ceiling_key(<span class="number">4</span>))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>操作解释</strong>：</p>
<ul>
<li><strong>删除前</strong>：1, 2, 3, [4], 5, 7, 8</li>
<li><strong>删除后</strong>：1, 2, 3, 5, 7, 8</li>
<li><strong>floor_key(4)</strong>：找到 ≤ 4 的最大值，可选值：[1, 2, 3]，最大值：3</li>
<li><strong>ceiling_key(4)</strong>：找到 ≥ 4 的最小值，可选值：[5, 7, 8]，最小值：5</li>
</ul>
<h3 id="TreeSet模拟"><a href="#TreeSet模拟" class="headerlink" title="TreeSet模拟"></a>TreeSet模拟</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TreeSet模拟：用set+排序（去重且有序）</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(<span class="number">3</span>)</span><br><span class="line">s.add(<span class="number">3</span>)</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有序表大小:&quot;</span>, <span class="built_in">len</span>(s))  <span class="comment"># 2，因为set里不会存储重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以有序弹出</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">sorted</span>(s):</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h2><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小根堆</span></span><br><span class="line">heap1 = []</span><br><span class="line">heapq.heappush(heap1, <span class="number">3</span>)</span><br><span class="line">heapq.heappush(heap1, <span class="number">3</span>)</span><br><span class="line">heapq.heappush(heap1, <span class="number">4</span>)</span><br><span class="line">heapq.heappush(heap1, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;堆大小:&quot;</span>, <span class="built_in">len</span>(heap1))  <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">while</span> heap1:</span><br><span class="line">    <span class="built_in">print</span>(heapq.heappop(heap1))  <span class="comment"># 3 3 4 4</span></span><br></pre></td></tr></table></figure>

<h3 id="大根堆实现技巧"><a href="#大根堆实现技巧" class="headerlink" title="大根堆实现技巧"></a>大根堆实现技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大根堆trick：使用负数</span></span><br><span class="line">heap2 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]:</span><br><span class="line">    heapq.heappush(heap2, -x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;堆大小:&quot;</span>, <span class="built_in">len</span>(heap2))  <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">while</span> heap2:</span><br><span class="line">    <span class="built_in">print</span>(-heapq.heappop(heap2))  <span class="comment"># 4 4 3 3</span></span><br></pre></td></tr></table></figure>

<p><strong>核心技巧</strong>：Python的heapq只提供小根堆，要实现大根堆可以将所有元素取负数。</p>
<h2 id="比较器的使用"><a href="#比较器的使用" class="headerlink" title="比较器的使用"></a>比较器的使用</h2><h3 id="基本比较器概念"><a href="#基本比较器概念" class="headerlink" title="基本比较器概念"></a>基本比较器概念</h3><p>任何比较器都有统一的规则：</p>
<ul>
<li><strong>返回负数</strong>：认为第一个对象优先级更高</li>
<li><strong>返回正数</strong>：认为第二个对象优先级更高</li>
<li><strong>返回0</strong>：两个对象优先级相等</li>
</ul>
<h3 id="员工类的排序示例"><a href="#员工类的排序示例" class="headerlink" title="员工类的排序示例"></a>员工类的排序示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, company, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.company = company</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Employee(<span class="subst">&#123;self.company&#125;</span>, <span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工比较器，按年龄升序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">employee_comparator</span>(<span class="params">o1, o2</span>):</span><br><span class="line">    <span class="keyword">return</span> o1.age - o2.age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建员工对象</span></span><br><span class="line">s1 = Employee(<span class="number">2</span>, <span class="number">27</span>)</span><br><span class="line">s2 = Employee(<span class="number">1</span>, <span class="number">60</span>)</span><br><span class="line">s3 = Employee(<span class="number">4</span>, <span class="number">19</span>)</span><br><span class="line">s4 = Employee(<span class="number">3</span>, <span class="number">23</span>)</span><br><span class="line">s5 = Employee(<span class="number">1</span>, <span class="number">35</span>)</span><br><span class="line">s6 = Employee(<span class="number">3</span>, <span class="number">55</span>)</span><br><span class="line">arr = [s1, s2, s3, s4, s5, s6]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按年龄升序排序</span></span><br><span class="line">arr.sort(key=cmp_to_key(employee_comparator))</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e.company&#125;</span>, <span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="多种排序方式"><a href="#多种排序方式" class="headerlink" title="多种排序方式"></a>多种排序方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按年龄降序排序（lambda表达式）</span></span><br><span class="line">arr.sort(key=<span class="keyword">lambda</span> x: -x.age)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e.company&#125;</span>, <span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多级排序：先按公司编号，再按年龄</span></span><br><span class="line">arr.sort(key=<span class="keyword">lambda</span> x: (x.company, x.age))</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e.company&#125;</span>, <span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义对象的去重策略"><a href="#自定义对象的去重策略" class="headerlink" title="自定义对象的去重策略"></a>自定义对象的去重策略</h3><h4 id="按年龄去重"><a href="#按年龄去重" class="headerlink" title="按年龄去重"></a>按年龄去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeByAge</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.age == other.age  <span class="comment"># 只看年龄</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.age)</span><br><span class="line"></span><br><span class="line">treeSet1 = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    treeSet1.add(EmployeeByAge(e.company, e.age))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet1))  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会去重，因为age一样的员工被认为是同一个</span></span><br><span class="line">treeSet1.add(EmployeeByAge(<span class="number">2</span>, <span class="number">27</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet1))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<h4 id="按多个属性去重"><a href="#按多个属性去重" class="headerlink" title="按多个属性去重"></a>按多个属性去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeByAll</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, EmployeeByAll):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">self</span>.company == other.company <span class="keyword">and</span> </span><br><span class="line">                <span class="variable language_">self</span>.age == other.age <span class="keyword">and</span> </span><br><span class="line">                <span class="built_in">repr</span>(<span class="variable language_">self</span>) == <span class="built_in">repr</span>(other))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="variable language_">self</span>.company, <span class="variable language_">self</span>.age, <span class="built_in">repr</span>(<span class="variable language_">self</span>)))</span><br><span class="line"></span><br><span class="line">treeSet2 = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    treeSet2.add(EmployeeByAll(e.company, e.age))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet2))  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会去重，因为repr不同（内存地址不同）</span></span><br><span class="line">treeSet2.add(EmployeeByAll(<span class="number">2</span>, <span class="number">27</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet2))  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>

<p><strong>重要概念</strong>：</p>
<ul>
<li><strong><code>__eq__</code>方法</strong>：定义对象间的相等性比较，当使用<code>==</code>操作符时调用</li>
<li><strong><code>__hash__</code>方法</strong>：定义对象的哈希值，用于在集合和字典中作为键</li>
</ul>
<h3 id="字符串的字典序比较"><a href="#字符串的字典序比较" class="headerlink" title="字符串的字典序比较"></a>字符串的字典序比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典序比较</span></span><br><span class="line">str1 = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;ks&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.__lt__(str2) - str1.__gt__(str2))  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(str2.__lt__(str1) - str2.__gt__(str1))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接用比较运算符</span></span><br><span class="line"><span class="built_in">print</span>((str1 &gt; str2) - (str1 &lt; str2))  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>((str2 &gt; str1) - (str2 &lt; str1))  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>字典序规则</strong>：按字符的ASCII码逐位比较，先遇到不同字符的位置决定大小关系。</p>
<h2 id="数据结构选择指南"><a href="#数据结构选择指南" class="headerlink" title="数据结构选择指南"></a>数据结构选择指南</h2><h3 id="性能对比表"><a href="#性能对比表" class="headerlink" title="性能对比表"></a>性能对比表</h3><table>
<thead>
<tr>
<th>数据结构</th>
<th>查找</th>
<th>插入</th>
<th>删除</th>
<th>有序性</th>
<th>去重</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>❌</td>
<td>✅</td>
<td>快速查重、集合运算</td>
</tr>
<tr>
<td>dict</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>❌</td>
<td>✅</td>
<td>键值映射、缓存</td>
</tr>
<tr>
<td>数组</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>❌</td>
<td>❌</td>
<td>key范围可控时替代哈希表</td>
</tr>
<tr>
<td>排序列表</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>✅</td>
<td>❌</td>
<td>需要有序且查找频繁</td>
</tr>
<tr>
<td>heapq</td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>部分</td>
<td>❌</td>
<td>优先队列、Top-K问题</td>
</tr>
</tbody></table>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ol>
<li><strong>快速查找、去重</strong>：使用<code>set</code></li>
<li><strong>键值映射</strong>：使用<code>dict</code></li>
<li><strong>key范围固定</strong>：考虑数组替代哈希表</li>
<li><strong>需要有序</strong>：使用排序+二分查找或第三方库</li>
<li><strong>优先队列</strong>：使用<code>heapq</code></li>
<li><strong>自定义排序</strong>：实现比较器或使用<code>key</code>参数</li>
</ol>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="场景1：统计词频"><a href="#场景1：统计词频" class="headerlink" title="场景1：统计词频"></a>场景1：统计词频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dict统计</span></span><br><span class="line">text = <span class="string">&quot;hello world hello python&quot;</span></span><br><span class="line">word_count = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split():</span><br><span class="line">    word_count[word] = word_count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(word_count)  <span class="comment"># &#123;&#x27;hello&#x27;: 2, &#x27;world&#x27;: 1, &#x27;python&#x27;: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="场景2：去重并保持顺序"><a href="#场景2：去重并保持顺序" class="headerlink" title="场景2：去重并保持顺序"></a>场景2：去重并保持顺序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dict保持插入顺序的去重</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe_keep_order</span>(<span class="params">items</span>):</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen[item] = <span class="literal">True</span></span><br><span class="line">            result.append(item)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(dedupe_keep_order(items))  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="场景3：Top-K问题"><a href="#场景3：Top-K问题" class="headerlink" title="场景3：Top-K问题"></a>场景3：Top-K问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_top_k</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="comment"># 使用小根堆，维护k个最大元素</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">elif</span> num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(heap, num)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(heap, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(find_top_k(nums, <span class="number">3</span>))  <span class="comment"># [9, 6, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>哈希表</strong>：提供O(1)的查找、插入、删除，但有较大常数因子</li>
<li><strong>有序表</strong>：在Python中需要模拟实现，适合需要有序性的场景</li>
<li><strong>比较器</strong>：统一的优先级比较规则，负数表示第一个对象优先级更高</li>
<li><strong>优化策略</strong>：key范围可控时用数组替代哈希表，性能更好</li>
<li><strong>实际应用</strong>：根据具体需求选择合适的数据结构，考虑时间复杂度和空间复杂度的权衡</li>
</ol>
<h1 id="027【必备】堆结构常见题"><a href="#027【必备】堆结构常见题" class="headerlink" title="027【必备】堆结构常见题"></a>027【必备】堆结构常见题</h1><h2 id="Python-heapq-模块详解"><a href="#Python-heapq-模块详解" class="headerlink" title="Python heapq 模块详解"></a>Python heapq 模块详解</h2><h3 id="heapq-基本概念"><a href="#heapq-基本概念" class="headerlink" title="heapq 基本概念"></a>heapq 基本概念</h3><p>heapq 是 Python 标准库提供的”二叉堆”实现工具，基于列表实现的<strong>最小堆（min-heap）</strong>。它能在 O(log n) 时间内插入与弹出最小元素，<code>heap[0]</code> 永远是当前最小值。</p>
<h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">heapq.heappush(heap, item)      <span class="comment"># 压入元素，O(log n)</span></span><br><span class="line">heapq.heappop(heap)             <span class="comment"># 弹出最小元素，O(log n)</span></span><br><span class="line">heapq.heapify(lst)              <span class="comment"># 原地把列表转成堆，O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高效组合操作</span></span><br><span class="line">heapq.heappushpop(heap, item)   <span class="comment"># 先推入再弹出（更高效的一步）</span></span><br><span class="line">heapq.heapreplace(heap, item)   <span class="comment"># 先弹出最小再推入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实用函数</span></span><br><span class="line">heapq.nsmallest(n, iterable)    <span class="comment"># 返回n个最小元素</span></span><br><span class="line">heapq.nlargest(n, iterable)     <span class="comment"># 返回n个最大元素</span></span><br><span class="line">heapq.merge(*iterables)         <span class="comment"># 合并多个已排序可迭代对象（惰性生成）</span></span><br></pre></td></tr></table></figure>

<h3 id="大根堆实现技巧-1"><a href="#大根堆实现技巧-1" class="headerlink" title="大根堆实现技巧"></a>大根堆实现技巧</h3><p>由于 Python 的 heapq 只提供小根堆，实现大根堆需要使用负数技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大根堆实现</span></span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]:</span><br><span class="line">    heapq.heappush(heap, -x)    <span class="comment"># 插入负数</span></span><br><span class="line"></span><br><span class="line">max_val = -heapq.heappop(heap)  <span class="comment"># 弹出并转回正数</span></span><br></pre></td></tr></table></figure>

<h2 id="问题一：合并K个有序链表"><a href="#问题一：合并K个有序链表" class="headerlink" title="问题一：合并K个有序链表"></a>问题一：合并K个有序链表</h2><p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6">https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6</a></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定K个有序链表，将它们合并成一个有序链表。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用<strong>小根堆</strong>维护所有链表的当前头节点，每次取出值最小的节点：</p>
<ol>
<li><strong>初始化</strong>：将所有链表的头节点放入堆中</li>
<li><strong>合并过程</strong>：<ul>
<li>弹出堆顶最小节点，连接到结果链表</li>
<li>如果该节点有下一个节点，将下一个节点入堆</li>
<li>重复直到堆为空</li>
</ul>
</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%B0%8F%E6%A0%B9%E5%A0%86%E7%89%88.png" alt="合并k个有序链表-小根堆版"></p>
<h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">arr: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="comment"># 小根堆，存储节点及其值，用堆结构的话时间复杂度会比O(NlogN)更小</span></span><br><span class="line">    <span class="comment"># Optional[T] 等价于 Union[T, None]</span></span><br><span class="line">    <span class="comment"># 表示这个值可能是 T 类型，也可能是 None</span></span><br><span class="line">    heap = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将所有链表头节点入堆</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> h <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Python的heapq不能直接比较对象，需包装</span></span><br><span class="line">            heapq.heappush(heap, (h.val, <span class="built_in">id</span>(h), h))</span><br><span class="line">            <span class="comment"># heapq 比较规则：它按元组字典序比较。你放入 (val, something, node) 时，先比 val，相等就比第二个元素；如果第二个也相等，就会去比第三个元素（即 ListNode 实例）。</span></span><br><span class="line">            <span class="comment"># 问题：ListNode 没有定义大小比较，直接比较会抛出 TypeError: &#x27;&lt;&#x27; not supported...</span></span><br><span class="line">            <span class="comment"># 加入 id(node)：id 是对象在该进程生命周期内的唯一“身份值”（可比较），作为“决胜键”保证元组能比较出大小，从而避免直接比较 ListNode。 </span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> heap:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 弹出一个节点作为总头部</span></span><br><span class="line">    _, _, h = heapq.heappop(heap)</span><br><span class="line">    pre = h</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将该节点的下一个节点入堆</span></span><br><span class="line">    <span class="keyword">if</span> pre.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        heapq.heappush(heap, (pre.<span class="built_in">next</span>.val, <span class="built_in">id</span>(pre.<span class="built_in">next</span>), pre.<span class="built_in">next</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 继续合并过程</span></span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        _, _, cur = heapq.heappop(heap)</span><br><span class="line">        pre.<span class="built_in">next</span> = cur      <span class="comment"># 连接链表</span></span><br><span class="line">        pre = cur          <span class="comment"># pre后移</span></span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            heapq.heappush(heap, (cur.<span class="built_in">next</span>.val, <span class="built_in">id</span>(cur.<span class="built_in">next</span>), cur.<span class="built_in">next</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">    <span class="comment"># 对 heapq 来说，一个 item 就是一个可比较的对象。这里把一个三元组 (pre.next.val, id(pre.next), pre.next) 当作 item 放入堆。</span></span><br><span class="line">    <span class="comment"># 比较顺序（字典序）：</span></span><br><span class="line">    <span class="comment"># 先比第 1 位 pre.next.val（值越小，优先级越高）</span></span><br><span class="line">    <span class="comment"># 若相等，再比第 2 位 id(pre.next)（保证能比较出大小，避免去比较 ListNode 本身）</span></span><br><span class="line">    <span class="comment"># 只在前两位都相等时，才会看第 3 位 pre.next（但通常不会用到，因为 id 已经唯一）</span></span><br></pre></td></tr></table></figure>

<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><p><strong>元组比较机制</strong>：</p>
<ul>
<li>heapq 按元组字典序比较：<code>(val, something, node)</code></li>
<li>先比较 <code>val</code>，相等时比较第二个元素</li>
<li>加入 <code>id(node)</code> 作为”决胜键”，避免直接比较 ListNode 对象</li>
</ul>
<p><strong>为什么需要 id(node)</strong>：</p>
<ul>
<li>ListNode 没有定义大小比较，直接比较会抛出 TypeError</li>
<li><code>id()</code> 返回对象的唯一标识符，可以进行比较</li>
<li>保证元组能比较出大小，避免直接比较 ListNode</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log K)，其中 N 是所有节点总数，K 是链表个数</li>
<li><strong>空间复杂度</strong>：O(K)，堆中最多存储 K 个节点<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="合并k个有序链表-复杂度分析"></li>
</ul>
<h2 id="问题二：最多线段重合问题"><a href="#问题二：最多线段重合问题" class="headerlink" title="问题二：最多线段重合问题"></a>问题二：最多线段重合问题</h2><p><strong>测试链接</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37">https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/">https://leetcode.cn/problems/meeting-rooms-ii/</a></li>
</ul>
<h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定n条线段，每条线段有起点和终点，求最多同时重合的线段数量。</p>
<h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用<strong>扫描线算法 + 小根堆</strong>：</p>
<ol>
<li><strong>排序</strong>：将所有线段按起点排序</li>
<li><strong>扫描</strong>：从左到右处理每条线段</li>
<li><strong>维护堆</strong>：堆中存储当前重合线段的结束时间</li>
<li><strong>清理</strong>：移除已结束的线段（结束点 ≤ 当前起点）</li>
<li><strong>更新</strong>：添加当前线段，更新最大重合数</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E6%9C%80%E5%A4%A7%E9%87%8D%E5%90%88%E7%BA%BF%E6%AE%B5%E6%95%B0.png" alt="最大重合线段数"></p>
<h3 id="核心实现-1"><a href="#核心实现-1" class="headerlink" title="核心实现"></a>核心实现</h3><ul>
<li><p>想象每条线段根据开始和结束位置，放在x轴上，然后有一根竖线，从左到右划过x轴，竖线压中的线段上的点，就需要把当前点放入到某个组里。</p>
</li>
<li><p>请问，从左到右划的过程，你最多需要准备几个组？最多重合几条线段，就需要几个组。这些组不断复用空间，放入不同的点。但是最大重合了多少，你就需要准备几个组。</p>
</li>
<li><p><strong>重要</strong>：我之前一直在纠结为什么不要考虑后面重复合并， 但是我们这个代码已经考虑了后面重复合并，因为我们是把结束点加入到堆里，而不是把线段加入到堆里。因此即便这条线段的结束点和后面的线段的开始点重合，我们也会把这条线段的结束点加入到堆里，则以这个为标准对数轴进行扫描，又因为小根堆是根据开始点进行从小大排序的，所以能够保证后面的线段初始点严格小于当前线段的初始点，不会忽略到后面的线段重合，这个是个离散的逐点扫描的过程。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # 时间复杂度：O(NlogN) ，n条线段，平均比较次数是logN，所以是O(NlogN)</span></span><br><span class="line"><span class="string">    # 空间复杂度：O(N)，因为需要存储每条线段的结束点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    size = <span class="number">0</span>  <span class="comment"># 堆的清空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 所有线段根据开始位置排序</span></span><br><span class="line">    sorted_lines = <span class="built_in">sorted</span>(line[:n], key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 最大重合数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 步骤1：清理已结束的线段</span></span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span> <span class="keyword">and</span> heap[<span class="number">0</span>] &lt;= sorted_lines[i][<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># 堆顶是最早结束的线段</span></span><br><span class="line">            <span class="comment"># 如果它的结束点 ≤ 当前线段的起点，说明已经不重合了</span></span><br><span class="line">            pop()  <span class="comment"># 移除这个已结束的线段</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2：加入当前线段</span></span><br><span class="line">        add(sorted_lines[i][<span class="number">1</span>])  <span class="comment"># 把当前线段的结束点加入堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3：更新答案</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, size)  <span class="comment"># 当前堆的大小 = 当前重合的线段数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法可视化"><a href="#算法可视化" class="headerlink" title="算法可视化"></a>算法可视化</h3><p>想象一根竖线从左到右扫过数轴：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线段1: |-------|</span><br><span class="line">线段2:    |-----|</span><br><span class="line">线段3:      |---|</span><br><span class="line">线段4:        |-----|</span><br><span class="line"></span><br><span class="line">扫描过程：</span><br><span class="line">时刻1: |          重合数 = 1</span><br><span class="line">时刻2:   |        重合数 = 2  </span><br><span class="line">时刻3:     |      重合数 = 3 (最大值)</span><br><span class="line">时刻4:       |    重合数 = 2</span><br></pre></td></tr></table></figure>

<h3 id="手写堆实现"><a href="#手写堆实现" class="headerlink" title="手写堆实现"></a>手写堆实现</h3><p>为了提高效率，使用数组实现小根堆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">10001</span></span><br><span class="line">heap = [<span class="number">0</span>] * MAXN  <span class="comment"># 存储结束点</span></span><br><span class="line">size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    heap[size] = x</span><br><span class="line">    i = size</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 上浮调整</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> heap[i] &lt; heap[(i - <span class="number">1</span>) // <span class="number">2</span>]:</span><br><span class="line">        swap(i, (i - <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        i = (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>():</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">    size -= <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 下沉调整</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:</span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> l + <span class="number">1</span> &lt; size <span class="keyword">and</span> heap[l + <span class="number">1</span>] &lt; heap[l] <span class="keyword">else</span> l</span><br><span class="line">        best = best <span class="keyword">if</span> heap[best] &lt; heap[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(i, best)</span><br><span class="line">        i = best</span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    heap[i], heap[j] = heap[j], heap[i]</span><br></pre></td></tr></table></figure>

<h3 id="变种问题"><a href="#变种问题" class="headerlink" title="变种问题"></a>变种问题</h3><h4 id="会议室问题"><a href="#会议室问题" class="headerlink" title="会议室问题"></a>会议室问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minMeetingRooms</span>(<span class="params">meeting</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(meeting)</span><br><span class="line">    meeting.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  <span class="comment"># 按起始时间排序</span></span><br><span class="line">    heap = []  <span class="comment"># 小根堆，会议的结束时间</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> heap[<span class="number">0</span>] &lt;= meeting[i][<span class="number">0</span>]:  <span class="comment"># 堆顶会议已结束</span></span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        heapq.heappush(heap, meeting[i][<span class="number">1</span>])      <span class="comment"># 当前会议结束时间入堆</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(heap))                <span class="comment"># 记录最大会议室数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minGroups</span>(<span class="params">meeting</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(meeting)</span><br><span class="line">    meeting.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    heap = []</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> heap[<span class="number">0</span>] &lt; meeting[i][<span class="number">0</span>]:  <span class="comment"># 注意此处是 &lt;，题意不同</span></span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        heapq.heappush(heap, meeting[i][<span class="number">1</span>])</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(heap))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p><strong>关键区别</strong>：会议室问题用 <code>&lt;=</code>（会议可以无缝衔接），分组问题用 <code>&lt;</code>（需要间隔）。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log N)，排序 + 每个元素平均 log N 次堆操作</li>
<li><strong>空间复杂度</strong>：O(N)，存储线段结束点的堆</li>
</ul>
<h2 id="问题三：将数组和减半的最少操作次数"><a href="#问题三：将数组和减半的最少操作次数" class="headerlink" title="问题三：将数组和减半的最少操作次数"></a>问题三：将数组和减半的最少操作次数</h2><p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/">https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/</a></p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组，每次操作可以将任意一个元素减半，求使数组总和减少到原来一半所需的最少操作次数。</p>
<h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用<strong>贪心策略 + 大根堆</strong>：</p>
<ol>
<li><strong>贪心原理</strong>：每次选择当前最大的元素进行减半，减少量最大</li>
<li><strong>堆维护</strong>：用大根堆维护当前所有元素</li>
<li><strong>操作过程</strong>：不断取出最大元素减半，直到总减少量达到目标</li>
</ol>
<h3 id="方法一：基于-heapq"><a href="#方法一：基于-heapq" class="headerlink" title="方法一：基于 heapq"></a>方法一：基于 heapq</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">halveArray1</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 大根堆（用负数模拟）</span></span><br><span class="line">    heap = []</span><br><span class="line">    sum_val = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        heapq.heappush(heap, -<span class="built_in">float</span>(num))  <span class="comment"># 负数模拟大根堆</span></span><br><span class="line">        sum_val += num</span><br><span class="line">    </span><br><span class="line">    sum_val /= <span class="number">2</span>  <span class="comment"># 要减少到总和一半</span></span><br><span class="line">    ans = <span class="number">0</span>       <span class="comment"># 操作次数</span></span><br><span class="line">    minus = <span class="number">0</span>     <span class="comment"># 已减少的和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> minus &lt; sum_val:</span><br><span class="line">        cur = -heapq.heappop(heap) / <span class="number">2</span>  <span class="comment"># 取出最大数、减半</span></span><br><span class="line">        heapq.heappush(heap, -cur)      <span class="comment"># 新值放回堆</span></span><br><span class="line">        minus += cur                    <span class="comment"># 记录减少量</span></span><br><span class="line">        ans += <span class="number">1</span>                        <span class="comment"># 操作次数加1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="方法二：手写堆-精度优化"><a href="#方法二：手写堆-精度优化" class="headerlink" title="方法二：手写堆 + 精度优化"></a>方法二：手写堆 + 精度优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">heap_arr = [<span class="number">0</span>] * MAXN</span><br><span class="line">size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">halveArray2</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    size = <span class="built_in">len</span>(nums)</span><br><span class="line">    sum_val = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化大根堆，左移20位保证精度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heap_arr[i] = <span class="built_in">int</span>(nums[i]) &lt;&lt; <span class="number">20</span>  <span class="comment"># 左移20位放大</span></span><br><span class="line">        sum_val += heap_arr[i]</span><br><span class="line">        heapify(i)  <span class="comment"># 调整堆</span></span><br><span class="line">    </span><br><span class="line">    sum_val //= <span class="number">2</span>  <span class="comment"># 目标减少量</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    minus = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> minus &lt; sum_val:</span><br><span class="line">        heap_arr[<span class="number">0</span>] //= <span class="number">2</span>    <span class="comment"># 堆顶减半</span></span><br><span class="line">        minus += heap_arr[<span class="number">0</span>]</span><br><span class="line">        heapify(<span class="number">0</span>)</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:</span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> l + <span class="number">1</span> &lt; size <span class="keyword">and</span> heap_arr[l + <span class="number">1</span>] &gt; heap_arr[l] <span class="keyword">else</span> l</span><br><span class="line">        best = best <span class="keyword">if</span> heap_arr[best] &gt; heap_arr[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(best, i)</span><br><span class="line">        i = best</span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    heap_arr[i], heap_arr[j] = heap_arr[j], heap_arr[i]</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E7%BB%BC%E5%90%88%E5%87%8F%E5%B0%91%E4%B8%80%E5%8D%8A%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95.png" alt="综合减少一半最少操作-优化方法"></p>
<h3 id="关键优化技术"><a href="#关键优化技术" class="headerlink" title="关键优化技术"></a>关键优化技术</h3><h4 id="精度处理"><a href="#精度处理" class="headerlink" title="精度处理"></a>精度处理</h4><p><strong>问题</strong>：浮点数运算有精度损失，可能导致结果错误</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>将所有数左移20位（乘以 2²⁰）</li>
<li>用整数运算模拟浮点数运算</li>
<li><code>int(32位) × 2²⁰ &lt; long(64位)</code>，不会溢出</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>手写堆 vs heapq</strong>：</p>
<ul>
<li>heapq 基于 Python 列表，有额外开销</li>
<li>手写数组堆效率更高，常数因子更小</li>
</ul>
<h3 id="算法正确性证明"><a href="#算法正确性证明" class="headerlink" title="算法正确性证明"></a>算法正确性证明</h3><p><strong>贪心策略的正确性</strong>：</p>
<ul>
<li>每次选择最大元素减半，获得的减少量最大</li>
<li>假设最优解不是每次选最大元素，可以证明交换操作不会使结果变差</li>
<li>因此贪心策略能得到最优解</li>
</ul>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log N)，每个元素最多被操作 log(max_value) 次。若傻傻地每个元素都缩1&#x2F;2，一定能达成目标；显然操作的元素个数一定小于n</li>
<li><strong>空间复杂度</strong>：O(N)，存储堆的空间</li>
</ul>
<h2 id="堆结构应用总结"><a href="#堆结构应用总结" class="headerlink" title="堆结构应用总结"></a>堆结构应用总结</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><table>
<thead>
<tr>
<th>问题类型</th>
<th>堆类型</th>
<th>核心思想</th>
<th>典型例题</th>
</tr>
</thead>
<tbody><tr>
<td>合并有序序列</td>
<td>小根堆</td>
<td>维护多个序列的当前最小值</td>
<td>合并K个有序链表</td>
</tr>
<tr>
<td>区间重合问题</td>
<td>小根堆</td>
<td>扫描线 + 维护结束时间</td>
<td>最多线段重合</td>
</tr>
<tr>
<td>贪心选择</td>
<td>大根堆</td>
<td>每次选择当前最值进行操作</td>
<td>数组和减半</td>
</tr>
<tr>
<td>Top-K问题</td>
<td>小根堆</td>
<td>维护K个最大值</td>
<td>第K大元素</td>
</tr>
<tr>
<td>任务调度</td>
<td>小根堆</td>
<td>按优先级处理任务</td>
<td>CPU任务调度</td>
</tr>
</tbody></table>
<h3 id="实现选择"><a href="#实现选择" class="headerlink" title="实现选择"></a>实现选择</h3><table>
<thead>
<tr>
<th>情况</th>
<th>推荐实现</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>原型开发</td>
<td>heapq</td>
<td>简单易用，标准库</td>
</tr>
<tr>
<td>性能要求高</td>
<td>手写堆</td>
<td>效率更高，常数因子小</td>
</tr>
<tr>
<td>需要大根堆</td>
<td>负数技巧</td>
<td>Python只有小根堆</td>
</tr>
<tr>
<td>精度要求高</td>
<td>整数模拟</td>
<td>避免浮点数误差</td>
</tr>
</tbody></table>
<h3 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h3><ol>
<li><strong>对象比较问题</strong>：自定义对象作为堆元素时，需要实现比较方法或使用包装</li>
<li><strong>精度问题</strong>：浮点数运算可能有误差，关键场合使用整数</li>
<li><strong>堆类型混淆</strong>：Python默认小根堆，大根堆需要取负数</li>
<li><strong>边界条件</strong>：空堆操作、单元素情况需要特殊处理</li>
</ol>
<h3 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><ol>
<li><strong>预分配空间</strong>：手写堆时预分配数组空间</li>
<li><strong>避免频繁内存操作</strong>：使用数组而非动态列表</li>
<li><strong>批量操作</strong>：<code>heapify</code> 比逐个插入效率高</li>
<li><strong>精度与性能平衡</strong>：根据需求选择合适的数据类型</li>
</ol>
<p>堆结构是解决很多算法问题的重要工具，在实际使用中，要根据具体问题选择合适的实现方式和优化策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89-%20%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F&%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89-%20%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F&%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（7）- 随机排序&随机选择算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-07 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-07T08:42:46+08:00">2025-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-10 14:32:18" itemprop="dateModified" datetime="2025-08-10T14:32:18+08:00">2025-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了随机快速排序和随机选择算法的原理与实现，涵盖了荷兰国旗问题优化、时间复杂度分析等内容，包括了class023 -&gt; class024的内容</p>
<h1 id="023【必备】随机快速排序"><a href="#023【必备】随机快速排序" class="headerlink" title="023【必备】随机快速排序"></a>023【必备】随机快速排序</h1><h2 id="快速排序的基本思想"><a href="#快速排序的基本思想" class="headerlink" title="快速排序的基本思想"></a>快速排序的基本思想</h2><p>快速排序是一种高效的分治排序算法，其核心思想是：</p>
<ol>
<li><strong>选择基准元素（pivot）</strong>：从数组中选择一个元素作为基准值pivot</li>
<li><strong>数组划分</strong>：将数组重新排列，使得所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面</li>
<li><strong>递归排序</strong>：对基准值两侧的子数组递归地应用快速排序</li>
</ol>
<h2 id="随机化的重要性"><a href="#随机化的重要性" class="headerlink" title="随机化的重要性"></a>随机化的重要性</h2><p><strong>为什么需要随机化？</strong></p>
<ul>
<li><strong>普通快速排序</strong>：固定选择位置（如最右元素）作为基准，最坏情况时间复杂度为O(n²)</li>
<li><strong>随机快速排序</strong>：随机选择基准元素，期望时间复杂度为O(n log n)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机选择基准元素是关键</span></span><br><span class="line">x = arr[random.randint(l, r)]  <span class="comment"># 在[l,r]范围内随机选择</span></span><br></pre></td></tr></table></figure>


<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<h2 id="经典快速排序实现（不推荐）"><a href="#经典快速排序实现（不推荐）" class="headerlink" title="经典快速排序实现（不推荐）"></a>经典快速排序实现（不推荐）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort1</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="comment"># l == r，只有一个数</span></span><br><span class="line">    <span class="comment"># l &gt; r，范围不存在，不用管</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 随机这一下，常数时间比较大</span></span><br><span class="line">    <span class="comment"># 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">    <span class="comment"># l......r 随机选一个位置，x这个值，做划分</span></span><br><span class="line">    x = arr[random.randint(l, r)]</span><br><span class="line">    mid = partition1(l, r, x) <span class="comment">#会返回x的下标即index</span></span><br><span class="line">    quickSort1(l, mid - <span class="number">1</span>)</span><br><span class="line">    quickSort1(mid + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"><span class="comment"># 划分数组 &lt;=x放左边，&gt;x放右边</span></span><br><span class="line"><span class="comment"># 并且确保划分完成后&lt;=x区域的最后一个数字是x</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition1</span>(<span class="params">l, r, x</span>):</span><br><span class="line">    <span class="comment"># a : arr[l....a-1]范围是&lt;=x的区域</span></span><br><span class="line">    <span class="comment"># xi : 记录在&lt;=x的区域上任何一个x的位置，哪一个都可以</span></span><br><span class="line">    a = l            <span class="comment"># 初始化指针a，表示&lt;=x区域的右边界，初值为l</span></span><br><span class="line">    xi = <span class="number">0</span>           <span class="comment"># 初始化xi，用于记录&lt;=x区域内某一个x的位置（后面需要与a-1交换）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):   <span class="comment"># 从l遍历到r，依次考察每个元素，每一步都会i++（重要，所以这里的代码没有显式写i++）</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= x:         <span class="comment"># 如果当前元素小于等于x</span></span><br><span class="line">            swap(a, i)          <span class="comment"># 把当前元素交换到a位置（即&lt;=x区的后面）</span></span><br><span class="line">            <span class="keyword">if</span> arr[a] == x:     <span class="comment"># 如果新放到a位置的元素等于x</span></span><br><span class="line">                xi = a          <span class="comment"># 记录下这个位置为xi</span></span><br><span class="line">            a += <span class="number">1</span>              <span class="comment"># &lt;=x区往右扩展一位</span></span><br><span class="line">    swap(xi, a - <span class="number">1</span>)             <span class="comment"># 把&lt;=x区域里某个x与区域最后一个元素交换，保证x落在最后</span></span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>                <span class="comment"># 返回&lt;=x区域的最后一个下标（即x最终所在的位置）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    tmp = arr[i]        <span class="comment"># 先把arr[i]暂存到tmp</span></span><br><span class="line">    arr[i] = arr[j]     <span class="comment"># arr[i]赋值为arr[j]</span></span><br><span class="line">    arr[j] = tmp        <span class="comment"># arr[j]赋值为tmp，实现arr[i]和arr[j]交换</span></span><br></pre></td></tr></table></figure>

<p><strong>经典版本的问题</strong>：</p>
<ul>
<li>经典快排每次只排掉一个等于pivot的元素，重复元素多时递归深度大，容易爆栈突变为，pivot 只确定了它自己的最终位置，如果有很多元素等于 pivot，只有一个会归位，剩下的还在“乱序”的子区间里。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(7)/class23-%E9%9A%8F%E6%9C%BA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/partition%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3-%E7%BB%8F%E5%85%B8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="partition函数理解-经典快速排序"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(7)/class23-%E9%9A%8F%E6%9C%BA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/partition%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3-%E6%94%B9%E8%BF%9B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="partition函数理解-改进快速排序"></p>
<h2 id="荷兰国旗问题优化版（推荐）"><a href="#荷兰国旗问题优化版（推荐）" class="headerlink" title="荷兰国旗问题优化版（推荐）"></a>荷兰国旗问题优化版（推荐）</h2><p>荷兰国旗问题是快速排序的重要优化，将数组分为三个区域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[小于x的区域] [等于x的区域] [大于x的区域]</span><br></pre></td></tr></table></figure>
<p>能够一次处理所有等于pivot的元素，递归层数大大降低，所以不会爆栈，每次把所有等于pivot的数都一次性放到中间，只对小于和大于pivot的区间递归</p>
<h3 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h3><ol>
<li><strong>一次性处理所有相等元素</strong>：将所有等于pivot的元素都放到正确位置</li>
<li><strong>减少递归层数</strong>：只需要对小于和大于pivot的区域递归</li>
<li><strong>避免栈溢出</strong>：特别适合处理有大量重复元素的数组</li>
</ol>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort2</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 随机这一下，常数时间比较大</span></span><br><span class="line">    <span class="comment"># 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">    x = arr[random.randint(l, r)]</span><br><span class="line">    partition2(l, r, x)</span><br><span class="line">    <span class="comment"># 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">    <span class="comment"># 这里用临时变量记录first、last</span></span><br><span class="line">    left = first[<span class="number">0</span>]</span><br><span class="line">    right = last[<span class="number">0</span>]</span><br><span class="line">    quickSort2(l, left - <span class="number">1</span>)</span><br><span class="line">    quickSort2(right + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 荷兰国旗问题</span></span><br><span class="line">first = [<span class="number">0</span>]  <span class="comment"># 用list模拟全局变量</span></span><br><span class="line">last = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"><span class="comment"># 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line"><span class="comment"># 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition2</span>(<span class="params">l, r, x</span>):</span><br><span class="line">    first[<span class="number">0</span>] = l</span><br><span class="line">    last[<span class="number">0</span>] = r</span><br><span class="line">    i = l</span><br><span class="line">    <span class="keyword">while</span> i &lt;= last[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> arr[i] == x:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[i] &lt; x:</span><br><span class="line">            swap(first[<span class="number">0</span>], i)</span><br><span class="line">            first[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            swap(i, last[<span class="number">0</span>])</span><br><span class="line">            last[<span class="number">0</span>] -= <span class="number">1</span> <span class="comment">#i不变的原因是交换后 i 位置上的新元素还没考察过</span></span><br><span class="line"><span class="comment">#前两种情况i++的原因是x作为基准，在i位置上，顶着左边区域向右推进，此外快速排序算法不需要随机元素的index</span></span><br></pre></td></tr></table></figure>

<h3 id="荷兰国旗问题详细演示"><a href="#荷兰国旗问题详细演示" class="headerlink" title="荷兰国旗问题详细演示"></a>荷兰国旗问题详细演示</h3><p>以数组 <code>[7, 2, 6, 3, 1, 5, 4]</code>，pivot&#x3D;3 为例：</p>
<p><strong>初始状态</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [7, 2, 6, 3, 1, 5, 4]</span><br><span class="line">first = 0, last = 6, i = 0</span><br></pre></td></tr></table></figure>

<p><strong>Step 1</strong>：<code>arr[0] = 7 &gt; 3</code></p>
<ul>
<li>与 <code>arr[6]</code> 交换：<code>[4, 2, 6, 3, 1, 5, 7]</code></li>
<li><code>last = 5</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 2</strong>：<code>arr[0] = 4 &gt; 3</code></p>
<ul>
<li>与 <code>arr[5]</code> 交换：<code>[5, 2, 6, 3, 1, 4, 7]</code></li>
<li><code>last = 4</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 3</strong>：<code>arr[0] = 5 &gt; 3</code></p>
<ul>
<li>与 <code>arr[4]</code> 交换：<code>[1, 2, 6, 3, 5, 4, 7]</code></li>
<li><code>last = 3</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 4</strong>：<code>arr[0] = 1 &lt; 3</code></p>
<ul>
<li>与 <code>arr[0]</code> 交换（自己）：不变</li>
<li><code>first = 1</code>，<code>i = 1</code></li>
</ul>
<p><strong>Step 5</strong>：<code>arr[1] = 2 &lt; 3</code></p>
<ul>
<li>与 <code>arr[1]</code> 交换（自己）：不变</li>
<li><code>first = 2</code>，<code>i = 2</code></li>
</ul>
<p><strong>Step 6</strong>：<code>arr[2] = 6 &gt; 3</code></p>
<ul>
<li>与 <code>arr[3]</code> 交换：<code>[1, 2, 3, 6, 5, 4, 7]</code></li>
<li><code>last = 2</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 7</strong>：<code>arr[2] = 3 == 3</code></p>
<ul>
<li><code>i = 3</code>，此时 <code>i &gt; last</code>，循环结束</li>
</ul>
<p><strong>最终结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [1, 2, 3, 6, 5, 4, 7]</span><br><span class="line">[0, 1]: 小于3的区域 [1, 2]</span><br><span class="line">[2, 2]: 等于3的区域 [3]</span><br><span class="line">[3, 6]: 大于3的区域 [6, 5, 4, 7]</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="随机快速排序的复杂度"><a href="#随机快速排序的复杂度" class="headerlink" title="随机快速排序的复杂度"></a>随机快速排序的复杂度</h3><p><strong>时间复杂度：O(n log n)</strong> （期望）</p>
<ul>
<li>每层的划分操作需要O(n)时间</li>
<li>随机选择使得平均递归深度为O(log n)</li>
<li>总时间复杂度：O(n) × O(log n) &#x3D; O(n log n)</li>
</ul>
<p><strong>空间复杂度：O(log n)</strong> （期望）</p>
<ul>
<li>来自递归调用栈的深度</li>
<li>最好情况：每次平分，深度为O(log n)</li>
<li>最坏情况：退化为链式递归，深度为O(n)</li>
</ul>
<h3 id="与普通快速排序对比"><a href="#与普通快速排序对比" class="headerlink" title="与普通快速排序对比"></a>与普通快速排序对比</h3><p><strong>普通快速排序</strong></p>
<ul>
<li>普通快速排序的时间复杂度O(n^2)：固定流程考虑最坏情况（极端不平衡，每次都选到最小或最大元素为主元），每次只能划分出一个元素，剩下的 n-1 继续递归；额外空间复杂度O(n)取得是最坏情况递归的栈的深度。</li>
<li>最好情况：T(n) &#x3D; 2 * T(n&#x2F;2) + O(n) &#x3D; O(n * logn),空间是O(logn)取得是递归的栈的深度。</li>
<li>因为固定流程的话，可以构造出特定的数据，导致每次固定取最右最左的元素都是最差情况。</li>
</ul>
<p><strong>随机快速排序</strong></p>
<ul>
<li>随机快速排序，时间复杂度O(n * logn)随机取得是期望理论上每次能比较均匀划分为两半，递归深度约为 log𝑛，每一层的划分操作需要 O(n) 时间。额外空间复杂度O(logn)取得是递归的栈的深度，运气好每次都是区间二分，参考中序二叉树</li>
<li>取期望，每个位置取1&#x2F;N的权重，最后能证明期望时间复杂度是O(n * logn)，额外空间复杂度O(logn)</li>
<li>关于复杂度的分析，进行定性的说明，定量证明略，因为证明较为复杂，算法导论-7.4.2有详细证明</li>
</ul>
<table>
<thead>
<tr>
<th>算法类型</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>空间复杂度（平均）</th>
<th>空间复杂度（最坏）</th>
</tr>
</thead>
<tbody><tr>
<td>普通快排</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>随机快排</td>
<td>O(n log n)</td>
<td>O(n log n)*</td>
<td>O(log n)</td>
<td>O(log n)*</td>
</tr>
</tbody></table>
<p>*期望意义下</p>
<h1 id="024【必备】随机选择算法"><a href="#024【必备】随机选择算法" class="headerlink" title="024【必备】随机选择算法"></a>024【必备】随机选择算法</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>无序数组中第K大的元素问题</strong>：</p>
<ul>
<li>给定整数数组 <code>nums</code> 和整数 <code>k</code></li>
<li>返回数组中第 <code>k</code> 个最大的元素</li>
<li>要求时间复杂度为 O(n)</li>
</ul>
<p><strong>关键转换</strong>：第K大 &#x3D; 第(len-k)小（python中）。事实上，若下标从0开始时，第K大等于第(len-k)小（即下标为len-k的元素）；如果下标从1开始，则用len+1-k</p>
<h2 id="随机选择算法原理"><a href="#随机选择算法原理" class="headerlink" title="随机选择算法原理"></a>随机选择算法原理</h2><p>随机选择算法是快速排序的变种，核心思想：</p>
<ol>
<li><strong>只关心目标位置</strong>：不需要完全排序，只需要找到第K大的元素</li>
<li><strong>单侧递归</strong>：每次只需要在包含目标位置的一侧继续查找</li>
<li><strong>随机化优化</strong>：通过随机选择pivot避免最坏情况</li>
</ol>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSelect</span>:</span><br><span class="line">    first = <span class="number">0</span>  <span class="comment"># 等于区域的左边界</span></span><br><span class="line">    last = <span class="number">0</span>   <span class="comment"># 等于区域的右边界</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找第K大元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 转换为找第(len-k)小的元素</span></span><br><span class="line">        <span class="keyword">return</span> RandomizedSelect.randomizedSelect(nums, <span class="built_in">len</span>(nums) - k)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomizedSelect</span>(<span class="params">arr, i</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        连递归都没用，所以时间复杂度是O(n)左右的量级</span></span><br><span class="line"><span class="string">        在数组中找到如果排序后在位置i的元素</span></span><br><span class="line"><span class="string">        时间复杂度：O(n)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:<span class="comment">#不断二分的过程中，l和r上是仍然有范围的，直到没有范围才终止</span></span><br><span class="line">            <span class="comment"># 随机这一下，常数时间比较大</span></span><br><span class="line">            <span class="comment"># 但只有这一下随机，才能在概率上把时间复杂度收敛到O(n)</span></span><br><span class="line">            pivot = arr[l + <span class="built_in">int</span>(random.random() * (r - l + <span class="number">1</span>))]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用荷兰国旗问题进行划分</span></span><br><span class="line">            RandomizedSelect.partition(arr, l, r, pivot)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 因为左右两侧只需要走一侧</span></span><br><span class="line">            <span class="comment"># 所以不需要临时变量记录全局的first、last，直接用即可</span></span><br><span class="line">            <span class="comment"># 等于的区域即first，last包住的位置，i小于first则去左侧，i大于last则去右侧</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; RandomizedSelect.first:</span><br><span class="line">                r = RandomizedSelect.first - <span class="number">1</span>  <span class="comment"># 目标在左侧，pivot左边变成r</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; RandomizedSelect.last:</span><br><span class="line">                l = RandomizedSelect.last + <span class="number">1</span>   <span class="comment"># 目标在右侧，pivot右边变成l</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = arr[i]  <span class="comment"># 找到目标</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, l, r, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;荷兰国旗问题划分&quot;&quot;&quot;</span></span><br><span class="line">        RandomizedSelect.first = l</span><br><span class="line">        RandomizedSelect.last = r</span><br><span class="line">        i = l</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt;= RandomizedSelect.last:</span><br><span class="line">            <span class="keyword">if</span> arr[i] == x:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i] &lt; x:</span><br><span class="line">                RandomizedSelect.swap(arr, RandomizedSelect.first, i)</span><br><span class="line">                RandomizedSelect.first += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                RandomizedSelect.swap(arr, i, RandomizedSelect.last)</span><br><span class="line">                RandomizedSelect.last -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;交换数组元素&quot;&quot;&quot;</span></span><br><span class="line">        arr[i], arr[j] = arr[j], arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="算法执行示例"><a href="#算法执行示例" class="headerlink" title="算法执行示例"></a>算法执行示例</h2><p>以数组 <code>[7, 2, 6, 3, 1, 5, 4]</code>，查找第4小元素（下标为3）为例：</p>
<p><strong>第一轮</strong>：</p>
<ul>
<li>随机选择 <code>pivot = 3</code></li>
<li>划分后：<code>[1, 2, 3, 6, 5, 4, 7]</code></li>
<li>等于区域：<code>first = 2, last = 2</code></li>
<li>目标下标3 &gt; last&#x3D;2，继续在右侧 <code>[6, 5, 4, 7]</code> 查找</li>
</ul>
<p><strong>第二轮</strong>：</p>
<ul>
<li>在右侧区域随机选择 <code>pivot = 4</code></li>
<li>划分后相对位置：<code>[4, 5, 6, 7]</code>（实际在原数组的3,4,5,6位置）</li>
<li>等于区域：<code>first = 3, last = 3</code></li>
<li>目标下标3 &#x3D;&#x3D; first &#x3D;&#x3D; last，找到答案 <code>arr[3] = 4</code></li>
</ul>
<h2 id="时间复杂度证明（定性分析）"><a href="#时间复杂度证明（定性分析）" class="headerlink" title="时间复杂度证明（定性分析）"></a>时间复杂度证明（定性分析）</h2><p><strong>为什么是O(n)？</strong></p>
<p>每次划分后，下一次只需要处理一侧的数据：</p>
<ul>
<li>第一次处理：n个元素</li>
<li>第二次处理：n&#x2F;2个元素（期望）</li>
<li>第三次处理：n&#x2F;4个元素（期望）</li>
<li>…</li>
</ul>
<p>总时间：<code>n + n/2 + n/4 + n/8 + ... ≈ 2n</code></p>
<p>因此期望时间复杂度为 <strong>O(n)</strong>。</p>
<h2 id="与其他算法的比较"><a href="#与其他算法的比较" class="headerlink" title="与其他算法的比较"></a>与其他算法的比较</h2><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>完全排序</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>简单但过度</td>
</tr>
<tr>
<td>堆排序K次</td>
<td>O(n + k log n)</td>
<td>O(1)</td>
<td>适合K很小的情况</td>
</tr>
<tr>
<td>随机选择</td>
<td>O(n)</td>
<td>O(1)</td>
<td>最优解</td>
</tr>
<tr>
<td>BFPRT算法</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>理论最优但常数大</td>
</tr>
</tbody></table>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ol>
<li><strong>Top-K问题</strong>：找出数组中最大&#x2F;最小的K个元素</li>
<li><strong>中位数查找</strong>：快速找到数组的中位数</li>
<li><strong>分位数计算</strong>：统计学中的百分位数计算</li>
<li><strong>数据分析</strong>：快速找到数据集中的特定排名元素</li>
</ol>
<h3 id="关键要点总结"><a href="#关键要点总结" class="headerlink" title="关键要点总结"></a>关键要点总结</h3><ol>
<li><p><strong>随机化的重要性</strong>：</p>
<ul>
<li>避免最坏情况的发生</li>
<li>使算法在期望意义下达到最优复杂度</li>
</ul>
</li>
<li><p><strong>荷兰国旗问题的优势</strong>：</p>
<ul>
<li>一次性处理所有相等元素</li>
<li>减少递归&#x2F;迭代次数</li>
<li>提高算法稳定性</li>
</ul>
</li>
<li><p><strong>单侧处理的效率</strong>：</p>
<ul>
<li>与完全排序不同，只需要处理包含目标的一侧</li>
<li>大大减少了计算量</li>
</ul>
</li>
<li><p><strong>工程实践建议</strong>：</p>
<ul>
<li>对于一般规模的数据，随机选择算法是首选</li>
<li>当需要多次查询不同K值时，可以考虑先排序</li>
<li>在对稳定性要求极高的场合，可以考虑BFPRT算法</li>
</ul>
</li>
</ol>
<p>这两个算法（随机快速排序和随机选择）是分治算法的经典应用，展示了随机化在算法设计中的重要作用。掌握这些算法不仅有助于解决实际问题，也为理解更复杂的分治算法奠定了基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（6）- 递归、归并排序与归并分治</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-06 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-06T08:42:46+08:00">2025-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-07 14:18:07" itemprop="dateModified" datetime="2025-08-07T14:18:07+08:00">2025-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a>  </p>
<p>记录的是class020→class022，包括了递归的本质理解、Master公式的应用、归并排序的递归与非递归实现，以及归并分治思想在解决小和问题和翻转对问题中的应用。</p>
<h1 id="020【必备】递归和Master公式"><a href="#020【必备】递归和Master公式" class="headerlink" title="020【必备】递归和Master公式"></a>020【必备】递归和Master公式</h1><h2 id="递归的本质理解"><a href="#递归的本质理解" class="headerlink" title="递归的本质理解"></a>递归的本质理解</h2><h3 id="思想层面的递归"><a href="#思想层面的递归" class="headerlink" title="思想层面的递归"></a>思想层面的递归</h3><p>递归不是玄学，它是一种**”大事化小”**的思维方式。对于新手来说，<strong>画调用图</strong>是理解递归的关键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;给定一个数组，在arr[l...r]范围上，返回最大值&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> f(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arr, l, r</span>):</span><br><span class="line">    <span class="comment"># arr[l...r] 范围上的最大值</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="comment"># 递归基：当左右下标相等时，区间只有一个数，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[l]</span><br><span class="line">    m = (l + r) // <span class="number">2</span>  <span class="comment"># 找到中点</span></span><br><span class="line">    lmax = f(arr, l, m)        <span class="comment"># 递归求左半部分最大值</span></span><br><span class="line">    rmax = f(arr, m + <span class="number">1</span>, r)    <span class="comment"># 递归求右半部分最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(lmax, rmax)     <span class="comment"># 返回左右部分的最大值</span></span><br></pre></td></tr></table></figure>

<p><strong>递归的三个关键点</strong>：</p>
<ol>
<li><strong>明确递归要干什么</strong>：这里是”返回 arr[l…r] 的最大值”</li>
<li><strong>找递归的终止条件</strong>：这里是”l &#x3D;&#x3D; r”，即区间只有一个数  </li>
<li><strong>思考如何缩小规模</strong>：这里是分别递归处理左区间和右区间</li>
</ol>
<h3 id="实际层面的递归"><a href="#实际层面的递归" class="headerlink" title="实际层面的递归"></a>实际层面的递归</h3><p>递归底层利用<strong>系统栈</strong>来实现：</p>
<ul>
<li>当函数调用发生时，系统会将函数的状态（参数、局部变量、返回地址）压入栈中</li>
<li>当函数返回时，系统从栈中弹出状态，恢复到调用点继续执行</li>
<li>这个过程是<strong>可视化的</strong>，所以所有递归函数都可以改成非递归</li>
</ul>
<p><strong>递归改非递归的必要性</strong>：</p>
<ul>
<li><strong>工程实践</strong>：几乎一定要改，除非确定递归深度不会太大</li>
<li><strong>算法竞赛</strong>：能通过就不改，时间紧迫时优先保证正确性</li>
</ul>
<p><strong>形象比喻</strong>：</p>
<ul>
<li><strong>迭代</strong>像是擂台赛：一个个来，逐步解决</li>
<li><strong>递归</strong>像是季后赛：分组对战，逐层淘汰<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%AD%A5.png" alt="递归过程分步"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E9%80%92%E5%BD%92%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="递归时的数据结构"></li>
</ul>
<h2 id="Master公式详解"><a href="#Master公式详解" class="headerlink" title="Master公式详解"></a>Master公式详解</h2><p>Master公式用于分析<strong>分治算法</strong>的时间复杂度，适用于所有子问题规模相同的递归。</p>
<h3 id="公式形式"><a href="#公式形式" class="headerlink" title="公式形式"></a>公式形式</h3><p>$$T(n) &#x3D; a \times T(\frac{n}{b}) + O(n^c)$$</p>
<p>其中：</p>
<ul>
<li><strong>a</strong>：子问题被调用的次数</li>
<li><strong>b</strong>：子问题规模（数据量变为原来的1&#x2F;b）  </li>
<li><strong>c</strong>：除去子问题之外的时间复杂度指数</li>
</ul>
<h3 id="判断标准"><a href="#判断标准" class="headerlink" title="判断标准"></a>判断标准</h3><p>设 $\log_b(a) &#x3D; d$，则：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$d &lt; c$</td>
<td>$O(n^c)$</td>
<td>合并工作量占主导</td>
</tr>
<tr>
<td>$d &gt; c$</td>
<td>$O(n^d)$</td>
<td>递归调用占主导</td>
</tr>
<tr>
<td>$d &#x3D; c$</td>
<td>$O(n^c \log n)$</td>
<td>两者平衡</td>
</tr>
</tbody></table>
<h3 id="经典例子分析"><a href="#经典例子分析" class="headerlink" title="经典例子分析"></a>经典例子分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序：T(n) = 2*T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"># a=2, b=2, c=1</span></span><br><span class="line"><span class="comment"># log₂(2) = 1 = c，所以复杂度为 O(n*logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找：T(n) = 1*T(n/2) + O(1)  </span></span><br><span class="line"><span class="comment"># a=1, b=2, c=0</span></span><br><span class="line"><span class="comment"># log₂(1) = 0 = c，所以复杂度为 O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速排序最好情况：T(n) = 2*T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"># 结果同归并排序：O(n*logn)</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>对于 $T(n) &#x3D; 2 \times T(\frac{n}{2}) + O(n \log n)$：</p>
<ul>
<li>这不符合标准Master公式形式，结果是 $O(n \times (\log n)^2)$，需要特殊记忆，证明过程较复杂，这种递归式常见于“分治 + 合并时需要二分&#x2F;复杂统计”的问题，比如“翻转对”、“区间对统计”，主定理告知其复杂度为 $O(n \log^2 n)$</li>
</ul>
<h1 id="021【必备】归并排序"><a href="#021【必备】归并排序" class="headerlink" title="021【必备】归并排序"></a>021【必备】归并排序</h1><h2 id="归并排序原理"><a href="#归并排序原理" class="headerlink" title="归并排序原理"></a>归并排序原理</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li><strong>左部分排好序、右部分排好序</strong></li>
<li><strong>利用merge过程让左右整体有序</strong></li>
<li><strong>merge过程</strong>：谁小拷贝谁，直到左右两部分数字耗尽，拷贝回原数组</li>
</ol>
<h3 id="为什么归并排序比O-n²-排序快？"><a href="#为什么归并排序比O-n²-排序快？" class="headerlink" title="为什么归并排序比O(n²)排序快？"></a>为什么归并排序比O(n²)排序快？</h3><p><strong>比较行为没有浪费！</strong></p>
<p>对比三种原始排序（选择、冒泡、插入）：</p>
<ul>
<li>每次1到N-1次比较只能确定一个位置</li>
<li>大量比较工作被浪费，效率低下</li>
</ul>
<p>归并排序中：</p>
<ul>
<li>每次比较都有意义，用于合并两个有序序列</li>
<li>比较结果被充分利用，没有浪费</li>
<li>系统栈不会太深</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%88%E4%B8%8D%E4%BC%9A%E6%B7%B1.png" alt="归并排序的栈不会深"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%88%E4%B8%8D%E4%BC%9A%E6%B7%B12.png" alt="归并排序的栈不会深2"></p>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN      <span class="comment"># 原数组</span></span><br><span class="line">help_arr = [<span class="number">0</span>] * MAXN <span class="comment"># 辅助数组</span></span><br><span class="line">n = <span class="number">0</span>                 <span class="comment"># 数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort1</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序递归版</span></span><br><span class="line"><span class="string">    T(n) = 2 * T(n/2) + O(n)</span></span><br><span class="line"><span class="string">    根据master公式，时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    空间复杂度O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:  <span class="comment"># 递归终止条件：只剩一个元素</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    mergeSort1(l, m)      <span class="comment"># 递归排序左半部分</span></span><br><span class="line">    mergeSort1(m + <span class="number">1</span>, r)  <span class="comment"># 递归排序右半部分</span></span><br><span class="line">    merge(l, m, r)        <span class="comment"># 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个有序区间 arr[l...m] 和 arr[m+1...r]</span></span><br><span class="line"><span class="string">    时间复杂度O(n)，其中n = r - l + 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = l      <span class="comment"># help数组写指针</span></span><br><span class="line">    a = l      <span class="comment"># 左侧起始指针</span></span><br><span class="line">    b = m + <span class="number">1</span>  <span class="comment"># 右侧起始指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双指针合并过程</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b] </span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 写回原数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[i] = help_arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序非递归版</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)：外层循环O(logn)，内层归并O(n)</span></span><br><span class="line"><span class="string">    空间复杂度O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    step = <span class="number">1</span>  <span class="comment"># 步长初始化为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> step &lt; n:  <span class="comment"># 外层控制步长，共O(logn)次</span></span><br><span class="line">        l = <span class="number">0</span>  <span class="comment"># 每轮从左端开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt; n:  <span class="comment"># 内层处理每一组</span></span><br><span class="line">            m = l + step - <span class="number">1</span>      <span class="comment"># 计算中点</span></span><br><span class="line">            <span class="keyword">if</span> m + <span class="number">1</span> &gt;= n:        <span class="comment"># 右半部分越界，跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            r = <span class="built_in">min</span>(l + (step &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, n - <span class="number">1</span>)  <span class="comment"># 计算右边界</span></span><br><span class="line">            merge(l, m, r)        <span class="comment"># 合并</span></span><br><span class="line">            l = r + <span class="number">1</span>             <span class="comment"># 移动到下一组</span></span><br><span class="line">            </span><br><span class="line">        step &lt;&lt;= <span class="number">1</span>  <span class="comment"># 步长翻倍</span></span><br></pre></td></tr></table></figure>

<h3 id="非递归实现的核心思路"><a href="#非递归实现的核心思路" class="headerlink" title="非递归实现的核心思路"></a>非递归实现的核心思路</h3><ol>
<li><strong>step表示每次要合并的有序段长度</strong>，初始为1（每个元素自己是有序段）</li>
<li><strong>每一轮成对合并</strong>长度为step的有序段，合并成长度为2*step的有序段</li>
<li><strong>下一轮step翻倍</strong>，继续两两合并</li>
<li><strong>重复直到step &gt;&#x3D; n</strong>，整个数组有序</li>
</ol>
<p><strong>过程示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数组: [3, 8, 7, 6, 4, 5, 1, 2]</span><br><span class="line"></span><br><span class="line">step=1: [3,8] [6,7] [4,5] [1,2] → [3,8,6,7,4,5,1,2]</span><br><span class="line">step=2: [3,6,7,8] [1,2,4,5] → [3,6,7,8,1,2,4,5] </span><br><span class="line">step=4: [1,2,3,4,5,6,7,8] → [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure>

<h2 id="merge过程详解"><a href="#merge过程详解" class="headerlink" title="merge过程详解"></a>merge过程详解</h2><h3 id="双指针合并策略"><a href="#双指针合并策略" class="headerlink" title="双指针合并策略"></a>双指针合并策略</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并过程详解：</span></span><br><span class="line"><span class="string">    1. 双指针扫描：a指向左部分，b指向右部分</span></span><br><span class="line"><span class="string">    2. 比较合并：较小值写入help_arr，对应指针右移</span></span><br><span class="line"><span class="string">    3. 剩余处理：一边扫完后，另一边直接复制</span></span><br><span class="line"><span class="string">    4. 写回原数组：完成排序合并</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = l      <span class="comment"># help_arr写入位置</span></span><br><span class="line">    a = l      <span class="comment"># 左部分起点</span></span><br><span class="line">    b = m + <span class="number">1</span>  <span class="comment"># 右部分起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 两两比较，选择较小值</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余元素（必有一边先结束）</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-log-n"><a href="#时间复杂度：O-n-log-n" class="headerlink" title="时间复杂度：O(n log n)"></a>时间复杂度：O(n log n)</h3><ul>
<li><strong>递归层数</strong>：log₂(n)层，每次将问题规模减半</li>
<li><strong>每层工作量</strong>：O(n)，所有元素都要参与一次合并</li>
<li><strong>总复杂度</strong>：O(n) × O(log n) &#x3D; O(n log n)</li>
</ul>
<h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O(n)"></a>空间复杂度：O(n)</h3><ul>
<li><strong>辅助数组</strong>：需要与原数组等长的help_arr</li>
<li><strong>递归栈</strong>：最大深度O(log n)，但主要空间开销是辅助数组</li>
<li><strong>原地归并</strong>：理论上可以做到O(1)空间，但时间复杂度会退化到O(n²)</li>
</ul>
<h1 id="022【必备】归并分治"><a href="#022【必备】归并分治" class="headerlink" title="022【必备】归并分治"></a>022【必备】归并分治</h1><h2 id="归并分治的核心思想"><a href="#归并分治的核心思想" class="headerlink" title="归并分治的核心思想"></a>归并分治的核心思想</h2><p>归并分治是在归并排序基础上的拓展，用来解决更复杂的问题。</p>
<h3 id="应用条件判断"><a href="#应用条件判断" class="headerlink" title="应用条件判断"></a>应用条件判断</h3><p>一个问题能用归并分治解决，需要满足：</p>
<ol>
<li><strong>大范围答案 &#x3D; 左部分答案 + 右部分答案 + 跨越左右产生的答案</strong></li>
<li><strong>计算”跨越左右产生的答案”时，左右各自有序能带来计算便利性</strong></li>
<li><strong>如果以上两点成立，该问题很可能被归并分治解决</strong></li>
</ol>
<p><strong>求解过程</strong>：在归并排序过程中加入统计逻辑，利用左右有序的特性获得计算便利性。</p>
<h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定数组arr，对于每个位置i，求出其左边所有小于等于arr[i]的数的累加和，所有位置的累加和即为数组的”小和”。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组: [1, 3, 5, 2, 4, 6]</span><br><span class="line"></span><br><span class="line">位置0(1): 左边小于等于1的数 → 0</span><br><span class="line">位置1(3): 左边小于等于3的数 → 1  </span><br><span class="line">位置2(5): 左边小于等于5的数 → 1+3 = 4</span><br><span class="line">位置3(2): 左边小于等于2的数 → 1</span><br><span class="line">位置4(4): 左边小于等于4的数 → 1+3+2 = 6</span><br><span class="line">位置5(6): 左边小于等于6的数 → 1+3+5+2+4 = 15</span><br><span class="line"></span><br><span class="line">小和 = 0+1+4+1+6+15 = 27</span><br></pre></td></tr></table></figure>


<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class22-%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/%E5%88%86%E6%B2%BB%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8.png" alt="分治指针滑动"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class22-%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%E6%8B%86%E5%88%86%E6%88%90%E5%AD%90%E9%97%AE%E9%A2%98.png" alt="小和问题拆分成子问题"></p>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469">https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469</a></p>
<h3 id="归并分治解法"><a href="#归并分治解法" class="headerlink" title="归并分治解法"></a>归并分治解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">smallSum</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回arr[l...r]范围上小和的累加和，同时让arr[l..r]变有序</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 递归统计左右部分和跨区部分的小和</span></span><br><span class="line">    <span class="keyword">return</span> smallSum(l, m) + smallSum(m + <span class="number">1</span>, r) + merge(l, m, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    统计跨左右产生的小和，同时完成合并</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span>        <span class="comment"># 累计小和</span></span><br><span class="line">    i = l          <span class="comment"># 左侧指针</span></span><br><span class="line">    sum_left = <span class="number">0</span>   <span class="comment"># 累计左侧小于等于当前右侧元素的和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计跨区贡献：对每个右侧元素，统计左侧贡献</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 左侧所有 &lt;= arr[j] 的元素都对arr[j]有贡献</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= m <span class="keyword">and</span> arr[i] &lt;= arr[j]:</span><br><span class="line">            sum_left += arr[i]  <span class="comment"># 累加左侧贡献</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans += sum_left  <span class="comment"># arr[j]的左侧贡献总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常归并过程</span></span><br><span class="line">    i = l</span><br><span class="line">    a = l</span><br><span class="line">    b = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法关键思路"><a href="#算法关键思路" class="headerlink" title="算法关键思路"></a>算法关键思路</h3><p><strong>为什么要在merge过程中统计？</strong></p>
<ol>
<li><strong>左右有序的便利性</strong>：因为左右都有序，可以用双指针线性扫描</li>
<li><strong>避免重复计算</strong>：每个跨区的小和贡献只需要计算一次</li>
<li><strong>时间复杂度优势</strong>：总体保持O(n log n)，而暴力解法是O(n²)</li>
</ol>
<p><strong>核心技巧</strong>：</p>
<ul>
<li>对于右半部分的每个元素arr[j]，左半部分所有 ≤ arr[j] 的元素都会对小和产生贡献</li>
<li>由于左半部分有序，可以用指针i从左向右扫描，累加贡献值</li>
<li>指针i只会前进不会后退，总的扫描时间为O(n)</li>
</ul>
<h2 id="翻转对问题"><a href="#翻转对问题" class="headerlink" title="翻转对问题"></a>翻转对问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定数组nums，如果i&lt;j且nums[i]&gt;2*nums[j]，我们就将(i,j)称作一个重要翻转对。求数组中翻转对的总数量。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组: [1,3,2,3,1]</span><br><span class="line">翻转对: (1,4)→3&gt;2*1, (3,4)→3&gt;2*1</span><br><span class="line">答案: 2</span><br></pre></td></tr></table></figure>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-pairs/">https://leetcode.cn/problems/reverse-pairs/</a></p>
<h3 id="归并分治解法-1"><a href="#归并分治解法-1" class="headerlink" title="归并分治解法"></a>归并分治解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计翻转对的主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> counts(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counts</span>(<span class="params">arr, l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    统计l...r范围上翻转对的数量，同时让l...r范围变有序</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 递归统计左右两边和跨区部分的翻转对数量</span></span><br><span class="line">    <span class="keyword">return</span> counts(arr, l, m) + counts(arr, m + <span class="number">1</span>, r) + merge(arr, l, m, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计跨区翻转对并完成合并&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 翻转对计数</span></span><br><span class="line">    j = m + <span class="number">1</span>  <span class="comment"># 右边数组起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计跨区翻转对</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, m + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 找到右侧第一个不满足 arr[i] &gt; 2*arr[j] 的位置</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= r <span class="keyword">and</span> arr[i] &gt; <span class="number">2</span> * arr[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当前i能形成的翻转对数量 = j - (m+1)</span></span><br><span class="line">        ans += j - m - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常merge过程（与归并排序相同）</span></span><br><span class="line">    i = l</span><br><span class="line">    a = l</span><br><span class="line">    b = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法关键思路-1"><a href="#算法关键思路-1" class="headerlink" title="算法关键思路"></a>算法关键思路</h3><p><strong>统计策略</strong>：</p>
<ol>
<li><strong>利用左右部分独立有序</strong>：对于左半部分的每个元素arr[i]，在右半部分找到满足arr[i] &gt; 2*arr[j]的所有j</li>
<li><strong>指针单向移动</strong>：左右部分都是有序的，指针j只需要前进，不需要回退  </li>
<li><strong>计数技巧</strong>：当找到第一个不满足条件的j时，说明j前面的所有元素都满足条件</li>
</ol>
<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>每个元素只会被访问一次，总的统计时间：O(n)，符合归并分治的要求</li>
</ul>
<h2 id="归并分治总结"><a href="#归并分治总结" class="headerlink" title="归并分治总结"></a>归并分治总结</h2><h3 id="适用问题特征"><a href="#适用问题特征" class="headerlink" title="适用问题特征"></a>适用问题特征</h3><ol>
<li><strong>可分解性</strong>：问题可以分解为左部分 + 右部分 + 跨区部分</li>
<li><strong>有序性便利</strong>：跨区部分的计算在左右有序时能够优化</li>
<li><strong>线性合并</strong>：跨区计算的时间复杂度为O(n)</li>
</ol>
<h3 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide_conquer</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> base_case</span><br><span class="line">    </span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    left_ans = divide_conquer(l, m)</span><br><span class="line">    right_ans = divide_conquer(m + <span class="number">1</span>, r)</span><br><span class="line">    cross_ans = merge_and_count(l, m, r)  <span class="comment"># 关键：统计跨区答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left_ans + right_ans + cross_ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_and_count</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="comment"># 1. 利用左右有序性，统计跨区答案</span></span><br><span class="line">    cross_count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># ... 统计逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 正常的归并排序merge过程</span></span><br><span class="line">    <span class="comment"># ... 合并逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cross_count</span><br></pre></td></tr></table></figure>

<h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h3><ol>
<li><strong>小和问题</strong>：统计左侧小于等于当前元素的累加和</li>
<li><strong>翻转对问题</strong>：统计满足特定大小关系的数对</li>
<li><strong>最近点对问题</strong>：二维空间中最近两点距离（高难度）</li>
<li><strong>逆序对问题</strong>：统计数组中的逆序对数量</li>
</ol>
<h3 id="与其他算法的关系"><a href="#与其他算法的关系" class="headerlink" title="与其他算法的关系"></a>与其他算法的关系</h3><ul>
<li><strong>线段树</strong>：也可以解决类似问题，但常数因子可能更大</li>
<li><strong>树状数组</strong>：适合在线查询修改，离线场景下归并分治更简洁</li>
<li><strong>分块算法</strong>：另一种分治思想，将在后续课程中介绍</li>
</ul>
<p>归并分治是一种优雅而强大的算法思想，它将复杂问题通过分治和有序性的结合，优雅地降低了时间复杂度。掌握这种思想对于解决许多看似困难的问题都有很大帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="page-number" href="/default-index/page/3/">3</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AgioPan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">AgioPan</p>
  <div class="site-description" itemprop="description">Solving equations, decoding life, exploring minds.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Agio910" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Agio910" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://orcid.org/0009-0005-1485-9515" title="orcid → https:&#x2F;&#x2F;orcid.org&#x2F;0009-0005-1485-9515" rel="noopener" target="_blank"><i class="fab fa-orcid fa-fw"></i>orcid</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:202111079094@mail.bnu.edu.cn" title="E-Mail → mailto:202111079094@mail.bnu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AgioPan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
