<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog of AgioPan">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Blog of AgioPan">
<meta property="og:description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="AgioPan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog of AgioPan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of AgioPan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-02 14:42:46 / Modified: 13:23:10" itemprop="dateCreated datePublished" datetime="2025-08-02T14:42:46+08:00">2025-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了栈和队列的基础实现、相互转换以及最小栈等核心内容，涵盖了链表实现、数组实现、循环队列等多种实现方式,包括了class013 -&gt; class015的内容。</p>
<hr>
<h1 id="013【入门】队列和栈-链表、数组实现"><a href="#013【入门】队列和栈-链表、数组实现" class="headerlink" title="013【入门】队列和栈-链表、数组实现"></a>013【入门】队列和栈-链表、数组实现</h1><h2 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h2><p>队列（Queue）是一种先进先出（FIFO, First In First Out）的线性数据结构。元素从队尾（rear）插入，从队首（front）删除。</p>
<h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><ul>
<li><strong>enqueue&#x2F;offer</strong>: 入队，将元素添加到队尾</li>
<li><strong>dequeue&#x2F;poll</strong>: 出队，从队首移除元素</li>
<li><strong>front&#x2F;peek</strong>: 查看队首元素，但不移除</li>
<li><strong>isEmpty</strong>: 判断队列是否为空</li>
<li><strong>size</strong>: 获取队列中元素个数</li>
</ul>
<h2 id="队列的实现方式"><a href="#队列的实现方式" class="headerlink" title="队列的实现方式"></a>队列的实现方式</h2><h3 id="方式一：基于双端队列（deque）实现"><a href="#方式一：基于双端队列（deque）实现" class="headerlink" title="方式一：基于双端队列（deque）实现"></a>方式一：基于双端队列（deque）实现</h3><p>Python内置的<code>collections.deque</code>提供了高效的双端操作，但常数时间较慢。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于Python内置deque实现的队列</span></span><br><span class="line"><span class="string">    内部使用双向链表，常数操作较慢但使用简单</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.queue = deque()  <span class="comment"># 内部存储使用deque（双端队列）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.queue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">offer</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向队列中加入元素，加到队尾&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">poll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从队列头部弹出元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队列头的元素但不弹出&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队列中元素个数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.queue)</span><br></pre></td></tr></table></figure>

<h3 id="方式二：基于固定数组实现"><a href="#方式二：基于固定数组实现" class="headerlink" title="方式二：基于固定数组实现"></a>方式二：基于固定数组实现</h3><p>在已知操作次数上限的情况下，使用固定数组实现具有更好的常数时间性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于固定数组实现的队列</span></span><br><span class="line"><span class="string">    适用于已知加入操作总次数上限的场景</span></span><br><span class="line"><span class="string">    常数时间性能更好，是实际刷题中最常用的方式</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化队列</span></span><br><span class="line"><span class="string">        参数: n - 加入操作的总次数上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue = [<span class="number">0</span>] * n  <span class="comment"># 固定大小数组</span></span><br><span class="line">        <span class="variable language_">self</span>.l = <span class="number">0</span>  <span class="comment"># 队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>.r = <span class="number">0</span>  <span class="comment"># 队尾指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.l == <span class="variable language_">self</span>.r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">offer</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入队操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.r] = num  <span class="comment"># 在队尾位置插入元素</span></span><br><span class="line">        <span class="variable language_">self</span>.r += <span class="number">1</span>  <span class="comment"># 队尾指针后移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">poll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队操作&quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.l]  <span class="comment"># 取队首元素</span></span><br><span class="line">        <span class="variable language_">self</span>.l += <span class="number">1</span>  <span class="comment"># 队首指针后移</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">head</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.l]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tail</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.r - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队列当前元素个数，区间[l, r)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.r - <span class="variable language_">self</span>.l</span><br></pre></td></tr></table></figure>

<h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><p>栈（Stack）是一种后进先出（LIFO, Last In First Out）的线性数据结构。元素只能从栈顶插入和删除。</p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><ul>
<li><strong>push</strong>: 压栈，将元素添加到栈顶</li>
<li><strong>pop</strong>: 弹栈，从栈顶移除元素</li>
<li><strong>peek&#x2F;top</strong>: 查看栈顶元素，但不移除</li>
<li><strong>isEmpty</strong>: 判断栈是否为空</li>
<li><strong>size</strong>: 获取栈中元素个数</li>
</ul>
<h2 id="栈的实现方式"><a href="#栈的实现方式" class="headerlink" title="栈的实现方式"></a>栈的实现方式</h2><h3 id="方式一：基于动态数组实现"><a href="#方式一：基于动态数组实现" class="headerlink" title="方式一：基于动态数组实现"></a>方式一：基于动态数组实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于Python内置列表实现的栈</span></span><br><span class="line"><span class="string">    使用动态数组，常数时间不是最优但使用简单</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []  <span class="comment"># 用列表模拟栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;压栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈的大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.stack)</span><br></pre></td></tr></table></figure>

<h3 id="方式二：基于固定数组实现-1"><a href="#方式二：基于固定数组实现-1" class="headerlink" title="方式二：基于固定数组实现"></a>方式二：基于固定数组实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基于固定数组实现的栈</span></span><br><span class="line"><span class="string">    适用于已知同时在栈里元素个数上限的场景</span></span><br><span class="line"><span class="string">    常数时间性能更好，空间可以复用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化栈</span></span><br><span class="line"><span class="string">        参数: n - 同时在栈里的元素个数上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack = [<span class="number">0</span>] * n  <span class="comment"># 固定大小数组</span></span><br><span class="line">        <span class="variable language_">self</span>.size_ = <span class="number">0</span>  <span class="comment"># 当前栈元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size_ == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;压栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack[<span class="variable language_">self</span>.size_] = num  <span class="comment"># 在当前size位置插入</span></span><br><span class="line">        <span class="variable language_">self</span>.size_ += <span class="number">1</span>  <span class="comment"># 元素个数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size_ -= <span class="number">1</span>  <span class="comment"># 元素个数-1，先减后取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[<span class="variable language_">self</span>.size_]  <span class="comment"># 返回弹出的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[<span class="variable language_">self</span>.size_ - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回栈大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size_</span><br></pre></td></tr></table></figure>

<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列是队列的一种特殊实现，通过循环使用固定大小的数组来避免空间浪费。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    循环队列实现</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/design-circular-queue/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化循环队列</span></span><br><span class="line"><span class="string">        参数: k - 队列容量上限</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.queue = [<span class="number">0</span>] * k  <span class="comment"># 固定大小数组</span></span><br><span class="line">        <span class="variable language_">self</span>.l = <span class="number">0</span>  <span class="comment"># 队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>.r = <span class="number">0</span>  <span class="comment"># 队尾指针</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>  <span class="comment"># 当前元素个数</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = k  <span class="comment"># 容量上限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enQueue</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        入队操作</span></span><br><span class="line"><span class="string">        返回: 成功返回True，队列满返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 队列已满</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.r] = value  <span class="comment"># 队尾插入元素</span></span><br><span class="line">            <span class="comment"># 队尾指针循环移动</span></span><br><span class="line">            <span class="variable language_">self</span>.r = <span class="number">0</span> <span class="keyword">if</span> <span class="variable language_">self</span>.r == <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">else</span> <span class="variable language_">self</span>.r + <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span>  <span class="comment"># 元素个数+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deQueue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        出队操作</span></span><br><span class="line"><span class="string">        返回: 成功返回True，队列空返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 队列为空</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 队首指针循环移动</span></span><br><span class="line">            <span class="variable language_">self</span>.l = <span class="number">0</span> <span class="keyword">if</span> <span class="variable language_">self</span>.l == <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">else</span> <span class="variable language_">self</span>.l + <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span>  <span class="comment"># 元素个数-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队首元素，队列为空返回-1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="variable language_">self</span>.l]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Rear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队尾元素，队列为空返回-1&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 计算队尾指针的实际位置</span></span><br><span class="line">            last = <span class="variable language_">self</span>.limit - <span class="number">1</span> <span class="keyword">if</span> <span class="variable language_">self</span>.r == <span class="number">0</span> <span class="keyword">else</span> <span class="variable language_">self</span>.r - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.queue[last]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isFull</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="variable language_">self</span>.limit</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="014【入门】队列和栈入门题目-栈和队列相互实现"><a href="#014【入门】队列和栈入门题目-栈和队列相互实现" class="headerlink" title="014【入门】队列和栈入门题目-栈和队列相互实现"></a>014【入门】队列和栈入门题目-栈和队列相互实现</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>队列是先进先出（FIFO），而栈是后进先出（LIFO）。要用栈实现队列，需要使用两个栈来模拟队列的行为。</p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用两个栈：</p>
<ul>
<li><strong>输入栈（in_stack）</strong>：负责接收新元素的push操作</li>
<li><strong>输出栈（out_stack）</strong>：负责输出元素的pop和peek操作</li>
</ul>
<h3 id="关键规则"><a href="#关键规则" class="headerlink" title="关键规则"></a>关键规则</h3><ol>
<li><strong>倒数据条件</strong>：只有当输出栈为空时，才能从输入栈倒数据</li>
<li><strong>倒数据原则</strong>：如果要倒数据，必须将输入栈的数据全部倒完</li>
<li><strong>时间复杂度</strong>：虽然单次操作可能是O(n)，但均摊时间复杂度是O(1)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用栈实现队列</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/implement-queue-using-stacks/</span></span><br><span class="line"><span class="string">    时间复杂度: 均摊O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.in_stack = []     <span class="comment"># 输入栈，负责push</span></span><br><span class="line">        <span class="variable language_">self</span>.out_stack = []    <span class="comment"># 输出栈，负责pop/peek</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inToOut</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        倒数据操作：从输入栈将数据倒入输出栈</span></span><br><span class="line"><span class="string">        核心规则：</span></span><br><span class="line"><span class="string">        1) 输出栈空了，才能倒数据</span></span><br><span class="line"><span class="string">        2) 如果倒数据，输入栈必须倒完</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.out_stack:                     <span class="comment"># 只有输出栈为空才能倒</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.in_stack:                   <span class="comment"># 输入栈必须倒完</span></span><br><span class="line">                <span class="variable language_">self</span>.out_stack.append(<span class="variable language_">self</span>.in_stack.pop())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入队操作：新元素加入输入栈&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.in_stack.append(x)                    <span class="comment"># 新元素压入输入栈</span></span><br><span class="line">        <span class="variable language_">self</span>.inToOut()                             <span class="comment"># 检查是否需要倒数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队操作：从输出栈弹出元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.inToOut()                             <span class="comment"># 确保输出栈有数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.out_stack.pop()                <span class="comment"># 弹出队首元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看队首元素：不移除，只查看&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.inToOut()                             <span class="comment"># 确保输出栈有数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.out_stack[-<span class="number">1</span>]                  <span class="comment"># 返回栈顶即队首</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.in_stack <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.out_stack  <span class="comment"># 两个栈都空才是空队列</span></span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>虽然<code>inToOut()</code>操作在最坏情况下需要O(n)时间，但通过均摊分析：</p>
<ul>
<li>每个元素最多被移动两次（输入栈→输出栈→出队列）</li>
<li>n次操作的总时间复杂度为O(n)</li>
<li>均摊时间复杂度为O(1)</li>
</ul>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>栈是后进先出（LIFO），队列是先进先出（FIFO）。要用队列实现栈，需要在每次push操作后重新排列队列中的元素。</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用一个双端队列（deque），在每次push新元素后，将队列中原有的元素依次移动到新元素后面，确保新元素总是在队首位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用双端队列实现栈</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/implement-stack-using-queues/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.queue = deque()                       <span class="comment"># 用deque实现队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        压栈操作</span></span><br><span class="line"><span class="string">        时间复杂度: O(n)</span></span><br><span class="line"><span class="string">        核心思想: 新元素入队后，将前面所有元素重新排列到新元素后面</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(<span class="variable language_">self</span>.queue)                        <span class="comment"># 记录当前队列长度</span></span><br><span class="line">        <span class="variable language_">self</span>.queue.append(x)                       <span class="comment"># 新元素加入队尾</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将前面的n个元素依次移动到队尾</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="variable language_">self</span>.queue.append(<span class="variable language_">self</span>.queue.popleft())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作：弹出队首元素，即栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看栈顶元素：返回队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.queue</span><br></pre></td></tr></table></figure>

<h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3><p>假设依次push元素1, 2, 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始状态: []</span><br><span class="line"></span><br><span class="line">push(1): [1]</span><br><span class="line"></span><br><span class="line">push(2): [2] -&gt; [2,1] (将1移动到2后面)</span><br><span class="line"></span><br><span class="line">push(3): [3,2,1] -&gt; [3,2,1] (将2,1依次移动到3后面)</span><br></pre></td></tr></table></figure>

<p>最终队列状态为<code>[3,2,1]</code>，队首元素3就是栈顶元素，符合LIFO特性。</p>
<hr>
<h1 id="015【入门】栈的入门题目-最小栈"><a href="#015【入门】栈的入门题目-最小栈" class="headerlink" title="015【入门】栈的入门题目-最小栈"></a>015【入门】栈的入门题目-最小栈</h1><h2 id="最小栈问题"><a href="#最小栈问题" class="headerlink" title="最小栈问题"></a>最小栈问题</h2><p>最小栈要求实现一个栈，除了基本的栈操作外，还要能够在O(1)时间内获取栈中的最小元素。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>核心挑战是如何在保持基本栈操作O(1)时间复杂度的同时，追踪当前栈中的最小值。当栈顶元素（恰好是最小值）被弹出时，需要快速知道剩余元素中的最小值。</p>
<h3 id="解决方案：辅助栈法"><a href="#解决方案：辅助栈法" class="headerlink" title="解决方案：辅助栈法"></a>解决方案：辅助栈法</h3><p>使用两个栈：</p>
<ul>
<li><strong>数据栈（data）</strong>：存储实际数据</li>
<li><strong>最小值栈（min）</strong>：存储对应位置的最小值</li>
</ul>
<h2 id="实现方法一：基于列表"><a href="#实现方法一：基于列表" class="headerlink" title="实现方法一：基于列表"></a>实现方法一：基于列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack1</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小栈实现方法一：使用Python列表</span></span><br><span class="line"><span class="string">    测试链接: https://leetcode.cn/problems/min-stack/</span></span><br><span class="line"><span class="string">    时间复杂度: 所有操作均为O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = []  <span class="comment"># 数据栈，存储实际元素</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">min</span> = []   <span class="comment"># 最小值栈，存储对应位置的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        压栈操作</span></span><br><span class="line"><span class="string">        核心思想: 每次压栈时，同时在最小值栈中记录当前的最小值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.data.append(val)  <span class="comment"># 将val压入数据栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.<span class="built_in">min</span> <span class="keyword">or</span> val &lt;= <span class="variable language_">self</span>.<span class="built_in">min</span>[-<span class="number">1</span>]:  <span class="comment"># 如果最小栈为空或val是新的最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>.append(val)  <span class="comment"># 将val压入最小栈</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则val不是最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>.append(<span class="variable language_">self</span>.<span class="built_in">min</span>[-<span class="number">1</span>])  <span class="comment"># 将当前最小值再次压入最小栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作：同时弹出两个栈的栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.data.pop()  <span class="comment"># 弹出数据栈栈顶</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">min</span>.pop()   <span class="comment"># 弹出最小栈栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[-<span class="number">1</span>]  <span class="comment"># 返回数据栈栈顶元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">min</span>[-<span class="number">1</span>]   <span class="comment"># 返回最小栈栈顶元素</span></span><br></pre></td></tr></table></figure>

<h3 id="工作原理示例"><a href="#工作原理示例" class="headerlink" title="工作原理示例"></a>工作原理示例</h3><p>假设依次压入元素：5, 2, 7, 1, 3</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>数据栈</th>
<th>最小栈</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>push(5)</td>
<td>[5]</td>
<td>[5]</td>
<td>5是第一个元素，也是最小值</td>
</tr>
<tr>
<td>push(2)</td>
<td>[5,2]</td>
<td>[5,2]</td>
<td>2比5小，成为新的最小值</td>
</tr>
<tr>
<td>push(7)</td>
<td>[5,2,7]</td>
<td>[5,2,2]</td>
<td>7比2大，最小值仍是2</td>
</tr>
<tr>
<td>push(1)</td>
<td>[5,2,7,1]</td>
<td>[5,2,2,1]</td>
<td>1比2小，成为新的最小值</td>
</tr>
<tr>
<td>push(3)</td>
<td>[5,2,7,1,3]</td>
<td>[5,2,2,1,1]</td>
<td>3比1大，最小值仍是1</td>
</tr>
</tbody></table>
<h2 id="实现方法二：基于固定数组"><a href="#实现方法二：基于固定数组" class="headerlink" title="实现方法二：基于固定数组"></a>实现方法二：基于固定数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack2</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小栈实现方法二：使用固定大小数组</span></span><br><span class="line"><span class="string">    适用于已知最大容量的场景，常数时间性能更好</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 根据leetcode测试数据实验得出的容量上限</span></span><br><span class="line">        <span class="comment"># 如果测试数据增加导致溢出，需要调大此值</span></span><br><span class="line">        <span class="variable language_">self</span>.MAXN = <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="number">0</span>] * <span class="variable language_">self</span>.MAXN  <span class="comment"># 数据数组</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">min</span> = [<span class="number">0</span>] * <span class="variable language_">self</span>.MAXN   <span class="comment"># 最小值数组</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>  <span class="comment"># 当前栈大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;压栈操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.size] = val  <span class="comment"># 在size位置存储val</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.size == <span class="number">0</span> <span class="keyword">or</span> val &lt;= <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size - <span class="number">1</span>]:  <span class="comment"># 第一个元素或新的最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size] = val  <span class="comment"># 存储val作为最小值</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># val不是最小值</span></span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size] = <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size - <span class="number">1</span>]  <span class="comment"># 复制前一个最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span>  <span class="comment"># 栈大小加1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹栈操作：只需将size减1，不需要实际删除数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.size - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">min</span>[<span class="variable language_">self</span>.size - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>push操作</strong>：O(1) - 只需要常数次比较和赋值</li>
<li><strong>pop操作</strong>：O(1) - 只需要移动指针或减少计数</li>
<li><strong>top操作</strong>：O(1) - 直接访问数组元素</li>
<li><strong>getMin操作</strong>：O(1) - 直接访问最小值栈顶</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>总空间复杂度</strong>：O(n) - 需要两个栈存储数据</li>
<li><strong>额外空间</strong>：O(n) - 最小值栈的空间开销</li>
</ul>
<h3 id="优化思考"><a href="#优化思考" class="headerlink" title="优化思考"></a>优化思考</h3><p>虽然辅助栈法简单易懂，但存在空间冗余。可以考虑以下优化：</p>
<ol>
<li><strong>稀疏存储</strong>：最小值栈只在最小值更新时才压入新值</li>
<li><strong>差值存储</strong>：存储与最小值的差值而非绝对值</li>
<li><strong>链表实现</strong>：在节点中直接存储当前最小值</li>
</ol>
<hr>
<h1 id="数据结构选择指南"><a href="#数据结构选择指南" class="headerlink" title="数据结构选择指南"></a>数据结构选择指南</h1><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>常数因子</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Python内置容器</td>
<td>O(1)均摊</td>
<td>O(n)</td>
<td>较大</td>
<td>快速原型，不追求极致性能</td>
</tr>
<tr>
<td>固定数组</td>
<td>O(1)</td>
<td>O(n)</td>
<td>较小</td>
<td>已知容量上限，追求性能</td>
</tr>
<tr>
<td>双栈&#x2F;双队列</td>
<td>O(1)均摊</td>
<td>O(n)</td>
<td>中等</td>
<td>功能转换，教学示例</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-02 12:42:46 / Modified: 13:30:12" itemprop="dateCreated datePublished" datetime="2025-08-02T12:42:46+08:00">2025-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了class009 -&gt; class012，涵盖了链表的基础概念、反转操作、合并算法、链表运算以及分割技巧等内容。</p>
<hr>
<h1 id="009【入门】单双链表及其反转"><a href="#009【入门】单双链表及其反转" class="headerlink" title="009【入门】单双链表及其反转"></a>009【入门】单双链表及其反转</h1><h2 id="链表的基本概念"><a href="#链表的基本概念" class="headerlink" title="链表的基本概念"></a>链表的基本概念</h2><p>链表是一种线性数据结构，其中元素存储在节点中，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不必连续存储。</p>
<h3 id="单链表节点定义"><a href="#单链表节点定义" class="headerlink" title="单链表节点定义"></a>单链表节点定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单链表节点类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val                    <span class="comment"># 节点存储的数据值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span>                  <span class="comment"># 指向下一个节点的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="双链表节点定义"><a href="#双链表节点定义" class="headerlink" title="双链表节点定义"></a>双链表节点定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    双链表节点类</span></span><br><span class="line"><span class="string">    每个节点有两个指针：指向前驱和后继</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value                <span class="comment"># 节点存储的数据值</span></span><br><span class="line">        <span class="variable language_">self</span>.last = <span class="literal">None</span>                  <span class="comment"># 指向前一个节点的指针</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 指向下一个节点的指针</span></span><br></pre></td></tr></table></figure>

<h2 id="单链表反转算法"><a href="#单链表反转算法" class="headerlink" title="单链表反转算法"></a>单链表反转算法</h2><p>反转单链表测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<h3 id="迭代方法实现"><a href="#迭代方法实现" class="headerlink" title="迭代方法实现"></a>迭代方法实现</h3><p>单链表反转是链表操作中的经典问题，核心思想是改变节点间的指针方向。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListReverseOperations</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_linked_list</span>(<span class="params">head</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        反转单链表 - 迭代实现</span></span><br><span class="line"><span class="string">        时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: head - 链表头节点</span></span><br><span class="line"><span class="string">        返回: 反转后链表的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span>                        <span class="comment"># 前驱节点指针，初始为None</span></span><br><span class="line">        next_node = <span class="literal">None</span>                  <span class="comment"># 临时保存下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:           <span class="comment"># 遍历整个链表</span></span><br><span class="line">            next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点，防止链表断裂</span></span><br><span class="line">            head.<span class="built_in">next</span> = pre               <span class="comment"># 当前节点指向前驱（反转指针）</span></span><br><span class="line">            pre = head                    <span class="comment"># 前驱指针前进到当前节点</span></span><br><span class="line">            head = next_node              <span class="comment"># 头指针前进到下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pre                        <span class="comment"># pre此时指向原链表的尾节点，即新链表的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="反转过程图解"><a href="#反转过程图解" class="headerlink" title="反转过程图解"></a>反转过程图解</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(2)/%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B.png" alt="反转图解"></p>
<p>具体在上面的实现中，是利用next向后移动 利用pre改变方指针向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line"></span><br><span class="line">第1步: pre=NULL, head=1, next=2</span><br><span class="line">      NULL &lt;- 1    2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">             pre  head</span><br><span class="line"></span><br><span class="line">第2步: pre=1, head=2, next=3  </span><br><span class="line">      NULL &lt;- 1 &lt;- 2    3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">                  pre  head</span><br><span class="line"></span><br><span class="line">第3步: pre=2, head=3, next=4</span><br><span class="line">      NULL &lt;- 1 &lt;- 2 &lt;- 3    4 -&gt; 5 -&gt; NULL</span><br><span class="line">                        pre  head</span><br><span class="line"></span><br><span class="line">最终: NULL &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5</span><br><span class="line">                                  pre</span><br></pre></td></tr></table></figure>

<h3 id="递归方法实现"><a href="#递归方法实现" class="headerlink" title="递归方法实现"></a>递归方法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_linked_list_recursive</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    反转单链表 - 递归实现</span></span><br><span class="line"><span class="string">    时间复杂度: O(n), 空间复杂度: O(n) - 递归栈空间</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数: head - 链表头节点</span></span><br><span class="line"><span class="string">    返回: 反转后链表的头节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基础情况：空链表或单节点链表</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归反转剩余部分</span></span><br><span class="line">    new_head = ListReverseOperations.reverse_linked_list_recursive(head.<span class="built_in">next</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反转当前节点与下一个节点的连接</span></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head             <span class="comment"># 下一个节点指回当前节点</span></span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 当前节点的next置空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> new_head                   <span class="comment"># 返回新的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="双链表反转算法"><a href="#双链表反转算法" class="headerlink" title="双链表反转算法"></a>双链表反转算法</h2><p>双链表的反转需要同时处理前驱和后继两个指针，相比单链表更加复杂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_double_list</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    反转双链表</span></span><br><span class="line"><span class="string">    时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数: head - 双链表头节点</span></span><br><span class="line"><span class="string">    返回: 反转后双链表的头节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pre = <span class="literal">None</span>                        <span class="comment"># 前驱节点指针</span></span><br><span class="line">    next_node = <span class="literal">None</span>                  <span class="comment"># 临时保存下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:           <span class="comment"># 遍历整个双链表</span></span><br><span class="line">        next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 交换当前节点的前驱和后继指针</span></span><br><span class="line">        head.<span class="built_in">next</span> = pre               <span class="comment"># next指向前驱</span></span><br><span class="line">        head.last = next_node         <span class="comment"># last指向后继</span></span><br><span class="line">        </span><br><span class="line">        pre = head                    <span class="comment"># 前驱指针前进</span></span><br><span class="line">        head = next_node              <span class="comment"># 头指针前进</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre                        <span class="comment"># 返回新的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="双链表反转的关键点"><a href="#双链表反转的关键点" class="headerlink" title="双链表反转的关键点"></a>双链表反转的关键点</h3><ol>
<li><strong>指针交换</strong>：每个节点的<code>next</code>和<code>last</code>指针需要互换方向</li>
<li><strong>边界处理</strong>：正确处理链表两端的NULL指针</li>
<li><strong>遍历顺序</strong>：确保在修改指针前保存必要的信息</li>
</ol>
<hr>
<h1 id="010【入门】合并两个有序链表"><a href="#010【入门】合并两个有序链表" class="headerlink" title="010【入门】合并两个有序链表"></a>010【入门】合并两个有序链表</h1><p>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个已排序的链表，将它们合并成一个新的有序链表。新链表应该通过拼接给定的两个链表的所有节点组成。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>采用<strong>双指针技术</strong>，比较两个链表当前节点的值，选择较小的节点添加到结果链表中，然后移动对应的指针。</p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_two_lists</span>(<span class="params">head1, head2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个有序链表</span></span><br><span class="line"><span class="string">        时间复杂度: O(m + n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: head1, head2 - 两个有序链表的头节点</span></span><br><span class="line"><span class="string">        返回: 合并后有序链表的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 边界情况处理：其中一个链表为空</span></span><br><span class="line">        <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head2 <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> head1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确定合并后链表的头节点</span></span><br><span class="line">        <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">            head = head1                  <span class="comment"># head1的值更小，作为头节点</span></span><br><span class="line">            cur1 = head1.<span class="built_in">next</span>             <span class="comment"># cur1指向head1的下一个节点</span></span><br><span class="line">            cur2 = head2                  <span class="comment"># cur2指向head2的当前节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = head2                  <span class="comment"># head2的值更小，作为头节点</span></span><br><span class="line">            cur1 = head1                  <span class="comment"># cur1指向head1的当前节点</span></span><br><span class="line">            cur2 = head2.<span class="built_in">next</span>             <span class="comment"># cur2指向head2的下一个节点</span></span><br><span class="line">        </span><br><span class="line">        pre = head                        <span class="comment"># pre用于构建结果链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 双指针遍历两个链表</span></span><br><span class="line">        <span class="keyword">while</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> cur2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur1.val &lt;= cur2.val:     <span class="comment"># cur1的值更小或相等</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur1           <span class="comment"># 将cur1连接到结果链表</span></span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span>          <span class="comment"># cur1指针后移</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># cur2的值更小</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur2           <span class="comment"># 将cur2连接到结果链表</span></span><br><span class="line">                cur2 = cur2.<span class="built_in">next</span>          <span class="comment"># cur2指针后移</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span>                <span class="comment"># 结果链表指针后移</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理剩余节点：将未遍历完的链表直接连接到结果链表末尾</span></span><br><span class="line">        pre.<span class="built_in">next</span> = cur1 <span class="keyword">if</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> cur2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head                       <span class="comment"># 返回合并后链表的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="算法优化版本"><a href="#算法优化版本" class="headerlink" title="算法优化版本"></a>算法优化版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_two_lists_optimized</span>(<span class="params">head1, head2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个有序链表 - 优化版本</span></span><br><span class="line"><span class="string">    使用虚拟头节点简化边界处理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)               <span class="comment"># 创建虚拟头节点</span></span><br><span class="line">    current = dummy                   <span class="comment"># 当前指针指向虚拟头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双指针遍历两个链表</span></span><br><span class="line">    <span class="keyword">while</span> head1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">            current.<span class="built_in">next</span> = head1      <span class="comment"># 连接较小节点</span></span><br><span class="line">            head1 = head1.<span class="built_in">next</span>        <span class="comment"># 移动head1指针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current.<span class="built_in">next</span> = head2      <span class="comment"># 连接较小节点</span></span><br><span class="line">            head2 = head2.<span class="built_in">next</span>        <span class="comment"># 移动head2指针</span></span><br><span class="line">        current = current.<span class="built_in">next</span>        <span class="comment"># 移动结果链表指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接剩余节点</span></span><br><span class="line">    current.<span class="built_in">next</span> = head1 <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> head2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>                 <span class="comment"># 返回真正的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="合并过程示例"><a href="#合并过程示例" class="headerlink" title="合并过程示例"></a>合并过程示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">链表1: 1 -&gt; 2 -&gt; 4</span><br><span class="line">链表2: 1 -&gt; 3 -&gt; 4</span><br><span class="line"></span><br><span class="line">合并过程:</span><br><span class="line">step1: 比较1和1，选择链表1的1    结果: 1</span><br><span class="line">step2: 比较2和1，选择链表2的1    结果: 1 -&gt; 1  </span><br><span class="line">step3: 比较2和3，选择链表1的2    结果: 1 -&gt; 1 -&gt; 2</span><br><span class="line">step4: 比较4和3，选择链表2的3    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3</span><br><span class="line">step5: 比较4和4，选择链表1的4    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span><br><span class="line">step6: 连接剩余的4              结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="011【入门】两个链表相加"><a href="#011【入门】两个链表相加" class="headerlink" title="011【入门】两个链表相加"></a>011【入门】两个链表相加</h1><p>测试链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个非空链表来表示两个非负整数，数字最高位位于链表开始位置。它们的每个节点只存储一位数字，计算两个数的和并以相同形式返回一个表示和的链表。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>模拟手工加法运算，从链表尾部开始逐位相加，处理进位问题。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_two_numbers</span>(<span class="params">h1, h2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        两个链表数字相加</span></span><br><span class="line"><span class="string">        时间复杂度: O(max(m,n)), 空间复杂度: O(max(m,n))</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: h1, h2 - 两个表示数字的链表头节点</span></span><br><span class="line"><span class="string">        返回: 表示和的链表头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="literal">None</span>                        <span class="comment"># 结果链表头节点</span></span><br><span class="line">        cur = <span class="literal">None</span>                        <span class="comment"># 当前构建位置指针</span></span><br><span class="line">        carry = <span class="number">0</span>                         <span class="comment"># 进位标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历两个链表，直到都为空</span></span><br><span class="line">        <span class="keyword">while</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 获取当前位的数字，如果链表已结束则为0</span></span><br><span class="line">            val1 = h1.val <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            val2 = h2.val <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算当前位的和（包括进位）</span></span><br><span class="line">            total = val1 + val2 + carry</span><br><span class="line">            carry = total // <span class="number">10</span>           <span class="comment"># 计算新的进位</span></span><br><span class="line">            digit = total % <span class="number">10</span>            <span class="comment"># 当前位的数字</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 构建结果链表</span></span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="literal">None</span>:               <span class="comment"># 第一个节点</span></span><br><span class="line">                ans = ListNode(digit)</span><br><span class="line">                cur = ans</span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 后续节点</span></span><br><span class="line">                cur.<span class="built_in">next</span> = ListNode(digit)</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移动链表指针</span></span><br><span class="line">            h1 = h1.<span class="built_in">next</span> <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            h2 = h2.<span class="built_in">next</span> <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理最后的进位</span></span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans                        <span class="comment"># 返回结果链表头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="代码修正与优化"><a href="#代码修正与优化" class="headerlink" title="代码修正与优化"></a>代码修正与优化</h2><p>优化了源代码最后的进位问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_numbers_corrected</span>(<span class="params">h1, h2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    两个链表数字相加 - 优化版本，更加通用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="literal">None</span>                        <span class="comment"># 结果链表头节点</span></span><br><span class="line">    cur = <span class="literal">None</span>                        <span class="comment"># 当前构建位置指针</span></span><br><span class="line">    carry = <span class="number">0</span>                         <span class="comment"># 进位标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 安全获取节点值，避免空指针异常</span></span><br><span class="line">        val1 = h1.val <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        val2 = h2.val <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算当前位的和</span></span><br><span class="line">        total = val1 + val2 + carry</span><br><span class="line">        carry = total // <span class="number">10</span>           <span class="comment"># 新进位</span></span><br><span class="line">        digit = total % <span class="number">10</span>            <span class="comment"># 当前位数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建结果链表节点</span></span><br><span class="line">        new_node = ListNode(digit)</span><br><span class="line">        <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="literal">None</span>:               <span class="comment"># 初始化头节点</span></span><br><span class="line">            ans = cur = new_node</span><br><span class="line">        <span class="keyword">else</span>:                         <span class="comment"># 连接新节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = new_node</span><br><span class="line">            cur = new_node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 安全移动指针</span></span><br><span class="line">        h1 = h1.<span class="built_in">next</span> <span class="keyword">if</span> h1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        h2 = h2.<span class="built_in">next</span> <span class="keyword">if</span> h2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理最终进位</span></span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(carry)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">链表1: 2 -&gt; 4 -&gt; 3  (表示数字342)</span><br><span class="line">链表2: 5 -&gt; 6 -&gt; 4  (表示数字465)</span><br><span class="line"></span><br><span class="line">相加过程:</span><br><span class="line">位置0: 2 + 5 + 0(进位) = 7, 进位=0  结果: 7</span><br><span class="line">位置1: 4 + 6 + 0(进位) = 10, 进位=1  结果: 7 -&gt; 0</span><br><span class="line">位置2: 3 + 4 + 1(进位) = 8, 进位=0  结果: 7 -&gt; 0 -&gt; 8</span><br><span class="line"></span><br><span class="line">最终结果: 7 -&gt; 0 -&gt; 8 (表示数字807)</span><br><span class="line">验证: 342 + 465 = 807 ✓</span><br></pre></td></tr></table></figure>

<h2 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h2><ol>
<li><strong>不同长度链表</strong>：短链表结束后，继续处理长链表的剩余位</li>
<li><strong>最高位进位</strong>：最后可能产生新的最高位</li>
<li><strong>空链表</strong>：输入验证，确保链表非空</li>
<li><strong>单位数</strong>：正确处理个位数相加的情况</li>
</ol>
<hr>
<h1 id="012【入门】划分链表"><a href="#012【入门】划分链表" class="headerlink" title="012【入门】划分链表"></a>012【入门】划分链表</h1><p>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></p>
<h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个链表和一个特定值x，对链表进行分隔，使得所有小于x的节点都在大于或等于x的节点之前。保持两个分区中每个节点的初始相对位置。</p>
<h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>使用<strong>双链表分离</strong>的思想：</p>
<ol>
<li>创建两个独立的链表：小于x的节点链表和大于等于x的节点链表</li>
<li>遍历原链表，将节点分别添加到对应的链表中</li>
<li>最后将两个链表连接起来</li>
</ol>
<h2 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">head, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分链表</span></span><br><span class="line"><span class="string">        时间复杂度: O(n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数: head - 链表头节点, x - 划分值</span></span><br><span class="line"><span class="string">        返回: 划分后链表的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化两个链表的头尾指针</span></span><br><span class="line">        left_head = <span class="literal">None</span>                  <span class="comment"># 小于x的链表头指针</span></span><br><span class="line">        left_tail = <span class="literal">None</span>                  <span class="comment"># 小于x的链表尾指针</span></span><br><span class="line">        right_head = <span class="literal">None</span>                 <span class="comment"># 大于等于x的链表头指针</span></span><br><span class="line">        right_tail = <span class="literal">None</span>                 <span class="comment"># 大于等于x的链表尾指针</span></span><br><span class="line">        </span><br><span class="line">        next_node = <span class="literal">None</span>                  <span class="comment"># 临时保存下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历原链表，分离节点</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点</span></span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span>              <span class="comment"># 断开当前节点的连接</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:              <span class="comment"># 当前节点值小于x</span></span><br><span class="line">                <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 左链表为空</span></span><br><span class="line">                    left_head = head      <span class="comment"># 设置左链表头节点</span></span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 左链表非空</span></span><br><span class="line">                    left_tail.<span class="built_in">next</span> = head <span class="comment"># 连接到左链表尾部</span></span><br><span class="line">                left_tail = head          <span class="comment"># 更新左链表尾指针</span></span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 当前节点值大于等于x</span></span><br><span class="line">                <span class="keyword">if</span> right_head <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 右链表为空</span></span><br><span class="line">                    right_head = head     <span class="comment"># 设置右链表头节点</span></span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 右链表非空</span></span><br><span class="line">                    right_tail.<span class="built_in">next</span> = head <span class="comment"># 连接到右链表尾部</span></span><br><span class="line">                right_tail = head         <span class="comment"># 更新右链表尾指针</span></span><br><span class="line">            </span><br><span class="line">            head = next_node              <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 连接两个链表</span></span><br><span class="line">        <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:            <span class="comment"># 如果左链表为空</span></span><br><span class="line">            <span class="keyword">return</span> right_head             <span class="comment"># 直接返回右链表</span></span><br><span class="line">        <span class="keyword">else</span>:                            <span class="comment"># 左链表非空</span></span><br><span class="line">            left_tail.<span class="built_in">next</span> = right_head   <span class="comment"># 连接左右链表</span></span><br><span class="line">            <span class="keyword">return</span> left_head              <span class="comment"># 返回左链表头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="代码修正与完善"><a href="#代码修正与完善" class="headerlink" title="代码修正与完善"></a>代码修正与完善</h2><p>优化了原代码在遍历阶段的指针指代可能不清晰的问题，修改了if else后的指定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition_corrected</span>(<span class="params">head, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分链表 - 修正版本</span></span><br><span class="line"><span class="string">        修复了原代码的语法错误和逻辑问题</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化四个指针</span></span><br><span class="line">        left_head = left_tail = <span class="literal">None</span>      <span class="comment"># 小于x的链表头尾指针</span></span><br><span class="line">        right_head = right_tail = <span class="literal">None</span>    <span class="comment"># 大于等于x的链表头尾指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历原链表</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = head.<span class="built_in">next</span>         <span class="comment"># 保存下一个节点</span></span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span>              <span class="comment"># 断开当前节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:              <span class="comment"># 节点值小于x</span></span><br><span class="line">                <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 第一个小于x的节点</span></span><br><span class="line">                    left_head = left_tail = head</span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 后续小于x的节点</span></span><br><span class="line">                    left_tail.<span class="built_in">next</span> = head</span><br><span class="line">                    left_tail = head</span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># 节点值大于等于x</span></span><br><span class="line">                <span class="keyword">if</span> right_head <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 第一个大于等于x的节点</span></span><br><span class="line">                    right_head = right_tail = head</span><br><span class="line">                <span class="keyword">else</span>:                     <span class="comment"># 后续大于等于x的节点</span></span><br><span class="line">                    right_tail.<span class="built_in">next</span> = head</span><br><span class="line">                    right_tail = head</span><br><span class="line">            </span><br><span class="line">            head = next_node              <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 合并两个链表</span></span><br><span class="line">        <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="literal">None</span>:            <span class="comment"># 只有大于等于x的节点</span></span><br><span class="line">            <span class="keyword">return</span> right_head</span><br><span class="line">        </span><br><span class="line">        left_tail.<span class="built_in">next</span> = right_head       <span class="comment"># 连接两个链表</span></span><br><span class="line">        <span class="keyword">return</span> left_head                  <span class="comment"># 返回结果链表头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="优化版本：使用虚拟头节点"><a href="#优化版本：使用虚拟头节点" class="headerlink" title="优化版本：使用虚拟头节点"></a>优化版本：使用虚拟头节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition_optimized</span>(<span class="params">head, x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    划分链表 - 优化版本</span></span><br><span class="line"><span class="string">    使用虚拟头节点简化代码逻辑，简化了边界处理</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建虚拟头节点</span></span><br><span class="line">    left_dummy = ListNode(<span class="number">0</span>)          <span class="comment"># 小于x链表的虚拟头节点</span></span><br><span class="line">    right_dummy = ListNode(<span class="number">0</span>)         <span class="comment"># 大于等于x链表的虚拟头节点</span></span><br><span class="line">    </span><br><span class="line">    left = left_dummy                 <span class="comment"># 小于x链表的当前指针</span></span><br><span class="line">    right = right_dummy               <span class="comment"># 大于等于x链表的当前指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历原链表，分配节点</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">            left.<span class="built_in">next</span> = head          <span class="comment"># 连接到左链表</span></span><br><span class="line">            left = left.<span class="built_in">next</span>          <span class="comment"># 移动左指针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.<span class="built_in">next</span> = head         <span class="comment"># 连接到右链表</span></span><br><span class="line">            right = right.<span class="built_in">next</span>        <span class="comment"># 移动右指针</span></span><br><span class="line">        head = head.<span class="built_in">next</span>              <span class="comment"># 移动原链表指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 断开右链表的尾部连接，防止环</span></span><br><span class="line">    right.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接两个链表</span></span><br><span class="line">    left.<span class="built_in">next</span> = right_dummy.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left_dummy.<span class="built_in">next</span>            <span class="comment"># 返回真正的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原链表: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span><br><span class="line">划分值: x = 3</span><br><span class="line"></span><br><span class="line">分离过程:</span><br><span class="line">节点1 &lt; 3: 左链表 = 1</span><br><span class="line">节点4 &gt;= 3: 右链表 = 4  </span><br><span class="line">节点3 &gt;= 3: 右链表 = 4 -&gt; 3</span><br><span class="line">节点2 &lt; 3: 左链表 = 1 -&gt; 2</span><br><span class="line">节点5 &gt;= 3: 右链表 = 4 -&gt; 3 -&gt; 5</span><br><span class="line">节点2 &lt; 3: 左链表 = 1 -&gt; 2 -&gt; 2</span><br><span class="line"></span><br><span class="line">最终结果: 1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</span><br></pre></td></tr></table></figure>

<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><ol>
<li><strong>稳定性</strong>：保持原有的相对顺序</li>
<li><strong>原地操作</strong>：只调整指针，不创建新节点</li>
<li><strong>时间效率</strong>：单次遍历，O(n)时间复杂度</li>
<li><strong>空间效率</strong>：只使用常数额外空间</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><strong>链表排序的预处理</strong>：快速排序的分区操作</li>
<li><strong>数据分类</strong>：按条件将数据分为两组</li>
<li><strong>链表重组</strong>：根据特定规则重新排列链表节点</li>
</ol>
<hr>
<h1 id="链表操作技巧拓展"><a href="#链表操作技巧拓展" class="headerlink" title="链表操作技巧拓展"></a>链表操作技巧拓展</h1><h2 id="核心技巧与模式"><a href="#核心技巧与模式" class="headerlink" title="核心技巧与模式"></a>核心技巧与模式</h2><h3 id="1-双指针技术"><a href="#1-双指针技术" class="headerlink" title="1. 双指针技术"></a>1. 双指针技术</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_pointer_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    双指针模式：快慢指针、左右指针等</span></span><br><span class="line"><span class="string">    常用于链表中点查找、环检测、倒数第k个节点等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    slow = fast = head                    <span class="comment"># 快慢指针初始化</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>                  <span class="comment"># 慢指针每次移动1步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>             <span class="comment"># 快指针每次移动2步</span></span><br><span class="line">    <span class="keyword">return</span> slow                           <span class="comment"># 返回中点或其他目标位置</span></span><br></pre></td></tr></table></figure>

<h3 id="2-虚拟头节点"><a href="#2-虚拟头节点" class="headerlink" title="2. 虚拟头节点"></a>2. 虚拟头节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dummy_head_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    虚拟头节点模式：简化头节点的特殊处理</span></span><br><span class="line"><span class="string">    特别适用于可能删除头节点或构建新链表的场景</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)                   <span class="comment"># 创建虚拟头节点</span></span><br><span class="line">    dummy.<span class="built_in">next</span> = head                     <span class="comment"># 连接原链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在这里进行各种操作</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>                     <span class="comment"># 返回真正的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="3-递归模式"><a href="#3-递归模式" class="headerlink" title="3. 递归模式"></a>3. 递归模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归模式：将复杂问题分解为子问题</span></span><br><span class="line"><span class="string">    适用于链表反转、删除节点、合并等操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 基础情况</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归处理子问题</span></span><br><span class="line">    result = recursive_pattern(head.<span class="built_in">next</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理当前层</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="4-节点分离与重组"><a href="#4-节点分离与重组" class="headerlink" title="4. 节点分离与重组"></a>4. 节点分离与重组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">separate_and_merge_pattern</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    分离重组模式：将链表按条件分离后重新组合</span></span><br><span class="line"><span class="string">    适用于链表划分、奇偶分离、按值分组等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建多个子链表的头尾指针</span></span><br><span class="line">    list1_head = list1_tail = <span class="literal">None</span></span><br><span class="line">    list2_head = list2_tail = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        next_node = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 断开连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> condition(head):               <span class="comment"># 根据条件分配</span></span><br><span class="line">            <span class="comment"># 添加到list1</span></span><br><span class="line">            <span class="keyword">if</span> list1_head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                list1_head = list1_tail = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                list1_tail.<span class="built_in">next</span> = head</span><br><span class="line">                list1_tail = head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 添加到list2</span></span><br><span class="line">            <span class="keyword">if</span> list2_head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                list2_head = list2_tail = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                list2_tail.<span class="built_in">next</span> = head</span><br><span class="line">                list2_tail = head</span><br><span class="line">        </span><br><span class="line">        head = next_node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重新组合链表</span></span><br><span class="line">    <span class="keyword">if</span> list1_tail:</span><br><span class="line">        list1_tail.<span class="built_in">next</span> = list2_head</span><br><span class="line">    <span class="keyword">return</span> list1_head <span class="keyword">if</span> list1_head <span class="keyword">else</span> list2_head</span><br></pre></td></tr></table></figure>

<h2 id="常见错误与注意事项"><a href="#常见错误与注意事项" class="headerlink" title="常见错误与注意事项"></a>常见错误与注意事项</h2><h3 id="1-空指针处理"><a href="#1-空指针处理" class="headerlink" title="1. 空指针处理"></a>1. 空指针处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrong_example</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span>.val                  <span class="comment"># 可能导致空指针异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确示例  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">correct_example</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:                <span class="comment"># 先检查再访问</span></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span>.val</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="2-内存泄漏防止"><a href="#2-内存泄漏防止" class="headerlink" title="2. 内存泄漏防止"></a>2. 内存泄漏防止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prevent_memory_leak</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    防止内存泄漏：及时断开不需要的连接</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        next_node = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span>                  <span class="comment"># 断开连接，防止环</span></span><br><span class="line">        head = next_node</span><br></pre></td></tr></table></figure>

<h3 id="3-边界情况处理"><a href="#3-边界情况处理" class="headerlink" title="3. 边界情况处理"></a>3. 边界情况处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_edge_cases</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理边界情况：空链表、单节点链表等</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 空链表</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 单节点链表</span></span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常处理逻辑</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h2 id="性能分析与优化"><a href="#性能分析与优化" class="headerlink" title="性能分析与优化"></a>性能分析与优化</h2><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>单次遍历操作</strong>：O(n) - 反转、合并、查找等</li>
<li><strong>嵌套遍历操作</strong>：O(n²) - 某些复杂的链表操作</li>
<li><strong>递归操作</strong>：O(n) - 但需要考虑递归栈空间</li>
</ul>
<h3 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h3><ul>
<li><strong>原地操作</strong>：优先使用指针操作而非创建新节点</li>
<li><strong>迭代替代递归</strong>：在可能的情况下避免递归栈开销</li>
<li><strong>临时变量最小化</strong>：只保存必要的指针变量</li>
</ul>
<h3 id="实际性能考虑"><a href="#实际性能考虑" class="headerlink" title="实际性能考虑"></a>实际性能考虑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">performance_optimized_merge</span>(<span class="params">h1, h2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    性能优化的链表合并</span></span><br><span class="line"><span class="string">    减少条件判断和指针操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    tail = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> h1 <span class="keyword">and</span> h2:</span><br><span class="line">        <span class="keyword">if</span> h1.val &lt;= h2.val:</span><br><span class="line">            tail.<span class="built_in">next</span>, h1 = h1, h1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tail.<span class="built_in">next</span>, h2 = h2, h2.<span class="built_in">next</span></span><br><span class="line">        tail = tail.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 直接连接剩余部分，无需循环</span></span><br><span class="line">    tail.<span class="built_in">next</span> = h1 <span class="keyword">or</span> h2</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-30 18:42:46" itemprop="dateCreated datePublished" datetime="2025-07-30T18:42:46+08:00">2025-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:57:15" itemprop="dateModified" datetime="2025-08-02T12:57:15+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了class002 -&gt; class 007的内容，涵盖了社会实验模拟、位运算、基础排序算法、算法验证方法、二分搜索以及复杂度分析等核心内容。</p>
<p>原代码是java版，我改成了python</p>
<hr>
<h1 id="002【入门】从社会实验到入门提醒"><a href="#002【入门】从社会实验到入门提醒" class="headerlink" title="002【入门】从社会实验到入门提醒"></a>002【入门】从社会实验到入门提醒</h1><h2 id="基尼系数的理论基础"><a href="#基尼系数的理论基础" class="headerlink" title="基尼系数的理论基础"></a>基尼系数的理论基础</h2><p>基尼系数是经济学中衡量收入分配不平等程度的重要指标，其数学定义为：</p>
<p>$$<br>G &#x3D; \frac{\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}|x_i - x_j|}{2n\sum_{i&#x3D;1}^{n}x_i}<br>$$</p>
<p>其中 $x_i$ 表示第 $i$ 个个体的财富值，$n$ 为总人数。</p>
<h3 id="基尼系数的经济学意义"><a href="#基尼系数的经济学意义" class="headerlink" title="基尼系数的经济学意义"></a>基尼系数的经济学意义</h3><ul>
<li><strong>G &#x3D; 0</strong>：完全平等，所有人财富相同</li>
<li><strong>G &#x3D; 1</strong>：完全不平等，一人拥有全部财富  </li>
<li><strong>G &#x3D; 0.4-0.5</strong>：国际公认的贫富差距警戒线</li>
<li><strong>G &gt; 0.5</strong>：社会可能面临动荡风险</li>
</ul>
<h2 id="财富分配模拟实验"><a href="#财富分配模拟实验" class="headerlink" title="财富分配模拟实验"></a>财富分配模拟实验</h2><p>通过计算机模拟研究在完全随机的财富转移过程中，社会财富分配的自然演化规律。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_gini</span>(<span class="params">wealth</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算基尼系数的函数</span></span><br><span class="line"><span class="string">    参数: wealth - 财富分布列表</span></span><br><span class="line"><span class="string">    返回: 基尼系数值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(wealth)                        <span class="comment"># 获取人数</span></span><br><span class="line">    sum_of_wealth = <span class="built_in">sum</span>(wealth)            <span class="comment"># 计算总财富</span></span><br><span class="line">    sum_of_absolute_differences = <span class="number">0</span>        <span class="comment"># 初始化财富差异总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算所有个体间财富差异的绝对值之和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_of_absolute_differences += <span class="built_in">abs</span>(wealth[i] - wealth[j])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据基尼系数公式计算并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> sum_of_absolute_differences / (<span class="number">2</span> * n * sum_of_wealth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">experiment</span>(<span class="params">n, t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    财富分配模拟实验</span></span><br><span class="line"><span class="string">    参数: n - 人数, t - 模拟轮数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    wealth = [<span class="number">100</span>] * n                     <span class="comment"># 初始化每人财富为100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):                     <span class="comment"># 进行t轮模拟</span></span><br><span class="line">        has_money = [w &gt; <span class="number">0</span> <span class="keyword">for</span> w <span class="keyword">in</span> wealth]  <span class="comment"># 判断每个人是否有钱可转</span></span><br><span class="line">        transfers = []                     <span class="comment"># 记录本轮转账列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):                 <span class="comment"># 遍历每个人</span></span><br><span class="line">            <span class="keyword">if</span> has_money[j]:               <span class="comment"># 如果该人有钱</span></span><br><span class="line">                other = j                  <span class="comment"># 初始化接收者为自己</span></span><br><span class="line">                <span class="keyword">while</span> other == j:          <span class="comment"># 确保接收者不是自己</span></span><br><span class="line">                    other = random.randint(<span class="number">0</span>, n - <span class="number">1</span>)  <span class="comment"># 随机选择其他人</span></span><br><span class="line">                transfers.append((j, other))          <span class="comment"># 记录转账关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统一执行所有转账，避免执行顺序影响结果</span></span><br><span class="line">        <span class="keyword">for</span> giver, receiver <span class="keyword">in</span> transfers:</span><br><span class="line">            wealth[giver] -= <span class="number">1</span>             <span class="comment"># 转出者财富减1</span></span><br><span class="line">            wealth[receiver] += <span class="number">1</span>          <span class="comment"># 接收者财富加1</span></span><br><span class="line">    </span><br><span class="line">    wealth.sort()                          <span class="comment"># 按财富排序便于观察分布</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出结果分析</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;财富分布(从贫穷到富有):&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> idx, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(wealth):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">int</span>(w), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">9</span>:                  <span class="comment"># 每10个数换行</span></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;社会基尼系数:&quot;</span>, calculate_gini(wealth))</span><br></pre></td></tr></table></figure>

<h3 id="实验意义与启示"><a href="#实验意义与启示" class="headerlink" title="实验意义与启示"></a>实验意义与启示</h3><ol>
<li><strong>随机性中的必然性</strong>：即使在完全公平的随机转移规则下，财富差距仍会自然产生</li>
<li><strong>马太效应</strong>：财富分配存在自然的分化趋势</li>
<li><strong>社会政策启示</strong>：需要主动的调节机制来维护社会公平</li>
</ol>
<hr>
<h1 id="003【入门】二进制和位运算"><a href="#003【入门】二进制和位运算" class="headerlink" title="003【入门】二进制和位运算"></a>003【入门】二进制和位运算</h1><h2 id="计算机数值表示系统"><a href="#计算机数值表示系统" class="headerlink" title="计算机数值表示系统"></a>计算机数值表示系统</h2><h3 id="正数的二进制表示"><a href="#正数的二进制表示" class="headerlink" title="正数的二进制表示"></a>正数的二进制表示</h3><p>正数采用标准的二进制表示法，最高位为符号位（0表示正数）。</p>
<h3 id="负数的补码表示"><a href="#负数的补码表示" class="headerlink" title="负数的补码表示"></a>负数的补码表示</h3><p>负数采用补码（Two’s Complement）表示：</p>
<ul>
<li>原码按位取反</li>
<li>结果加1</li>
</ul>
<p>$$<br>\text{负数补码} &#x3D; \sim(\text{原码}) + 1<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_binary</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    打印32位二进制表示</span></span><br><span class="line"><span class="string">    参数: num - 要打印的整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span>                                 <span class="comment"># 初始化二进制字符串</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):           <span class="comment"># 从最高位到最低位遍历</span></span><br><span class="line">        <span class="comment"># 通过位与运算判断第i位是否为1</span></span><br><span class="line">        s += <span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(s)                              <span class="comment"># 输出32位二进制表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示正负数的二进制表示</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = <span class="number">78</span>                                <span class="comment"># 正数示例</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正数<span class="subst">&#123;a&#125;</span>的二进制表示:&quot;</span>)</span><br><span class="line">    print_binary(a)</span><br><span class="line">    </span><br><span class="line">    b = -<span class="number">6</span>                                <span class="comment"># 负数示例  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;负数<span class="subst">&#123;b&#125;</span>的二进制表示:&quot;</span>)</span><br><span class="line">    print_binary(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证补码计算</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;~<span class="subst">&#123;a&#125;</span> + 1 = <span class="subst">&#123;~a + <span class="number">1</span>&#125;</span>&quot;</span>)        <span class="comment"># 计算a的相反数</span></span><br><span class="line">    print_binary(~a + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="核心位运算操作"><a href="#核心位运算操作" class="headerlink" title="核心位运算操作"></a>核心位运算操作</h2><h3 id="基本位运算符详解"><a href="#基本位运算符详解" class="headerlink" title="基本位运算符详解"></a>基本位运算符详解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bitwise_operations_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位运算操作演示&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;0b 是Python中表示二进制数字的前缀。&#x27;&#x27;&#x27;</span></span><br><span class="line">    g = <span class="number">0b0001010</span>                         <span class="comment"># 二进制字面量：10</span></span><br><span class="line">    h = <span class="number">0b0001100</span>                         <span class="comment"># 二进制字面量：12</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;操作数g:&quot;</span>, <span class="built_in">bin</span>(g))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;操作数h:&quot;</span>, <span class="built_in">bin</span>(h))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按位或运算：有1则1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g | h  =&quot;</span>, <span class="built_in">bin</span>(g | h))         <span class="comment"># 0b1110 = 14</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按位与运算：全1则1  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g &amp; h  =&quot;</span>, <span class="built_in">bin</span>(g &amp; h))         <span class="comment"># 0b1000 = 8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按位异或运算：不同则1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g ^ h  =&quot;</span>, <span class="built_in">bin</span>(g ^ h))         <span class="comment"># 0b0110 = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shift_operations_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;移位运算演示&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0b0011010</span>                         <span class="comment"># 二进制：26</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;原数: <span class="subst">&#123;i&#125;</span>, 二进制: <span class="subst">&#123;<span class="built_in">bin</span>(i)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 左移运算：相当于乘以2的幂次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> &lt;&lt; 1 = <span class="subst">&#123;i &lt;&lt; <span class="number">1</span>&#125;</span>&quot;</span>)        <span class="comment"># 26 * 2 = 52</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> &lt;&lt; 2 = <span class="subst">&#123;i &lt;&lt; <span class="number">2</span>&#125;</span>&quot;</span>)        <span class="comment"># 26 * 4 = 104  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> &lt;&lt; 3 = <span class="subst">&#123;i &lt;&lt; <span class="number">3</span>&#125;</span>&quot;</span>)        <span class="comment"># 26 * 8 = 208</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 右移运算：相当于除以2的幂次（向下取整）</span></span><br><span class="line">    k = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> &gt;&gt; 1 = <span class="subst">&#123;k &gt;&gt; <span class="number">1</span>&#125;</span>&quot;</span>)        <span class="comment"># 10 / 2 = 5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> &gt;&gt; 2 = <span class="subst">&#123;k &gt;&gt; <span class="number">2</span>&#125;</span>&quot;</span>)        <span class="comment"># 10 / 4 = 2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> &gt;&gt; 3 = <span class="subst">&#123;k &gt;&gt; <span class="number">3</span>&#125;</span>&quot;</span>)        <span class="comment"># 10 / 8 = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算与位运算的重要区别"><a href="#逻辑运算与位运算的重要区别" class="headerlink" title="逻辑运算与位运算的重要区别"></a>逻辑运算与位运算的重要区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">return_true</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行了return_true函数&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_false</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行了return_false函数&quot;</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logical_vs_bitwise</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;演示逻辑运算与位运算的区别&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 位运算测试 ===&quot;</span>)</span><br><span class="line">    <span class="comment"># 位运算：两个函数都会被调用</span></span><br><span class="line">    test1 = return_true() | return_false()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;位运算结果: <span class="subst">&#123;test1&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 逻辑运算测试 ===&quot;</span>) </span><br><span class="line">    <span class="comment"># 逻辑运算：存在短路求值，第二个函数可能不被调用</span></span><br><span class="line">    test2 = return_true() <span class="keyword">or</span> return_false()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;逻辑运算结果: <span class="subst">&#123;test2&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="位运算的实际应用"><a href="#位运算的实际应用" class="headerlink" title="位运算的实际应用"></a>位运算的实际应用</h3><ol>
<li><strong>快速乘除法</strong>：左移代替乘法，右移代替除法</li>
<li><strong>奇偶性判断</strong>：<code>num &amp; 1 == 0</code> 判断偶数。这是因为：num &amp; 1 只保留 num 的二进制最低位，其余全部变成0。</li>
<li><strong>集合操作</strong>：用位掩码表示集合的并、交、差运算</li>
<li><strong>状态压缩</strong>：在动态规划中压缩状态空间</li>
</ol>
<hr>
<h1 id="004【入门】选择、冒泡、插入排序"><a href="#004【入门】选择、冒泡、插入排序" class="headerlink" title="004【入门】选择、冒泡、插入排序"></a>004【入门】选择、冒泡、插入排序</h1><h2 id="理解python中的class：什么是“实例化类”？"><a href="#理解python中的class：什么是“实例化类”？" class="headerlink" title="理解python中的class：什么是“实例化类”？"></a>理解python中的class：什么是“实例化类”？</h2><ul>
<li>类（class）：可以理解为一个“模具”或者“模板”，描述一类对象应该有哪些属性和行为。</li>
<li>实例（instance）：就是根据这个“模具”制造出来的一个具体的“物品”。</li>
<li>实例化：把类变成实例（对象）的过程，叫做实例化。</li>
</ul>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每次从未排序部分选择最小（或最大）元素，将其放置到已排序部分的末尾。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li><strong>比较次数</strong>：$\sum_{i&#x3D;0}^{n-2}(n-1-i) &#x3D; \frac{n(n-1)}{2} &#x3D; O(n^2)$</li>
<li><strong>交换次数</strong>：$O(n)$</li>
<li><strong>总体复杂度</strong>：$O(n^2)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortingAlgorithms</span>:</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        交换数组中两个位置的元素</span></span><br><span class="line"><span class="string">        参数: arr - 数组, i,j - 要交换的索引</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        arr[i], arr[j] = arr[j], arr[i]  <span class="comment"># Python的元组赋值交换</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选择排序实现</span></span><br><span class="line"><span class="string">        时间复杂度: O(n²), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">        不稳定排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:   <span class="comment"># 边界条件检查</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 外层循环控制已排序部分的边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">            min_index = i                  <span class="comment"># 假设当前位置为最小值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 内层循环在未排序部分寻找真正的最小值</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt; arr[min_index]:  <span class="comment"># 找到更小的元素</span></span><br><span class="line">                    min_index = j           <span class="comment"># 更新最小值索引</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将找到的最小值与当前位置交换</span></span><br><span class="line">            SortingAlgorithms.swap(arr, i, min_index)</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>重复遍历数组，比较相邻元素并在必要时交换，使得大元素逐渐”冒泡”到数组末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冒泡排序实现</span></span><br><span class="line"><span class="string">    时间复杂度: O(n²), 空间复杂度: O(1)  </span></span><br><span class="line"><span class="string">    稳定排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:   <span class="comment"># 边界条件检查</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环控制未排序部分的右边界</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内层循环进行相邻元素比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(end):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:    <span class="comment"># 如果前面元素大于后面元素</span></span><br><span class="line">                SortingAlgorithms.swap(arr, i, i + <span class="number">1</span>)  <span class="comment"># 交换位置</span></span><br><span class="line">                <span class="comment"># 经过一轮后，最大元素&quot;冒泡&quot;到末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_optimized</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化版冒泡排序：添加提前终止条件</span></span><br><span class="line"><span class="string">    如果某轮遍历中没有发生交换，说明数组已有序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        swapped = <span class="literal">False</span>               <span class="comment"># 标记本轮是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(end):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:</span><br><span class="line">                SortingAlgorithms.swap(arr, i, i + <span class="number">1</span>)</span><br><span class="line">                swapped = <span class="literal">True</span>        <span class="comment"># 发生了交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:               <span class="comment"># 如果本轮没有交换</span></span><br><span class="line">            <span class="keyword">break</span>                     <span class="comment"># 数组已有序，提前结束</span></span><br></pre></td></tr></table></figure>

<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>将数组分为已排序和未排序两部分，依次将未排序元素插入到已排序部分的正确位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序实现</span></span><br><span class="line"><span class="string">    时间复杂度: 最坏O(n²), 最好O(n), 平均O(n²)</span></span><br><span class="line"><span class="string">    空间复杂度: O(1)</span></span><br><span class="line"><span class="string">    稳定排序，对小规模或近似有序数据效率高</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:   <span class="comment"># 边界条件检查</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从第二个元素开始，逐个插入到已排序部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 从当前位置向前比较，寻找插入位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:    <span class="comment"># 如果前面元素大于后面元素</span></span><br><span class="line">                SortingAlgorithms.swap(arr, j, j + <span class="number">1</span>)  <span class="comment"># 交换位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>                  <span class="comment"># 找到正确位置，提前结束内层循环</span></span><br></pre></td></tr></table></figure>

<h3 id="插入排序的另一种实现"><a href="#插入排序的另一种实现" class="headerlink" title="插入排序的另一种实现"></a>插入排序的另一种实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort_v2</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    插入排序的另一种实现：先保存要插入的元素，然后移动其他元素</span></span><br><span class="line"><span class="string">    减少交换次数，提高效率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]                  <span class="comment"># 保存要插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span>                     <span class="comment"># 从已排序部分的末尾开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向右移动大于key的元素</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]       <span class="comment"># 元素后移</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        arr[j + <span class="number">1</span>] = key              <span class="comment"># 插入key到正确位置</span></span><br></pre></td></tr></table></figure>

<h2 id="排序算法性能对比"><a href="#排序算法性能对比" class="headerlink" title="排序算法性能对比"></a>排序算法性能对比</h2><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度(最好)</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
</tbody></table>
<hr>
<h1 id="005【入门】对数器-验证的重要手段"><a href="#005【入门】对数器-验证的重要手段" class="headerlink" title="005【入门】对数器-验证的重要手段"></a>005【入门】对数器-验证的重要手段</h1><h2 id="对数器的理论基础"><a href="#对数器的理论基础" class="headerlink" title="对数器的理论基础"></a>对数器的理论基础</h2><p>对数器（Logarithmic Validator）是一种系统性验证算法正确性的重要工具，通过大量随机测试用例来检验算法实现的可靠性。</p>
<h3 id="对数器设计的六个核心原则"><a href="#对数器设计的六个核心原则" class="headerlink" title="对数器设计的六个核心原则"></a>对数器设计的六个核心原则</h3><ol>
<li><strong>确定待测算法a</strong>：需要验证正确性的高效算法</li>
<li><strong>实现简单算法b</strong>：复杂度可能不优但逻辑简单、容易验证正确的算法  </li>
<li><strong>构建随机样本生成器</strong>：能够产生各种边界情况的测试数据</li>
<li><strong>对比验证</strong>：在相同输入下比较两种算法的输出结果</li>
<li><strong>错误定位</strong>：当发现不一致时，人工分析并修正错误</li>
<li><strong>大规模验证</strong>：通过大量测试建立对算法正确性的信心</li>
</ol>
<h2 id="对数器实现框架（以上节课的三种排序方法为例）"><a href="#对数器实现框架（以上节课的三种排序方法为例）" class="headerlink" title="对数器实现框架（以上节课的三种排序方法为例）"></a>对数器实现框架（以上节课的三种排序方法为例）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlgorithmValidator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;算法验证器类&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">random_array</span>(<span class="params">n, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成随机数组</span></span><br><span class="line"><span class="string">        参数: n - 数组长度, v - 元素值域[1,v]</span></span><br><span class="line"><span class="string">        返回: 长度为n的随机数组</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用列表推导式生成随机数组</span></span><br><span class="line">        <span class="keyword">return</span> [random.randint(<span class="number">1</span>, v) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy_array</span>(<span class="params">arr</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        数组深拷贝</span></span><br><span class="line"><span class="string">        参数: arr - 原数组</span></span><br><span class="line"><span class="string">        返回: 原数组的副本</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> arr[:]                     <span class="comment"># 切片操作创建新列表</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrays_equal</span>(<span class="params">arr1, arr2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        比较两个数组是否相等</span></span><br><span class="line"><span class="string">        参数: arr1, arr2 - 待比较的数组</span></span><br><span class="line"><span class="string">        返回: 布尔值表示是否相等</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr1) != <span class="built_in">len</span>(arr2):        <span class="comment"># 长度不等直接返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 逐元素比较</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(arr1, arr2):</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">comprehensive_sort_test</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        排序算法综合测试</span></span><br><span class="line"><span class="string">        使用对数器方法验证多种排序算法的正确性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 测试参数配置</span></span><br><span class="line">        N = <span class="number">200</span>                          <span class="comment"># 数组最大长度</span></span><br><span class="line">        V = <span class="number">1000</span>                         <span class="comment"># 元素最大值</span></span><br><span class="line">        test_times = <span class="number">50000</span>               <span class="comment"># 测试次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;算法验证开始...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> test_round <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">            <span class="comment"># 生成随机测试用例</span></span><br><span class="line">            n = random.randint(<span class="number">0</span>, N - <span class="number">1</span>)  <span class="comment"># 随机数组长度</span></span><br><span class="line">            arr = AlgorithmValidator.random_array(n, V)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 创建多个数组副本用于不同算法测试</span></span><br><span class="line">            arr_selection = AlgorithmValidator.copy_array(arr)</span><br><span class="line">            arr_bubble = AlgorithmValidator.copy_array(arr)  </span><br><span class="line">            arr_insertion = AlgorithmValidator.copy_array(arr)</span><br><span class="line">            arr_builtin = AlgorithmValidator.copy_array(arr)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 应用不同排序算法</span></span><br><span class="line">            SortingAlgorithms.selection_sort(arr_selection)</span><br><span class="line">            SortingAlgorithms.bubble_sort(arr_bubble)</span><br><span class="line">            SortingAlgorithms.insertion_sort(arr_insertion)</span><br><span class="line">            arr_builtin.sort()            <span class="comment"># Python内置排序作为标准答案</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 结果一致性验证</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (AlgorithmValidator.arrays_equal(arr_selection, arr_builtin) <span class="keyword">and</span></span><br><span class="line">                    AlgorithmValidator.arrays_equal(arr_bubble, arr_builtin) <span class="keyword">and</span>  </span><br><span class="line">                    AlgorithmValidator.arrays_equal(arr_insertion, arr_builtin)):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 发现错误时输出详细信息</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;发现算法错误!&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;测试轮次: <span class="subst">&#123;test_round + <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;原始数组: <span class="subst">&#123;arr&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;选择排序: <span class="subst">&#123;arr_selection&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;冒泡排序: <span class="subst">&#123;arr_bubble&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;插入排序: <span class="subst">&#123;arr_insertion&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;内置排序: <span class="subst">&#123;arr_builtin&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 每完成1000次测试输出进度</span></span><br><span class="line">            <span class="keyword">if</span> (test_round + <span class="number">1</span>) % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;已完成 <span class="subst">&#123;test_round + <span class="number">1</span>&#125;</span> 次测试...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;所有测试通过！算法实现正确。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="对数器方法的优势"><a href="#对数器方法的优势" class="headerlink" title="对数器方法的优势"></a>对数器方法的优势</h3><ol>
<li><strong>自动化验证</strong>：减少人工测试的工作量和错误率</li>
<li><strong>覆盖边界情况</strong>：随机生成能够触及各种极端情况</li>
<li><strong>置信度建立</strong>：大量测试通过后可以高度确信算法正确性</li>
<li><strong>错误定位</strong>：一旦发现问题能够提供具体的错误样例</li>
</ol>
<hr>
<h1 id="006【入门】二分搜索"><a href="#006【入门】二分搜索" class="headerlink" title="006【入门】二分搜索"></a>006【入门】二分搜索</h1><h2 id="二分搜索的数学基础"><a href="#二分搜索的数学基础" class="headerlink" title="二分搜索的数学基础"></a>二分搜索的数学基础</h2><p>二分搜索基于<strong>分治思想</strong>，每次将搜索空间减半，时间复杂度为 $O(\log n)$。</p>
<p>设数组长度为 $n$，经过 $k$ 次二分后搜索空间大小为 $\frac{n}{2^k}$，当搜索空间减小到1时：</p>
<p>$$\frac{n}{2^k} &#x3D; 1 \Rightarrow k &#x3D; \log_2 n$$</p>
<h2 id="基础二分搜索"><a href="#基础二分搜索" class="headerlink" title="基础二分搜索"></a>基础二分搜索</h2><h3 id="问题：判断有序数组中是否存在目标值"><a href="#问题：判断有序数组中是否存在目标值" class="headerlink" title="问题：判断有序数组中是否存在目标值"></a>问题：判断有序数组中是否存在目标值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_exist</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在有序数组中查找目标值是否存在</span></span><br><span class="line"><span class="string">    参数: arr - 有序数组, target - 目标值</span></span><br><span class="line"><span class="string">    返回: True/False 表示是否存在</span></span><br><span class="line"><span class="string">    时间复杂度: O(log n), 空间复杂度: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:      <span class="comment"># 边界条件：空数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>         <span class="comment"># 初始化搜索边界[left, right]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:                  <span class="comment"># 搜索空间非空时继续</span></span><br><span class="line">        <span class="comment"># 防止整数溢出的中点计算方法</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span>   <span class="comment"># 等价于 (left + right) // 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:            <span class="comment"># 找到目标值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; target:           <span class="comment"># 目标值在左半部分</span></span><br><span class="line">            right = mid - <span class="number">1</span>               <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 目标值在右半部分  </span></span><br><span class="line">            left = mid + <span class="number">1</span>                <span class="comment"># 收缩左边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>                          <span class="comment"># 搜索完毕未找到</span></span><br></pre></td></tr></table></figure>

<h3 id="暴力验证方法"><a href="#暴力验证方法" class="headerlink" title="暴力验证方法"></a>暴力验证方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search_exist</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    线性搜索验证方法</span></span><br><span class="line"><span class="string">    用于对数器验证二分搜索的正确性</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> arr:                   <span class="comment"># 遍历数组每个元素</span></span><br><span class="line">        <span class="keyword">if</span> element == target:             <span class="comment"># 找到目标值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>                          <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure>

<h2 id="二分搜索的边界查找变种"><a href="#二分搜索的边界查找变种" class="headerlink" title="二分搜索的边界查找变种"></a>二分搜索的边界查找变种</h2><h3 id="查找左边界：-target的最左位置"><a href="#查找左边界：-target的最左位置" class="headerlink" title="查找左边界：&gt;&#x3D;target的最左位置"></a>查找左边界：&gt;&#x3D;target的最左位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在有序数组中查找 &gt;= target 的最左位置</span></span><br><span class="line"><span class="string">    参数: arr - 有序数组, target - 目标值</span></span><br><span class="line"><span class="string">    返回: 满足条件的最左索引，不存在返回-1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    ans = -<span class="number">1</span>                              <span class="comment"># 记录答案，初始化为-1表示未找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:            <span class="comment"># 当前元素满足条件</span></span><br><span class="line">            ans = mid                     <span class="comment"># 更新答案</span></span><br><span class="line">            right = mid - <span class="number">1</span>               <span class="comment"># 继续在左半部分寻找更左的位置</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 当前元素小于target</span></span><br><span class="line">            left = mid + <span class="number">1</span>                <span class="comment"># 在右半部分继续搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search_left_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性搜索验证：查找&gt;=target的最左位置&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):             <span class="comment"># 从左到右遍历</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt;= target:              <span class="comment"># 找到第一个满足条件的位置</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                             <span class="comment"># 未找到</span></span><br></pre></td></tr></table></figure>

<h3 id="查找右边界："><a href="#查找右边界：" class="headerlink" title="查找右边界：&lt;&#x3D;target的最右位置"></a>查找右边界：&lt;&#x3D;target的最右位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在有序数组中查找 &lt;= target 的最右位置</span></span><br><span class="line"><span class="string">    参数: arr - 有序数组, target - 目标值  </span></span><br><span class="line"><span class="string">    返回: 满足条件的最右索引，不存在返回-1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    ans = -<span class="number">1</span>                              <span class="comment"># 记录答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt;= target:            <span class="comment"># 当前元素满足条件</span></span><br><span class="line">            ans = mid                     <span class="comment"># 更新答案</span></span><br><span class="line">            left = mid + <span class="number">1</span>                <span class="comment"># 继续在右半部分寻找更右的位置</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 当前元素大于target</span></span><br><span class="line">            right = mid - <span class="number">1</span>               <span class="comment"># 在左半部分继续搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search_right_bound</span>(<span class="params">arr, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性搜索验证：查找&lt;=target的最右位置&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 从右到左遍历</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= target:              <span class="comment"># 找到第一个满足条件的位置</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                             <span class="comment"># 未找到</span></span><br></pre></td></tr></table></figure>

<h2 id="峰值元素查找"><a href="#峰值元素查找" class="headerlink" title="峰值元素查找"></a>峰值元素查找</h2><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>在数组中找到任意一个峰值元素（比左右邻居都大的元素），假设边界外的元素为负无穷。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_peak_element</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找数组中的峰值元素</span></span><br><span class="line"><span class="string">    参数: arr - 整数数组（相邻元素不相等）</span></span><br><span class="line"><span class="string">    返回: 任意峰值元素的索引</span></span><br><span class="line"><span class="string">    时间复杂度: O(log n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 边界情况处理</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:                            <span class="comment"># 单元素数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>]:                   <span class="comment"># 第一个元素是峰值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">if</span> arr[n-<span class="number">1</span>] &gt; arr[n-<span class="number">2</span>]:              <span class="comment"># 最后一个元素是峰值</span></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在 [1, n-2] 范围内二分搜索</span></span><br><span class="line">    left, right = <span class="number">1</span>, n - <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> arr[mid-<span class="number">1</span>] &gt; arr[mid]:         <span class="comment"># 左邻居更大，峰值在左半部分</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; arr[mid+<span class="number">1</span>]:       <span class="comment"># 右邻居更大，峰值在右半部分  </span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># arr[mid-1] &lt; arr[mid] &gt; arr[mid+1]</span></span><br><span class="line">            <span class="keyword">return</span> mid                    <span class="comment"># 找到峰值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                             <span class="comment"># 理论上不会到达这里</span></span><br></pre></td></tr></table></figure>

<h3 id="峰值查找的正确性证明"><a href="#峰值查找的正确性证明" class="headerlink" title="峰值查找的正确性证明"></a>峰值查找的正确性证明</h3><p><strong>定理</strong>：在满足相邻元素不相等的数组中，上述算法一定能找到峰值。</p>
<p><strong>证明</strong>：</p>
<ol>
<li>边界已处理端点峰值。</li>
<li>二分查找时，每次都能缩小到含有峰值的半区。</li>
<li>因为每次都“爬坡”，必然最终会达到一个峰值。</li>
<li>相邻元素不等消除了平台的歧义。</li>
<li>因此，算法在O(log n)时间内一定能找到一个峰值。</li>
</ol>
<h2 id="二分搜索验证框架"><a href="#二分搜索验证框架" class="headerlink" title="二分搜索验证框架"></a>二分搜索验证框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_binary_search_algorithms</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分搜索算法综合测试&quot;&quot;&quot;</span></span><br><span class="line">    N = <span class="number">100</span>                               <span class="comment"># 数组最大长度</span></span><br><span class="line">    V = <span class="number">1000</span>                              <span class="comment"># 元素值域</span></span><br><span class="line">    test_times = <span class="number">500000</span>                   <span class="comment"># 测试次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二分搜索算法测试开始...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">        <span class="comment"># 生成随机有序数组</span></span><br><span class="line">        n = random.randint(<span class="number">0</span>, N - <span class="number">1</span>)</span><br><span class="line">        arr = [random.randint(<span class="number">1</span>, V) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        arr.sort()                        <span class="comment"># 确保数组有序</span></span><br><span class="line">        </span><br><span class="line">        target = random.randint(<span class="number">0</span>, V - <span class="number">1</span>) <span class="comment"># 随机目标值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 验证基础二分搜索</span></span><br><span class="line">        <span class="keyword">if</span> binary_search_exist(arr, target) != linear_search_exist(arr, target):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;基础二分搜索错误!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 验证左边界查找    </span></span><br><span class="line">        <span class="keyword">if</span> binary_search_left_bound(arr, target) != linear_search_left_bound(arr, target):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;左边界查找错误!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 验证右边界查找</span></span><br><span class="line">        <span class="keyword">if</span> binary_search_right_bound(arr, target) != linear_search_right_bound(arr, target):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;右边界查找错误!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有二分搜索测试通过!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="007【入门】时间复杂度和空间复杂度"><a href="#007【入门】时间复杂度和空间复杂度" class="headerlink" title="007【入门】时间复杂度和空间复杂度"></a>007【入门】时间复杂度和空间复杂度</h1><h2 id="时间复杂度的数学基础"><a href="#时间复杂度的数学基础" class="headerlink" title="时间复杂度的数学基础"></a>时间复杂度的数学基础</h2><h3 id="渐近记号系统"><a href="#渐近记号系统" class="headerlink" title="渐近记号系统"></a>渐近记号系统</h3><p>设 $f(n)$ 和 $g(n)$ 为定义在正整数集上的函数：</p>
<ul>
<li><strong>大O记号</strong> $O(g(n))$：$f(n) &#x3D; O(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \geq n_0$ 有 $f(n) \leq c \cdot g(n)$</li>
<li><strong>大Ω记号</strong> $\Omega(g(n))$：$f(n) &#x3D; \Omega(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \geq n_0$ 有 $f(n) \geq c \cdot g(n)$  </li>
<li><strong>大Θ记号</strong> $\Theta(g(n))$：$f(n) &#x3D; \Theta(g(n))$ 当且仅当 $f(n) &#x3D; O(g(n))$ 且 $f(n) &#x3D; \Omega(g(n))$</li>
</ul>
<p>其实和泛函的函数的范数有点像，也就是这个映射算是有界的那种感觉。</p>
<h3 id="常见复杂度级别"><a href="#常见复杂度级别" class="headerlink" title="常见复杂度级别"></a>常见复杂度级别</h3><p>$$O(1) &lt; O(\log n) &lt; O(n) &lt; O(n \log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$$</p>
<h2 id="复杂嵌套循环分析"><a href="#复杂嵌套循环分析" class="headerlink" title="复杂嵌套循环分析"></a>复杂嵌套循环分析</h2><h3 id="等差数列型循环"><a href="#等差数列型循环" class="headerlink" title="等差数列型循环"></a>等差数列型循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quadratic_complexity_demo</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示O(n²)时间复杂度</span></span><br><span class="line"><span class="string">    等差数列求和：1 + 2 + ... + n = n(n+1)/2 = O(n²)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    operations = <span class="number">0</span>                        <span class="comment"># 记录操作次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):            <span class="comment"># 外层循环：i从1到N</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N + <span class="number">1</span>):        <span class="comment"># 内层循环：j从i到N</span></span><br><span class="line">            operations += <span class="number">1</span>               <span class="comment"># 模拟一次基本操作</span></span><br><span class="line">            <span class="comment"># 当i=1时，内层执行N次</span></span><br><span class="line">            <span class="comment"># 当i=2时，内层执行N-1次  </span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            <span class="comment"># 当i=N时，内层执行1次</span></span><br><span class="line">            <span class="comment"># 总计：N + (N-1) + ... + 1 = N(N+1)/2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N=<span class="subst">&#123;N&#125;</span>, 总操作次数=<span class="subst">&#123;operations&#125;</span>, 理论值=<span class="subst">&#123;N*(N+<span class="number">1</span>)//<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> operations</span><br></pre></td></tr></table></figure>

<h3 id="调和级数型循环"><a href="#调和级数型循环" class="headerlink" title="调和级数型循环"></a>调和级数型循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">n_log_n_complexity_demo</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示O(n log n)时间复杂度  </span></span><br><span class="line"><span class="string">    调和级数：1 + 1/2 + 1/3 + ... + 1/n ≈ ln(n) = O(log n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    operations = <span class="number">0</span>                        <span class="comment"># 记录操作次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):            <span class="comment"># 外层循环：i从1到N</span></span><br><span class="line">        j = i                             <span class="comment"># 内层循环起始值</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= N:                     <span class="comment"># 按i的倍数递增</span></span><br><span class="line">            operations += <span class="number">1</span>               <span class="comment"># 模拟一次基本操作</span></span><br><span class="line">            j += i                        <span class="comment"># j = i, 2i, 3i, ...</span></span><br><span class="line">            <span class="comment"># 当i=1时，内层执行N次（N/1）</span></span><br><span class="line">            <span class="comment"># 当i=2时，内层执行N/2次</span></span><br><span class="line">            <span class="comment"># 当i=3时，内层执行N/3次</span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            <span class="comment"># 总计：N(1 + 1/2 + 1/3 + ... + 1/N) = N·H_N ≈ N log N</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N=<span class="subst">&#123;N&#125;</span>, 总操作次数=<span class="subst">&#123;operations&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> operations</span><br></pre></td></tr></table></figure>

<h3 id="复杂度实验验证"><a href="#复杂度实验验证" class="headerlink" title="复杂度实验验证"></a>复杂度实验验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">complexity_benchmark</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过实际运行时间验证复杂度分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    test_sizes = [<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">8000</span>]   <span class="comment"># 测试规模</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 复杂度实验验证 ===&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;规模\tO(n²)时间\tO(n log n)时间\t比率&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> N <span class="keyword">in</span> test_sizes:</span><br><span class="line">        <span class="comment"># 测试O(n²)算法</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        quadratic_complexity_demo(N)</span><br><span class="line">        quadratic_time = time.time() - start_time</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 测试O(n log n)算法  </span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        n_log_n_complexity_demo(N)</span><br><span class="line">        n_log_n_time = time.time() - start_time</span><br><span class="line">        </span><br><span class="line">        ratio = quadratic_time / n_log_n_time <span class="keyword">if</span> n_log_n_time &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;N&#125;</span>\t<span class="subst">&#123;quadratic_time:<span class="number">.4</span>f&#125;</span>s\t<span class="subst">&#123;n_log_n_time:<span class="number">.4</span>f&#125;</span>s\t<span class="subst">&#123;ratio:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="单循环冒泡排序的复杂度分析"><a href="#单循环冒泡排序的复杂度分析" class="headerlink" title="单循环冒泡排序的复杂度分析"></a>单循环冒泡排序的复杂度分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">single_loop_bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用单个循环实现冒泡排序</span></span><br><span class="line"><span class="string">    虽然只有一个while循环，但时间复杂度仍然是O(n²)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    end = n - <span class="number">1</span>                           <span class="comment"># 未排序部分的右边界</span></span><br><span class="line">    i = <span class="number">0</span>                                 <span class="comment"># 当前比较位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> end &gt; <span class="number">0</span>:                        <span class="comment"># 外层逻辑：控制轮次</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]:          <span class="comment"># 相邻元素比较</span></span><br><span class="line">            arr[i], arr[i + <span class="number">1</span>] = arr[i + <span class="number">1</span>], arr[i]  <span class="comment"># 交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &lt; end - <span class="number">1</span>:                   <span class="comment"># 当前轮次未结束</span></span><br><span class="line">            i += <span class="number">1</span>                        <span class="comment"># 移动到下一个比较位置</span></span><br><span class="line">        <span class="keyword">else</span>:                             <span class="comment"># 当前轮次结束</span></span><br><span class="line">            end -= <span class="number">1</span>                      <span class="comment"># 缩小未排序范围</span></span><br><span class="line">            i = <span class="number">0</span>                         <span class="comment"># 重置比较位置</span></span><br><span class="line">            <span class="comment"># 虽然是单循环，但逻辑上等价于双层嵌套</span></span><br><span class="line">            <span class="comment"># 时间复杂度仍为O(n²)</span></span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><h3 id="动态数组的均摊复杂度分析"><a href="#动态数组的均摊复杂度分析" class="headerlink" title="动态数组的均摊复杂度分析"></a>动态数组的均摊复杂度分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_array_analysis</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    动态数组扩容的均摊复杂度分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    arr = []                              <span class="comment"># 初始空数组</span></span><br><span class="line">    operations = []                       <span class="comment"># 记录每次操作的代价</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):                   <span class="comment"># 插入16个元素</span></span><br><span class="line">        old_capacity = <span class="built_in">len</span>(arr)           <span class="comment"># 当前容量</span></span><br><span class="line">        arr.append(i)                     <span class="comment"># 插入元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟扩容过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; old_capacity:       <span class="comment"># 发生了扩容</span></span><br><span class="line">            <span class="comment"># Python的list实际扩容策略比较复杂，这里简化为2倍扩容</span></span><br><span class="line">            cost = old_capacity            <span class="comment"># 扩容代价：复制所有旧元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cost = <span class="number">1</span>                      <span class="comment"># 普通插入代价</span></span><br><span class="line">        </span><br><span class="line">        operations.append(cost)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;插入元素<span class="subst">&#123;i&#125;</span>, 当前大小=<span class="subst">&#123;<span class="built_in">len</span>(arr)&#125;</span>, 本次代价=<span class="subst">&#123;cost&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    total_cost = <span class="built_in">sum</span>(operations)</span><br><span class="line">    average_cost = total_cost / <span class="built_in">len</span>(operations)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总代价=<span class="subst">&#123;total_cost&#125;</span>, 平均代价=<span class="subst">&#123;average_cost:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数学分析：</span></span><br><span class="line">    <span class="comment"># 扩容发生在容量为1,2,4,8,...时</span></span><br><span class="line">    <span class="comment"># 总扩容代价：0 + 1 + 2 + 4 + 8 + ... &lt; 2n</span></span><br><span class="line">    <span class="comment"># 总插入代价：n  </span></span><br><span class="line">    <span class="comment"># 均摊代价：(2n + n) / n = 3 = O(1)</span></span><br></pre></td></tr></table></figure>

<h3 id="递归算法的空间复杂度"><a href="#递归算法的空间复杂度" class="headerlink" title="递归算法的空间复杂度"></a>递归算法的空间复杂度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_space_analysis</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归算法空间复杂度分析</span></span><br><span class="line"><span class="string">    计算阶乘的递归实现</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:                           <span class="comment"># 基础情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每次递归调用占用O(1)空间</span></span><br><span class="line">    <span class="comment"># 最大递归深度为n，所以空间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">return</span> n * recursive_space_analysis(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_space_analysis</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    迭代版本的阶乘计算</span></span><br><span class="line"><span class="string">    空间复杂度为O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="number">1</span>                           <span class="comment"># 只使用常数额外空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析的实用技巧"><a href="#复杂度分析的实用技巧" class="headerlink" title="复杂度分析的实用技巧"></a>复杂度分析的实用技巧</h2><h3 id="主定理（Master-Theorem）"><a href="#主定理（Master-Theorem）" class="headerlink" title="主定理（Master Theorem）"></a>主定理（Master Theorem）</h3><p>对于递归关系 $T(n) &#x3D; aT(\frac{n}{b}) + f(n)$，其中 $a \geq 1, b &gt; 1$：</p>
<ul>
<li>如果 $f(n) &#x3D; O(n^{\log_b a - \epsilon})$，则 $T(n) &#x3D; \Theta(n^{\log_b a})$</li>
<li>如果 $f(n) &#x3D; \Theta(n^{\log_b a})$，则 $T(n) &#x3D; \Theta(n^{\log_b a} \log n)$  </li>
<li>如果 $f(n) &#x3D; \Omega(n^{\log_b a + \epsilon})$，则 $T(n) &#x3D; \Theta(f(n))$</li>
</ul>
<h3 id="均摊分析方法"><a href="#均摊分析方法" class="headerlink" title="均摊分析方法"></a>均摊分析方法</h3><ul>
<li><strong>聚合分析</strong>：分析一系列操作的总代价</li>
<li><strong>核算法</strong>：为每种操作分配均摊代价</li>
<li><strong>势能法</strong>：定义势能函数分析代价分布</li>
</ul>
<h3 id="实际性能考虑因素"><a href="#实际性能考虑因素" class="headerlink" title="实际性能考虑因素"></a>实际性能考虑因素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">practical_performance_factors</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    影响实际性能的因素</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;影响算法实际性能的因素：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1. 常数因子：O(n)算法的常数可能很大&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2. 数据规模：小规模时简单算法可能更快&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3. 内存访问模式：缓存友好的算法性能更好&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4. 分支预测：减少条件分支可提高性能&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5. 编译器优化：现代编译器能显著优化代码&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6. 硬件特性：利用SIMD等特性可大幅提速&quot;</span>)</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/" class="post-title-link" itemprop="url">24 Spring - 概率论课程判断题留档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-30 11:42:46" itemprop="dateCreated datePublished" datetime="2025-07-30T11:42:46+08:00">2025-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:20:14" itemprop="dateModified" datetime="2025-08-02T12:20:14+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coursework/" itemprop="url" rel="index"><span itemprop="name">Coursework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  longlongago之前的概率论判断题作业，记录一下</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/概率论判断题大全.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/" class="post-title-link" itemprop="url">25 Spring - 模式识别笔记(5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-17 18:42:46" itemprop="dateCreated datePublished" datetime="2025-06-17T18:42:46+08:00">2025-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:21:04" itemprop="dateModified" datetime="2025-08-02T12:21:04+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Course/" itemprop="url" rel="index"><span itemprop="name">Course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式识别期末笔记"><a href="#模式识别期末笔记" class="headerlink" title="模式识别期末笔记"></a>模式识别期末笔记</h1><p>基于模式识别期末考纲最后一个part，符号源于课程讲义，整理了关于MLP及其网络训练、反向传播算法的相关笔记。</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/模式识别期末_MLP.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">25 Spring - 模式识别笔记(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-17 10:42:46" itemprop="dateCreated datePublished" datetime="2025-06-17T10:42:46+08:00">2025-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:20:58" itemprop="dateModified" datetime="2025-08-02T12:20:58+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Course/" itemprop="url" rel="index"><span itemprop="name">Course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式识别期末笔记"><a href="#模式识别期末笔记" class="headerlink" title="模式识别期末笔记"></a>模式识别期末笔记</h1><p>基于模式识别期末考纲第四个和第五个part，符号源于课程讲义，整理了关于混合模型分类（GMM），EM算法及其变分表示以及MM算法的相关笔记。</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/模式识别期末_EM算法及其变种.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/16/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/16/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">25 Spring - 模式识别笔记(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-16 18:42:46" itemprop="dateCreated datePublished" datetime="2025-06-16T18:42:46+08:00">2025-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:20:52" itemprop="dateModified" datetime="2025-08-02T12:20:52+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Course/" itemprop="url" rel="index"><span itemprop="name">Course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式识别期末笔记"><a href="#模式识别期末笔记" class="headerlink" title="模式识别期末笔记"></a>模式识别期末笔记</h1><p>基于模式识别期末考纲前三个part，符号源于课程讲义，整理了关于K-means 聚类及其变分表达、熵正则与空间正则的相关笔记。用markdown在网页上做笔记还是太费劲了，回归latex！</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/K-means 聚类及其变分表达、熵正则与空间正则.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/10/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/10/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">25 Spring - 模式识别笔记(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-10 18:42:46" itemprop="dateCreated datePublished" datetime="2025-05-10T18:42:46+08:00">2025-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:20:45" itemprop="dateModified" datetime="2025-08-02T12:20:45+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Course/" itemprop="url" rel="index"><span itemprop="name">Course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模式识别笔记汇总"><a href="#模式识别笔记汇总" class="headerlink" title="模式识别笔记汇总"></a>模式识别笔记汇总</h1><p>本次笔记主要关于K-Means 及其变分问题、熵不等式、Softmax&#x2F;Softmin 函数、数值稳定化、以及泛函与方向导数等内容。</p>
<hr>
<h2 id="K-Means-基本原理与能量函数"><a href="#K-Means-基本原理与能量函数" class="headerlink" title="K-Means 基本原理与能量函数"></a>K-Means 基本原理与能量函数</h2><h3 id="K-Means-能量函数的定义"><a href="#K-Means-能量函数的定义" class="headerlink" title="K-Means 能量函数的定义"></a>K-Means 能量函数的定义</h3><p>K-Means 算法的能量函数（目标函数）定义如下：</p>
<p>$$<br>E(\vec{U}, \vec{C})<br>&#x3D; \sum_{x \in \Omega} \sum_{k&#x3D;1}^{K} \bigl(f(x) - C_k\bigr)^2  U_k(x)<br>$$</p>
<p>其中：</p>
<ul>
<li>$ f(x) $ 表示数据点 $ x $ 的特征值；</li>
<li>$ C_k $ 表示第 $ k $ 个聚类中心；</li>
<li>$ U_k(x) $ 为归属矩阵的元素，表示数据点 $ x $ 是否属于第 $ k $ 个簇（在硬分类中，取值为 0 或 1）。</li>
</ul>
<p>然后定义</p>
<p>$$<br>\langle \overrightarrow{O}, \overrightarrow{u} \rangle &#x3D; \sum_{x \in \Omega} \sum_{k&#x3D;1}^{K} O_k(x) \cdot u_k(x)<br>$$</p>
<p>其中误差函数为：</p>
<p>$$<br>O_k(x) &#x3D; \bigl(f(x) - C_k\bigr)^2<br>$$</p>
<p>该能量函数也可用内积的形式表示：</p>
<p>$$<br>E(\vec{U}, \vec{C}) &#x3D; \langle \vec{O}, \vec{U} \rangle<br>$$</p>
<p>其中 $\vec{O}$ 为一个误差向量。</p>
<hr>
<h3 id="K-Means-算法的迭代更新规则"><a href="#K-Means-算法的迭代更新规则" class="headerlink" title="K-Means 算法的迭代更新规则"></a>K-Means 算法的迭代更新规则</h3><p>K-Means 算法通过两步交替迭代来最小化能量函数 $E(\vec{U}, \vec{C})$：</p>
<ol>
<li><p><strong>更新归属矩阵</strong> $\vec{U}^{t+1}$：</p>
<p>$$<br>\vec{U}^{t+1} &#x3D; \arg \min_{\vec{U}}  E(\vec{U}, \vec{C}^t)<br>$$</p>
<p>具体到每个样本点 $x$ 的更新规则为：</p>
  
   $$
   U_k^{t+1}(x)= 
   \begin{cases}
   1, & \text{if} k = \arg \min_{k \in \{1, \dots, K\}} (f(x) - C_k^t)^2 \\
   0, & \text{otherwise}
   \end{cases}
   $$
     

<p>即将每个数据点分配给距离其最近的簇中心。</p>
</li>
<li><p><strong>更新聚类中心</strong> $\vec{C}^{t+1}$：</p>
<p>$$<br>\vec{C}^{t+1} &#x3D; \arg \min_{\vec{C}}  E\bigl(\vec{U}^{t+1}, \vec{C}\bigr)<br>$$</p>
<p>即对每个簇的样本求均值，作为新的聚类中心。</p>
</li>
</ol>
<hr>
<h3 id="误差函数与误差向量"><a href="#误差函数与误差向量" class="headerlink" title="误差函数与误差向量"></a>误差函数与误差向量</h3><p>定义误差函数：</p>
<p>$$<br>O_k(x) &#x3D; \bigl(f(x) - C_k\bigr)^2<br>$$</p>
<p>令</p>
<p>$$<br>\vec{O}(x) &#x3D; \bigl(O_1(x), O_2(x), \dots, O_K(x)\bigr)^\mathsf{T},<br>$$</p>
<p>则 $\vec{O}$ 是一个向量值函数，映射</p>
<p>$$<br>\vec{O}: \Omega \subseteq \mathbb{R}^2 \to \mathbb{R}^K.<br>$$</p>
<hr>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li>K-Means 采用<strong>硬聚类</strong>方式，每个数据点只能属于一个簇，$U_k(x) \in {0,1}$。</li>
<li>优化目标：在每次迭代中，先更新 $\vec{U}$，再更新 $\vec{C}$，直至收敛。</li>
<li>计算复杂度：主要与数据点数 $N$ 和簇数 $K$ 有关，通常为 $O(NKT)$（$T$ 为迭代次数）。</li>
</ul>
<hr>
<h2 id="K-Means-的变分问题与熵的性质"><a href="#K-Means-的变分问题与熵的性质" class="headerlink" title="K-Means 的变分问题与熵的性质"></a>K-Means 的变分问题与熵的性质</h2><h3 id="K-Means-变分问题"><a href="#K-Means-变分问题" class="headerlink" title="K-Means 变分问题"></a>K-Means 变分问题</h3><p>我们希望最小化下述能量函数：</p>
<p>$$<br>\min_{\vec{U}, \vec{C}} E(\vec{U}, \vec{C})<br>$$</p>
<p>其中 $\vec{U}$ 为归属矩阵，$\vec{C}$ 为聚类中心。</p>
<p>除硬划分之外，还可使用许多优化或正则化技巧，例如引入<strong>软分类</strong>思想（softmax &#x2F; softmin）的方法。</p>
<hr>
<h3 id="熵的性质"><a href="#熵的性质" class="headerlink" title="熵的性质"></a>熵的性质</h3><p>在分析 K-Means 变分问题时，引入熵的一条不等式，用于约束归属矩阵的对数项：</p>
<p>$$<br>-\ln K<br>\le \langle \vec{U}, \ln \vec{U} \rangle<br>\le 0<br>$$</p>
<p>其中：</p>
<ul>
<li>$U_k$ 表示数据点对第 $k$ 个簇的归属概率（软分类时可在 $[0,1]$ 之间）；</li>
<li>$\langle \vec{U}, \ln \vec{U}\rangle &#x3D; \sum_{k&#x3D;1}^{K} U_k \ln U_k$ 是熵相关的项。</li>
</ul>
<p>该不等式可以用 Jensen 不等式等方法证明。等号成立的两种情况为：</p>
<ul>
<li>左边等号：所有 $U_k &#x3D; \frac{1}{K}$，即均匀分布；</li>
<li>右边等号：某一个 $U_k&#x3D;1$，其它为 0，即完全硬分类。</li>
</ul>
<hr>
<h3 id="变分方法的直观解释"><a href="#变分方法的直观解释" class="headerlink" title="变分方法的直观解释"></a>变分方法的直观解释</h3><ul>
<li><strong>最优化角度</strong>：寻找最优的 $\vec{U}, \vec{C}$ 使得数据点与簇中心的总体误差最小；</li>
<li><strong>信息论角度</strong>：考虑信息熵约束，避免过度偏向某一簇，从而获得更合理的簇划分。</li>
</ul>
<hr>
<h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h3><ul>
<li>熵的约束：对归属矩阵 $ \vec{U} $ 提供了额外的正则约束。</li>
<li>与 EM（期望最大化）算法中的<strong>软聚类</strong>思想存在对应关系。</li>
</ul>
<hr>
<h2 id="熵不等式的证明"><a href="#熵不等式的证明" class="headerlink" title="熵不等式的证明"></a>熵不等式的证明</h2><p>这里给出熵不等式：</p>
<p>$$<br>-\ln K<br>\leq \langle \vec{U}, \ln \vec{U} \rangle<br>\leq 0<br>$$</p>
<p>的推导思路详述如下：</p>
<h3 id="证明-f-u-ln-u-是凸函数："><a href="#证明-f-u-ln-u-是凸函数：" class="headerlink" title="证明 $f(u)&#x3D;-\ln u$ 是凸函数："></a>证明 $f(u)&#x3D;-\ln u$ 是凸函数：</h3><p>函数 $f(u) &#x3D; -\ln u$ 的一阶导数和二阶导数分别为：</p>
<p>$$<br>f’(u) &#x3D; -\frac{1}{u},<br>\quad<br>f’’(u) &#x3D; \frac{1}{u^2} &gt; 0 \quad (u&gt;0)<br>$$</p>
<p>由于 $f’’(u) &gt; 0$，可知 $f(u)$ 是凸函数。</p>
<h3 id="计算极限-lim-limits-u-to0-u-ln-u-："><a href="#计算极限-lim-limits-u-to0-u-ln-u-：" class="headerlink" title="计算极限 $\lim\limits_{u\to0^+} u \ln u$："></a>计算极限 $\lim\limits_{u\to0^+} u \ln u$：</h3><p>令 $g(u) &#x3D; -u \ln u$，求其极限：</p>
<p>$$<br>\lim_{u\to0^+} u \ln u &#x3D; \lim_{u\to0^+} \frac{\ln u}{1&#x2F;u}<br>$$</p>
<p>利用洛必达法则，分子求导得$1&#x2F;u$，分母求导得 $-1&#x2F;u^2$，因此：</p>
<p>$$<br>\lim_{u\to0^+} \frac{\ln u}{1&#x2F;u} &#x3D; \lim_{u\to0^+} \frac{1&#x2F;u}{-1&#x2F;u^2} &#x3D; \lim_{u\to0^+} -u &#x3D; 0<br>$$</p>
<p>所以：</p>
<p>$$<br>\lim_{u\to0^+} u \ln u &#x3D; 0.<br>$$</p>
<p>这表明当 $u \to 0$ 时，$u \ln u$ 趋于 0。</p>
<h3 id="用-Jensen-不等式推导熵不等式："><a href="#用-Jensen-不等式推导熵不等式：" class="headerlink" title="用 Jensen 不等式推导熵不等式："></a>用 Jensen 不等式推导熵不等式：</h3><p>由于 $f(x)&#x3D;-\ln x$ 是凸函数，因此对于满足 $\sum_{k&#x3D;1}^{K} \alpha_k &#x3D; 1$ 且 $ 0 \leq \alpha_k \leq 1$ 的权重  $\alpha_{k} $ ，有：</p>
<p>$$<br>\left( \sum_{k&#x3D;1}^{K} \alpha_k x_k \right) \leq \sum_{k&#x3D;1}^{K} \alpha_k f(x_k)<br>$$</p>
<p>取 $\alpha_k &#x3D; U_k$，$x_k &#x3D; \frac{1}{U_k}$，则：</p>
<p>$$<br>-ln \left( \sum_{k&#x3D;1}^{K} U_k \cdot \frac{1}{U_k} \right) \leq \sum_{k&#x3D;1}^{K} U_k (-\ln \frac{1}{U_k})<br>$$</p>
<p>由于 $\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$，所以：</p>
<p>$$<br>-ln K \leq \sum_{k&#x3D;1}^{K} U_k \ln U_k \leq 0<br>$$</p>
<p>即</p>
<p>$$<br>ln K \geq -\langle \vec{U}, \ln \vec{U} \rangle<br>$$</p>
<h3 id="等号成立的条件："><a href="#等号成立的条件：" class="headerlink" title="等号成立的条件："></a>等号成立的条件：</h3><ul>
<li><strong>左边等号成立条件</strong>：当所有 $U_k$ 相等，即 $U_k &#x3D; 1&#x2F;K$ 时，左侧等号成立。</li>
<li><strong>右边等号成立条件</strong>：当仅有一个 $U_k&#x3D;1$，其余 $U_k&#x3D;0$ 时，右侧等号成立。</li>
</ul>
<h3 id="熵不等式在-K-Means-变分问题中的作用："><a href="#熵不等式在-K-Means-变分问题中的作用：" class="headerlink" title="熵不等式在 K-Means 变分问题中的作用："></a>熵不等式在 K-Means 变分问题中的作用：</h3><p>该不等式用于限制聚类的过度集中，即防止所有数据点都归属于同一簇。同时，它也鼓励一定程度的分散度，使簇划分更加均匀，从而优化聚类效果。</p>
<hr>
<h2 id="K-Means-的变分问题扩展"><a href="#K-Means-的变分问题扩展" class="headerlink" title="K-Means 的变分问题扩展"></a>K-Means 的变分问题扩展</h2><p>在传统 K-Means 的能量函数 $E(\vec{U}, \vec{C})$ 基础上，引入一项基于熵的正则化：</p>
<p>$$<br>\min_{\vec{u}\in U}<br>\Bigl[<br>E(\vec{u}, \vec{C})<br>+\varepsilon \langle \vec{u}, \ln \vec{u}\rangle<br>\Bigr]<br>$$</p>
<p>其中 $\varepsilon &gt; 0$ 为权衡系数（正则化参数）。当 $\varepsilon \to 0$ 时，该模型接近传统 K-Means 硬分类；当 $\varepsilon$ 较大时，模型更倾向于<strong>软聚类</strong>。</p>
<p>更新过程：</p>
<ol>
<li>$\vec{u}^{t+1} &#x3D; \arg \min_{\vec{u}} \bigl[E(\vec{u}, \vec{C}^t) - \varepsilon H(\vec{u})\bigr]$ (变成了严格凸)</li>
<li>$\vec{C}^{t+1} &#x3D; \arg \min_{\vec{C}} \bigl[E(\vec{u}^{t+1}, \vec{C})\bigr]$  （与传统 K-Means 相同）</li>
</ol>
<p>这里的熵项</p>
<p>$$<br>H(\vec{u})<br>&#x3D; - \sum_{k&#x3D;1}^{K} \sum_{x\in \Omega} u_k(x)\ln u_k(x)<br>$$</p>
<p>作为“软化”或正则化手段，避免完全的 0-1 硬分类。</p>
<h3 id="偏导数计算"><a href="#偏导数计算" class="headerlink" title="偏导数计算"></a>偏导数计算</h3><p>熵项 $H(\vec{u})$ 可重写为</p>
<p>$$<br> -H(\vec{u}) &#x3D; \langle \vec{u}, \ln \vec{u} \rangle.<br>$$</p>
<p>对于目标函数 $E(\vec{u}, \vec{C}) - \varepsilon H(\vec{u})$，计算其关于 $u_k$ 的偏导数：</p>
<ol>
<li><p>设 $E(\vec{u}, \vec{C})$ 关于 $u_k$ 的偏导数为：</p>
<p>$$<br>\frac{\delta E}{\delta u_k} &#x3D; O_k<br>$$</p>
</li>
<li><p>对于熵项：</p>
<p>$$<br>\frac{\delta (-H)}{\delta u_k} &#x3D; \ln u_k + 1<br>$$</p>
</li>
<li><p>结合上述结果，求解极值条件：</p>
<p>$$<br>O_k - \varepsilon (\ln u_k + 1) &#x3D; 0<br>$$</p>
</li>
<li><p>化简得：</p>
<p>$$<br>u_k &#x3D; \exp\left(-\frac{O_k}{\varepsilon} - 1\right)<br>$$</p>
</li>
</ol>
<p>这表明更新 $u_k$ 时，其值受 $\varepsilon$ 控制，较大的 $\varepsilon$ 使得 $u_k$ 更加平滑，有助于软聚类。</p>
<hr>
<h2 id="拉格朗日函数与-Softmax-分析"><a href="#拉格朗日函数与-Softmax-分析" class="headerlink" title="拉格朗日函数与 Softmax 分析"></a>拉格朗日函数与 Softmax 分析</h2><h3 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h3><p>定义拉格朗日函数：</p>
<p>$$<br>\mathcal{L}(\vec{u}, \lambda)<br>&#x3D; E(\vec{u}, \vec{c})<br>-\varepsilon H(\vec{u})+\sum_{x \in \Omega} \lambda(x)<br>\Bigl(<br>\sum_{k&#x3D;1}^{K} u_k(x)-1<br>\Bigr)<br>$$</p>
<p>其中：</p>
<ul>
<li>$H(\vec{u})$ 是熵项；</li>
<li>$\lambda(x)$ 为拉格朗日乘子，用于保证 $\sum_{k&#x3D;1}^{K} u_k(x)&#x3D;1$。</li>
</ul>
<h3 id="软分类-Softmin-Softmax-的推导"><a href="#软分类-Softmin-Softmax-的推导" class="headerlink" title="软分类 (Softmin &#x2F; Softmax) 的推导"></a>软分类 (Softmin &#x2F; Softmax) 的推导</h3><p>对 $\mathcal{L}(\vec{u}, \lambda)$ 关于 $u_k$ 取偏导为 0，可得到：</p>
<p>$$<br>\ln u_k(x)&#x3D; -\frac{O_k(x) +\lambda(x)}{\varepsilon}<br>$$</p>
<p>其中 $O_k$ 是某类损失（例如 $(f(x)-C_k)^2$ ）或能量。</p>
<p>结合约束 $\sum_{k&#x3D;1}^K u_k(x)&#x3D;1$，可得<strong>Softmin</strong>形式：</p>
<p>$$<br>u_k^{t+1}(x)&#x3D; \frac{\exp\Bigl(\dfrac{-O_k(x)}{\varepsilon}\Bigr)}{\sum_{j&#x3D;1}^{K} \exp\Bigl(\dfrac{-O_j(x)}{\varepsilon}\Bigr)}<br>$$</p>
<p>也可写成<strong>softmax</strong>形式：</p>
  
$$
\text{Softmax}_{\varepsilon}(-\vec{O}) =
\left[\text{Softmin}_{\varepsilon}(\vec{O})\right]_k
$$
  

<hr>
<h2 id="极限问题与分母拆分"><a href="#极限问题与分母拆分" class="headerlink" title="极限问题与分母拆分"></a>极限问题与分母拆分</h2><h3 id="k-means-硬分类更新公式"><a href="#k-means-硬分类更新公式" class="headerlink" title="k-means 硬分类更新公式"></a>k-means 硬分类更新公式</h3><p>当不考虑熵正则化时，k-means 的硬分类可写为：</p>
<p>$$<br>u_k^{t+1}(x) &#x3D;<br>\begin{cases}<br>    1, &amp; \text{if } k &#x3D; \arg \min_{k \in {1, \dots, K}} O_k, \<br>    0, &amp; \text{otherwise}.<br>\end{cases}<br>$$</p>
<h3 id="Softmin-的极限"><a href="#Softmin-的极限" class="headerlink" title="Softmin 的极限"></a>Softmin 的极限</h3><p>考虑</p>

$$
\lim_{\varepsilon \to 0^+}
\frac{\exp\bigl(-O_k(x)/\varepsilon\bigr)}{\sum_{j=1}^K \exp\bigl(-O_j(x)/\varepsilon\bigr)}
=\lim_{\varepsilon \to 0^+}\frac{\exp\bigl(-O_k(x)+m(x)/\varepsilon\bigr)}{\sum_{j\in M} \exp\bigl(-O_j(x)+m(x)/\varepsilon\bigr)+\sum_{j\notin M} \exp\bigl(-O_j(x)+m(x)/\varepsilon\bigr)}
$$


<p>令 $m = \min \bigl\{ O_1(x), O_2(x), \dots, O_K(x) \bigr\}, \quad M = \arg\min_{k \in \bigl\{ 1, \dots, K \bigr\}} O_k(x)$。<br>当 $\varepsilon \to 0^+$，对于属于最优集 $M$ 的索引 $k$，$\exp(-O_k&#x2F;\varepsilon)$ 主导；而不是最优集的 $\exp(-O_k&#x2F;\varepsilon)$ 迅速衰减为 0。因此极限结果为：</p>

$$
\lim_{\varepsilon \to 0^+}
\text{Softmin}_{\varepsilon}(\vec{O})
=
\begin{cases}
1, & \text{if } k \in M \\
0, & \text{if } k \notin M
\end{cases}
\quad \text{where } M = \left\{ k \mid O_k = \min_j O_j \right\}
$$


<h2 id="这与-k-means-硬分类（一次只属于距离最近的簇）相一致。称-为softmin-softmax的分类的变分优化问题"><a href="#这与-k-means-硬分类（一次只属于距离最近的簇）相一致。称-为softmin-softmax的分类的变分优化问题" class="headerlink" title="这与 k-means 硬分类（一次只属于距离最近的簇）相一致。称   为softmin&#x2F;softmax的分类的变分优化问题"></a>这与 k-means 硬分类（一次只属于距离最近的簇）相一致。<br>称   $\min_{\vec{u}\in U，\vec{C}}\Bigl[E(\vec{u}, \vec{C})-\varepsilon H(u)\Bigr]$   为softmin&#x2F;softmax的分类的变分优化问题</h2><h2 id="k-means-的光滑化与-Softmax-溢出问题"><a href="#k-means-的光滑化与-Softmax-溢出问题" class="headerlink" title="k-means 的光滑化与 Softmax 溢出问题"></a>k-means 的光滑化与 Softmax 溢出问题</h2><h3 id="k-means-的光滑化"><a href="#k-means-的光滑化" class="headerlink" title="k-means 的光滑化"></a>k-means 的光滑化</h3><p>通过在 k-means 能量函数中加入熵项并令 $\varepsilon&gt;0$，可以将硬分类变为软分类，使其输出变得连续可导。</p>
<ul>
<li>当 $\varepsilon \to 0$，Softmin 退化为 k-means 硬分类；</li>
<li>当 $\varepsilon$ 较大时，软分类更加显著。</li>
</ul>
<h3 id="Softmax-的数值溢出问题"><a href="#Softmax-的数值溢出问题" class="headerlink" title="Softmax 的数值溢出问题"></a>Softmax 的数值溢出问题</h3><p><strong>Softmax 标准形式</strong>：</p>
  
$$
\text{Softmax}\bigl(\vec{O}\bigr)_k
=
\frac{e^{O_k}}{\sum_{j=1}^K e^{O_j}}.
$$
  

<p>若 $O_k$ 值过大，$e^{O_k}$ 可能数值溢出。</p>
<p><strong>解决方案：数值稳定化</strong><br>取   $\displaystyle M = \max\{O_1, O_2, \dots, O_K\}$  ，将所有项减去 $M$：</p>
  
$$
\text{Softmax}(\vec{O})_k
=
\frac{e^{O_k - M}}{\sum_{j=1}^K e^{O_j - M}}
$$


<p>这样可防止溢出，保持结果不变。</p>
<hr>
<h2 id="泛函分析与方向导数"><a href="#泛函分析与方向导数" class="headerlink" title="泛函分析与方向导数"></a>泛函分析与方向导数</h2><h3 id="泛函与方向导数基本概念"><a href="#泛函与方向导数基本概念" class="headerlink" title="泛函与方向导数基本概念"></a>泛函与方向导数基本概念</h3><p>在更高层次，令</p>
  
$$
J: \mathcal{F} \to \mathbb{R}
$$
  

<p>是作用于函数空间 $\mathcal{F}$ 的一个泛函（functional）。对于 $u(x)$ 的变化，可以定义方向导数：</p>
  
$$
\lim_{h \to 0}
\frac{J\bigl(x + hv\bigr) - J(x)}{h}
=
\left.
\frac{d}{dh} 
J\bigl(x + hv\bigr)
\right|_{h=0}
$$
  

<p>方向导数与梯度存在对应关系：若把 $\nabla J&#x3D;(\tfrac{\delta J}{\delta x_1}，\tfrac{\delta J}{\delta x_2} \cdot \cdot \cdot \tfrac{\delta J}{\delta x_n})$ 类比于有限维中的梯度，则方向导数可理解为梯度在 $v$ 方向的投影。</p>
<hr>
<h3 id="方向导数与梯度的关系"><a href="#方向导数与梯度的关系" class="headerlink" title="方向导数与梯度的关系"></a>方向导数与梯度的关系</h3><p>对 $J(U_k)$ 做微分：</p>
  
$$
\langle \tfrac{\delta J}{\delta U_k},  V_k \rangle
=
\left.
\tfrac{d}{dh}
J\bigl(U_k + hV_k\bigr)
\right|_{h=0}.
$$
  

<p>例如，若</p>
  
$$
J(U_k)
=
\sum_{x\in \Omega}
O_k(x)\ln U_k(x),
$$
  

<p>则</p>
  
$$
J(U_k + hV_k)
=
\sum_{x\in \Omega}
O_k(x)\ln\bigl(U_k(x) + hV_k(x)\bigr)
$$
  

<p>对其在 $h&#x3D;0$ 处求导，可得到对应的偏导，从而确定梯度形式。</p>
<hr>
<h2 id="九、总结与要点"><a href="#九、总结与要点" class="headerlink" title="九、总结与要点"></a>九、总结与要点</h2><ol>
<li><p><strong>K-Means 算法</strong></p>
<ul>
<li>能量函数：数据点到簇中心的平方误差和；</li>
<li>经典迭代：硬分类与均值更新交替进行。</li>
</ul>
</li>
<li><p><strong>K-Means 的变分扩展</strong></p>
<ul>
<li>通过引入熵（软分类），可得到 Softmin &#x2F; Softmax 形式；</li>
<li>当正则系数 $\varepsilon \to 0$ 时，又可退化到原始硬划分结果。</li>
</ul>
</li>
<li><p><strong>熵不等式与数值稳定</strong></p>
<ul>
<li>熵提供了在聚类中的分布约束；</li>
<li>Softmax 需用数值移位避免溢出。</li>
</ul>
</li>
<li><p><strong>泛函与方向导数</strong></p>
<ul>
<li>在更高阶场景中，可将 K-Means 问题放到泛函分析框架下；</li>
<li>方向导数、梯度概念可帮助理解对函数空间的优化。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/10/The%20Applications%20of%20Large%20Language%20Models%20in%20Mental%20Health%20Scoping%20Review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/10/The%20Applications%20of%20Large%20Language%20Models%20in%20Mental%20Health%20Scoping%20Review/" class="post-title-link" itemprop="url">The Applications of Large Language Models in Mental Health Scoping Review.</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-10 13:42:46" itemprop="dateCreated datePublished" datetime="2025-05-10T13:42:46+08:00">2025-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-30 16:05:29" itemprop="dateModified" datetime="2025-07-30T16:05:29+08:00">2025-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Publication/" itemprop="url" rel="index"><span itemprop="name">Publication</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  I am honored to be the co-first author of this paper, and my main contrbution are data extraction and visualization.<br>  Based on the 2019-2024 scoping review of 95 peer-reviewed articles, this study mapped the landscape of large language models (LLMs) applications in mental health across three key domains. The analysis revealed that LLMs are predominantly utilized for screening and detection of mental disorders (71%), with particular emphasis on depression detection (35%) and suicide risk prediction (13%). Additionally, LLMs demonstrate significant potential in supporting clinical treatments (33%) and facilitating mental health counseling and education (12%). Comparative assessments indicate that LLMs exhibit superior capabilities in information processing and natural language response generation relative to traditional non-transformer models and human performance in specific contexts. The research identified distinct advantages among different LLM architectures for various mental health applications, highlighting their promising role in addressing critical challenges in global mental healthcare, including detection efficiency, treatment effectiveness, privacy protection, and access to specialized care. These findings provide essential scientific evidence for the development and implementation of LLM-enhanced mental health interventions, which may significantly improve early detection rates and expand access to mental healthcare resources.</p>
<h1 id="PDF-file"><a href="#PDF-file" class="headerlink" title="PDF file"></a>PDF file</h1><iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/The Applications of Large Language Models in Mental Health Scoping Review.pdf" style='width:100%;height:800px'></iframe>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/07/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/07/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">25 Spring - 模式识别笔记(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-03-07 18:42:46" itemprop="dateCreated datePublished" datetime="2025-03-07T18:42:46+08:00">2025-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-02 12:20:39" itemprop="dateModified" datetime="2025-08-02T12:20:39+08:00">2025-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Course/" itemprop="url" rel="index"><span itemprop="name">Course</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="Word2Vec-Embedding-技术"><a href="#Word2Vec-Embedding-技术" class="headerlink" title="Word2Vec Embedding 技术"></a>Word2Vec Embedding 技术</h2><p>Word2Vec 是一种用于将单词映射到向量空间的技术，通过训练语料库来学习单词的语义关系。核心思想是将单词转换为一个高维向量，使得语义相近的单词在向量空间中距离较近。</p>
<h3 id="Word2Vec-过程"><a href="#Word2Vec-过程" class="headerlink" title="Word2Vec 过程"></a>Word2Vec 过程</h3><ol>
<li><strong>输入文本</strong>（例如：”我”、”是”、”中国”、”人民”）</li>
<li><strong>嵌入层（Embedding）</strong>：将单词转换为向量表示</li>
<li><strong>训练</strong>：使用 Skip-gram 或 CBOW 模型进行训练</li>
<li><strong>输出向量</strong>：得到语义空间中的词向量表示</li>
</ol>
<p>在黑板上的示例中，展示了单词如何通过 Word2Vec 进行向量化，并且最终映射到一个 <em>n</em> 维向量空间中。</p>
<hr>
<h2 id="K-Means-聚类算法"><a href="#K-Means-聚类算法" class="headerlink" title="K-Means 聚类算法"></a>K-Means 聚类算法</h2><p>K-Means 是一种常见的无监督学习算法，主要用于数据聚类。其基本思想是：</p>
<ol>
<li>给定样本集合 $S$，包含样本 $S_1, S_2, \dots, S_k$。</li>
<li>设定 $k$ 个聚类中心 $C_1, C_2, \dots, C_k$。</li>
<li>将样本 $f$ 分配给最近的聚类中心 $C_k$。</li>
</ol>
<h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><p>定义样本 $f$ 归属于最接近的簇：</p>
<p>$$<br>U_k^* &#x3D;<br>\begin{cases}<br>1, &amp; f \in S_k \<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
<p>其中，样本 $f$ 的归属取决于其与聚类中心 $C_k$ 的欧式距离：</p>
<p>$$<br>| f - C_k |^2<br>$$</p>
<p>因此，每个样本都会归属于离它最近的簇。</p>
<h3 id="K-Means-迭代步骤"><a href="#K-Means-迭代步骤" class="headerlink" title="K-Means 迭代步骤"></a>K-Means 迭代步骤</h3><ol>
<li>随机初始化 $k$ 个聚类中心 $C_1, C_2, \dots, C_k$。</li>
<li>计算每个样本到聚类中心的距离，并将其分配到最近的簇。</li>
<li>更新聚类中心，使其成为簇中所有样本的平均值。</li>
<li>重复步骤 2 和 3，直到聚类中心不再发生变化或达到迭代次数上限。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Word2Vec</strong> 将单词映射到向量空间，使语义相似的单词在向量空间中更接近。  </li>
<li><strong>K-Means</strong> 通过反复迭代，将数据点划分到不同的簇中进行聚类分析。</li>
</ul>
<p>这两者结合在自然语言处理 (NLP) 中可用于 <strong>文本分类、聚类分析</strong> 等任务。例如，先用 Word2Vec 将文本转换为向量，然后使用 K-Means 进行文本聚类。</p>
<h2 id="kmeans算法的定义"><a href="#kmeans算法的定义" class="headerlink" title="kmeans算法的定义"></a>kmeans算法的定义</h2><h3 id="独热编码（One-Hot-Encoding）"><a href="#独热编码（One-Hot-Encoding）" class="headerlink" title="独热编码（One-Hot Encoding）"></a>独热编码（One-Hot Encoding）</h3><p>在 K-Means 聚类算法中，我们使用独热编码（One-Hot Encoding）来表示样本所属的类别：</p>
<ul>
<li><p>若样本 $f$ 属于第 $k$ 个簇，则其独热编码表示为</p>
<p>$$<br>\mathbf{U}^* &#x3D; (0, 0, \dots, 1, \dots, 0)<br>$$</p>
<p>其中只有第 $k$ 维的值为 1，其余维度为 0。</p>
</li>
<li><p>例如：</p>
<ul>
<li><strong>若 $f \in S_1$</strong>：<br>$$<br>\mathbf{U}^* &#x3D; (1, 0, 0, \dots, 0)<br>$$</li>
<li><strong>若 $f \in S_k$</strong>：<br>$$<br>\mathbf{U}^* &#x3D; (0, 0, \dots, 1, \dots, 0)<br>$$</li>
</ul>
</li>
</ul>
<hr>
<h3 id="K-Means-目标函数"><a href="#K-Means-目标函数" class="headerlink" title="K-Means 目标函数"></a>K-Means 目标函数</h3><p>在 K-Means 算法中，我们的目标是最小化样本点到其分配的聚类中心的距离平方和：</p>
<p>$$<br>\mathbf{U}^* &#x3D; \arg\min_{\mathbf{U} \in \mathcal{U}} \sum_{k&#x3D;1}^{K}U_k (f - C_k)^2<br>$$</p>
<p>其中：</p>
<ul>
<li>$\mathcal{U}$ 是所有可能的独热编码集合：</li>
</ul>
  
  $$\mathcal{U} = \left\{ \mathbf{u} = (U_1, U_2, \dots, U_K) \,\middle|\, \sum_{k=1}^{K} U_k = 1, \quad 0 \leq U_k \leq 1 \right\}$$

<p>  表示每个样本点只能属于一个簇。</p>
<hr>
<h3 id="定理及其证明"><a href="#定理及其证明" class="headerlink" title="定理及其证明"></a>定理及其证明</h3><h4 id="定理（Thm）"><a href="#定理（Thm）" class="headerlink" title="定理（Thm）"></a>定理（Thm）</h4><p>对于任意样本 $f$ 和聚类中心 $C_1, C_2, \dots, C_K$，定义：</p>

$$
U_k^* =
\begin{cases} 
1, & k = \arg\min\limits_{R=1,2,\dots,K} (f - C_R)^2 \\
0, & \text{else}
\end{cases}
$$


<p>即，样本 $f$ 应该被分配到使得 $(f - C_k)^2$（最小值唯一） 最小的簇 $C_k$。</p>
<h4 id="证明（Proof）"><a href="#证明（Proof）" class="headerlink" title="证明（Proof）"></a>证明（Proof）</h4><ol>
<li><p>定义</p>
<p>$$<br>m &#x3D; \min_{k \in {1,2,\dots,K}} {(f - C_k)^2}<br>$$</p>
<p>由于 $U_k$ 是独热编码，所有可能的 $U_k$ 满足</p>
<p>$$<br>\sum_{k&#x3D;1}^{K} U_k &#x3D; 1<br>$$</p>
</li>
<li><p>目标函数展开：</p>
<p>$$<br>\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \geq\ \sum_{k&#x3D;1}^{K} U_k \cdot m<br>$$</p>
<p>由于 $\sum_{k&#x3D;1}^{K} U_k &#x3D; 1,$ 代入可得：</p>
<p>$$<br>\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \geq m<br>$$</p>
</li>
<li><p>取 $U_k^*$ 使得 $k$ 取最小距离的索引，则：</p>
<p>$$<br>\sum_{k&#x3D;1}^{K} U_k^* (f - C_k)^2 &#x3D; m.<br>$$</p>
<p>这说明只有当 $U_k^<em>$ 取最优独热编码时，目标函数才能取到最小值 $m$ ，从而证明了 $U_k^</em>$ 具有唯一最优解。</p>
</li>
</ol>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li><strong>独热编码</strong> 用于表示样本所属的类别，每个样本只能属于一个簇。  </li>
<li><strong>目标函数</strong> 通过最小化样本到其最近聚类中心的距离平方和，确定最优分类。  </li>
<li><strong>定理证明</strong> 说明了最佳分配方案是将样本分配到使得 $(f - C_k)^2$ 最小的簇。</li>
</ul>
<p>这一定理是 K-Means 算法的核心之一，保证了算法在每一步迭代中都能使目标函数收敛到一个局部最优解。</p>
<p>–</p>
<h2 id="连续情况下的-K-Means-聚类定义"><a href="#连续情况下的-K-Means-聚类定义" class="headerlink" title="连续情况下的 K-Means 聚类定义"></a>连续情况下的 K-Means 聚类定义</h2><p>在离散情况下，我们用有限个样本点 $f$ 进行聚类，而在连续情况下，需要对整个定义域 $\Omega$ 进行考虑。</p>
<h3 id="目标函数扩展到连续情况"><a href="#目标函数扩展到连续情况" class="headerlink" title="目标函数扩展到连续情况"></a>目标函数扩展到连续情况</h3><ul>
<li><p>设函数 $f: \Omega \to \mathbb{R}$，其中 $\Omega$ 是定义域，$f(x)$ 是定义在 $\Omega$ 上的连续函数。  </p>
</li>
<li><p>目标是在整个 $\Omega$ 上最小化聚类误差：</p>
<p>$$<br>\min_{\mathbf{U}(x) \in \mathcal{U}} \sum_{x \in \Omega} \sum_{k&#x3D;1}^{K} U_k(x) (f(x) - C_k)^2<br>$$</p>
<p>其中：</p>
<ul>
<li>$C_1, C_2, \dots, C_K$ 为 $K$ 个聚类中心。  </li>
<li>$U_k(x)$ 表示位置 $x$ 归属于第 $k$ 个聚类中心的程度。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><p>为了保证每个点 $x$ 仅归属于一个聚类簇，引入约束：</p>

$$
\mathcal{U} = \left\{ \mathbf{U}(x) = (U_1(x), U_2(x), \dots, U_K(x)) \,\middle|\, \sum_{k=1}^{K} U_k(x) = 1, \quad 0 \leq U_k(x) \leq 1, \quad \forall x \in \Omega \right\}
$$



<p>这意味着：</p>
<ul>
<li>每个 $x$ 只能属于一个簇（即某个 $U_k(x)$ 取 1，其余取 0）。</li>
<li>$U_k(x)$ 的取值范围在 $[0,1]$ 之间。</li>
</ul>
<hr>
<h3 id="直观解释"><a href="#直观解释" class="headerlink" title="直观解释"></a>直观解释</h3><p>从黑板上的示意图可以看出：</p>
<ul>
<li>$x \in \Omega$ 表示数据点在连续空间中的分布。</li>
<li>$f(x)$ 代表数据点的特征值。</li>
<li>目标是将这些数据点划分到不同的簇 $C_1, C_2, \dots, C_K$ 中，使得同一簇中的点具有较小的方差。</li>
</ul>
<hr>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li>在连续情况下，K-Means 的目标函数和约束条件从离散样本点扩展到了整个定义域 $\Omega$。  </li>
<li>目标仍然是最小化数据点到聚类中心的平方误差。  </li>
<li>约束条件确保每个点 $x$ 只能归属于一个簇。  </li>
<li>这种扩展形式在实际应用中可用于处理连续空间中的数据，如图像分割或概率密度估计。</li>
</ul>
<hr>
<h2 id="K-Means-迭代优化过程"><a href="#K-Means-迭代优化过程" class="headerlink" title="K-Means 迭代优化过程"></a>K-Means 迭代优化过程</h2><p>K-Means 算法的目标是最小化聚类误差 $E(\mathbf{U}, \mathbf{C})$，即样本点到其聚类中心的平方误差和。它采用 <strong>迭代优化</strong> 的方式，在每次迭代中交替更新 <strong>簇分配</strong> 和 <strong>聚类中心</strong>，直到收敛。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>聚类中心向量：</p>
<p>$$<br>\mathbf{C} &#x3D; (C_1, C_2, \dots, C_K)^T.<br>$$</p>
</li>
<li><p>K-Means 的优化目标：</p>
<p>$$<br>\min_{\mathbf{U} \in \mathcal{U}, \mathbf{C}} E(\mathbf{U}, \mathbf{C}).<br>$$</p>
</li>
</ul>
<h3 id="Step-1：更新簇分配-mathbf-U"><a href="#Step-1：更新簇分配-mathbf-U" class="headerlink" title="Step 1：更新簇分配 $\mathbf{U}$"></a>Step 1：更新簇分配 $\mathbf{U}$</h3><p>$$<br>\mathbf{U}^{t+1} &#x3D; \arg\min_{\mathbf{U} \in \mathcal{U}} E(\mathbf{U}, \mathbf{C}^t).<br>$$</p>
<p>其中，$U_k^{t+1}(x)$ 按照最近邻准则更新：</p>

$$
U_k^{t+1}(x) =
\begin{cases}
1, & k = \arg\min\limits_{\,k' \in \{1,2,\dots,K\}} \bigl(f(x) - C_{k'}^t\bigr)^2 \\
0, & \text{otherwise}
\end{cases}
$$


<p>即，将样本 $x$ 归到当前最近的聚类中心 $C_k^t$。</p>
<h3 id="Step-2：更新聚类中心-mathbf-C"><a href="#Step-2：更新聚类中心-mathbf-C" class="headerlink" title="Step 2：更新聚类中心 $\mathbf{C}$"></a>Step 2：更新聚类中心 $\mathbf{C}$</h3><p>$$<br>\mathbf{C}^{t+1} &#x3D; \arg\min_{\mathbf{C}} E(\mathbf{U}^{t+1}, \mathbf{C}).<br>$$</p>
<p>聚类中心的更新公式：</p>
<p>$$<br>C_k &#x3D; \frac{\sum\limits_{x \in \Omega} U_k^{t+1}(x) , f(x)}{|\Omega_k|},<br>$$</p>
<p>其中：</p>
<ul>
<li>$\Omega_k$ 是当前属于第 $k$ 个簇的所有样本点集合。</li>
<li>上式表示：新的聚类中心是该簇内所有样本的加权平均值。</li>
<li>也可以把$\Omega_k$替换成$\sum_{x \in \Omega} U_k^{t+1} (x) :&#x3D; \Omega^{t+1}_{k}$</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Step 1</strong>：更新簇分配，使得每个点归属于与其最近的聚类中心。  </li>
<li><strong>Step 2</strong>：更新聚类中心，使其为簇内所有点的均值。  </li>
<li>这两步交替进行，直到聚类中心不再变化，算法收敛。</li>
</ul>
<hr>
<h2 id="目标函数关于聚类中心的推导"><a href="#目标函数关于聚类中心的推导" class="headerlink" title="目标函数关于聚类中心的推导"></a>目标函数关于聚类中心的推导</h2><p>以下演示 <strong>Step 2</strong>（更新聚类中心）中，如何对目标函数关于聚类中心 $C_k$ 求导并得到更新公式。为简化，只对离散情形展示，连续情形可将求和替换为积分，思路相同。</p>
<h3 id="目标函数拆分"><a href="#目标函数拆分" class="headerlink" title="目标函数拆分"></a>目标函数拆分</h3><p>K-Means 的目标函数（离散情形）：</p>
<p>$$<br>E(\mathbf{U}, \mathbf{C})<br>&#x3D; \sum_{k&#x3D;1}^{K} \sum_{x \in \Omega} U_k(x)\bigl(f(x) - C_k\bigr)^2<br>$$</p>
<p>我们先单独关注属于簇 $k$ 的部分：</p>
<p>$$<br>E_k(\mathbf{U}, C_k)<br>&#x3D; \sum_{x \in \Omega} U_k(x)\bigl(f(x) - C_k\bigr)^2<br>$$</p>
<p>在更新 $C_k$ 时，$U_k(x)$ 固定，只需对 $C_k$ 进行最优化。</p>
<h3 id="对-C-k-求偏导"><a href="#对-C-k-求偏导" class="headerlink" title="对 $C_k$ 求偏导"></a>对 $C_k$ 求偏导</h3><p>令</p>
<p>$$<br>E_k(\mathbf{U}, C_k)<br>&#x3D; \sum_{x \in \Omega} U_k(x)\bigl(f(x) - C_k\bigr)^2<br>$$</p>
<p>对 $C_k$ 求导并令其为 0：</p>
<p>$$<br>\frac{\partial}{\partial C_k} E_k(\mathbf{U}, C_k)<br>&#x3D; \sum_{x \in \Omega} 2 U_k(x)  \bigl(C_k - f(x)\bigr).<br>$$</p>
<p>令其为 0，可得：</p>
<p>$$<br>\sum_{x \in \Omega} U_k(x)\bigl(C_k - f(x)\bigr) &#x3D; 0<br>$$</p>
<h3 id="解方程，得到更新公式"><a href="#解方程，得到更新公式" class="headerlink" title="解方程，得到更新公式"></a>解方程，得到更新公式</h3><p>整理可得：</p>
<p>$$<br>C_k \sum_{x \in \Omega} U_k(x)<br>&#x3D; \sum_{x \in \Omega} U_k(x)f(x)<br>$$</p>
<p>若分母不为 0（该簇有样本），则</p>
<p>$$<br>C_k &#x3D; \frac{\sum\limits_{x \in \Omega} U_k(x) f(x)}{\sum\limits_{x \in \Omega} U_k(x)}<br>$$</p>
<p>这就是 <strong>K-Means 中聚类中心的更新公式</strong>。在常见的离散数据立场下，上式意味着“该簇内所有样本特征的加权平均值”，权值由 $U_k(x)$ 决定。<br>若 $U_k(x)$ 只取 0 或 1（硬划分），则退化为简单的算术平均。</p>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li><p>在连续情况下，将“求和”换为对 $\Omega$ 的积分即可：</p>
<p>$$C_k &#x3D; \frac{\int_{\Omega} U_k(x)f(x)\mathrm{d}x}{\int_{\Omega} U_k(x)\mathrm{d}x}$$</p>
</li>
<li><p>当 $U_k(x)$ 只取 0 或 1，即标准 K-Means，公式变为簇内样本的算术平均。</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="K-Means-能量单调下降（不增）性"><a href="#K-Means-能量单调下降（不增）性" class="headerlink" title="K-Means 能量单调下降（不增）性"></a>K-Means 能量单调下降（不增）性</h2><p>以下笔记基于课堂板书，展示 K-Means 迭代过程中目标函数（也称“能量”或“误差”）如何在每一步都单调下降（或不增），从而收敛到局部最优解。</p>
<h3 id="引理-定理描述"><a href="#引理-定理描述" class="headerlink" title="引理 &#x2F; 定理描述"></a>引理 &#x2F; 定理描述</h3><blockquote>
<p><strong>定理：</strong><br>由 K-Means 算法产生的迭代序列 $(\mathbf{u}^{(t)}, \mathbf{c}^{(t)})$ 满足</p>
<p>$$<br>E\bigl(\mathbf{u}^{(t+1)}, \mathbf{c}^{(t+1)}\bigr)<br>\le<br>E\bigl(\mathbf{u}^{(t)}, \mathbf{c}^{(t)}\bigr),<br>$$</p>
<p>即每次迭代更新后，目标函数 $E(\cdot)$ 不会增大，从而保证了算法的单调收敛性。</p>
</blockquote>
<h3 id="目标函数回顾"><a href="#目标函数回顾" class="headerlink" title="目标函数回顾"></a>目标函数回顾</h3><p>离散情形下的 K-Means 目标函数：</p>
<p>$$<br>E\bigl(\mathbf{u}, \mathbf{c}\bigr)<br>&#x3D; \sum_{k&#x3D;1}^{K} \sum_{x \in \Omega}<br>U_k(x)\bigl(f(x) - C_k\bigr)^2<br>$$</p>
<h3 id="迭代过程（两步更新）"><a href="#迭代过程（两步更新）" class="headerlink" title="迭代过程（两步更新）"></a>迭代过程（两步更新）</h3><ul>
<li><p><strong>Step 1：更新 $\mathbf{u}^{(t+1)}$</strong><br>固定 $\mathbf{c}^{(t)}$，令</p>
<p>$$<br>\mathbf{u}^{(t+1)}<br>&#x3D; \arg\min_{\mathbf{u} \in \mathcal{U}}<br>  E\bigl(\mathbf{u}, \mathbf{c}^{(t)}\bigr)<br>$$</p>
<p>由于独热编码的性质，每个样本 $x$ 归于距离最近的中心 $C_k^{(t)}$。<br>这样得到</p>
<p>$$<br>E\bigl(\mathbf{u}^{(t+1)}, \mathbf{c}^{(t)}\bigr)<br>\le<br>E\bigl(\mathbf{u}^{(t)}, \mathbf{c}^{(t)}\bigr)<br>$$</p>
</li>
<li><p><strong>Step 2：更新 $\mathbf{c}^{(t+1)}$</strong><br>固定 $\mathbf{u}^{(t+1)}$，令</p>
<p>$$<br>\mathbf{c}^{(t+1)}<br>&#x3D; \arg\min_{\mathbf{c}}<br>  E\bigl(\mathbf{u}^{(t+1)}, \mathbf{c}\bigr).<br>$$</p>
<p>对每个 $C_k$ 求导并令其为 0，得到聚类中心是该簇内样本的加权平均。于是</p>
<p>$$<br>E\bigl(\mathbf{u}^{(t+1)}, \mathbf{c}^{(t+1)}\bigr)<br>\le<br>E\bigl(\mathbf{u}^{(t+1)}, \mathbf{c}^{(t)}\bigr)<br>$$</p>
</li>
</ul>
<h3 id="能量严格下降的证明思路"><a href="#能量严格下降的证明思路" class="headerlink" title="能量严格下降的证明思路"></a>能量严格下降的证明思路</h3><p>上两步结合，可得：</p>
<p>$$<br>E\bigl(\mathbf{u}^{(t+1)}, \mathbf{c}^{(t+1)}\bigr)<br>\le<br>E\bigl(\mathbf{u}^{(t)}, \mathbf{c}^{(t)}\bigr)<br>$$</p>
<p>这说明每一轮迭代后，目标函数都会朝着不增的方向变化，从而收敛到某个局部最优或鞍点。</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><ul>
<li>K-Means 通过交替最小化簇分配 $\mathbf{u}$ 和聚类中心 $\mathbf{c}$，使目标函数在每次迭代中不增。  </li>
<li>因此，算法<strong>单调地</strong>收敛到一个局部最优解（或鞍点）。</li>
</ul>
<p>这便是 <strong>K-Means 能量单调下降</strong> 的主要证明思路，也是该算法能保证在有限步内收敛的关键原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AgioPan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">AgioPan</p>
  <div class="site-description" itemprop="description">Solving equations, decoding life, exploring minds.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Agio910" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Agio910" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://orcid.org/0009-0005-1485-9515" title="orcid → https:&#x2F;&#x2F;orcid.org&#x2F;0009-0005-1485-9515" rel="noopener" target="_blank"><i class="fab fa-orcid fa-fw"></i>orcid</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:202111079094@mail.bnu.edu.cn" title="E-Mail → mailto:202111079094@mail.bnu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AgioPan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
