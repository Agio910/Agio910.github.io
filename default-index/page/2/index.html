<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog of AgioPan">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="Blog of AgioPan">
<meta property="og:description" content="Solving equations, decoding life, exploring minds.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="AgioPan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog of AgioPan</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of AgioPan</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（12）- 链表高频题目和必备技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-17 08:42:46 / Modified: 17:06:58" itemprop="dateCreated datePublished" datetime="2025-08-17T08:42:46+08:00">2025-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记总结了链表类题目的高频考点和必备技巧，包含6道经典链表题目的详细解析。链表题目主要考察的是编程能力而非算法设计，是class034的内容。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习链表高频题目之前，需要掌握以下基础知识：</p>
<ul>
<li>链表入门内容（009~012讲）</li>
<li>归并排序（021讲）</li>
<li>哈希表的使用（026讲）</li>
<li>排序算法的稳定性（029讲）</li>
</ul>
<h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的指针</span></span><br></pre></td></tr></table></figure>


<h1 id="034【必备】链表高频题目和必备技巧"><a href="#034【必备】链表高频题目和必备技巧" class="headerlink" title="034【必备】链表高频题目和必备技巧"></a>034【必备】链表高频题目和必备技巧</h1><h2 id="链表题目解题要点"><a href="#链表题目解题要点" class="headerlink" title="链表题目解题要点"></a>链表题目解题要点</h2><h3 id="核心注意事项"><a href="#核心注意事项" class="headerlink" title="核心注意事项"></a>核心注意事项</h3><ol>
<li><p><strong>空间复杂度的选择</strong>：</p>
<ul>
<li>如果笔试中空间要求不严格，直接使用容器来解决链表问题</li>
<li>如果笔试中空间要求严格、或者在面试中面试官强调空间的优化，需要使用额外空间复杂度O(1)的方法</li>
</ul>
</li>
<li><p><strong>最常用的技巧</strong>：快慢指针</p>
</li>
<li><p><strong>考察重点</strong>：链表类题目往往都是很简单的算法问题，核心考察点并不是算法设计，而是coding能力</p>
</li>
<li><p><strong>练习建议</strong>：既然练的就是coding，那么不要采取空间上讨巧的方式来练习（容器方法），这些题难就难在要用有限几个变量来解决</p>
</li>
</ol>
<h2 id="题目一：返回两个无环链表相交的第一个节点"><a href="#题目一：返回两个无环链表相交的第一个节点" class="headerlink" title="题目一：返回两个无环链表相交的第一个节点"></a>题目一：返回两个无环链表相交的第一个节点</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个单链表的头节点，判断两个链表是否相交，如果相交返回第一个交点，否则返回None。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="链表相交的概念"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法（空间复杂度O(N)）</strong>：</p>
<ol>
<li>遍历链表1，将每个节点加入哈希表</li>
<li>遍历链表2，检查每个节点是否在哈希表中</li>
<li>如果找到第一个在哈希表中的节点，即为第一个交点</li>
</ol>
<p><strong>最优解法（空间复杂度O(1)）</strong>：<br>核心思想是先判断两条链表是否相交，再找交点。</p>
<p>判断相交的关键：两条链表如果相交，最后一个节点一定是同一个节点（因为链表每个节点只有一个next指针）。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回两个无环链表相交的第一个节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, h1: ListNode, h2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> h1 <span class="keyword">or</span> <span class="keyword">not</span> h2:  <span class="comment"># 任一链表为空，不可能相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    a = h1  <span class="comment"># a指针遍历链表1</span></span><br><span class="line">    b = h2  <span class="comment"># b指针遍历链表2</span></span><br><span class="line">    diff = <span class="number">0</span>  <span class="comment"># 记录两个链表的长度差</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历链表1，计算其长度</span></span><br><span class="line">    <span class="keyword">while</span> a.<span class="built_in">next</span>:</span><br><span class="line">        a = a.<span class="built_in">next</span>  <span class="comment"># a指针后移</span></span><br><span class="line">        diff += <span class="number">1</span>  <span class="comment"># 长度差加1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历链表2，计算其长度</span></span><br><span class="line">    <span class="keyword">while</span> b.<span class="built_in">next</span>:</span><br><span class="line">        b = b.<span class="built_in">next</span>  <span class="comment"># b指针后移</span></span><br><span class="line">        diff -= <span class="number">1</span>  <span class="comment"># 长度差减1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> a != b:  <span class="comment"># 最后一个节点不同，说明不相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 根据长度差的正负，确定哪个是长链表，哪个是短链表</span></span><br><span class="line">    <span class="comment"># a指向长链表的头，b指向短链表的头</span></span><br><span class="line">    <span class="keyword">if</span> diff &gt;= <span class="number">0</span>:</span><br><span class="line">        a = h1  <span class="comment"># a指向长链表</span></span><br><span class="line">        b = h2  <span class="comment"># b指向短链表</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = h2</span><br><span class="line">        b = h1</span><br><span class="line">        </span><br><span class="line">    diff = <span class="built_in">abs</span>(diff)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> diff != <span class="number">0</span>:</span><br><span class="line">        a = a.<span class="built_in">next</span></span><br><span class="line">        diff -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 同时移动直到相遇</span></span><br><span class="line">    <span class="keyword">while</span> a != b:</span><br><span class="line">        a = a.<span class="built_in">next</span></span><br><span class="line">        b = b.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> a  <span class="comment"># 返回交点</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(M + N)，M和N分别是两个链表的长度</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：长度差计算 + 双指针</li>
</ul>
<h2 id="题目二：每k个节点一组翻转链表"><a href="#题目二：每k个节点一组翻转链表" class="headerlink" title="题目二：每k个节点一组翻转链表"></a>题目二：每k个节点一组翻转链表</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，每k个节点一组进行翻转，如果最后剩余节点不够k个，则保持原样。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：把所有节点都放到数组里，然后每k个节点一组进行翻转，但空间复杂度为O(N)。</p>
<p><strong>最优解法</strong>：使用有限变量完成分组翻转。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" alt="每k个节点一组反转链表"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-reverse%E8%BF%87%E7%A8%8B.png" alt="每k个节点一组反转链表-reverse过程"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E6%89%BElastteamend.png" alt="每k个节点一组反转链表-找lastteamend"></p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按k个一组翻转链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    start = head  <span class="comment"># start指向当前组的开始节点</span></span><br><span class="line">    end = <span class="variable language_">self</span>.teamEnd(start, k)  <span class="comment"># 找到第一组的结束节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果第一组的长度不足k，直接返回原链表头节点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一组很特殊因为牵扯到换头的问题</span></span><br><span class="line">    <span class="comment"># 翻转后，第一组的末尾节点end会成为整个链表的新头节点</span></span><br><span class="line">    head = end</span><br><span class="line">    <span class="variable language_">self</span>.reverse(start, end)  <span class="comment"># 翻转第一组节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 翻转之后start变成了上一组的结尾节点</span></span><br><span class="line">    lastTeamEnd = start  <span class="comment"># lastTeamEnd记录上一组翻转后的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环处理剩余的链表</span></span><br><span class="line">    <span class="keyword">while</span> lastTeamEnd.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        start = lastTeamEnd.<span class="built_in">next</span>  <span class="comment"># 下一组的开始节点</span></span><br><span class="line">        end = <span class="variable language_">self</span>.teamEnd(start, k)  <span class="comment"># 找到下一组的结束节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果剩余部分的长度不足k，直接返回头节点，不进行翻转</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.reverse(start, end)  <span class="comment"># 翻转当前组</span></span><br><span class="line">        lastTeamEnd.<span class="built_in">next</span> = end  <span class="comment"># 将上一组的尾节点与当前组翻转后的头节点(即原来的end)连接起来</span></span><br><span class="line">        lastTeamEnd = start  <span class="comment"># 更新lastTeamEnd为当前组翻转后的尾节点(即原来的start)</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回新的头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前组的开始节点是s，往下数k个找到当前组的结束节点返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">teamEnd</span>(<span class="params">self, s: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找到从s开始第k个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从s开始，向后移动k-1次</span></span><br><span class="line">    <span class="keyword">while</span> k - <span class="number">1</span> != <span class="number">0</span> <span class="keyword">and</span> s <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        s = s.<span class="built_in">next</span>  <span class="comment"># s指针后移</span></span><br><span class="line">        k -= <span class="number">1</span>  <span class="comment"># 计数器减1</span></span><br><span class="line">    <span class="keyword">return</span> s  <span class="comment"># 返回第k个节点，如果不足k个则返回None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s -&gt; a -&gt; b -&gt; c -&gt; e -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment"># 上面的链表通过如下的reverse方法调整成 : e -&gt; c -&gt; b -&gt; a -&gt; s -&gt; 下一组的开始节点</span></span><br><span class="line"><span class="comment"># 翻转从s到e的这一段链表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, s: ListNode, e: ListNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;翻转从s到e的链表段&quot;&quot;&quot;</span></span><br><span class="line">    e = e.<span class="built_in">next</span>  <span class="comment"># e是当前组的结尾，e.next指向下一组的开头</span></span><br><span class="line">    pre = <span class="literal">None</span>  <span class="comment"># pre是前一个节点，初值为None</span></span><br><span class="line">    cur = s  <span class="comment"># cur是当前节点，初值为s</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next是下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历当前组，直到cur到达下一组的开头</span></span><br><span class="line">    <span class="keyword">while</span> cur != e:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存当前节点的下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre  <span class="comment"># 将当前节点的next指针指向前一个节点</span></span><br><span class="line">        pre = cur  <span class="comment"># pre, cur向后移动</span></span><br><span class="line">        cur = next_node</span><br><span class="line">    </span><br><span class="line">    s.<span class="built_in">next</span> = e  <span class="comment"># 翻转后，原来的头节点s变成了尾节点，它的next应该指向下一组的开头</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：分组处理 + 局部翻转</li>
</ul>
<h2 id="题目三：复制带随机指针的链表"><a href="#题目三：复制带随机指针的链表" class="headerlink" title="题目三：复制带随机指针的链表"></a>题目三：复制带随机指针的链表</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>复制一个带random指针的链表，random可以指向链表中的任意节点或者null。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：使用哈希表记录原节点和新节点的对应关系，空间复杂度O(N)。</p>
<p><strong>最优解法</strong>：在原链表上直接操作，分三步完成复制。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E6%8B%B7%E8%B4%9D%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88.png" alt="拷贝随机指针"></p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果头节点为空，直接返回None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    cur = head  <span class="comment"># cur指针用于遍历原链表</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next指针用于暂存下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1 -&gt; 2 -&gt; 3 -&gt; ...变成 : 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; -&gt; ...</span></span><br><span class="line">    <span class="comment"># 第一步：复制每个节点并将其插入到原节点之后</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存原节点的下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = <span class="variable language_">self</span>.Node(cur.val)  <span class="comment"># 创建新节点，值为原节点的值</span></span><br><span class="line">        cur.<span class="built_in">next</span>.<span class="built_in">next</span> = next_node  <span class="comment"># 将新节点的next指向原节点的下一个节点</span></span><br><span class="line">        cur = next_node  <span class="comment"># 移动cur到下一个原节点</span></span><br><span class="line">    </span><br><span class="line">    cur = head  <span class="comment"># cur指针重置回头节点，准备设置新节点的random指针</span></span><br><span class="line">    copy = <span class="literal">None</span>  <span class="comment"># copy指针用于指向复制的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二步：为新节点设置random指针</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 保存下一个原节点的位置</span></span><br><span class="line">        copy = cur.<span class="built_in">next</span>  <span class="comment"># 获取当前节点的复制节点</span></span><br><span class="line">        <span class="comment"># 设置复制节点的random指针</span></span><br><span class="line">        <span class="comment"># 如果原节点的random不为空，则其复制节点的random指向原节点random的下一个节点(即random指向节点的复制品)</span></span><br><span class="line">        copy.random = cur.random.<span class="built_in">next</span> <span class="keyword">if</span> cur.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        cur = next_node  <span class="comment"># 移动cur到下一个原节点</span></span><br><span class="line">        </span><br><span class="line">    ans = head.<span class="built_in">next</span>  <span class="comment"># ans是新链表的头节点，即原头节点的下一个节点</span></span><br><span class="line">    cur = head  <span class="comment"># cur指针重置回头节点，准备分离新旧链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三步：分离原链表和新链表</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 保存下一个原节点的位置</span></span><br><span class="line">        copy = cur.<span class="built_in">next</span>  <span class="comment"># 获取当前节点的复制节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = next_node  <span class="comment"># 恢复原链表的next指针</span></span><br><span class="line">        <span class="comment"># 设置复制节点的next指针</span></span><br><span class="line">        <span class="comment"># 如果下一个原节点不为空，则复制节点的next指向下一个原节点的复制节点</span></span><br><span class="line">        copy.<span class="built_in">next</span> = next_node.<span class="built_in">next</span> <span class="keyword">if</span> next_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        cur = next_node  <span class="comment"># 移动cur到下一个原节点</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans  <span class="comment"># 返回新链表的头节点</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：节点插入 + 关系复制 + 链表分离</li>
</ul>
<h2 id="题目四：判断链表是否是回文结构"><a href="#题目四：判断链表是否是回文结构" class="headerlink" title="题目四：判断链表是否是回文结构"></a>题目四：判断链表是否是回文结构</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断链表是否是回文结构，一个链表节点视为一个字符。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：使用栈存储所有节点，然后比较压栈过程和弹栈过程的数字是不是一致的，空间复杂度O(N)。</p>
<p><strong>最优解法</strong>：使用快慢指针找中点，翻转后半部分，然后比较。</p>
<h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交如下的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空链表或只有一个节点的链表是回文结构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    slow = head  <span class="comment"># slow指针每次走一步，fast指针每次走两步</span></span><br><span class="line">    fast = head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找中点，当fast到达链表末尾时，slow正好在中间位置</span></span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>  <span class="comment"># slow指针后移一步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># fast指针后移两步</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 现在中点就是slow，从中点开始往后的节点逆序</span></span><br><span class="line">    pre = slow  <span class="comment"># pre是反转后的链表的头节点，初始是slow</span></span><br><span class="line">    cur = pre.<span class="built_in">next</span>  <span class="comment"># cur是当前要处理的节点，初始是slow的下一个</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next_node用于保存cur的下一个节点</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 断开前半部分和后半部分的连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环反转后半部分链表</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre  <span class="comment"># 当前节点的next指向前一个节点(pre)</span></span><br><span class="line">        pre = cur  <span class="comment"># pre和cur指针后移</span></span><br><span class="line">        cur = next_node</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 上面的过程已经把链表调整成从左右两侧往中间指</span></span><br><span class="line">    <span class="comment"># head -&gt; ... -&gt; slow &lt;- ... &lt;- pre</span></span><br><span class="line">    ans = <span class="literal">True</span>  <span class="comment"># ans默认为True，即假设是回文</span></span><br><span class="line">    left = head  <span class="comment"># left指针从头开始</span></span><br><span class="line">    right = pre  <span class="comment"># right指针从后半部分的头（即反转前的尾）开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># left往右、right往左，每一步比对值是否一样，如果某一步不一样答案就是false</span></span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:  <span class="comment"># 如果左右两边的值不相等</span></span><br><span class="line">            ans = <span class="literal">False</span>  <span class="comment"># 那么不是回文</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 退出循环</span></span><br><span class="line">        left = left.<span class="built_in">next</span>  <span class="comment"># 移动指针</span></span><br><span class="line">        right = right.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 本着不坑的原则，把链表调整回原来的样子再返回判断结果</span></span><br><span class="line">    <span class="comment"># 再次反转后半部分，恢复原链表结构</span></span><br><span class="line">    cur = pre.<span class="built_in">next</span>  <span class="comment"># cur是当前要处理的节点，初始是pre的下一个</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 断开连接</span></span><br><span class="line">    next_node = <span class="literal">None</span>  <span class="comment"># next_node用于保存cur的下一个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环将后半部分链表反转回来</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span>  <span class="comment"># 保存下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre  <span class="comment"># 当前节点的next指向前一个节点(pre)</span></span><br><span class="line">        pre = cur  <span class="comment"># pre和cur指针后移</span></span><br><span class="line">        cur = next_node</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans  <span class="comment"># 返回最终的判断结果</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：快慢指针找中点 + 链表翻转</li>
</ul>
<h2 id="题目五：返回链表的第一个入环节点"><a href="#题目五：返回链表的第一个入环节点" class="headerlink" title="题目五：返回链表的第一个入环节点"></a>题目五：返回链表的第一个入环节点</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断链表是否有环，如果有环，返回入环节点，否则返回None。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>容器解法</strong>：用哈希表记录每个节点，如果某个节点再次出现，则该节点就是入环节点。</p>
<p><strong>最优解法</strong>：使用快慢指针，分两阶段找环。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(12)/class34-%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%BC%9A%E5%9C%A8%E5%85%A5%E7%8E%AF%E5%A4%84%E7%9B%B8%E9%81%87.png" alt="快慢指针会在入环处相遇"></p>
<h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>设链表头到入环点距离为a，入环点到相遇点距离为b，相遇点到入环点距离为c。</p>
<p>当快慢指针相遇时：</p>
<ul>
<li>慢指针走过距离：a + b</li>
<li>快指针走过距离：a + b + c + b &#x3D; a + 2b + c</li>
</ul>
<p>由于快指针速度是慢指针的2倍：<br>2(a + b) &#x3D; a + 2b + c<br>解得：a &#x3D; c</p>
<h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    slow = head.<span class="built_in">next</span>  <span class="comment"># 慢指针slow每次走一步</span></span><br><span class="line">    fast = head.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 快指针fast每次走两步</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一阶段：快慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        <span class="keyword">if</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果快指针或其下一个节点为空，说明没有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span>  <span class="comment"># 慢指针走一步</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 快指针走两步</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 第二阶段：快指针回到头部，同步移动</span></span><br><span class="line">    fast = head  <span class="comment"># 当快慢指针相遇后，将快指针重置到链表头</span></span><br><span class="line">    <span class="comment"># 此时，慢指针和快指针同时以每次一步的速度前进</span></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        slow = slow.<span class="built_in">next</span>  <span class="comment"># 慢指针后移</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>  <span class="comment"># 快指针后移</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> slow  <span class="comment"># 相遇点即为入环点</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>核心技巧</strong>：快慢指针 + 数学推导</li>
</ul>
<h2 id="题目六：链表排序"><a href="#题目六：链表排序" class="headerlink" title="题目六：链表排序"></a>题目六：链表排序</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>在链表上排序，要求时间复杂度O(n*logn)，额外空间复杂度O(1)，还要求排序有稳定性。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>链表由于有指针存在可以做到这个指标，但是数组排序不行。使用自底向上的归并排序，采用非递归方法避免O(logn)的递归空间。</p>
<h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findEnd</span>(<span class="params">self, s: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从s开始找第k个节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> s.<span class="built_in">next</span> <span class="keyword">and</span> k - <span class="number">1</span> &gt; <span class="number">0</span>:</span><br><span class="line">        s = s.<span class="built_in">next</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># l1...r1 -&gt; null : 有序的左部分 (在Python实现中r1,r2参数是不必要的)</span></span><br><span class="line"><span class="comment"># l2...r2 -&gt; null : 有序的右部分</span></span><br><span class="line"><span class="comment"># 整体merge在一起，保证有序</span></span><br><span class="line"><span class="comment"># 并且返回整体的头和尾</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; (ListNode, ListNode):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并两个有序链表，返回头和尾&quot;&quot;&quot;</span></span><br><span class="line">    dummy = <span class="variable language_">self</span>.ListNode(<span class="number">0</span>)  <span class="comment"># dummy是哨兵节点，方便处理</span></span><br><span class="line">    pre = dummy  <span class="comment"># pre指针用于构建新链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当两个链表都不为空时</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="comment"># 比较两个链表节点的值</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            pre.<span class="built_in">next</span> = l1  <span class="comment"># 将较小的节点连接到新链表</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span>  <span class="comment"># 移动l1指针</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre.<span class="built_in">next</span> = l2  <span class="comment"># 将较小的节点连接到新链表</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span>  <span class="comment"># 移动l2指针</span></span><br><span class="line">        pre = pre.<span class="built_in">next</span>  <span class="comment"># 移动pre指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果l1还有剩余，直接连接</span></span><br><span class="line">    <span class="keyword">if</span> l1:</span><br><span class="line">        pre.<span class="built_in">next</span> = l1</span><br><span class="line">    <span class="keyword">elif</span> l2:  <span class="comment"># 如果l2还有剩余，直接连接</span></span><br><span class="line">        pre.<span class="built_in">next</span> = l2</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 找到合并后链表的尾部</span></span><br><span class="line">    <span class="keyword">while</span> pre.<span class="built_in">next</span>:</span><br><span class="line">        pre = pre.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>, pre  <span class="comment"># 返回新链表的头和尾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;正式排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:  <span class="comment"># 如果链表为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="number">0</span>  <span class="comment"># n用于存储链表长度</span></span><br><span class="line">    cur = head  <span class="comment"># cur用于遍历链表</span></span><br><span class="line">    <span class="comment"># 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># l1...r1 每组的左部分</span></span><br><span class="line">    <span class="comment"># l2...r2 每组的右部分</span></span><br><span class="line">    <span class="comment"># next_group_head 下一组的开头</span></span><br><span class="line">    <span class="comment"># last_team_end 上一组的结尾</span></span><br><span class="line">    </span><br><span class="line">    step = <span class="number">1</span>  <span class="comment"># step是每次合并的子链表长度，从1开始，每次翻倍</span></span><br><span class="line">    <span class="keyword">while</span> step &lt; n:</span><br><span class="line">        <span class="comment"># 每一轮归并开始时，重新从头开始，dummy是一个哨兵节点，方便处理头节点</span></span><br><span class="line">        dummy = <span class="variable language_">self</span>.ListNode(<span class="number">0</span>, head)</span><br><span class="line">        last_team_end = dummy  <span class="comment"># last_team_end指向上一次合并后的尾部</span></span><br><span class="line">        cur = dummy.<span class="built_in">next</span>  <span class="comment"># cur指向当前处理的链表的头部</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:       </span><br><span class="line">            l1 = cur  <span class="comment"># l1是第一部分的头</span></span><br><span class="line">            r1 = <span class="variable language_">self</span>.findEnd(l1, step)  <span class="comment"># r1是第一部分的尾</span></span><br><span class="line">            l2 = r1.<span class="built_in">next</span> <span class="keyword">if</span> r1 <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># l2是第二部分的头</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l2:  <span class="comment"># 如果没有第二部分，就结束这一轮的合并</span></span><br><span class="line">                last_team_end.<span class="built_in">next</span> = l1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            r2 = <span class="variable language_">self</span>.findEnd(l2, step)  <span class="comment"># r2是第二部分的尾</span></span><br><span class="line">            </span><br><span class="line">            next_group_head = r2.<span class="built_in">next</span> <span class="keyword">if</span> r2 <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># next_group_head是下一组的头</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 断开链表，准备合并</span></span><br><span class="line">            r1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            r2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            merged_head, merged_end = <span class="variable language_">self</span>.merge(l1, l2)  <span class="comment"># 合并l1和l2两个有序链表</span></span><br><span class="line">            </span><br><span class="line">            last_team_end.<span class="built_in">next</span> = merged_head  <span class="comment"># 将合并后的链表接在上一组的后面</span></span><br><span class="line">            last_team_end = merged_end  <span class="comment"># 更新last_team_end为当前合并后的尾部</span></span><br><span class="line">            </span><br><span class="line">            cur = next_group_head  <span class="comment"># cur指向下一组的开头</span></span><br><span class="line">        </span><br><span class="line">        head = dummy.<span class="built_in">next</span>  <span class="comment"># 更新整个链表的头</span></span><br><span class="line">        step &lt;&lt;= <span class="number">1</span>  <span class="comment"># 步长翻倍</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N*logN)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：是</li>
<li><strong>核心技巧</strong>：自底向上归并 + 非递归实现</li>
</ul>
<h2 id="链表问题核心技巧总结"><a href="#链表问题核心技巧总结" class="headerlink" title="链表问题核心技巧总结"></a>链表问题核心技巧总结</h2><h3 id="1-快慢指针技巧"><a href="#1-快慢指针技巧" class="headerlink" title="1. 快慢指针技巧"></a>1. 快慢指针技巧</h3><p>快慢指针是链表问题中最重要的技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找链表中点</span></span><br><span class="line">slow = fast = head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># slow指向中点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断链表是否有环</span></span><br><span class="line">slow = fast = head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> slow == fast:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 有环</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="2-虚拟头节点技巧"><a href="#2-虚拟头节点技巧" class="headerlink" title="2. 虚拟头节点技巧"></a>2. 虚拟头节点技巧</h3><p>当需要修改头节点时，使用虚拟头节点简化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">dummy.<span class="built_in">next</span> = head</span><br><span class="line"><span class="comment"># 对dummy.next进行操作</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="3-双指针技巧"><a href="#3-双指针技巧" class="headerlink" title="3. 双指针技巧"></a>3. 双指针技巧</h3><p>用于处理需要同时操作两个位置的问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除倒数第n个节点</span></span><br><span class="line">dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">first = second = dummy</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">    first = first.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">while</span> first:</span><br><span class="line">    first = first.<span class="built_in">next</span></span><br><span class="line">    second = second.<span class="built_in">next</span></span><br><span class="line">second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="4-链表翻转技巧"><a href="#4-链表翻转技巧" class="headerlink" title="4. 链表翻转技巧"></a>4. 链表翻转技巧</h3><p>翻转是链表的基础操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">head</span>):</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        next_node = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next_node</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析总结"><a href="#复杂度分析总结" class="headerlink" title="复杂度分析总结"></a>复杂度分析总结</h2><table>
<thead>
<tr>
<th>题目</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心技巧</th>
</tr>
</thead>
<tbody><tr>
<td>链表相交</td>
<td>O(M+N)</td>
<td>O(1)</td>
<td>长度差+双指针</td>
</tr>
<tr>
<td>K组翻转</td>
<td>O(N)</td>
<td>O(1)</td>
<td>分组+局部翻转</td>
</tr>
<tr>
<td>复制随机链表</td>
<td>O(N)</td>
<td>O(1)</td>
<td>节点插入+分离</td>
</tr>
<tr>
<td>回文判断</td>
<td>O(N)</td>
<td>O(1)</td>
<td>快慢指针+翻转</td>
</tr>
<tr>
<td>环检测</td>
<td>O(N)</td>
<td>O(1)</td>
<td>快慢指针+数学</td>
</tr>
<tr>
<td>链表排序</td>
<td>O(N*logN)</td>
<td>O(1)</td>
<td>自底向上归并</td>
</tr>
</tbody></table>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ol>
<li><p><strong>重视编程能力</strong>：链表题目主要考察coding能力，要多练习用有限变量解决问题</p>
</li>
<li><p><strong>掌握核心技巧</strong>：</p>
<ul>
<li>快慢指针（最重要）</li>
<li>虚拟头节点</li>
<li>双指针</li>
<li>链表翻转</li>
</ul>
</li>
<li><p><strong>避免容器方法</strong>：在练习时尽量使用O(1)空间的方法，提升编程能力</p>
</li>
<li><p><strong>注意边界条件</strong>：</p>
<ul>
<li>空链表</li>
<li>单节点链表</li>
<li>链表长度不足的情况</li>
</ul>
</li>
<li><p><strong>保持链表结构</strong>：某些题目要求恢复原链表结构，要特别注意</p>
</li>
</ol>
<p>链表问题虽然算法相对简单，但对编程能力要求较高。通过大量练习和对核心技巧的熟练掌握，可以有效提升解题能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89-%20%E4%BD%8D%E5%9B%BE&%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89-%20%E4%BD%8D%E5%9B%BE&%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（11）- 位图&位运算实现加减乘除</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-16 08:42:46 / Modified: 17:27:38" itemprop="dateCreated datePublished" datetime="2025-08-16T08:42:46+08:00">2025-08-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记包括了位图数据结构的原理、实现和应用，以及如何用位运算实现加减乘除（完全不依赖任何算术运算符）。涵盖了class032 and class033的内容</p>
<h1 id="032【必备】位图"><a href="#032【必备】位图" class="headerlink" title="032【必备】位图"></a>032【必备】位图</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在学习位图之前，需要掌握以下基础知识：</p>
<ul>
<li>二进制和位运算操作</li>
<li>对数器的使用方法</li>
</ul>
<p><strong>Python特别提醒</strong>：在实现位运算题目时需要特别注意溢出和符号扩展问题，通常需要手动处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中处理溢出的常见方法</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h2 id="位图的核心概念"><a href="#位图的核心概念" class="headerlink" title="位图的核心概念"></a>位图的核心概念</h2><h3 id="什么是位图"><a href="#什么是位图" class="headerlink" title="什么是位图"></a>什么是位图</h3><p>位图（Bitset）是一种极其节省空间的数据结构，用于存储大量布尔值。相比传统哈希表，位图具有显著的空间优势：</p>
<ul>
<li><strong>哈希表</strong>：每存储一个数字需要32个bit的空间</li>
<li><strong>位图</strong>：每存储一个数字只需要1个bit的空间</li>
</ul>
<h3 id="位图的基本原理"><a href="#位图的基本原理" class="headerlink" title="位图的基本原理"></a>位图的基本原理</h3><p>位图本质上是用bit组成的数组来存放值，使用bit的状态（1和0）来表示元素的存在性：</p>
<ul>
<li><strong>bit位为1</strong>：表示该数字存在于集合中</li>
<li><strong>bit位为0</strong>：表示该数字不存在于集合中</li>
</ul>
<p><strong>基本思想</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用一个很长的二进制位数组，每一位（bit）对应一个整数的&quot;有无&quot;状态</span><br><span class="line">第0位代表数字0，第1位代表数字1，第2位代表数字2，依此类推</span><br></pre></td></tr></table></figure>

<h3 id="位图的适用场景"><a href="#位图的适用场景" class="headerlink" title="位图的适用场景"></a>位图的适用场景</h3><p><strong>优势</strong>：</p>
<ul>
<li>极大节省空间（1个数字仅占1个bit）</li>
<li>查询和修改操作都是O(1)时间复杂度</li>
<li>支持高效的批量操作</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>必须是连续范围的整数</li>
<li>范围不能过大（适合0到几百万，不适合到几十亿）</li>
<li>只能表示元素的存在性，不能存储额外信息</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>判断大量整数是否存在</li>
<li>统计范围内数字的出现情况</li>
<li>实现简单的集合操作</li>
</ul>
<h2 id="位图的实现"><a href="#位图的实现" class="headerlink" title="位图的实现"></a>位图的实现</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(11)/class32-%E4%BD%8D%E5%9B%BE/%E4%BD%8D%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="位图实现原理"></p>
<h3 id="类设计接口"><a href="#类设计接口" class="headerlink" title="类设计接口"></a>类设计接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitset</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):          <span class="comment"># 初始化位图，支持0~n-1所有数字</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num</span>):             <span class="comment"># 把num加入到位图</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, num</span>):          <span class="comment"># 把num从位图中删除</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, num</span>):         <span class="comment"># 翻转num的状态（存在则删除，不存在则添加）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, num</span>):        <span class="comment"># 查询num是否在位图中</span></span><br></pre></td></tr></table></figure>

<h3 id="完整实现代码"><a href="#完整实现代码" class="headerlink" title="完整实现代码"></a>完整实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitset</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化位图，支持0~n-1范围内的数字</span></span><br><span class="line"><span class="string">        n个数字需要 (n + 31) // 32 个32位整数来存储</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 计算需要多少个32位整数</span></span><br><span class="line">        <span class="comment"># 使用 (n + 31) // 32 实现向上取整</span></span><br><span class="line">        <span class="comment"># 例如：32个数字需要1个整数，33个数字需要2个整数</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span> = [<span class="number">0</span>] * ((n + <span class="number">31</span>) // <span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将num添加到位图中（将对应位设置为1）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># num // 32：确定数字在第几个32位整数中</span></span><br><span class="line">        <span class="comment"># num % 32：确定在该32位整数中的第几位</span></span><br><span class="line">        <span class="comment"># 1 &lt;&lt; (num % 32)：创建掩码，将1左移到对应位置</span></span><br><span class="line">        <span class="comment"># |=：按位或赋值，将对应位设置为1</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (num % <span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将num从位图中删除（将对应位设置为0）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ~(1 &lt;&lt; (num % 32))：创建掩码并取反，除了目标位其他位都是1</span></span><br><span class="line">        <span class="comment"># &amp;=：按位与赋值，将对应位清除为0</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (num % <span class="number">32</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻转num在位图中的状态</span></span><br><span class="line"><span class="string">        如果存在则删除，如果不存在则添加</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ^=：按位异或赋值</span></span><br><span class="line">        <span class="comment"># 如果位是0，异或1后变成1</span></span><br><span class="line">        <span class="comment"># 如果位是1，异或1后变成0</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] ^= <span class="number">1</span> &lt;&lt; (num % <span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断num是否存在于位图中</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># &gt;&gt; (num % 32)：将目标位移动到最低位</span></span><br><span class="line">        <span class="comment"># &amp; 1：提取最低位的值</span></span><br><span class="line">        <span class="comment"># == 1：判断是否为1</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="variable language_">self</span>.<span class="built_in">set</span>[num // <span class="number">32</span>] &gt;&gt; (num % <span class="number">32</span>)) &amp; <span class="number">1</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="关键实现细节"><a href="#关键实现细节" class="headerlink" title="关键实现细节"></a>关键实现细节</h3><h4 id="1-空间分配策略"><a href="#1-空间分配策略" class="headerlink" title="1. 空间分配策略"></a>1. 空间分配策略</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向上取整的巧妙实现</span></span><br><span class="line"><span class="comment"># 对于n个数字，需要的32位整数个数</span></span><br><span class="line">array_size = (n + <span class="number">31</span>) // <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原理：</span></span><br><span class="line"><span class="comment"># - 如果n=32，则(32+31)//32 = 63//32 = 1（正好1个整数）</span></span><br><span class="line"><span class="comment"># - 如果n=33，则(33+31)//32 = 64//32 = 2（需要2个整数）</span></span><br></pre></td></tr></table></figure>

<h4 id="2-位置计算"><a href="#2-位置计算" class="headerlink" title="2. 位置计算"></a>2. 位置计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_position</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算数字num在位图中的位置&quot;&quot;&quot;</span></span><br><span class="line">    array_index = num // <span class="number">32</span>    <span class="comment"># 在第几个32位整数中</span></span><br><span class="line">    bit_index = num % <span class="number">32</span>       <span class="comment"># 在该整数的第几位</span></span><br><span class="line">    <span class="keyword">return</span> array_index, bit_index</span><br></pre></td></tr></table></figure>

<h4 id="3-位运算技巧总结"><a href="#3-位运算技巧总结" class="headerlink" title="3. 位运算技巧总结"></a>3. 位运算技巧总结</h4><table>
<thead>
<tr>
<th>操作</th>
<th>位运算实现</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>设置位为1</td>
<td><code>x |= (1 &lt;&lt; i)</code></td>
<td>按位或运算</td>
</tr>
<tr>
<td>清除位为0</td>
<td><code>x &amp;= ~(1 &lt;&lt; i)</code></td>
<td>按位与运算（掩码取反）</td>
</tr>
<tr>
<td>翻转位</td>
<td><code>x ^= (1 &lt;&lt; i)</code></td>
<td>按位异或运算</td>
</tr>
<tr>
<td>检查位</td>
<td><code>(x &gt;&gt; i) &amp; 1</code></td>
<td>右移后提取最低位</td>
</tr>
</tbody></table>
<h2 id="对数器测试"><a href="#对数器测试" class="headerlink" title="对数器测试"></a>对数器测试</h2><h3 id="测试设计思路"><a href="#测试设计思路" class="headerlink" title="测试设计思路"></a>测试设计思路</h3><p>使用Python内置的<code>set</code>作为参照标准，对位图的所有操作进行验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_bitset</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用对数器验证位图实现的正确性&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="number">1000</span>          <span class="comment"># 位图大小</span></span><br><span class="line">    testTimes = <span class="number">10000</span> <span class="comment"># 测试次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试开始&quot;</span>)</span><br><span class="line">    bitSet = Bitset(n)      <span class="comment"># 被测试的位图结构</span></span><br><span class="line">    hashSet = <span class="built_in">set</span>()         <span class="comment"># 参照标准（Python内置set）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用阶段开始&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(testTimes):</span><br><span class="line">        decide = random.random()                    <span class="comment"># 随机决定操作类型</span></span><br><span class="line">        number = <span class="built_in">int</span>(random.random() * n)          <span class="comment"># 随机生成0~n-1的数字</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> decide &lt; <span class="number">0.333</span>:                         <span class="comment"># 33%概率执行add操作</span></span><br><span class="line">            bitSet.add(number)</span><br><span class="line">            hashSet.add(number)</span><br><span class="line">        <span class="keyword">elif</span> decide &lt; <span class="number">0.666</span>:                       <span class="comment"># 33%概率执行remove操作</span></span><br><span class="line">            bitSet.remove(number)</span><br><span class="line">            hashSet.discard(number)                <span class="comment"># 使用discard避免KeyError</span></span><br><span class="line">        <span class="keyword">else</span>:                                      <span class="comment"># 34%概率执行reverse操作</span></span><br><span class="line">            bitSet.reverse(number)</span><br><span class="line">            <span class="keyword">if</span> number <span class="keyword">in</span> hashSet:</span><br><span class="line">                hashSet.remove(number)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashSet.add(number)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用阶段结束&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证阶段开始&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证所有数字的存在性是否一致</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> bitSet.contains(i) != (i <span class="keyword">in</span> hashSet):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;出错了!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证阶段结束&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试结束&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="测试覆盖的场景"><a href="#测试覆盖的场景" class="headerlink" title="测试覆盖的场景"></a>测试覆盖的场景</h3><ol>
<li><strong>随机操作序列</strong>：大量随机的增删改查操作</li>
<li><strong>边界条件</strong>：0和n-1等边界值</li>
<li><strong>重复操作</strong>：对同一个数字的重复操作</li>
<li><strong>状态一致性</strong>：每次操作后验证状态的一致性</li>
</ol>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>O(n&#x2F;32)</td>
<td>需要初始化数组</td>
</tr>
<tr>
<td>add</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
<tr>
<td>remove</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
<tr>
<td>reverse</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
<tr>
<td>contains</td>
<td>O(1)</td>
<td>常数时间位运算</td>
</tr>
</tbody></table>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>位图空间</strong>：O(n&#x2F;32) &#x3D; O(n)</li>
<li><strong>相比哈希表</strong>：空间节省约32倍</li>
</ul>
<h3 id="实际空间对比"><a href="#实际空间对比" class="headerlink" title="实际空间对比"></a>实际空间对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储1000万个数字的空间对比</span></span><br><span class="line">numbers = <span class="number">10_000_000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希表（假设每个数字32位）</span></span><br><span class="line">hash_space = numbers * <span class="number">32</span>  <span class="comment"># 320,000,000 bits</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位图</span></span><br><span class="line">bitset_space = numbers * <span class="number">1</span>  <span class="comment"># 10,000,000 bits</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空间节省比例</span></span><br><span class="line">space_saving = hash_space / bitset_space  <span class="comment"># 32倍</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景与扩展"><a href="#应用场景与扩展" class="headerlink" title="应用场景与扩展"></a>应用场景与扩展</h2><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ol>
<li><strong>大数据去重</strong>：判断海量数据中的重复元素</li>
<li><strong>布隆过滤器基础</strong>：位图是布隆过滤器的核心组件</li>
<li><strong>状态压缩</strong>：在动态规划中压缩状态空间</li>
<li><strong>集合运算</strong>：高效实现并集、交集、差集运算</li>
</ol>
<h3 id="位图的集合运算"><a href="#位图的集合运算" class="headerlink" title="位图的集合运算"></a>位图的集合运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bitset_union</span>(<span class="params">bitset1, bitset2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位图并集运算&quot;&quot;&quot;</span></span><br><span class="line">    result = Bitset(<span class="built_in">max</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>)) * <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>))):</span><br><span class="line">        result.<span class="built_in">set</span>[i] = bitset1.<span class="built_in">set</span>[i] | bitset2.<span class="built_in">set</span>[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bitset_intersection</span>(<span class="params">bitset1, bitset2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位图交集运算&quot;&quot;&quot;</span></span><br><span class="line">    result = Bitset(<span class="built_in">max</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>)) * <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(bitset1.<span class="built_in">set</span>), <span class="built_in">len</span>(bitset2.<span class="built_in">set</span>))):</span><br><span class="line">        result.<span class="built_in">set</span>[i] = bitset1.<span class="built_in">set</span>[i] &amp; bitset2.<span class="built_in">set</span>[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_missing_numbers</span>(<span class="params">arr, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找出0到n-1范围内缺失的所有数字&quot;&quot;&quot;</span></span><br><span class="line">    bitset = Bitset(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 标记存在的数字</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= num &lt; n:</span><br><span class="line">            bitset.add(num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找出缺失的数字</span></span><br><span class="line">    missing = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bitset.contains(i):</span><br><span class="line">            missing.append(i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> missing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">missing = find_missing_numbers(arr, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;缺失的数字: <span class="subst">&#123;missing&#125;</span>&quot;</span>)  <span class="comment"># 输出: [2, 4, 5, 8]</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位图是一种非常实用的数据结构，特别适合处理大量整数的存在性判断问题。它的核心优势在于：</p>
<ol>
<li><strong>极致的空间效率</strong>：相比传统数据结构节省32倍空间</li>
<li><strong>优秀的时间性能</strong>：所有基本操作都是O(1)时间复杂度</li>
<li><strong>简单的实现逻辑</strong>：基于基础位运算，易于理解和实现</li>
</ol>
<p>在大数据处理、系统设计等场景中，位图都是一个非常有价值的工具。</p>
<h1 id="033【必备】位运算实现加减乘除"><a href="#033【必备】位运算实现加减乘除" class="headerlink" title="033【必备】位运算实现加减乘除"></a>033【必备】位运算实现加减乘除</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>位运算实现四则运算的核心在于模拟计算机底层的运算逻辑：</p>
<ul>
<li><strong>加法</strong>：基于异或（无进位相加）和与运算（进位处理）</li>
<li><strong>减法</strong>：通过加法和取反实现</li>
<li><strong>乘法</strong>：基于移位和加法的重复运算</li>
<li><strong>除法</strong>：基于减法和移位的优化算法</li>
</ul>
<h2 id="Python中的特殊处理"><a href="#Python中的特殊处理" class="headerlink" title="Python中的特殊处理"></a>Python中的特殊处理</h2><p>在实现过程中，需要特别注意Python与Java的差异：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Java中的整数范围限制</span></span><br><span class="line">MIN = -<span class="number">2</span>**<span class="number">31</span>      <span class="comment"># -2147483648</span></span><br><span class="line">MAX = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>   <span class="comment"># 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python中需要手动处理32位整数溢出</span></span><br><span class="line">result &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保持32位</span></span><br><span class="line"><span class="keyword">if</span> result &gt; <span class="number">0x7FFFFFFF</span>:</span><br><span class="line">    result = ~(result ^ <span class="number">0xFFFFFFFF</span>)  <span class="comment"># 转换为有符号整数</span></span><br></pre></td></tr></table></figure>

<h2 id="1-加法实现（核心基础）"><a href="#1-加法实现（核心基础）" class="headerlink" title="1. 加法实现（核心基础）"></a>1. 加法实现（核心基础）</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>加法的位运算实现基于两个关键概念：</p>
<ol>
<li><strong>无进位相加</strong>：使用异或运算（XOR）</li>
<li><strong>进位信息</strong>：使用与运算（AND）后左移</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位运算实现加法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#单次相加的结果为：无进位相加的结果+进位信息</span></span><br><span class="line">    ans = a</span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>: <span class="comment"># 当b为0时，说明没有进位了，加法结束</span></span><br><span class="line">        <span class="comment"># 单次进位只能把当前位的进位信息加到下一高位，但新一位的进位可能和更高位产生新的进位冲突，需要继续处理。</span></span><br><span class="line">        <span class="comment"># 只有所有进位都为0，结果才是完整无误的。</span></span><br><span class="line">        <span class="comment"># ans : a和b无进位相加的结果</span></span><br><span class="line">        ans = a ^ b</span><br><span class="line">        <span class="comment"># b : a和b相加时的进位信息</span></span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># Python中int无限大，为了模拟int32，需要对超出部分进行处理</span></span><br><span class="line">        <span class="comment"># 下面两行确保ans和b都保持32位</span></span><br><span class="line">        ans &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        b &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        a = ans</span><br><span class="line">    <span class="comment"># 处理负数转为补码</span></span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(ans ^ <span class="number">0xFFFFFFFF</span>)  <span class="comment">#结果超过最大值时，需要将无符号32位结果转换为有符号，当加法结果超过0x7FFFFFFF时，实际上表示的是负数，需要转换为对应的有符号表示</span></span><br><span class="line">    <span class="comment">#将ans与全1进行异或，相当于按位取反，~(...)：再次取反，相当于恢复原值</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以 <code>5 + 3</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第1轮：a=5(101), b=3(011)</span><br><span class="line">  无进位：5^3 = 101^011 = 110 = 6</span><br><span class="line">  进位：(5&amp;3)&lt;&lt;1 = (001)&lt;&lt;1 = 010 = 2</span><br><span class="line">  </span><br><span class="line">第2轮：a=6(110), b=2(010)  </span><br><span class="line">  无进位：6^2 = 110^010 = 100 = 4</span><br><span class="line">  进位：(6&amp;2)&lt;&lt;1 = (010)&lt;&lt;1 = 100 = 4</span><br><span class="line">  </span><br><span class="line">第3轮：a=4(100), b=4(100)</span><br><span class="line">  无进位：4^4 = 100^100 = 000 = 0</span><br><span class="line">  进位：(4&amp;4)&lt;&lt;1 = (100)&lt;&lt;1 = 1000 = 8</span><br><span class="line">  </span><br><span class="line">第4轮：a=0(000), b=8(1000)</span><br><span class="line">  无进位：0^8 = 1000 = 8</span><br><span class="line">  进位：(0&amp;8)&lt;&lt;1 = 0</span><br><span class="line">  </span><br><span class="line">结果：8</span><br></pre></td></tr></table></figure>

<h2 id="2-取反运算"><a href="#2-取反运算" class="headerlink" title="2. 取反运算"></a>2. 取反运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">neg</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;取相反数：~n + 1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.add(~n, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>基于补码的性质：一个数的相反数等于该数按位取反后加1。</p>
<ul>
<li>正数：直接按位取反加1</li>
<li>负数：同样规则，利用补码特性</li>
</ul>
<h2 id="3-减法实现"><a href="#3-减法实现" class="headerlink" title="3. 减法实现"></a>3. 减法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minus</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;减法就是加上-b&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.add(a, BitOperationAddMinusMultiplyDivide.neg(b))</span><br></pre></td></tr></table></figure>

<p>减法的实现非常简洁：<code>a - b = a + (-b)</code></p>
<h2 id="4-乘法实现（龟速乘）"><a href="#4-乘法实现（龟速乘）" class="headerlink" title="4. 乘法实现（龟速乘）"></a>4. 乘法实现（龟速乘）</h2><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><p>基于二进制乘法的原理，将乘法转换为多次加法和移位运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位运算实现乘法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把乘法拆成若干次加法，用位运算（移位）和加法实现，不直接用乘号，适合大数和防溢出场合。</span></span><br><span class="line">    <span class="comment"># 二进制的乘法也是像十进制一样，从右到左，一位一位的乘，然后错位相加</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 为了模拟int32，确保a, b, ans都在32位内</span></span><br><span class="line">    a &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">    b &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>: <span class="comment">#说明乘数没有耗尽，继续乘</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) != <span class="number">0</span>: <span class="comment">#说明当前位是1，需要加到结果上</span></span><br><span class="line">            <span class="comment"># 考察b当前最右的状态！</span></span><br><span class="line">            ans = BitOperationAddMinusMultiplyDivide.add(ans, a)</span><br><span class="line">            ans &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保持32位</span></span><br><span class="line">        a = (a &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>  <span class="comment"># 左移并保持32位</span></span><br><span class="line">        <span class="comment"># Java中的 &gt;&gt;&gt; 表示无符号右移，Python没有，需特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> b &gt;= <span class="number">0</span>:</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#在Java中，&gt;&gt;&gt; 是无符号右移操作，无论原数是正数还是负数，右移时都在高位补0。但在Python中，&gt;&gt; 是有符号右移，对于负数会补1</span></span><br><span class="line">            <span class="comment">#内存中：b + 0x100000000和b的位模式完全相同，这时候又该告诉python该改变语义理解了</span></span><br><span class="line">            b = (b + <span class="number">0x100000000</span>) &gt;&gt; <span class="number">1</span> <span class="comment">#0x100000000等于2^32</span></span><br><span class="line">        b &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保持32位</span></span><br><span class="line">    <span class="comment"># 处理负数转为补码</span></span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(ans ^ <span class="number">0xFFFFFFFF</span>) <span class="comment"># 0xFFFFFFFF是全1，保证结果是32位，</span></span><br><span class="line">    <span class="comment"># 如果结果超过0x7FFFFFFF，说明发生了溢出</span></span><br><span class="line">    <span class="comment"># 使用~(ans ^ 0xFFFFFFFF)将结果&quot;包装&quot;到32位范围内</span></span><br><span class="line">    <span class="comment"># 这样就能得到正确的有符号32位整数结果</span></span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例-1"><a href="#执行过程示例-1" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以 <code>5 × 3</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3的二进制：011</span><br><span class="line">第1轮：b=011, b&amp;1=1, ans += 5×2^0 = 5</span><br><span class="line">第2轮：b=001, b&amp;1=1, ans += 5×2^1 = 5+10 = 15</span><br><span class="line">第3轮：b=000, 结束</span><br><span class="line">结果：15</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种”龟速乘”在以下场景特别有用：</p>
<ul>
<li>大数乘法防溢出</li>
<li>模运算：<code>(a × b) % m</code></li>
<li>快速幂运算的基础</li>
</ul>
<h2 id="5-除法实现（最复杂）"><a href="#5-除法实现（最复杂）" class="headerlink" title="5. 除法实现（最复杂）"></a>5. 除法实现（最复杂）</h2><h3 id="核心挑战"><a href="#核心挑战" class="headerlink" title="核心挑战"></a>核心挑战</h3><p>除法是四则运算中最复杂的，需要处理多种边界情况：</p>
<ol>
<li>除数为0的情况</li>
<li>整数最小值的特殊处理</li>
<li>溢出预防</li>
<li>符号处理</li>
</ol>
<h3 id="主要函数结构"><a href="#主要函数结构" class="headerlink" title="主要函数结构"></a>主要函数结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主除法函数，处理各种边界情况&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 处理 a 和 b 都为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> a == BitOperationAddMinusMultiplyDivide.MIN <span class="keyword">and</span> b == BitOperationAddMinusMultiplyDivide.MIN:</span><br><span class="line">        <span class="comment"># a和b都是整数最小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 处理 a 和 b 都不是最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> a != BitOperationAddMinusMultiplyDivide.MIN <span class="keyword">and</span> b != BitOperationAddMinusMultiplyDivide.MIN:</span><br><span class="line">        <span class="comment"># a和b都不是整数最小，那么正常去除</span></span><br><span class="line">        <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.div(a, b)</span><br><span class="line">    <span class="comment"># 处理 b 为最小值的情况</span></span><br><span class="line">    <span class="keyword">if</span> b == BitOperationAddMinusMultiplyDivide.MIN: </span><br><span class="line">        <span class="comment"># a不是整数最小，b是整数最小，整数最小值是负数，而且整数最小值无法转成相反数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 处理 a 为最小值，b 为 -1 的情况（防止溢出）</span></span><br><span class="line">    <span class="comment"># 第1个if不成立：a 和 b 不都是最小值；第2个if不成立：a 和 b 不都不是最小值；第3个if不成立：b 不是最小值，则排除完b，a就是最小值</span></span><br><span class="line">    <span class="keyword">if</span> b == BitOperationAddMinusMultiplyDivide.neg(<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了</span></span><br><span class="line">        <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.MAX</span><br><span class="line">    <span class="comment"># a是整数最小，b不是整数最小，b也不是-1</span></span><br><span class="line">    a = BitOperationAddMinusMultiplyDivide.add(a, b <span class="keyword">if</span> b &gt; <span class="number">0</span> <span class="keyword">else</span> BitOperationAddMinusMultiplyDivide.neg(b)) <span class="comment">#让 a 不再是最小值，这样就可以安全地调用 div 函数了，如果 b &gt; 0：a = a + b；如果 b &lt; 0：a = a + (-b)</span></span><br><span class="line">    ans = BitOperationAddMinusMultiplyDivide.div(a, b) <span class="comment"># 现在 a 不再是最小值，可以安全地调用 div 函数</span></span><br><span class="line">    offset = BitOperationAddMinusMultiplyDivide.neg(<span class="number">1</span>) <span class="keyword">if</span> b &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="comment"># 如果 b &gt; 0，则 offset = -1；如果 b &lt; 0，则 offset = 1</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.add(ans, offset) <span class="comment"># 最后把 offset 加回去</span></span><br></pre></td></tr></table></figure>

<h3 id="核心除法算法"><a href="#核心除法算法" class="headerlink" title="核心除法算法"></a>核心除法算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a, b</span>): <span class="comment">#向下取整，但是不返回余数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;核心除法实现，要求a和b都不是整数最小值&quot;&quot;&quot;</span></span><br><span class="line">    x = BitOperationAddMinusMultiplyDivide.neg(a) <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">else</span> a  <span class="comment"># 取绝对值</span></span><br><span class="line">    y = BitOperationAddMinusMultiplyDivide.neg(b) <span class="keyword">if</span> b &lt; <span class="number">0</span> <span class="keyword">else</span> b  <span class="comment"># 取绝对值</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    i = <span class="number">30</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># (x &gt;&gt; i) &gt;= y 时，说明y &lt;&lt; i 还能减掉</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;&gt; i) &gt;= y: <span class="comment">#判断x右移i位后是否大于等于y，若大于则记录1</span></span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i)  <span class="comment"># 记录这个位</span></span><br><span class="line">            x = BitOperationAddMinusMultiplyDivide.minus(x, y &lt;&lt; i)  <span class="comment"># x 减去 y &lt;&lt; i，即y*2^i</span></span><br><span class="line">        i = BitOperationAddMinusMultiplyDivide.minus(i, <span class="number">1</span>)  <span class="comment"># 相当于 i--</span></span><br><span class="line">    <span class="comment"># 最后根据正负判断符号</span></span><br><span class="line">    <span class="keyword">return</span> BitOperationAddMinusMultiplyDivide.neg(ans) <span class="keyword">if</span> (a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>) <span class="keyword">else</span> ans <span class="comment">#当两个数的符号不同时，结果取负；当符号相同时，结果保持正。</span></span><br></pre></td></tr></table></figure>

<h3 id="算法原理解析"><a href="#算法原理解析" class="headerlink" title="算法原理解析"></a>算法原理解析</h3><p>除法算法本质上是<strong>二分查找的变种</strong>：</p>
<ol>
<li><strong>从高位到低位</strong>：尝试每一位是否能为1</li>
<li><strong>位移优化</strong>：<code>y &lt;&lt; i</code> 相当于 <code>y × 2^i</code></li>
<li><strong>贪心策略</strong>：能减就减，记录对应的位</li>
</ol>
<h3 id="执行过程示例-2"><a href="#执行过程示例-2" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以 <code>10 ÷ 3</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=10, y=3</span><br><span class="line">i=30: (10&gt;&gt;30)=0 &lt; 3, 跳过</span><br><span class="line">...</span><br><span class="line">i=2: (10&gt;&gt;2)=2 &lt; 3, 跳过  </span><br><span class="line">i=1: (10&gt;&gt;1)=5 &gt;= 3, ans|=(1&lt;&lt;1), x=10-6=4</span><br><span class="line">i=0: (4&gt;&gt;0)=4 &gt;= 3, ans|=(1&lt;&lt;0), x=4-3=1</span><br><span class="line">结果：ans = 11(二进制) = 3(十进制)</span><br></pre></td></tr></table></figure>

<h2 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h2><h3 id="整数最小值的特殊性"><a href="#整数最小值的特殊性" class="headerlink" title="整数最小值的特殊性"></a>整数最小值的特殊性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MIN = -<span class="number">2</span>**<span class="number">31</span>  <span class="comment"># -2147483648</span></span><br><span class="line">MAX = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>  <span class="comment"># 2147483647</span></span><br></pre></td></tr></table></figure>

<p>整数最小值的特殊性在于它<strong>没有对应的正数</strong>，因为：</p>
<ul>
<li>最小值的绝对值是 <code>2^31</code></li>
<li>最大正整数只有 <code>2^31 - 1</code></li>
</ul>
<h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><ol>
<li><strong>预处理</strong>：将最小值调整为非最小值</li>
<li><strong>后处理</strong>：补偿调整造成的误差</li>
<li><strong>特殊返回</strong>：<code>MIN ÷ (-1)</code> 返回 <code>MAX</code></li>
</ol>
<h2 id="完整实现的使用示例"><a href="#完整实现的使用示例" class="headerlink" title="完整实现的使用示例"></a>完整实现的使用示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类实例</span></span><br><span class="line">calc = BitOperationAddMinusMultiplyDivide()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试各种运算</span></span><br><span class="line"><span class="built_in">print</span>(calc.add(<span class="number">15</span>, <span class="number">27</span>))        <span class="comment"># 42</span></span><br><span class="line"><span class="built_in">print</span>(calc.minus(<span class="number">50</span>, <span class="number">18</span>))      <span class="comment"># 32  </span></span><br><span class="line"><span class="built_in">print</span>(calc.multiply(<span class="number">6</span>, <span class="number">7</span>))     <span class="comment"># 42</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(<span class="number">84</span>, <span class="number">2</span>))      <span class="comment"># 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试边界情况</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(-<span class="number">2</span>**<span class="number">31</span>, -<span class="number">1</span>)) <span class="comment"># 2**31-1 (MAX)</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(<span class="number">10</span>, <span class="number">3</span>))      <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(calc.divide(-<span class="number">10</span>, <span class="number">3</span>))     <span class="comment"># -3</span></span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><table>
<thead>
<tr>
<th>运算</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>加法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>最多32次循环</td>
</tr>
<tr>
<td>减法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>调用加法和取反</td>
</tr>
<tr>
<td>乘法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>最多32次循环</td>
</tr>
<tr>
<td>除法</td>
<td>O(1)</td>
<td>O(1)</td>
<td>固定31次循环</td>
</tr>
</tbody></table>
<p>虽然有循环，但循环次数是固定的（最多32次），所以时间复杂度为常数。</p>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul>
<li><ol>
<li>底层系统编程<br>在某些嵌入式系统或底层驱动中，可能需要在没有算术运算单元的情况下实现运算。</li>
</ol>
</li>
<li><ol start="2">
<li>大数运算<br>在实现大整数库时，这些技巧是基础构建块。</li>
</ol>
</li>
<li><ol start="3">
<li>密码学应用<br>在某些密码学算法中，需要避免使用标准库的运算函数。</li>
</ol>
</li>
<li><ol start="4">
<li>算法竞赛<br>某些特殊题目可能限制算术运算的使用。</li>
</ol>
</li>
<li><ol start="5">
<li>教学演示<br>帮助理解计算机底层运算原理。</li>
</ol>
</li>
</ul>
<h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>位运算实现四则运算展示了计算机底层运算的本质。虽然在实际开发中很少直接使用，但理解这些原理对于：</p>
<ol>
<li><strong>加深对计算机原理的理解</strong></li>
<li><strong>提升位运算技巧</strong>  </li>
<li><strong>应对特殊场景需求</strong></li>
<li><strong>算法思维的训练</strong></li>
</ol>
<p>都具有重要意义。特别是除法的实现，体现了二分思想和贪心策略的完美结合，是位运算技巧的集大成者。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89-%20%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89-%20%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（10）- 异或运算和位运算的骚操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-14 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-14T08:42:46+08:00">2025-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-16 17:19:15" itemprop="dateModified" datetime="2025-08-16T17:19:15+08:00">2025-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了异或运算和位运算的高效技巧与应用，包括了class030 -&gt; class031的内容</p>
<h1 id="030【必备】异或运算的骚操作"><a href="#030【必备】异或运算的骚操作" class="headerlink" title="030【必备】异或运算的骚操作"></a>030【必备】异或运算的骚操作</h1><h2 id="异或运算的核心性质"><a href="#异或运算的核心性质" class="headerlink" title="异或运算的核心性质"></a>异或运算的核心性质</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>异或运算是计算机科学中一种重要的位运算，符号为<code>^</code>。在Python中实现位运算题目时需要特别注意溢出和符号扩展问题，通常需要手动处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中处理溢出的常见方法</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h3 id="异或运算的四大核心性质"><a href="#异或运算的四大核心性质" class="headerlink" title="异或运算的四大核心性质"></a>异或运算的四大核心性质</h3><h4 id="1-异或运算就是无进位相加"><a href="#1-异或运算就是无进位相加" class="headerlink" title="1. 异或运算就是无进位相加"></a>1. 异或运算就是无进位相加</h4><p>这是理解异或运算最重要的性质，其他所有性质都可以由此推导得出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：5 ^ 3</span><br><span class="line">5: 101</span><br><span class="line">3: 011</span><br><span class="line">   ---</span><br><span class="line">   110  (结果为6)</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(10)/class30-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/%E5%BC%82%E6%88%96%E9%A2%84%E7%AE%97%E5%8F%96%E4%B8%8B%E6%A0%87.png" alt="异或预算取下标"></p>
<h4 id="2-异或运算满足交换律和结合律"><a href="#2-异或运算满足交换律和结合律" class="headerlink" title="2. 异或运算满足交换律和结合律"></a>2. 异或运算满足交换律和结合律</h4><p>同一批数字，不管异或顺序如何，最终结果都相同：</p>
<ul>
<li>a ^ b &#x3D; b ^ a（交换律）</li>
<li>(a ^ b) ^ c &#x3D; a ^ (b ^ c)（结合律）</li>
</ul>
<h4 id="3-特殊值性质"><a href="#3-特殊值性质" class="headerlink" title="3. 特殊值性质"></a>3. 特殊值性质</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任何数与0异或等于自己</span></span><br><span class="line"><span class="number">0</span> ^ n = n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任何数与自己异或等于0</span></span><br><span class="line">n ^ n = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(10)/class30-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/n%E6%88%96n.png" alt="n或n"></p>
<h4 id="4-整体异或和性质"><a href="#4-整体异或和性质" class="headerlink" title="4. 整体异或和性质"></a>4. 整体异或和性质</h4><p>如果整体异或和为x，其中某部分异或和为y，那么剩余部分的异或和为<code>x ^ y</code>。</p>
<p>这个性质在很多题目中都有应用，特别是区间异或和相关的问题。</p>
<h3 id="有趣的数学问题"><a href="#有趣的数学问题" class="headerlink" title="有趣的数学问题"></a>有趣的数学问题</h3><p>让我们从一个有趣的概率问题开始：</p>
<p><strong>问题</strong>：袋子里有a个白球，b个黑球。每次取2个球：</p>
<ul>
<li>取出2个白球或2个黑球 → 放回1个白球</li>
<li>取出1白1黑 → 放回1个黑球</li>
</ul>
<p>最终袋子里剩1个球，问这个球是黑球的概率？</p>
<p><strong>答案</strong>：</p>
<ul>
<li>如果黑球数量为偶数，最终是黑球的概率为0%</li>
<li>如果黑球数量为奇数，最终是黑球的概率为100%</li>
<li>完全与白球数量无关！</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(10)/class30-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/%E9%BB%91%E7%99%BD%E7%90%83%E7%BB%93%E6%9E%9C.png" alt="黑白球结果"></p>
<p>这个结果与异或运算的性质有关：黑球数量的奇偶性在整个过程中保持不变。</p>
<h2 id="经典应用题目"><a href="#经典应用题目" class="headerlink" title="经典应用题目"></a>经典应用题目</h2><h3 id="题目1：用异或运算交换两数的值"><a href="#题目1：用异或运算交换两数的值" class="headerlink" title="题目1：用异或运算交换两数的值"></a>题目1：用异或运算交换两数的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">    <span class="comment"># 注意：当i==j时会出错，实际开发中不推荐使用</span></span><br><span class="line">    <span class="keyword">if</span> i != j:  <span class="comment"># 添加安全检查</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j]  <span class="comment"># 第一步</span></span><br><span class="line">        arr[j] = arr[i] ^ arr[j]  <span class="comment"># 第二步：arr[j]变成原arr[i]</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j]  <span class="comment"># 第三步：arr[i]变成原arr[j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更简洁的变量交换</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap_variables</span>():</span><br><span class="line">    a, b = -<span class="number">2323</span>, <span class="number">10</span></span><br><span class="line">    a = a ^ b  <span class="comment"># a现在是原a^原b</span></span><br><span class="line">    b = a ^ b  <span class="comment"># b现在是原a^原b^原b = 原a</span></span><br><span class="line">    a = a ^ b  <span class="comment"># a现在是原a^原b^原a = 原b</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = -<span class="number">2323</span>  <span class="comment"># 定义a</span></span><br><span class="line">    b = <span class="number">10</span>     <span class="comment"># 定义b  因为a^b=b^a ，这么操作的前提是a和b都有自己的内存空间</span></span><br><span class="line">    a = a ^ b  <span class="comment"># 第一步，a和b异或后的结果给a</span></span><br><span class="line">    b = a ^ b  <span class="comment"># 第二步，a和b再次异或的结果赋给b，b&#x27;=(a^b)^b</span></span><br><span class="line">    a = a ^ b  <span class="comment"># 第三步，a和b再次异或的结果赋给a,a&#x27;&#x27;=a^b^((a^b)^b)=a^b^a^b^b=a^b^a，根据交换律，a^b^a=a^a^b=b</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment"># 输出此时的a</span></span><br><span class="line">    <span class="built_in">print</span>(b)   <span class="comment"># 输出此时的b</span></span><br><span class="line"></span><br><span class="line">    arr = [<span class="number">3</span>, <span class="number">5</span>]          <span class="comment"># 定义一个数组</span></span><br><span class="line">    swap(arr, <span class="number">0</span>, <span class="number">1</span>)       <span class="comment"># 交换arr[0]和arr[1]</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">0</span>])         <span class="comment"># 输出交换后的arr[0],输出3</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">1</span>])         <span class="comment"># 输出交换后的arr[1],输出5</span></span><br><span class="line">    swap(arr, <span class="number">0</span>, <span class="number">0</span>)       <span class="comment"># 交换同一个元素（java会出错，需谨慎，但是python不会） Python的整数对象是不可变的，每次赋值都会创建新的整数对象。更重要的是，Python的异或运算对于相同值的结果是 0，这是数学上正确的，内存模型不同：Java：直接操作内存中的值Python：操作的是对象的引用，整数是不可变对象</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">0</span>])         <span class="comment"># 输出arr[0]，输出3</span></span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">1</span>])         <span class="comment"># 输出arr[1]，输出5</span></span><br></pre></td></tr></table></figure>

<p><strong>原理分析</strong>：</p>
<ol>
<li>第一步：<code>a = a ^ b</code>，a存储了原始a和b的异或结果</li>
<li>第二步：<code>b = a ^ b ，则 b&#39;=(a^b)^b</code></li>
<li>第三步：<code>a = a ^ b ，则 a&#39;&#39;=a^b^((a^b)^b)=a^b^a^b^b=a^b^a，根据交换律，a^b^a=a^a^b=b</code></li>
</ol>
<h3 id="题目2：不用判断语句返回两数最大值"><a href="#题目2：不用判断语句返回两数最大值" class="headerlink" title="题目2：不用判断语句返回两数最大值"></a>题目2：不用判断语句返回两数最大值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;翻转0和1&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> n ^ <span class="number">1</span>  <span class="comment"># 0变1，1变0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;非负数返回1，负数返回0&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> flip((n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#因为负数符号位为1，正数符号位为0，所以负数右移31位后符号位为1，正数右移31位后符号位为0</span></span><br><span class="line">    <span class="comment"># 右移后得到的值，可能不是严格的0或1，尤其在Python里，负数右移得到的是全1（二进制全是1，对应十进制-1）。</span></span><br><span class="line">    <span class="comment"># 所以为了保证只取最低1位（也就是现在的符号位），要 &amp; 1。</span></span><br><span class="line">    <span class="comment"># 如果结果是0，0 &amp; 1 = 0。</span></span><br><span class="line">    <span class="comment"># 如果结果是-1，-1 &amp; 1 = 1（因为-1的二进制补码是全1)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMax1</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 有溢出风险的实现，若c溢出了的话会出错</span></span><br><span class="line">    c = a - b                    <span class="comment"># 计算差值</span></span><br><span class="line">    returnA = sign(c)            <span class="comment"># 差值非负则返回a</span></span><br><span class="line">    returnB = flip(returnA)      <span class="comment"># 差值负则返回b</span></span><br><span class="line">    <span class="keyword">return</span> a * returnA + b * returnB  <span class="comment"># 保证互斥就行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMax2</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 没有溢出风险的实现，增加了一个判断a、b符号的逻辑</span></span><br><span class="line">    c = a - b                    <span class="comment"># 差值</span></span><br><span class="line">    sa = sign(a)                 <span class="comment"># a的符号，非负返回1，负数返回0</span></span><br><span class="line">    sb = sign(b)                 <span class="comment"># b的符号</span></span><br><span class="line">    sc = sign(c)                 <span class="comment"># 差值的符号</span></span><br><span class="line">    diffAB = sa ^ sb             <span class="comment"># 判断a和b的符号是否一样，如果符号不同，则为1；符号一样，则为0</span></span><br><span class="line">    sameAB = flip(diffAB)        <span class="comment"># 符号相同，则为1</span></span><br><span class="line">    returnA = diffAB * sa + sameAB * sc  <span class="comment"># 决定返回哪个，diffAB和sameAB只有一个能为1，a和b的符号不同，且a非负，则返回1；a和b的符号相同，且c非负，则返回1，整合起来就是判断a</span></span><br><span class="line">    returnB = flip(returnA)                <span class="comment"># 另一个</span></span><br><span class="line">    <span class="keyword">return</span> a * returnA + b * returnB       <span class="comment"># 返回最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例用法</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = -<span class="number">2</span>**<span class="number">31</span>                <span class="comment"># Integer.MIN_VALUE</span></span><br><span class="line">    b = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>             <span class="comment"># Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment"># getMax1方法会错误，因为溢出</span></span><br><span class="line">    <span class="built_in">print</span>(getMax1(a, b))      <span class="comment"># 可能错误</span></span><br><span class="line">    <span class="comment"># getMax2方法永远正确</span></span><br><span class="line">    <span class="built_in">print</span>(getMax2(a, b))      <span class="comment"># 永远正确</span></span><br></pre></td></tr></table></figure>

<p><strong>核心思想</strong>：</p>
<ul>
<li>通过位运算判断数字符号</li>
<li>用乘法实现条件选择，避免if语句</li>
<li>处理溢出情况，确保算法的鲁棒性</li>
</ul>
<h3 id="题目3：找到缺失的数字"><a href="#题目3：找到缺失的数字" class="headerlink" title="题目3：找到缺失的数字"></a>题目3：找到缺失的数字</h3><p><strong>题目</strong>：给定包含n个不同数字的数组，数字范围为[0,n]，找出缺失的那个数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://leetcode.cn/problems/missing-number/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># eorAll用于异或0~n，0到10之间的数字缺了一个</span></span><br><span class="line">    <span class="comment"># eorHas用于异或数组内所有数</span></span><br><span class="line">    eorAll = <span class="number">0</span>                  <span class="comment"># 初始化eorAll</span></span><br><span class="line">    eorHas = <span class="number">0</span>                  <span class="comment"># 初始化eorHas</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):  <span class="comment"># 遍历数组</span></span><br><span class="line">        eorAll ^= i             <span class="comment"># 累计异或0~n-1，把下标0-n-1全都异或起来</span></span><br><span class="line">        eorHas ^= nums[i]       <span class="comment"># 累计异或数组元素，</span></span><br><span class="line">    eorAll ^= <span class="built_in">len</span>(nums)         <span class="comment"># 最后再异或n</span></span><br><span class="line">    <span class="keyword">return</span> eorAll ^ eorHas      <span class="comment"># 缺失的数即为两者异或结果，这是由于交换律，所有出现两次的数字会相互抵消，最后只剩下缺失的数字</span></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(missingNumber([3,0,1]))  # 输出2</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong>：</p>
<ul>
<li>完整序列：0,1,2,…,n</li>
<li>给定数组：缺少一个数字</li>
<li>两者异或后，相同数字抵消，剩下的就是缺失数字</li>
</ul>
<h3 id="题目4：找到出现奇数次的数字"><a href="#题目4：找到出现奇数次的数字" class="headerlink" title="题目4：找到出现奇数次的数字"></a>题目4：找到出现奇数次的数字</h3><p><strong>题目</strong>：数组中只有一种数出现奇数次，其他数都出现偶数次，找到这个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://leetcode.cn/problems/single-number/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    eor = <span class="number">0</span>                     <span class="comment"># 初始化eor</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:            <span class="comment"># 遍历数组</span></span><br><span class="line">        eor ^= num              <span class="comment"># 累计异或</span></span><br><span class="line">    <span class="keyword">return</span> eor                  <span class="comment"># 返回结果，原理同code03</span></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(singleNumber([2,2,1]))  # 输出1</span></span><br></pre></td></tr></table></figure>


<h3 id="题目5：找到两个出现奇数次的数字"><a href="#题目5：找到两个出现奇数次的数字" class="headerlink" title="题目5：找到两个出现奇数次的数字"></a>题目5：找到两个出现奇数次的数字</h3><p><strong>题目</strong>：数组中有2种数出现奇数次，其他数都出现偶数次，返回这2种数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode.cn/problems/single-number-iii/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    eor1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次</span></span><br><span class="line">        eor1 ^= num                        <span class="comment"># 累计异或所有数，得到a^b</span></span><br><span class="line">    <span class="comment"># eor1 : a ^ b</span></span><br><span class="line">    <span class="comment"># Brian Kernighan算法</span></span><br><span class="line">    <span class="comment"># 提取出二进制里最右侧的1</span></span><br><span class="line">    rightOne = eor1 &amp; -eor1                <span class="comment"># &amp;是与运算，返回1和1相与为1，0和0相与为0，1和0相与为0；</span></span><br><span class="line">    <span class="comment"># n 的二进制表示中，最右边的 1 之前可能有若干个 0。</span></span><br><span class="line">    <span class="comment"># -n 的二进制表示会反转所有位，然后加1，相当于把最右边的 1 及其右边的 0 都翻转了。</span></span><br><span class="line">    <span class="comment"># 这样，n &amp; -n 只会留下最右边的 1，其余位都变成0。</span></span><br><span class="line">    <span class="comment"># 因为~n= n的取反+1，所以能够提取最右侧的1，所以就拿这个最右侧的1来分组</span></span><br><span class="line">    eor2 = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 此外因为a^b不尽相同，则从左到右，a和b的二进制状态中，必然有一位不同（能找到一个位置上是1，假设是第k位），则可以利用这个不同进行分组</span></span><br><span class="line">    <span class="comment"># 分成两组，一组是第k位为0的数，另一组是第k位为1的数，而q，b一定分别落在不同的组里</span></span><br><span class="line">    <span class="comment"># 所以额外引入一个变量eor2来得到a或者b</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> (num &amp; rightOne) == <span class="number">0</span>:          <span class="comment"># 分组，最后返回，</span></span><br><span class="line">            eor2 ^= num                    <span class="comment"># 分组后累加异或，对分到“那一位为0”这一组的数进行异或。</span></span><br><span class="line">    <span class="comment"># 这组里除了 a 或 b 以外，其他数都成对出现（偶数次），异或后消掉了，只剩下一个（假设是 a）。</span></span><br><span class="line">    <span class="keyword">return</span> [eor2, eor1 ^ eor2]             <span class="comment"># 返回那两个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(singleNumber([1,2,1,3,2,5]))  # 输出[3,5]（顺序无关）</span></span><br></pre></td></tr></table></figure>

<p><strong>关键技巧</strong>：</p>
<ul>
<li><code>n &amp; -n</code>：提取最右侧的1</li>
<li>用这个位进行分组，将a和b分到不同组</li>
<li>每组内除了a或b，其他数都成对出现</li>
</ul>
<p><strong>Brian Kernighan算法原理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设 eor1 = 6 (二进制: 110)</span><br><span class="line">-eor1 = -6 (二进制: ...11111010)  // 补码表示</span><br><span class="line">eor1 &amp; -eor1 = 110 &amp; ...11111010 = 010 = 2</span><br></pre></td></tr></table></figure>

<h3 id="题目6：通用的k次方法"><a href="#题目6：通用的k次方法" class="headerlink" title="题目6：通用的k次方法"></a>题目6：通用的k次方法</h3><p><strong>题目</strong>：数组中只有1种数出现次数少于m次，其他数都出现m次，找到这个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接 : https://leetcode.cn/problems/single-number-ii/</span></span><br><span class="line"><span class="comment"># 注意 : 测试题目只是通用方法的一个特例，课上讲了更通用的情况</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">return</span> find(nums, <span class="number">3</span>)  <span class="comment"># 调用更通用的方法，m=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更通用的方法</span></span><br><span class="line"><span class="comment"># 已知数组中只有1种数出现次数少于m次，其他数都出现了m次</span></span><br><span class="line"><span class="comment"># 返回出现次数小于m次的那种数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">arr, m</span>):</span><br><span class="line">    <span class="comment"># 统计每个位有多少个1，如果一个位置的1的个数不是m的整数倍，说明该位属于出现次数小于m次的数</span></span><br><span class="line">    <span class="comment"># cnts[0] : 0位上有多少个1</span></span><br><span class="line">    <span class="comment"># cnts[i] : i位上有多少个1</span></span><br><span class="line">    <span class="comment"># cnts[31] : 31位上有多少个1</span></span><br><span class="line">    cnts = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            cnts[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>   <span class="comment"># 统计每个位有多少个1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">if</span> cnts[i] % m != <span class="number">0</span>:            <span class="comment"># 如果不是m的整数倍，说明该位属于少于m次的数</span></span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i               <span class="comment"># 把该位设置为1，|= 是“按位或赋值”运算符，相当于 ans = ans | (1 &lt;&lt; i)</span></span><br><span class="line">    <span class="comment"># 处理负数</span></span><br><span class="line">    <span class="keyword">if</span> (ans &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) != <span class="number">0</span>:          <span class="comment"># 如果最高位是1，说明是负数</span></span><br><span class="line">        <span class="comment"># 检查ans的第31位（最高位）是否为1。在32位整数里，第31位是符号位，1表示负数（补码）</span></span><br><span class="line">        ans -= <span class="number">1</span> &lt;&lt; <span class="number">32</span>                  <span class="comment"># 当检测到ans的第31位（最高位）为1时，把它转化为Python中的负数表示</span></span><br><span class="line">        <span class="comment">#在32位二进制补码表示中，负数的真实值等于它的二进制表示减去2^32，而Python的int没有溢出，补码负数要手动转换</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="comment"># print(singleNumber([2,2,3,2]))  # 输出3</span></span><br></pre></td></tr></table></figure>

<p><strong>算法思路</strong>：</p>
<ol>
<li>统计每一位上1的个数</li>
<li>如果某位上1的个数不是m的整数倍，说明目标数字在该位为1</li>
<li>重新构造答案</li>
</ol>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>说明度</th>
</tr>
</thead>
<tbody><tr>
<td>交换两数</td>
<td>O(1)</td>
<td>O(1)</td>
<td>常数时间操作</td>
</tr>
<tr>
<td>找最大值</td>
<td>O(1)</td>
<td>O(1)</td>
<td>位运算替代条件判断</td>
</tr>
<tr>
<td>找缺失数字</td>
<td>O(n)</td>
<td>O(1)</td>
<td>遍历数组一次</td>
</tr>
<tr>
<td>找一个奇数次数字</td>
<td>O(n)</td>
<td>O(1)</td>
<td>异或运算线性时间</td>
</tr>
<tr>
<td>找两个奇数次数字</td>
<td>O(n)</td>
<td>O(1)</td>
<td>两次遍历，分组处理</td>
</tr>
<tr>
<td>通用k次方法</td>
<td>O(n)</td>
<td>O(1)</td>
<td>虽然有32层循环但32是常数</td>
</tr>
</tbody></table>
<h2 id="核心技巧总结"><a href="#核心技巧总结" class="headerlink" title="核心技巧总结"></a>核心技巧总结</h2><h3 id="1-位运算技巧"><a href="#1-位运算技巧" class="headerlink" title="1. 位运算技巧"></a>1. 位运算技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最右侧的1</span></span><br><span class="line">rightOne = n &amp; -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断数字符号</span></span><br><span class="line">sign = (n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转0和1</span></span><br><span class="line">flip = n ^ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某位为1</span></span><br><span class="line">ans |= <span class="number">1</span> &lt;&lt; i</span><br></pre></td></tr></table></figure>

<h3 id="2-异或运算应用模式"><a href="#2-异或运算应用模式" class="headerlink" title="2. 异或运算应用模式"></a>2. 异或运算应用模式</h3><ol>
<li><strong>消除配对</strong>：相同数字异或为0，利用这个性质找到不配对的数字</li>
<li><strong>分组策略</strong>：根据某一位的不同将数组分成两组</li>
<li><strong>位统计</strong>：统计每一位上1的个数，重构答案</li>
</ol>
<h3 id="3-Python特有注意事项"><a href="#3-Python特有注意事项" class="headerlink" title="3. Python特有注意事项"></a>3. Python特有注意事项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理负数</span></span><br><span class="line"><span class="keyword">if</span> (ans &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) != <span class="number">0</span>:</span><br><span class="line">    ans -= <span class="number">1</span> &lt;&lt; <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理溢出</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<p>异或运算虽然看起来简单，但在算法设计中有着广泛而巧妙的应用。掌握这些核心性质和应用模式，能够帮助我们解决很多看似困难的问题。特别是在处理数组中的配对、查找问题时，异或运算往往能提供O(1)空间复杂度的优雅解法。</p>
<h1 id="031【必备】位运算的骚操作"><a href="#031【必备】位运算的骚操作" class="headerlink" title="031【必备】位运算的骚操作"></a>031【必备】位运算的骚操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>位运算有很多奇技淫巧，位运算的速度非常快，仅次于赋值操作，常数时间极好！<br>属于是大佬骚解，左神讲解，苯人copy就对了。</p>
<p><strong>特别提醒</strong>：Python实现位运算的题目需要特别注意，需要自己去手动处理溢出和符号扩展等问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中处理溢出的常见方法</span></span><br><span class="line">result = (n &lt;&lt; shift_amount) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h2 id="核心算法：Brian-Kernighan算法"><a href="#核心算法：Brian-Kernighan算法" class="headerlink" title="核心算法：Brian Kernighan算法"></a>核心算法：Brian Kernighan算法</h2><p>Brian Kernighan算法是位运算中的经典算法，用于提取二进制数中最右侧的1。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最右侧的1</span></span><br><span class="line">rightOne = n &amp; -n</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>：</p>
<ol>
<li><code>n</code>的二进制表示中，最右边的1右边可能有若干个0</li>
<li><code>-n</code>是n的补码表示（所有位取反后加1），所以可以进位到最右边的1，这个1左边的和<code>n</code> 的左边也都是完全相反的</li>
<li><code>n &amp; -n</code>只会保留最右边的1，其余位都变成0</li>
</ol>
<p><strong>示例演示</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设 n = 12 (二进制: 1100)</span><br><span class="line">-n = -12 (二进制: ...11110100)  // 补码表示</span><br><span class="line">n &amp; -n = 1100 &amp; ...11110100 = 0100 = 4</span><br></pre></td></tr></table></figure>

<p>这个算法在很多高级位运算技巧中都有应用，是理解后续算法的基础。</p>
<h2 id="经典应用题目-1"><a href="#经典应用题目-1" class="headerlink" title="经典应用题目"></a>经典应用题目</h2><h3 id="题目1：判断一个整数是不是2的幂"><a href="#题目1：判断一个整数是不是2的幂" class="headerlink" title="题目1：判断一个整数是不是2的幂"></a>题目1：判断一个整数是不是2的幂</h3><p><strong>问题描述</strong>：给定一个整数n，判断它是否为2的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/power-of-two/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># n &gt; 0 确保正数</span></span><br><span class="line">    <span class="comment"># n &amp; -n 提取最右侧的1，如果n是2的幂，只会有一个1</span></span><br><span class="line">    <span class="comment"># n == (n &amp; -n) 则说明n只有一个1</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n == (n &amp; -n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfTwo(<span class="number">4</span>))   <span class="comment"># True (4 = 2^2)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfTwo(<span class="number">6</span>))   <span class="comment"># False (6的二进制是110，有两个1)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfTwo(<span class="number">16</span>))  <span class="comment"># True (16 = 2^4)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理</strong>：</p>
<ul>
<li>2的幂的特点：二进制表示中只有一个1</li>
<li>例如：1(1), 2(10), 4(100), 8(1000), 16(10000)</li>
<li>利用Brian Kernighan算法提取最右侧的1</li>
<li>如果提取的结果等于原数，说明只有一个1</li>
</ul>
<p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="题目2：判断一个整数是不是3的幂"><a href="#题目2：判断一个整数是不是3的幂" class="headerlink" title="题目2：判断一个整数是不是3的幂"></a>题目2：判断一个整数是不是3的幂</h3><p><strong>问题描述</strong>：给定一个整数n，判断它是否为3的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/power-of-three/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPowerOfThree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子</span></span><br><span class="line">    <span class="comment"># 1162261467是int型范围内，最大的3的幂，它是3的19次方</span></span><br><span class="line">    <span class="comment"># 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么</span></span><br><span class="line">    <span class="comment"># 1162261467 % n == 0</span></span><br><span class="line">    <span class="comment"># 反之如果1162261467 % n != 0 说明n一定含有其他因子</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="number">1162261467</span> % n == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfThree(<span class="number">27</span>))  <span class="comment"># True (27 = 3^3)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfThree(<span class="number">45</span>))  <span class="comment"># False (45 = 3^2 * 5)</span></span><br><span class="line"><span class="built_in">print</span>(isPowerOfThree(<span class="number">81</span>))  <span class="comment"># True (81 = 3^4)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理</strong>：</p>
<ul>
<li>利用数论知识：如果n是3的幂，那么n只含有质数因子3</li>
<li>1162261467 &#x3D; 3^19，是32位整数范围内最大的3的幂</li>
<li>如果n也只含有质数因子3，那么1162261467一定能被n整除</li>
<li>这种方法引入了额外的先验知识，是一种巧妙的数学技巧</li>
</ul>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>3^19 &#x3D; 1162261467 (32位int范围内最大的3的幂)</li>
<li>如果n是3的幂，则n只有质数因子3</li>
<li>因此最大的3的幂能被所有较小的3的幂整除</li>
</ul>
<p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="题目3：返回大于等于n的最小的2的幂"><a href="#题目3：返回大于等于n的最小的2的幂" class="headerlink" title="题目3：返回大于等于n的最小的2的幂"></a>题目3：返回大于等于n的最小的2的幂</h3><p><strong>问题描述</strong>：给定一个非负整数n，返回大于等于n的最小的2的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">near2power</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 非正数直接返回1</span></span><br><span class="line">    n -= <span class="number">1</span>        <span class="comment"># 先减1，保证等于2的幂时不变，这样处理可以保证：如果 n 本身就是 2 的幂，返回的还是 n 本身。</span></span><br><span class="line">    <span class="comment"># 例如 n = 8，n-1 = 7 (0111)，后面填充后再加1，结果还是 8</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">1</span>   <span class="comment">#这个是或逻辑，右移1位再取或可以保证用1填充右边</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">2</span>  </span><br><span class="line">    n |= n &gt;&gt; <span class="number">4</span>   </span><br><span class="line">    n |= n &gt;&gt; <span class="number">8</span>   </span><br><span class="line">    n |= n &gt;&gt; <span class="number">16</span>  <span class="comment"># 这一坨代码的作用是把左边第一个1开始，往右的1都变成1</span></span><br><span class="line">    n += <span class="number">1</span>        <span class="comment"># 再加1得到最小2的幂</span></span><br><span class="line">    <span class="comment"># Python没有int溢出，可以直接返回</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0x7fffffff</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0x80000000</span>  <span class="comment"># 超过int范围，返回整数最小值</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(near2power(<span class="number">100</span>))  <span class="comment"># 128 (2^7)</span></span><br><span class="line"><span class="built_in">print</span>(near2power(<span class="number">16</span>))   <span class="comment"># 16 (本身就是2的幂)</span></span><br><span class="line"><span class="built_in">print</span>(near2power(<span class="number">33</span>))   <span class="comment"># 64 (2^6)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理详解</strong>：</p>
<p>让我们以<code>n = 100</code>为例，详细演示算法过程：</p>
<p><strong>Step 1</strong>：<code>n = 100</code>，先减1得到<code>n = 99</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 的二进制：01100011</span><br></pre></td></tr></table></figure>

<p><strong>Step 2</strong>：逐步填充最高位右边的所有位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = 99        : 01100011</span><br><span class="line">n &gt;&gt; 1        : 00110001</span><br><span class="line">n |= n &gt;&gt; 1   : 01110011  (把最高位向右扩展1位)</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 2        : 00011100</span><br><span class="line">n |= n &gt;&gt; 2   : 01111111  (继续向右扩展2位)</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 4        : 00000111</span><br><span class="line">n |= n &gt;&gt; 4   : 01111111  (继续向右扩展4位)</span><br><span class="line"></span><br><span class="line">... (8位和16位移动不会改变结果，因为数字较小)</span><br></pre></td></tr></table></figure>

<p><strong>Step 3</strong>：<code>n + 1 = 01111111 + 1 = 10000000 = 128</code></p>
<p><strong>核心思想</strong>：</p>
<ol>
<li>先减1：确保如果n本身是2的幂，结果仍然是n</li>
<li>逐步填充：将最高位1右边的所有位都填充为1</li>
<li>加1：得到下一个2的幂</li>
</ol>
<p><strong>为什么先减1？</strong></p>
<ul>
<li>如果n&#x3D;16(10000)，我们希望结果是16而不是32</li>
<li>减1后：15(01111)</li>
<li>填充后：15(01111)</li>
<li>加1后：16(10000) ✓</li>
</ul>
<p><strong>位运算技巧解析</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过连续的右移和或运算，将最高位的1向右&quot;传播&quot;</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">1</span>   <span class="comment"># 传播1位</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">2</span>   <span class="comment"># 传播2位  </span></span><br><span class="line">n |= n &gt;&gt; <span class="number">4</span>   <span class="comment"># 传播4位</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">8</span>   <span class="comment"># 传播8位</span></span><br><span class="line">n |= n &gt;&gt; <span class="number">16</span>  <span class="comment"># 传播16位（覆盖32位整数的所有位）</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(1) - 固定数量的位运算<br><strong>空间复杂度</strong>：O(1) - 只使用常数额外空间</p>
<h3 id="题目4：区间-left-right-内所有数字按位与的结果"><a href="#题目4：区间-left-right-内所有数字按位与的结果" class="headerlink" title="题目4：区间[left, right]内所有数字按位与的结果"></a>题目4：区间[left, right]内所有数字按位与的结果</h3><p><strong>问题描述</strong>：给定两个整数left和right，返回区间[left, right]内所有数字按位与的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/bitwise-and-of-numbers-range/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rangeBitwiseAnd</span>(<span class="params">left, right</span>):</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        right -= right &amp; -right  <span class="comment"># 每次消掉right最右边的1</span></span><br><span class="line">    <span class="keyword">return</span> right <span class="comment">#当 left == right 时，区间内只有1个数，直接返回即可；若left&gt;right, 也照样返回right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(rangeBitwiseAnd(<span class="number">5</span>, <span class="number">7</span>))   <span class="comment"># 输出4</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理</strong>：</p>
<p><strong>按位与的关键特性</strong>：</p>
<ul>
<li>如果区间[left, right]内某一位在这段区间内经历了从0到1的变化，那么最终结果这一位一定为0</li>
<li>只有left和right的公共前缀部分才可能保留为1</li>
</ul>
<p><strong>消去变化的位</strong>：</p>
<ul>
<li><code>right &amp; -right</code>取出right的最右侧的1（最低位的1）</li>
<li>每次把right的最右边的1消掉，right变小，靠近left</li>
<li>只要left &lt; right，说明区间还有变化，继续消掉最低位的1</li>
</ul>
<p><strong>详细示例分析</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">区间[5, 7]的按位与：</span><br><span class="line">5: 101</span><br><span class="line">6: 110  </span><br><span class="line">7: 111</span><br><span class="line">-----</span><br><span class="line">结果: 100 = 4</span><br><span class="line"></span><br><span class="line">分析过程：</span><br><span class="line">- 最低位：5(1), 6(0), 7(1) → 有0有1 → 结果为0</span><br><span class="line">- 第2位：5(0), 6(1), 7(1) → 有0有1 → 结果为0  </span><br><span class="line">- 第3位：5(1), 6(1), 7(1) → 全为1 → 结果为1</span><br></pre></td></tr></table></figure>

<p><strong>算法执行过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">left=5(101), right=7(111)</span><br><span class="line">第1次：right &amp; -right = 111 &amp; 001 = 001</span><br><span class="line">       right = 111 - 001 = 110</span><br><span class="line">       left=5, right=6，继续</span><br><span class="line">第2次：right &amp; -right = 110 &amp; 010 = 010  </span><br><span class="line">       right = 110 - 010 = 100</span><br><span class="line">       left=5, right=4，left &gt; right，结束</span><br><span class="line">返回right=4</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(log n) - 最多执行log(right)次循环<br><strong>空间复杂度</strong>：O(1)</p>
<p><strong>看题目5和题目6前的提醒</strong></p>
<ul>
<li>题目5和题目6代码看着跟脑子有大病一样，承认很强但似乎有点太嘚瑟了，是这样吗？</li>
<li>不是的，条件判断相比于赋值、位运算、算术运算是稍慢的，所以其实有现实意义</li>
<li>但是不需要追求在练算法过程中尽量少写条件判断，</li>
<li>那样会带来很多不必要的困扰，还是要写尽量直白、尤其是自己能理解的代码最好</li>
<li>大牛的实现欣赏完理解就好，下次当模版直接用</li>
<li>还是那句话：属于是大佬骚解，左神讲解，苯人copy就对了</li>
</ul>
<h3 id="题目5：反转二进制位（超自然版）"><a href="#题目5：反转二进制位（超自然版）" class="headerlink" title="题目5：反转二进制位（超自然版）"></a>题目5：反转二进制位（超自然版）</h3><p><strong>问题描述</strong>：将一个32位无符号整数的二进制位完全反转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/reverse-bits/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 逆序二进制的状态，分治思想：1v1 → 2v2 → 4v4 → 8v8 → 16v16</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)   <span class="comment"># 交换奇偶位</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)   <span class="comment"># 交换每两位</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)   <span class="comment"># 交换每四位</span></span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)   <span class="comment"># 交换每八位</span></span><br><span class="line">    n = (n &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>)                    <span class="comment"># 交换高低16位</span></span><br><span class="line">    <span class="keyword">return</span> n &amp; <span class="number">0xffffffff</span>  <span class="comment"># 保证结果32位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(reverseBits(<span class="number">43261596</span>))  <span class="comment"># 输出964176192</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理深度解析</strong>：</p>
<p>这是著名的<strong>位分组逆序法（Bitwise reversal by mask）</strong>，采用分治思想：</p>
<p><strong>第1步：交换奇偶位</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0xaaaaaaaa = 10101010...10101010 (偶数位为1)</span></span><br><span class="line"><span class="comment"># 0x55555555 = 01010101...01010101 (奇数位为1)</span></span><br><span class="line"></span><br><span class="line">例如：n = <span class="number">11010110</span></span><br><span class="line">奇数位(从右数第<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>位): 1_1_1_1_ = <span class="number">1111</span></span><br><span class="line">偶数位(从右数第<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>位): _1_0_0_0 = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">交换后：01101101</span><br></pre></td></tr></table></figure>

<p><strong>第2步：交换每两位</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0xcccccccc = 11001100...11001100 (每两位的高位)</span></span><br><span class="line"><span class="comment"># 0x33333333 = 00110011...00110011 (每两位的低位)</span></span><br><span class="line"></span><br><span class="line">例如：n = 01101101</span><br><span class="line">分组：01|<span class="number">10</span>|<span class="number">11</span>|01</span><br><span class="line">交换：<span class="number">10</span>|01|<span class="number">11</span>|<span class="number">10</span> = <span class="number">10011110</span></span><br></pre></td></tr></table></figure>

<p><strong>第3步-5步：类似地交换4位、8位、16位</strong></p>
<p><strong>完整示例演示</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数：11010110 (从左到右)</span><br><span class="line">目标：01101011 (反转后)</span><br><span class="line"></span><br><span class="line">Step1(交换奇偶位)：01101101</span><br><span class="line">Step2(交换每2位)：  10011110  </span><br><span class="line">Step3(交换每4位)：  11101001</span><br><span class="line">Step4(交换每8位)：  01101011 ✓</span><br></pre></td></tr></table></figure>

<p><strong>为什么效率极高？</strong></p>
<ul>
<li>没有任何条件判断和循环</li>
<li>全部是位操作：按位与、或、移位</li>
<li>5次操作完成32位反转，而传统方法需要32次循环</li>
</ul>
<p><strong>时间复杂度</strong>：O(1) - 固定5次位运算<br><strong>空间复杂度</strong>：O(1)</p>
<h3 id="题目6：统计二进制中1的个数（超自然版）"><a href="#题目6：统计二进制中1的个数（超自然版）" class="headerlink" title="题目6：统计二进制中1的个数（超自然版）"></a>题目6：统计二进制中1的个数（超自然版）</h3><p><strong>问题描述</strong>：计算两个整数的汉明距离（二进制位不同的位置数目）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试链接: https://leetcode.cn/problems/hamming-distance/</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> cntOnes(x ^ y)  <span class="comment"># 先异或，统计不同位数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cntOnes</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 分组统计法：每次合并相邻组的1的个数</span></span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>)     <span class="comment"># 每两位一组</span></span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>)     <span class="comment"># 每四位一组  </span></span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>)     <span class="comment"># 每八位一组</span></span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>)     <span class="comment"># 每十六位一组</span></span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>)    <span class="comment"># 全部加起来</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line"><span class="built_in">print</span>(hammingDistance(<span class="number">1</span>, <span class="number">4</span>))  <span class="comment"># 输出2 (1:001, 4:100, 异或:101, 有2个1)</span></span><br><span class="line"><span class="built_in">print</span>(cntOnes(<span class="number">13</span>))           <span class="comment"># 输出3 (13:1101, 有3个1)</span></span><br></pre></td></tr></table></figure>

<p><strong>算法原理深度解析</strong>：</p>
<p>这是<strong>分组统计法</strong>，核心思想是逐步合并局部的1的个数：</p>
<p><strong>详细示例（n &#x3D; 13 &#x3D; 1101）</strong>：</p>
<p><strong>初始状态</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 1101 (二进制)</span><br></pre></td></tr></table></figure>

<p><strong>第1步：每两位统计1的个数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x55555555 = 01010101...01010101</span></span><br><span class="line">n &amp; <span class="number">0x55555555</span>     = <span class="number">1101</span> &amp; <span class="number">0</span>101 = <span class="number">0</span>101  <span class="comment"># 保留奇数位</span></span><br><span class="line">(n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span> = 0110 &amp; <span class="number">0</span>101 = <span class="number">0</span>100  <span class="comment"># 保留偶数位(右移后)</span></span><br><span class="line"></span><br><span class="line">相加：<span class="number">0</span>101 + <span class="number">0</span>100 = <span class="number">1001</span></span><br></pre></td></tr></table></figure>
<p>此时n的每2位表示该2位内1的个数：</p>
<ul>
<li>10（二进制）&#x3D; 2（十进制）：前2位有2个1</li>
<li>01（二进制）&#x3D; 1（十进制）：后2位有1个1</li>
</ul>
<p><strong>第2步：每四位统计1的个数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x33333333 = 00110011...00110011  </span></span><br><span class="line">n &amp; <span class="number">0x33333333</span>     = <span class="number">1001</span> &amp; 0011 = 0001</span><br><span class="line">(n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span> = <span class="number">00</span>10 &amp; 0011 = <span class="number">00</span>10</span><br><span class="line"></span><br><span class="line">相加：0001 + <span class="number">00</span>10 = 0011</span><br></pre></td></tr></table></figure>
<p>此时n&#x3D;0011，表示整个4位中有3个1。</p>
<p><strong>后续步骤</strong>类似，最终得到总的1的个数，更高位依此类推，每一步后，n的每2^k位表示这2^k位内1的总个数，最终全加到最低位</p>
<p><strong>状态变化图解</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始：  1101 (每位表示原始位值)</span><br><span class="line">Step1： 1001 (每2位表示该2位内1的个数)  </span><br><span class="line">Step2： 0011 (每4位表示该4位内1的个数)</span><br><span class="line">Step3： 0011 (8位内1的个数，但只有4位所以不变)</span><br><span class="line">...</span><br><span class="line">最终：  3 (总共3个1)</span><br></pre></td></tr></table></figure>

<p><strong>为什么叫”分组统计”？</strong></p>
<ol>
<li>不是独立统计每组，而是累加合并</li>
<li>每步都使用上一步的统计结果</li>
<li>最终所有1的个数聚合到最低位</li>
</ol>
<p><strong>核心技巧总结</strong>：</p>
<ul>
<li>利用掩码分离不同位置的位</li>
<li>用加法累积局部统计结果  </li>
<li>分治思想：部分→整体</li>
</ul>
<p><strong>时间复杂度</strong>：O(1) - 固定5次位运算<br><strong>空间复杂度</strong>：O(1)</p>
<h2 id="算法性能对比与应用场景"><a href="#算法性能对比与应用场景" class="headerlink" title="算法性能对比与应用场景"></a>算法性能对比与应用场景</h2><h3 id="性能对比表"><a href="#性能对比表" class="headerlink" title="性能对比表"></a>性能对比表</h3><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>核心技巧</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>判断2的幂</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Brian Kernighan算法</td>
<td>内存分配、哈希表大小</td>
</tr>
<tr>
<td>判断3的幂</td>
<td>O(1)</td>
<td>O(1)</td>
<td>数论+预计算</td>
<td>数学问题、特殊判断</td>
</tr>
<tr>
<td>最小2的幂</td>
<td>O(1)</td>
<td>O(1)</td>
<td>位填充技术</td>
<td>内存对齐、缓存优化</td>
</tr>
<tr>
<td>区间按位与</td>
<td>O(log n)</td>
<td>O(1)</td>
<td>公共前缀</td>
<td>区间查询、数据结构</td>
</tr>
<tr>
<td>反转二进制</td>
<td>O(1)</td>
<td>O(1)</td>
<td>分治+掩码</td>
<td>图像处理、编码转换</td>
</tr>
<tr>
<td>统计1的个数</td>
<td>O(1)</td>
<td>O(1)</td>
<td>分组统计</td>
<td>数据压缩、校验算法</td>
</tr>
</tbody></table>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p><strong>1. 系统编程中的应用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存对齐检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isAligned</span>(<span class="params">address, alignment</span>):</span><br><span class="line">    <span class="keyword">return</span> isPowerOfTwo(alignment) <span class="keyword">and</span> (address &amp; (alignment - <span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速向上对齐到2的幂</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alignUp</span>(<span class="params">size, alignment</span>):</span><br><span class="line">    <span class="keyword">return</span> (size + alignment - <span class="number">1</span>) &amp; ~(alignment - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2. 数据结构优化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表大小优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.size = near2power(initial_size)  <span class="comment"># 确保是2的幂</span></span><br><span class="line">        <span class="variable language_">self</span>.table = [<span class="literal">None</span>] * <span class="variable language_">self</span>.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) &amp; (<span class="variable language_">self</span>.size - <span class="number">1</span>)  <span class="comment"># 快速取模</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 图像处理应用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图像位操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mirrorImage</span>(<span class="params">pixel_data</span>):</span><br><span class="line">    <span class="keyword">return</span> [reverseBits(pixel) <span class="keyword">for</span> pixel <span class="keyword">in</span> pixel_data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像特征提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">img1, img2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(cntOnes(p1 ^ p2) <span class="keyword">for</span> p1, p2 <span class="keyword">in</span> <span class="built_in">zip</span>(img1, img2))</span><br></pre></td></tr></table></figure>

<h2 id="核心技巧模板总结"><a href="#核心技巧模板总结" class="headerlink" title="核心技巧模板总结"></a>核心技巧模板总结</h2><h3 id="1-Brian-Kernighan系列"><a href="#1-Brian-Kernighan系列" class="headerlink" title="1. Brian Kernighan系列"></a>1. Brian Kernighan系列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础：提取最右侧的1</span></span><br><span class="line">rightOne = n &amp; -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用1：判断2的幂</span></span><br><span class="line">isPowerOfTwo = n &gt; <span class="number">0</span> <span class="keyword">and</span> n == (n &amp; -n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用2：清除最右侧的1  </span></span><br><span class="line">n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用3：计算1的个数（朴素版）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countOnes</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>)  <span class="comment"># 每次清除最右侧的1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="2-位填充技术模板"><a href="#2-位填充技术模板" class="headerlink" title="2. 位填充技术模板"></a>2. 位填充技术模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准位填充（用于找下一个2的幂）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fillBits</span>(<span class="params">n</span>):</span><br><span class="line">    n |= n &gt;&gt; <span class="number">1</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">2</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">4</span>  </span><br><span class="line">    n |= n &gt;&gt; <span class="number">8</span></span><br><span class="line">    n |= n &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nextPowerOfTwo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fillBits(n - <span class="number">1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-分治-掩码模板"><a href="#3-分治-掩码模板" class="headerlink" title="3. 分治+掩码模板"></a>3. 分治+掩码模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反转二进制位模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">n, bits=<span class="number">32</span></span>):</span><br><span class="line">    <span class="keyword">if</span> bits == <span class="number">32</span>:</span><br><span class="line">        n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">        n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        n = (n &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组统计模板  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countOnes</span>(<span class="params">n</span>):</span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>)</span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>

<h3 id="4-Python位运算注意事项"><a href="#4-Python位运算注意事项" class="headerlink" title="4. Python位运算注意事项"></a>4. Python位运算注意事项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleSign</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) != <span class="number">0</span>:  <span class="comment"># 检查符号位</span></span><br><span class="line">        n -= <span class="number">1</span> &lt;&lt; <span class="number">32</span>          <span class="comment"># 转换为Python负数</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 溢出检查</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkOverflow</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">0x80000000</span> &lt;= n &lt;= <span class="number">0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 掩码应用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mask32bit</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n &amp; <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><h3 id="1-为什么位运算如此高效？"><a href="#1-为什么位运算如此高效？" class="headerlink" title="1. 为什么位运算如此高效？"></a>1. 为什么位运算如此高效？</h3><ul>
<li><strong>CPU层面</strong>：位运算是最接近硬件的操作，执行速度极快</li>
<li><strong>并行性</strong>：现代CPU可以并行处理多个位</li>
<li><strong>无条件判断</strong>：避免了分支预测失误的性能损失</li>
</ul>
<h3 id="2-什么时候不应该使用这些技巧？"><a href="#2-什么时候不应该使用这些技巧？" class="headerlink" title="2. 什么时候不应该使用这些技巧？"></a>2. 什么时候不应该使用这些技巧？</h3><ul>
<li><strong>代码可读性</strong>：团队协作时，清晰比技巧更重要</li>
<li><strong>过度优化</strong>：在非性能关键路径上使用可能得不偿失</li>
<li><strong>平台差异</strong>：某些技巧在不同架构上表现可能不同</li>
</ul>
<h3 id="3-如何掌握位运算？"><a href="#3-如何掌握位运算？" class="headerlink" title="3. 如何掌握位运算？"></a>3. 如何掌握位运算？</h3><ol>
<li><strong>理解原理</strong>：每个技巧背后的数学&#x2F;逻辑基础</li>
<li><strong>动手实践</strong>：在纸上画出二进制变化过程</li>
<li><strong>模板化</strong>：将常用技巧整理成模板</li>
<li><strong>适度应用</strong>：在合适的场景使用，不要炫技</li>
</ol>
<p>位运算虽然看起来神秘，但其本质是对二进制数据的高效操作。掌握了这些核心技巧后，不仅能解决特定的算法问题，更能在系统编程、性能优化等场景中发挥重要作用。关键是要在”技巧性”和”可读性”之间找到平衡，让代码既高效又易维护。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89-%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89-%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（9）- 基数排序&排序算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-10 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-10T08:42:46+08:00">2025-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-16 17:19:16" itemprop="dateModified" datetime="2025-08-16T17:19:16+08:00">2025-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了基数排序的原理与实现，以及重要排序算法的性能总结与选择策略，包括了class028 -&gt; class029的内容</p>
<h1 id="028【必备】基数排序"><a href="#028【必备】基数排序" class="headerlink" title="028【必备】基数排序"></a>028【必备】基数排序</h1><h2 id="基数排序概述"><a href="#基数排序概述" class="headerlink" title="基数排序概述"></a>基数排序概述</h2><p>基数排序是一种<strong>非基于比较</strong>的排序算法，它通过对数字的每一位进行排序来实现整体排序。与其他基于比较的排序算法不同，基数排序对数据类型有特定要求。</p>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(9)/class28-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90.png" alt="基数排序例子"></p>
<h3 id="基于比较-vs-非基于比较的排序"><a href="#基于比较-vs-非基于比较的排序" class="headerlink" title="基于比较 vs 非基于比较的排序"></a>基于比较 vs 非基于比较的排序</h3><p><strong>基于比较的排序</strong>：</p>
<ul>
<li>只需要定义好两个对象之间怎么比较即可</li>
<li>对象的数据特征并不关心，很通用</li>
<li>例如：快速排序、归并排序、堆排序等</li>
</ul>
<p><strong>非基于比较的排序</strong>：</p>
<ul>
<li>和比较无关的排序，对于对象的数据特征有要求</li>
<li>并不通用，但在特定条件下效率极高</li>
<li>例如：计数排序、桶排序、基数排序</li>
</ul>
<h2 id="从计数排序到基数排序"><a href="#从计数排序到基数排序" class="headerlink" title="从计数排序到基数排序"></a>从计数排序到基数排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是最简单的非比较排序算法：</p>
<ul>
<li>用一个数组或哈希表来记录每个数字出现的次数</li>
<li>遍历数组统计，然后按顺序输出</li>
<li><strong>限制</strong>：数值范围比较大时就不实用了</li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版：</p>
<ul>
<li>将数据分到有限数量的桶里，然后对每个桶再分别排序，最后合并</li>
<li>计数排序可以看成每个桶只存储相同元素</li>
<li>桶排序每个桶存储一定范围的元素</li>
<li>需要确定两个信息：桶的数量和每个桶的区间范围</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(9)/class28-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F%E4%BE%8B%E5%AD%90.png" alt="桶排序例子"></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序进一步优化了桶的使用：</p>
<ul>
<li>按位进行排序，比如先按个位数字放进桶里再倒出，再按十位数字放进桶里再倒出</li>
<li>这样就得到一个有序的序列</li>
</ul>
<h2 id="基数排序的核心思想"><a href="#基数排序的核心思想" class="headerlink" title="基数排序的核心思想"></a>基数排序的核心思想</h2><p>基数排序采用**LSD（Least Significant Digit）**策略，从最低位开始排序：</p>
<ol>
<li><strong>从个位开始</strong>：按个位数字进行计数排序</li>
<li><strong>依次向高位</strong>：按十位、百位、千位…依次排序</li>
<li><strong>保持稳定性</strong>：每次排序都要保持之前排序的相对顺序</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>前缀数量分区的技巧</li>
<li>数字提取某一位的技巧</li>
<li>时间复杂度O(n)，额外空间复杂度O(m)</li>
</ul>
<h2 id="基数排序实现详解"><a href="#基数排序实现详解" class="headerlink" title="基数排序实现详解"></a>基数排序实现详解</h2><h3 id="核心代码结构"><a href="#核心代码结构" class="headerlink" title="核心代码结构"></a>核心代码结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以设置进制，不一定10进制</span></span><br><span class="line">BASE = <span class="number">10</span>  <span class="comment"># 基数，当前设置为10进制</span></span><br><span class="line"></span><br><span class="line">MAXN = <span class="number">100001</span>  <span class="comment"># 最大数据量</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN      <span class="comment"># 存储待排序数组</span></span><br><span class="line">help_arr = [<span class="number">0</span>] * MAXN <span class="comment"># 辅助数组</span></span><br><span class="line">cnts = [<span class="number">0</span>] * BASE     <span class="comment"># 计数数组</span></span><br><span class="line">n = <span class="number">0</span>                 <span class="comment"># 元素数量</span></span><br></pre></td></tr></table></figure>

<h3 id="处理负数的技巧"><a href="#处理负数的技巧" class="headerlink" title="处理负数的技巧"></a>处理负数的技巧</h3><p>由于基数排序要求非负整数，需要特殊处理负数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort</span>():</span><br><span class="line">    <span class="comment"># 找到数组中的最小值</span></span><br><span class="line">    min_val = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        min_val = <span class="built_in">min</span>(min_val, arr[i])</span><br><span class="line">    </span><br><span class="line">    max_val = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] -= min_val  <span class="comment"># 全部减去最小值，转为非负数</span></span><br><span class="line">        max_val = <span class="built_in">max</span>(max_val, arr[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据最大值在BASE进制下的位数，决定基数排序做多少轮</span></span><br><span class="line">    radixSort(bits(max_val))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数组中所有数都减去了最小值，所以最后不要忘了还原</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] += min_val</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(9)/class28-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/%E8%BF%9B%E4%BD%8D%E5%BE%97%E5%88%B0%E6%95%B0%E5%AD%97.png" alt="进位得到数字"></p>
<h3 id="计算位数"><a href="#计算位数" class="headerlink" title="计算位数"></a>计算位数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bits</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回number在BASE进制下有几位&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">        number //= BASE</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="基数排序核心算法"><a href="#基数排序核心算法" class="headerlink" title="基数排序核心算法"></a>基数排序核心算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radixSort</span>(<span class="params">bits_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基数排序核心代码</span></span><br><span class="line"><span class="string">    arr内要保证没有负数</span></span><br><span class="line"><span class="string">    bits_是arr中最大值在BASE进制下有几位</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    offset = <span class="number">1</span>  <span class="comment"># 当前位权重</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bits_):</span><br><span class="line">        <span class="comment"># 每一轮针对某一位排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 计数数组清零</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(BASE):</span><br><span class="line">            cnts[i] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 统计该位各数字出现次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cnts[(arr[i] // offset) % BASE] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 转换为前缀和（确定位置）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, BASE):</span><br><span class="line">            cnts[i] += cnts[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 从后往前放入辅助数组（保证稳定性）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            idx = (arr[i] // offset) % BASE  <span class="comment"># 该位的值</span></span><br><span class="line">            cnts[idx] -= <span class="number">1</span></span><br><span class="line">            help_arr[cnts[idx]] = arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 拷回原数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            arr[i] = help_arr[i]</span><br><span class="line">        </span><br><span class="line">        offset *= BASE  <span class="comment"># 下一位</span></span><br></pre></td></tr></table></figure>

<h2 id="算法详细步骤演示"><a href="#算法详细步骤演示" class="headerlink" title="算法详细步骤演示"></a>算法详细步骤演示</h2><p>以数组 <code>[170, 45, 75, 90, 2, 802, 24, 66]</code> 为例：</p>
<p><strong>初始数组</strong>：<code>[170, 45, 75, 90, 2, 802, 24, 66]</code></p>
<h3 id="第一轮（个位排序）"><a href="#第一轮（个位排序）" class="headerlink" title="第一轮（个位排序）"></a>第一轮（个位排序）</h3><p><strong>Step 1 - 统计个位数字</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">个位: [0, 5, 5, 0, 2, 2, 4, 6]</span><br><span class="line">cnts: [2, 0, 2, 0, 1, 2, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p><strong>Step 2 - 计算前缀和</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnts: [2, 2, 4, 4, 5, 7, 8, 8, 8, 8]</span><br></pre></td></tr></table></figure>

<p><strong>Step 3 - 从后往前放置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果: [170, 90, 2, 802, 24, 45, 75, 66]</span><br></pre></td></tr></table></figure>

<h3 id="第二轮（十位排序）"><a href="#第二轮（十位排序）" class="headerlink" title="第二轮（十位排序）"></a>第二轮（十位排序）</h3><p><strong>Step 1 - 统计十位数字</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">十位: [7, 9, 0, 0, 2, 4, 7, 6]</span><br><span class="line">cnts: [2, 0, 1, 0, 1, 0, 1, 2, 0, 1]</span><br></pre></td></tr></table></figure>

<p><strong>Step 2 - 计算前缀和并放置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果: [2, 802, 24, 45, 66, 170, 75, 90]</span><br></pre></td></tr></table></figure>

<h3 id="第三轮（百位排序）"><a href="#第三轮（百位排序）" class="headerlink" title="第三轮（百位排序）"></a>第三轮（百位排序）</h3><p>最终结果：<code>[2, 24, 45, 66, 75, 90, 170, 802]</code></p>
<h2 id="稳定性保证"><a href="#稳定性保证" class="headerlink" title="稳定性保证"></a>稳定性保证</h2><p>基数排序的稳定性通过以下方式保证：</p>
<ol>
<li><strong>从后往前处理</strong>：在放入辅助数组时从后往前遍历原数组</li>
<li><strong>前缀和技巧</strong>：使用前缀和确定每个元素在结果数组中的准确位置</li>
<li><strong>逐位处理</strong>：每一位的排序都保持前一位排序的相对顺序</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键：从后往前，确保稳定性</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    idx = (arr[i] // offset) % BASE</span><br><span class="line">    cnts[idx] -= <span class="number">1</span></span><br><span class="line">    help_arr[cnts[idx]] = arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：O(n)</strong></p>
<ul>
<li>设最大数有d位，需要进行d轮排序</li>
<li>每轮排序需要O(n + k)时间，其中k是基数（通常k&#x3D;10）</li>
<li>总时间复杂度：O(d × (n + k)) ≈ O(n)</li>
</ul>
<p><strong>空间复杂度：O(m)</strong></p>
<ul>
<li>m为基数大小，需要辅助空间做类似桶的作用</li>
<li>包括辅助数组help_arr和计数数组cnts</li>
</ul>
<h2 id="应用限制"><a href="#应用限制" class="headerlink" title="应用限制"></a>应用限制</h2><p><strong>一般来讲，基数排序要求</strong>：</p>
<ul>
<li>样本是10进制的非负整数</li>
<li>如果不是就需要转化（如代码中处理负数的方式）</li>
<li>可以设置任何进制来进行排序</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>一旦比较的对象不再是常规数字，改写代价显著增加</li>
<li>不基于比较的排序并不通用</li>
</ul>
<h1 id="029【必备】重要排序算法的总结"><a href="#029【必备】重要排序算法的总结" class="headerlink" title="029【必备】重要排序算法的总结"></a>029【必备】重要排序算法的总结</h1><h2 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h2><h3 id="稳定性定义"><a href="#稳定性定义" class="headerlink" title="稳定性定义"></a>稳定性定义</h3><p><strong>排序算法的稳定性</strong>是指：同样大小的样本在排序之后不会改变原始的相对次序。</p>
<p><strong>重要性</strong>：</p>
<ul>
<li>稳定性对基础类型对象来说毫无意义</li>
<li>稳定性对非基础类型对象有意义，可以保留之前的相对次序</li>
</ul>
<h2 id="主要排序算法性能总结"><a href="#主要排序算法性能总结" class="headerlink" title="主要排序算法性能总结"></a>主要排序算法性能总结</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SelectionSort</strong><br/>选择排序</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>❌</td>
<td>因为是随机的交换</td>
</tr>
<tr>
<td><strong>BubbleSort</strong><br/>冒泡排序</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>✅</td>
<td>数学归纳法可以保证</td>
</tr>
<tr>
<td><strong>InsertionSort</strong><br/>插入排序</td>
<td>O(N²)</td>
<td>O(1)</td>
<td>✅</td>
<td>相等会直接停，能够保证稳定性</td>
</tr>
<tr>
<td><strong>MergeSort</strong><br/>归并排序</td>
<td>O(N log N)</td>
<td>O(N)</td>
<td>✅</td>
<td>左右两边的区域满足偏序性</td>
</tr>
<tr>
<td><strong>QuickSort</strong><br/>快速排序</td>
<td>O(N log N)</td>
<td>O(log N)</td>
<td>❌</td>
<td>普通的是固定选择，随机的随机选择</td>
</tr>
<tr>
<td><strong>HeapSort</strong><br/>堆排序</td>
<td>O(N log N)</td>
<td>O(1)</td>
<td>❌</td>
<td>建堆的过程根本不在乎稳不稳定</td>
</tr>
<tr>
<td><strong>CountSort</strong><br/>计数排序</td>
<td>O(N)</td>
<td>O(M)</td>
<td>✅</td>
<td>入桶和出桶的过程是按次序的</td>
</tr>
<tr>
<td><strong>RadixSort</strong><br/>基数排序</td>
<td>O(N)</td>
<td>O(M)</td>
<td>✅</td>
<td>同计数排序</td>
</tr>
</tbody></table>
<h3 id="关键说明"><a href="#关键说明" class="headerlink" title="关键说明"></a>关键说明</h3><p><strong>随机快速排序的复杂度</strong>：</p>
<ul>
<li>一定要按照概率上的期望指标来估计</li>
<li>用最差的复杂度估计无意义</li>
<li>随机快排的详细说明在之前的视频中已有详细解释</li>
</ul>
<p><strong>重要结论</strong>：</p>
<blockquote>
<p>基于比较的排序，时间复杂度O(n log n)，空间复杂度低于O(n)，还具有稳定性的排序算法目前没有找到</p>
</blockquote>
<p><strong>TimSort说明</strong>：</p>
<ul>
<li>TimSort也不行，虽然在实际应用中通常不需要这么多的额外空间</li>
<li>但空间复杂度指标就是O(n)</li>
<li>在算法面试、笔试、比赛中都很少用到</li>
</ul>
<p><strong>希尔排序（ShellSort）</strong>：</p>
<ul>
<li>也不常用，就是加入步长调整的插入排序</li>
<li>有兴趣的同学可以研究一下</li>
</ul>
<h2 id="排序算法选择策略"><a href="#排序算法选择策略" class="headerlink" title="排序算法选择策略"></a>排序算法选择策略</h2><p>排序算法的选择完全取决于你在排序过程中在乎什么：</p>
<h3 id="1-数据量非常小的情况"><a href="#1-数据量非常小的情况" class="headerlink" title="1. 数据量非常小的情况"></a>1. 数据量非常小的情况</h3><p><strong>推荐：插入排序</strong></p>
<ul>
<li>可以做到非常迅速</li>
<li>实现简单，常数项小</li>
<li>很多高级排序算法在小数据量时会切换到插入排序</li>
</ul>
<h3 id="2-性能优异-实现简单-不在乎稳定性"><a href="#2-性能优异-实现简单-不在乎稳定性" class="headerlink" title="2. 性能优异 + 实现简单 + 不在乎稳定性"></a>2. 性能优异 + 实现简单 + 不在乎稳定性</h3><p><strong>推荐：随机快速排序</strong></p>
<ul>
<li>性能优异，期望时间复杂度O(n log n)</li>
<li>实现简单且利于改进</li>
<li>面对不同业务可以选择不同划分策略</li>
<li>空间复杂度较小O(log n)</li>
</ul>
<h3 id="3-性能优异-需要稳定性-不在乎额外空间"><a href="#3-性能优异-需要稳定性-不在乎额外空间" class="headerlink" title="3. 性能优异 + 需要稳定性 + 不在乎额外空间"></a>3. 性能优异 + 需要稳定性 + 不在乎额外空间</h3><p><strong>推荐：归并排序</strong></p>
<ul>
<li>性能优异，稳定的O(n log n)时间复杂度</li>
<li>具有稳定性</li>
<li>适合外部排序（大数据量）</li>
<li>空间复杂度O(n)</li>
</ul>
<h3 id="4-性能优异-额外空间要求O-1-不在乎稳定性"><a href="#4-性能优异-额外空间要求O-1-不在乎稳定性" class="headerlink" title="4. 性能优异 + 额外空间要求O(1) + 不在乎稳定性"></a>4. 性能优异 + 额外空间要求O(1) + 不在乎稳定性</h3><p><strong>推荐：堆排序</strong></p>
<ul>
<li>性能优异，稳定的O(n log n)时间复杂度</li>
<li>额外空间占用O(1)</li>
<li>最坏情况下性能依然稳定</li>
<li>不具有稳定性</li>
</ul>
<h3 id="5-特定数据特征-追求极致性能"><a href="#5-特定数据特征-追求极致性能" class="headerlink" title="5. 特定数据特征 + 追求极致性能"></a>5. 特定数据特征 + 追求极致性能</h3><p><strong>推荐：基数排序&#x2F;计数排序</strong></p>
<ul>
<li>在特定条件下可以达到O(n)时间复杂度</li>
<li>对数据类型有严格要求</li>
<li>适用于整数排序且范围有限的场景</li>
</ul>
<h2 id="实际应用建议"><a href="#实际应用建议" class="headerlink" title="实际应用建议"></a>实际应用建议</h2><h3 id="编程竞赛-面试"><a href="#编程竞赛-面试" class="headerlink" title="编程竞赛&#x2F;面试"></a>编程竞赛&#x2F;面试</h3><ol>
<li><strong>快速排序</strong>：最常考查，需要熟练掌握</li>
<li><strong>归并排序</strong>：稳定性要求时的首选</li>
<li><strong>堆排序</strong>：空间复杂度有严格限制时</li>
</ol>
<h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><ol>
<li><strong>小数组</strong>：插入排序</li>
<li><strong>大数组</strong>：快速排序（随机化）</li>
<li><strong>需要稳定性</strong>：归并排序</li>
<li><strong>内存敏感</strong>：堆排序</li>
<li><strong>特殊数据</strong>：计数排序&#x2F;基数排序</li>
</ol>
<h3 id="语言内置排序"><a href="#语言内置排序" class="headerlink" title="语言内置排序"></a>语言内置排序</h3><p>大多数编程语言的内置排序算法都是混合算法：</p>
<ul>
<li><strong>Python</strong>：Timsort（归并+插入的混合）</li>
<li><strong>Java</strong>：双轴快排（小数组时用插入排序）</li>
<li><strong>C++</strong>：通常是内省排序（快排+堆排序+插入排序的混合）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解各种排序算法的特点和适用场景比单纯记忆算法更重要。在实际应用中，需要根据具体需求（数据规模、稳定性要求、空间限制等）来选择合适的排序算法。基数排序作为非比较排序的代表，在特定场景下能够突破O(n log n)的理论下界，达到线性时间复杂度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89-%20%E5%A0%86%E7%BB%93%E6%9E%84&%E5%93%88%E5%B8%8C%E8%A1%A8&%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89-%20%E5%A0%86%E7%BB%93%E6%9E%84&%E5%93%88%E5%B8%8C%E8%A1%A8&%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（8）- 堆结构&哈希表&堆结构相关习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-09 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-09T08:42:46+08:00">2025-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-10 15:44:22" itemprop="dateModified" datetime="2025-08-10T15:44:22+08:00">2025-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>本笔记涵盖了堆的基本概念与堆排序、哈希表的实现以及堆结构的一些相关习题，包括了class025→027的内容。</p>
<h1 id="025【必备】堆结构和堆排序"><a href="#025【必备】堆结构和堆排序" class="headerlink" title="025【必备】堆结构和堆排序"></a>025【必备】堆结构和堆排序</h1><h2 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h2><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种特殊的<strong>完全二叉树</strong>结构，通常用数组来实现存储。堆有以下特性：</p>
<ol>
<li><strong>结构性质</strong>：堆是完全二叉树，即除了最后一层，其他层都是满的，最后一层从左到右连续填充</li>
<li><strong>堆序性质</strong>：<ul>
<li><strong>大根堆</strong>：任何一个子树内部的最大值一定在顶部（父节点 ≥ 子节点）</li>
<li><strong>小根堆</strong>：任何一个子树内部的最小值一定在顶部（父节点 ≤ 子节点）</li>
</ul>
</li>
</ol>
<h3 id="堆的数组表示"><a href="#堆的数组表示" class="headerlink" title="堆的数组表示"></a>堆的数组表示</h3><p>堆使用数组实现，通过下标关系来表示父子关系：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于下标为 i 的节点：</span></span><br><span class="line">parent = (i - <span class="number">1</span>) // <span class="number">2</span>    <span class="comment"># 父节点下标</span></span><br><span class="line">left_child = i * <span class="number">2</span> + <span class="number">1</span>   <span class="comment"># 左孩子下标  </span></span><br><span class="line">right_child = i * <span class="number">2</span> + <span class="number">2</span>  <span class="comment"># 右孩子下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否有孩子节点：</span></span><br><span class="line"><span class="comment"># 如果 left_child &gt;= size，则没有左孩子</span></span><br><span class="line"><span class="comment"># 如果 right_child &gt;= size，则没有右孩子</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E5%A0%86%E7%BB%93%E6%9E%84%E2%86%92%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="堆结构→完全二叉树"></p>
<h3 id="堆的核心操作"><a href="#堆的核心操作" class="headerlink" title="堆的核心操作"></a>堆的核心操作</h3><p>堆有两个核心调整操作，时间复杂度都是 <strong>O(log n)</strong>：</p>
<ol>
<li><strong>heapInsert（向上调整）</strong>：新元素插入后向上调整维持堆性质</li>
<li><strong>heapify（向下调整）</strong>：删除堆顶后向下调整维持堆性质</li>
</ol>
<h2 id="堆的核心算法实现"><a href="#堆的核心算法实现" class="headerlink" title="堆的核心算法实现"></a>堆的核心算法实现</h2><h3 id="heapInsert-向上调整"><a href="#heapInsert-向上调整" class="headerlink" title="heapInsert - 向上调整"></a>heapInsert - 向上调整</h3><p>当在堆的末尾插入新元素时，需要向上调整以维持堆的性质：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapInsert</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    i位置的数，向上调整大根堆</span></span><br><span class="line"><span class="string">    时间复杂度：O(logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> arr[i] &gt; arr[(i - <span class="number">1</span>) // <span class="number">2</span>]:  <span class="comment"># 当前节点大于父节点时</span></span><br><span class="line">        swap(i, (i - <span class="number">1</span>) // <span class="number">2</span>)          <span class="comment"># 与父节点交换</span></span><br><span class="line">        i = (i - <span class="number">1</span>) // <span class="number">2</span>               <span class="comment"># 更新当前位置为父节点位置</span></span><br></pre></td></tr></table></figure>

<p><strong>算法流程</strong>：</p>
<ol>
<li>比较当前节点与其父节点的值</li>
<li>如果当前节点更大（大根堆），则交换</li>
<li>向上移动到父节点位置，重复过程</li>
<li>直到满足堆性质或到达根节点</li>
</ol>
<p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E5%A4%A7%E6%A0%B9%E5%A0%86%E7%9A%84%E5%A0%86%E6%8F%92%E5%85%A5.png" alt="大根堆的堆插入"></p>
<h3 id="heapify-向下调整"><a href="#heapify-向下调整" class="headerlink" title="heapify - 向下调整"></a>heapify - 向下调整</h3><p>当删除堆顶元素后，需要向下调整以维持堆的性质：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">i, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    i位置的数，向下调整大根堆</span></span><br><span class="line"><span class="string">    当前堆的大小为size</span></span><br><span class="line"><span class="string">    时间复杂度：O(logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    l = i * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 左孩子</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:  <span class="comment"># 如果左孩子存在</span></span><br><span class="line">        <span class="comment"># 选出左右孩子中更大的那个</span></span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> (l + <span class="number">1</span> &lt; size <span class="keyword">and</span> arr[l + <span class="number">1</span>] &gt; arr[l]) <span class="keyword">else</span> l</span><br><span class="line">        <span class="comment"># 当前节点和最强孩子之间，选出最强的</span></span><br><span class="line">        best = best <span class="keyword">if</span> arr[best] &gt; arr[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:  <span class="comment"># 如果当前节点最大，调整完成</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(best, i)  <span class="comment"># 交换</span></span><br><span class="line">        i = best       <span class="comment"># 移动到交换后的位置</span></span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 更新左孩子</span></span><br><span class="line"><span class="comment"># 1.找到更大的子节点：比较左右子节点，选出值更大的那个</span></span><br><span class="line"><span class="comment"># 2.与父节点比较：将较大的子节点与当前父节点比较</span></span><br><span class="line"><span class="comment"># 3.决定是否交换：如果子节点更大就交换，否则停止调整</span></span><br><span class="line"><span class="comment"># 4.继续向下：交换后继续对新位置进行同样的操作</span></span><br></pre></td></tr></table></figure>

<p><strong>算法流程</strong>：</p>
<ol>
<li>找到更大的子节点：比较左右子节点，选出值更大的那个</li>
<li>与父节点比较：将较大的子节点与当前父节点比较</li>
<li>决定是否交换：如果子节点更大就交换，否则停止调整</li>
<li>继续向下：交换后继续对新位置进行同样的操作</li>
</ol>
<h2 id="堆排序的两种实现"><a href="#堆排序的两种实现" class="headerlink" title="堆排序的两种实现"></a>堆排序的两种实现</h2><h3 id="方法一：从顶到底建堆（经典版本）"><a href="#方法一：从顶到底建堆（经典版本）" class="headerlink" title="方法一：从顶到底建堆（经典版本）"></a>方法一：从顶到底建堆（经典版本）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    完全二叉树的节点为N的话，高度是log_2(N)的水平</span></span><br><span class="line"><span class="string">    从顶到底建立大根堆，从顶到底建立大根堆，O(n * logn)，每次排好一个数，排n个数要n次，每排一个数时间复杂度是logn，排n个数当然是nlogn</span></span><br><span class="line"><span class="string">    依次弹出堆内最大值并排好序，O(n * logn)</span></span><br><span class="line"><span class="string">    整体时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆阶段：从第一个元素开始，依次插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heapInsert(i)  <span class="comment"># 每个元素向上调整</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 排序阶段：不断取出最大值</span></span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)  <span class="comment"># 将最大值（堆顶）放到数组末尾</span></span><br><span class="line">        size -= <span class="number">1</span>          <span class="comment"># 减少堆的大小</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)   <span class="comment"># 对新的堆顶进行向下调整</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>建堆阶段：<code>log₁ + log₂ + log₃ + ... + logₙ =（收敛于） O(n logn)</code></li>
<li>排序阶段：每次调整 <code>O(log n)</code>，共 <code>n-1</code> 次，总计 <code>O(n logn)</code></li>
<li><strong>总时间复杂度：O(n logn)</strong></li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E4%BB%8E%E5%BA%95%E9%83%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="从底部到顶部的堆排序"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E4%BB%8E%E4%BB%8E%E5%BA%95%E9%83%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="从底部到顶部的堆排序-复杂度分析"></p>
<h3 id="方法二：从底到顶建堆（优化版本）"><a href="#方法二：从底到顶建堆（优化版本）" class="headerlink" title="方法二：从底到顶建堆（优化版本）"></a>方法二：从底到顶建堆（优化版本）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从底到顶建立大根堆，O(n) </span></span><br><span class="line"><span class="string">    依次弹出堆内最大值并排好序，O(n * logn)</span></span><br><span class="line"><span class="string">    整体时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆阶段：从最后一个非叶子节点开始，向前调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(i, n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 排序阶段：与方法一相同</span></span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)</span><br><span class="line"><span class="comment"># 这种方法更像修理一栋破房子，从最下面的楼层开始修。建堆阶段只需要O(n)时间，具体是从最后一个非叶子节点开始逐个向前调整，每个节点只需要&quot;向下看&quot;把不合格的子节点换上来，由于采用从底向上的策略效率更高。</span></span><br><span class="line"><span class="comment"># 排序阶段的做法与方法1相同，先取堆顶元素放到合适位置，然后重新调整剩余元素成堆并重复进行。整体而言方法2更优，因为它的建堆过程比方法1快了一个数量级，从O(n logn)优化到了O(n)</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class25-%E5%A0%86%E7%BB%93%E6%9E%84/%E4%BB%8E%E4%BB%8E%E5%BA%95%E9%83%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="两种排序方法对比"><br><strong>为什么从底到顶建堆更快？</strong></p>
<p>从底到顶建堆的时间复杂度是 <strong>O(n)</strong>，这是因为：</p>
<ol>
<li><strong>叶子节点无需调整</strong>：完全二叉树中约有 n&#x2F;2 个叶子节点，它们天然满足堆性质</li>
<li><strong>调整距离递减</strong>：越靠近叶子的节点，需要向下调整的最大距离越小</li>
<li><strong>数学分析</strong>：可以证明总的调整代价是一个等比数列，收敛到 O(n)</li>
</ol>
<p><strong>两种方法的对比</strong>：</p>
<table>
<thead>
<tr>
<th>建堆方法</th>
<th>建堆复杂度</th>
<th>排序复杂度</th>
<th>总复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>从顶到底</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>逐个插入元素”爬楼梯”</td>
</tr>
<tr>
<td>从底到顶</td>
<td>O(n)</td>
<td>O(n logn)</td>
<td>O(n logn)</td>
<td>从下往上”修房子”</td>
</tr>
</tbody></table>
<h2 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    data = sys.stdin.read().split()</span><br><span class="line">    n = <span class="built_in">int</span>(data[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr[i] = <span class="built_in">int</span>(data[i + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    heapSort2()  <span class="comment"># 使用优化版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 高效输出</span></span><br><span class="line">    sys.stdout.write(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">str</span>(arr[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>)))</span><br><span class="line">    sys.stdout.write(<span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(arr[n - <span class="number">1</span>]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapInsert</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">while</span> arr[i] &gt; arr[(i - <span class="number">1</span>) // <span class="number">2</span>]:</span><br><span class="line">        swap(i, (i - <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        i = (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">i, size</span>):</span><br><span class="line">    l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:</span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> (l + <span class="number">1</span> &lt; size <span class="keyword">and</span> arr[l + <span class="number">1</span>] &gt; arr[l]) <span class="keyword">else</span> l</span><br><span class="line">        best = best <span class="keyword">if</span> arr[best] &gt; arr[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(best, i)</span><br><span class="line">        i = best</span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heapInsert(i)</span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort2</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(i, n)</span><br><span class="line">    size = n</span><br><span class="line">    <span class="keyword">while</span> size &gt; <span class="number">1</span>:</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">        size -= <span class="number">1</span></span><br><span class="line">        heapify(<span class="number">0</span>, size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="堆排序的特点总结"><a href="#堆排序的特点总结" class="headerlink" title="堆排序的特点总结"></a>堆排序的特点总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>时间复杂度稳定</strong>：无论什么数据，时间复杂度都是 O(n logn)</li>
<li><strong>原地排序</strong>：额外空间复杂度 O(1)，直接在原数组上建堆</li>
<li><strong>不稳定但可预测</strong>：虽然不是稳定排序，但性能可预测</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>不稳定</strong>：相同元素的相对位置可能改变</li>
<li><strong>常数因子较大</strong>：虽然渐进复杂度优秀，但实际运行时常数因子比快排大</li>
<li><strong>缓存友好性差</strong>：堆调整过程中的访问模式对CPU缓存不太友好</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><strong>优先队列</strong>：堆是实现优先队列的最佳数据结构</li>
<li><strong>Top-K 问题</strong>：找出最大或最小的K个元素</li>
<li><strong>实时数据流</strong>：需要实时维护最值的场景</li>
<li><strong>任务调度</strong>：按优先级处理任务</li>
</ol>
<h2 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h2><p><strong>堆结构比堆排序有用得多，尤其是和比较器结合之后</strong>。堆排序只是堆数据结构的一个应用，堆在实际开发中更多用于实现优先队列、解决Top-K问题等场景。</p>
<h1 id="026【必备】哈希表、有序表和比较器的用法"><a href="#026【必备】哈希表、有序表和比较器的用法" class="headerlink" title="026【必备】哈希表、有序表和比较器的用法"></a>026【必备】哈希表、有序表和比较器的用法</h1><h2 id="哈希表（Hash-Table）的基本概念"><a href="#哈希表（Hash-Table）的基本概念" class="headerlink" title="哈希表（Hash Table）的基本概念"></a>哈希表（Hash Table）的基本概念</h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h3><p>哈希表是一种数据结构，它通过键（key）来直接访问存储在值（value）中的数据，实现快速查找、插入和删除操作。</p>
<p>大概约等于python中的字典啦</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li><strong>将数据存储在数组中</strong></li>
<li><strong>通过哈希函数将key转换为数组索引</strong></li>
<li><strong>理想情况下，查找、插入、删除的时间复杂度都是O(1)</strong></li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key → 哈希函数 → 数组索引 → 存储位置</span><br></pre></td></tr></table></figure>

<h3 id="哈希表的特点"><a href="#哈希表的特点" class="headerlink" title="哈希表的特点"></a>哈希表的特点</h3><ul>
<li><strong>时间复杂度</strong>：增、删、改、查时间为O(1)，但是大常数</li>
<li><strong>空间换时间</strong>：用额外的空间来换取时间效率</li>
<li><strong>两种形式</strong>：<ul>
<li><strong>HashSet</strong>：只存储键，用于判断元素是否存在</li>
<li><strong>HashMap</strong>：存储键值对，根据键快速找到对应的值</li>
</ul>
</li>
</ul>
<h2 id="Python中的哈希表实现"><a href="#Python中的哈希表实现" class="headerlink" title="Python中的哈希表实现"></a>Python中的哈希表实现</h2><h3 id="字符串的比较机制"><a href="#字符串的比较机制" class="headerlink" title="字符串的比较机制"></a>字符串的比较机制</h3><p>Python中字符串有特殊的驻留机制，需要注意<code>is</code>和<code>==</code>的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串比较</span></span><br><span class="line">str1 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>) </span><br><span class="line">str2 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 不同内存地址，但是内容都是Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较对象身份（内存地址）</span></span><br><span class="line"><span class="built_in">print</span>(str1 <span class="keyword">is</span> str2)   <span class="comment"># 可能是True（驻留机制）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较值（内容）</span></span><br><span class="line"><span class="built_in">print</span>(str1 == str2)   <span class="comment"># True，内容一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态生成的字符串</span></span><br><span class="line">s3 = <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s1 == s3)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">is</span> s3)  <span class="comment"># False，复杂或动态生成的字符串，is一般是False</span></span><br></pre></td></tr></table></figure>

<p><strong>重要概念</strong>：</p>
<ul>
<li><strong>字符串驻留</strong>：Python对于短小、常用的字符串可能会优化，放到同一个内存地址</li>
<li><strong>内容比较 vs 身份比较</strong>：<code>==</code>比较内容，<code>is</code>比较内存地址</li>
</ul>
<h3 id="set操作（HashSet）"><a href="#set操作（HashSet）" class="headerlink" title="set操作（HashSet）"></a>set操作（HashSet）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set判断元素是否相等靠内容，不看对象id</span></span><br><span class="line">str1 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>) </span><br><span class="line">str2 = <span class="built_in">str</span>(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 不同内存地址，但是内容都是Hello</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(str1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span> <span class="keyword">in</span> s)     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(str2 <span class="keyword">in</span> s)        <span class="comment"># True</span></span><br><span class="line">s.add(str2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))           <span class="comment"># 1，因为set里不会存储重复元素</span></span><br><span class="line">s.discard(str1)         <span class="comment"># 删除等价元素（内容相等的字符串都会被删掉）</span></span><br><span class="line">s.clear()               <span class="comment"># 清空所有元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s) == <span class="number">0</span>)      <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="dict操作（HashMap）"><a href="#dict操作（HashMap）" class="headerlink" title="dict操作（HashMap）"></a>dict操作（HashMap）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dict操作</span></span><br><span class="line">map1 = <span class="built_in">dict</span>()</span><br><span class="line">map1[str1] = <span class="string">&quot;World&quot;</span>    <span class="comment"># str1是key，&quot;World&quot;是value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span> <span class="keyword">in</span> map1)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(str2 <span class="keyword">in</span> map1)     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(map1.get(str2))   <span class="comment"># World</span></span><br><span class="line"><span class="built_in">print</span>(map1.get(<span class="string">&quot;你好&quot;</span>) <span class="keyword">is</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;Hello&quot;</span> <span class="keyword">in</span> map1:</span><br><span class="line">    <span class="keyword">del</span> map1[<span class="string">&quot;Hello&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(map1))        <span class="comment"># 0</span></span><br><span class="line">map1.clear()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(map1) == <span class="number">0</span>)   <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h2 id="哈希表的优化策略"><a href="#哈希表的优化策略" class="headerlink" title="哈希表的优化策略"></a>哈希表的优化策略</h2><h3 id="数组替代哈希表"><a href="#数组替代哈希表" class="headerlink" title="数组替代哈希表"></a>数组替代哈希表</h3><p>当key的范围是固定的、可控的情况下，可以用数组结构替代哈希表结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表实现</span></span><br><span class="line">map2 = <span class="built_in">dict</span>()</span><br><span class="line">map2[<span class="number">56</span>] = <span class="number">7285</span></span><br><span class="line">map2[<span class="number">34</span>] = <span class="number">3671263</span></span><br><span class="line">map2[<span class="number">17</span>] = <span class="number">716311</span></span><br><span class="line">map2[<span class="number">24</span>] = <span class="number">1263161</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组替代实现（速度更快）</span></span><br><span class="line">arr = [<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">arr[<span class="number">56</span>] = <span class="number">7285</span></span><br><span class="line">arr[<span class="number">34</span>] = <span class="number">3671263</span></span><br><span class="line">arr[<span class="number">17</span>] = <span class="number">716311</span></span><br><span class="line">arr[<span class="number">24</span>] = <span class="number">1263161</span></span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：</p>
<ul>
<li><strong>速度更快</strong>：直接数组访问，无需哈希计算</li>
<li><strong>空间可控</strong>：预知范围，精确分配空间</li>
<li><strong>无哈希冲突</strong>：避免了哈希表的冲突处理</li>
</ul>
<h3 id="自定义对象作为Key"><a href="#自定义对象作为Key" class="headerlink" title="自定义对象作为Key"></a>自定义对象作为Key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="number">17</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">s2 = Student(<span class="number">17</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">map3 = <span class="built_in">dict</span>()</span><br><span class="line">map3[s1] = <span class="string">&quot;这是张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">in</span> map3)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s2 <span class="keyword">in</span> map3)  <span class="comment"># False，Python默认不同对象hash不同</span></span><br><span class="line">map3[s2] = <span class="string">&quot;这是另一个张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(map3))   <span class="comment"># 2，s1和s2是不同的对象，字典中有两个键值对</span></span><br></pre></td></tr></table></figure>

<p><strong>重要提示</strong>：Python自定义对象没有实现<code>__eq__</code>和<code>__hash__</code>时，默认按对象id判定。</p>
<h2 id="有序表（TreeMap-TreeSet）"><a href="#有序表（TreeMap-TreeSet）" class="headerlink" title="有序表（TreeMap&#x2F;TreeSet）"></a>有序表（TreeMap&#x2F;TreeSet）</h2><h3 id="Python中的有序表模拟"><a href="#Python中的有序表模拟" class="headerlink" title="Python中的有序表模拟"></a>Python中的有序表模拟</h3><p>Python没有内置的TreeMap，需要用其他方式模拟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用dict+排序模拟TreeMap</span></span><br><span class="line">tree_map = <span class="built_in">dict</span>()</span><br><span class="line">tree_map[<span class="number">5</span>] = <span class="string">&quot;这是5&quot;</span></span><br><span class="line">tree_map[<span class="number">7</span>] = <span class="string">&quot;这是7&quot;</span></span><br><span class="line">tree_map[<span class="number">1</span>] = <span class="string">&quot;这是1&quot;</span></span><br><span class="line">tree_map[<span class="number">2</span>] = <span class="string">&quot;这是2&quot;</span></span><br><span class="line">tree_map[<span class="number">3</span>] = <span class="string">&quot;这是3&quot;</span></span><br><span class="line">tree_map[<span class="number">4</span>] = <span class="string">&quot;这是4&quot;</span></span><br><span class="line">tree_map[<span class="number">8</span>] = <span class="string">&quot;这是8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> tree_map)        <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> tree_map)       <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(tree_map.get(<span class="number">4</span>))      <span class="comment"># 这是4</span></span><br><span class="line">tree_map[<span class="number">4</span>] = <span class="string">&quot;张三是4&quot;</span></span><br><span class="line"><span class="built_in">print</span>(tree_map.get(<span class="number">4</span>))      <span class="comment"># 张三是4</span></span><br><span class="line"></span><br><span class="line">tree_map.pop(<span class="number">4</span>, <span class="literal">None</span>)       <span class="comment"># 删除key为4的键值对</span></span><br><span class="line"><span class="built_in">print</span>(tree_map.get(<span class="number">4</span>) <span class="keyword">is</span> <span class="literal">None</span>)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="有序表的特殊操作"><a href="#有序表的特殊操作" class="headerlink" title="有序表的特殊操作"></a>有序表的特殊操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firstKey 和 lastKey 需要排序</span></span><br><span class="line">keys = <span class="built_in">sorted</span>(tree_map.keys())</span><br><span class="line"><span class="built_in">print</span>(keys[<span class="number">0</span>])      <span class="comment"># firstKey: 1</span></span><br><span class="line"><span class="built_in">print</span>(keys[-<span class="number">1</span>])     <span class="comment"># lastKey: 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># floorKey: 所有的key，&lt;= 4且最近的key是什么</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">floor_key</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> tree_map <span class="keyword">if</span> x &lt;= k], default=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ceilingKey: 所有的key，&gt;= 4且最近的key是什么</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ceiling_key</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> tree_map <span class="keyword">if</span> x &gt;= k], default=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(floor_key(<span class="number">4</span>))    <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(ceiling_key(<span class="number">4</span>))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><strong>操作解释</strong>：</p>
<ul>
<li><strong>删除前</strong>：1, 2, 3, [4], 5, 7, 8</li>
<li><strong>删除后</strong>：1, 2, 3, 5, 7, 8</li>
<li><strong>floor_key(4)</strong>：找到 ≤ 4 的最大值，可选值：[1, 2, 3]，最大值：3</li>
<li><strong>ceiling_key(4)</strong>：找到 ≥ 4 的最小值，可选值：[5, 7, 8]，最小值：5</li>
</ul>
<h3 id="TreeSet模拟"><a href="#TreeSet模拟" class="headerlink" title="TreeSet模拟"></a>TreeSet模拟</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TreeSet模拟：用set+排序（去重且有序）</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">s.add(<span class="number">3</span>)</span><br><span class="line">s.add(<span class="number">3</span>)</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有序表大小:&quot;</span>, <span class="built_in">len</span>(s))  <span class="comment"># 2，因为set里不会存储重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以有序弹出</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">sorted</span>(s):</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h2><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小根堆</span></span><br><span class="line">heap1 = []</span><br><span class="line">heapq.heappush(heap1, <span class="number">3</span>)</span><br><span class="line">heapq.heappush(heap1, <span class="number">3</span>)</span><br><span class="line">heapq.heappush(heap1, <span class="number">4</span>)</span><br><span class="line">heapq.heappush(heap1, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;堆大小:&quot;</span>, <span class="built_in">len</span>(heap1))  <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">while</span> heap1:</span><br><span class="line">    <span class="built_in">print</span>(heapq.heappop(heap1))  <span class="comment"># 3 3 4 4</span></span><br></pre></td></tr></table></figure>

<h3 id="大根堆实现技巧"><a href="#大根堆实现技巧" class="headerlink" title="大根堆实现技巧"></a>大根堆实现技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大根堆trick：使用负数</span></span><br><span class="line">heap2 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]:</span><br><span class="line">    heapq.heappush(heap2, -x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;堆大小:&quot;</span>, <span class="built_in">len</span>(heap2))  <span class="comment"># 4</span></span><br><span class="line"><span class="keyword">while</span> heap2:</span><br><span class="line">    <span class="built_in">print</span>(-heapq.heappop(heap2))  <span class="comment"># 4 4 3 3</span></span><br></pre></td></tr></table></figure>

<p><strong>核心技巧</strong>：Python的heapq只提供小根堆，要实现大根堆可以将所有元素取负数。</p>
<h2 id="比较器的使用"><a href="#比较器的使用" class="headerlink" title="比较器的使用"></a>比较器的使用</h2><h3 id="基本比较器概念"><a href="#基本比较器概念" class="headerlink" title="基本比较器概念"></a>基本比较器概念</h3><p>任何比较器都有统一的规则：</p>
<ul>
<li><strong>返回负数</strong>：认为第一个对象优先级更高</li>
<li><strong>返回正数</strong>：认为第二个对象优先级更高</li>
<li><strong>返回0</strong>：两个对象优先级相等</li>
</ul>
<h3 id="员工类的排序示例"><a href="#员工类的排序示例" class="headerlink" title="员工类的排序示例"></a>员工类的排序示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, company, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.company = company</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Employee(<span class="subst">&#123;self.company&#125;</span>, <span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工比较器，按年龄升序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">employee_comparator</span>(<span class="params">o1, o2</span>):</span><br><span class="line">    <span class="keyword">return</span> o1.age - o2.age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建员工对象</span></span><br><span class="line">s1 = Employee(<span class="number">2</span>, <span class="number">27</span>)</span><br><span class="line">s2 = Employee(<span class="number">1</span>, <span class="number">60</span>)</span><br><span class="line">s3 = Employee(<span class="number">4</span>, <span class="number">19</span>)</span><br><span class="line">s4 = Employee(<span class="number">3</span>, <span class="number">23</span>)</span><br><span class="line">s5 = Employee(<span class="number">1</span>, <span class="number">35</span>)</span><br><span class="line">s6 = Employee(<span class="number">3</span>, <span class="number">55</span>)</span><br><span class="line">arr = [s1, s2, s3, s4, s5, s6]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按年龄升序排序</span></span><br><span class="line">arr.sort(key=cmp_to_key(employee_comparator))</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e.company&#125;</span>, <span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="多种排序方式"><a href="#多种排序方式" class="headerlink" title="多种排序方式"></a>多种排序方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按年龄降序排序（lambda表达式）</span></span><br><span class="line">arr.sort(key=<span class="keyword">lambda</span> x: -x.age)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e.company&#125;</span>, <span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多级排序：先按公司编号，再按年龄</span></span><br><span class="line">arr.sort(key=<span class="keyword">lambda</span> x: (x.company, x.age))</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;e.company&#125;</span>, <span class="subst">&#123;e.age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义对象的去重策略"><a href="#自定义对象的去重策略" class="headerlink" title="自定义对象的去重策略"></a>自定义对象的去重策略</h3><h4 id="按年龄去重"><a href="#按年龄去重" class="headerlink" title="按年龄去重"></a>按年龄去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeByAge</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.age == other.age  <span class="comment"># 只看年龄</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.age)</span><br><span class="line"></span><br><span class="line">treeSet1 = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    treeSet1.add(EmployeeByAge(e.company, e.age))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet1))  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会去重，因为age一样的员工被认为是同一个</span></span><br><span class="line">treeSet1.add(EmployeeByAge(<span class="number">2</span>, <span class="number">27</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet1))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<h4 id="按多个属性去重"><a href="#按多个属性去重" class="headerlink" title="按多个属性去重"></a>按多个属性去重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeByAll</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, EmployeeByAll):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">self</span>.company == other.company <span class="keyword">and</span> </span><br><span class="line">                <span class="variable language_">self</span>.age == other.age <span class="keyword">and</span> </span><br><span class="line">                <span class="built_in">repr</span>(<span class="variable language_">self</span>) == <span class="built_in">repr</span>(other))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="variable language_">self</span>.company, <span class="variable language_">self</span>.age, <span class="built_in">repr</span>(<span class="variable language_">self</span>)))</span><br><span class="line"></span><br><span class="line">treeSet2 = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">    treeSet2.add(EmployeeByAll(e.company, e.age))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet2))  <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会去重，因为repr不同（内存地址不同）</span></span><br><span class="line">treeSet2.add(EmployeeByAll(<span class="number">2</span>, <span class="number">27</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(treeSet2))  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>

<p><strong>重要概念</strong>：</p>
<ul>
<li><strong><code>__eq__</code>方法</strong>：定义对象间的相等性比较，当使用<code>==</code>操作符时调用</li>
<li><strong><code>__hash__</code>方法</strong>：定义对象的哈希值，用于在集合和字典中作为键</li>
</ul>
<h3 id="字符串的字典序比较"><a href="#字符串的字典序比较" class="headerlink" title="字符串的字典序比较"></a>字符串的字典序比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典序比较</span></span><br><span class="line">str1 = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;ks&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.__lt__(str2) - str1.__gt__(str2))  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(str2.__lt__(str1) - str2.__gt__(str1))  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接用比较运算符</span></span><br><span class="line"><span class="built_in">print</span>((str1 &gt; str2) - (str1 &lt; str2))  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>((str2 &gt; str1) - (str2 &lt; str1))  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p><strong>字典序规则</strong>：按字符的ASCII码逐位比较，先遇到不同字符的位置决定大小关系。</p>
<h2 id="数据结构选择指南"><a href="#数据结构选择指南" class="headerlink" title="数据结构选择指南"></a>数据结构选择指南</h2><h3 id="性能对比表"><a href="#性能对比表" class="headerlink" title="性能对比表"></a>性能对比表</h3><table>
<thead>
<tr>
<th>数据结构</th>
<th>查找</th>
<th>插入</th>
<th>删除</th>
<th>有序性</th>
<th>去重</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>❌</td>
<td>✅</td>
<td>快速查重、集合运算</td>
</tr>
<tr>
<td>dict</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>❌</td>
<td>✅</td>
<td>键值映射、缓存</td>
</tr>
<tr>
<td>数组</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>❌</td>
<td>❌</td>
<td>key范围可控时替代哈希表</td>
</tr>
<tr>
<td>排序列表</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>✅</td>
<td>❌</td>
<td>需要有序且查找频繁</td>
</tr>
<tr>
<td>heapq</td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>部分</td>
<td>❌</td>
<td>优先队列、Top-K问题</td>
</tr>
</tbody></table>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ol>
<li><strong>快速查找、去重</strong>：使用<code>set</code></li>
<li><strong>键值映射</strong>：使用<code>dict</code></li>
<li><strong>key范围固定</strong>：考虑数组替代哈希表</li>
<li><strong>需要有序</strong>：使用排序+二分查找或第三方库</li>
<li><strong>优先队列</strong>：使用<code>heapq</code></li>
<li><strong>自定义排序</strong>：实现比较器或使用<code>key</code>参数</li>
</ol>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="场景1：统计词频"><a href="#场景1：统计词频" class="headerlink" title="场景1：统计词频"></a>场景1：统计词频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dict统计</span></span><br><span class="line">text = <span class="string">&quot;hello world hello python&quot;</span></span><br><span class="line">word_count = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split():</span><br><span class="line">    word_count[word] = word_count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(word_count)  <span class="comment"># &#123;&#x27;hello&#x27;: 2, &#x27;world&#x27;: 1, &#x27;python&#x27;: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="场景2：去重并保持顺序"><a href="#场景2：去重并保持顺序" class="headerlink" title="场景2：去重并保持顺序"></a>场景2：去重并保持顺序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dict保持插入顺序的去重</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe_keep_order</span>(<span class="params">items</span>):</span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen[item] = <span class="literal">True</span></span><br><span class="line">            result.append(item)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(dedupe_keep_order(items))  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="场景3：Top-K问题"><a href="#场景3：Top-K问题" class="headerlink" title="场景3：Top-K问题"></a>场景3：Top-K问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_top_k</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="comment"># 使用小根堆，维护k个最大元素</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">elif</span> num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(heap, num)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(heap, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(find_top_k(nums, <span class="number">3</span>))  <span class="comment"># [9, 6, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>哈希表</strong>：提供O(1)的查找、插入、删除，但有较大常数因子</li>
<li><strong>有序表</strong>：在Python中需要模拟实现，适合需要有序性的场景</li>
<li><strong>比较器</strong>：统一的优先级比较规则，负数表示第一个对象优先级更高</li>
<li><strong>优化策略</strong>：key范围可控时用数组替代哈希表，性能更好</li>
<li><strong>实际应用</strong>：根据具体需求选择合适的数据结构，考虑时间复杂度和空间复杂度的权衡</li>
</ol>
<h1 id="027【必备】堆结构常见题"><a href="#027【必备】堆结构常见题" class="headerlink" title="027【必备】堆结构常见题"></a>027【必备】堆结构常见题</h1><h2 id="Python-heapq-模块详解"><a href="#Python-heapq-模块详解" class="headerlink" title="Python heapq 模块详解"></a>Python heapq 模块详解</h2><h3 id="heapq-基本概念"><a href="#heapq-基本概念" class="headerlink" title="heapq 基本概念"></a>heapq 基本概念</h3><p>heapq 是 Python 标准库提供的”二叉堆”实现工具，基于列表实现的<strong>最小堆（min-heap）</strong>。它能在 O(log n) 时间内插入与弹出最小元素，<code>heap[0]</code> 永远是当前最小值。</p>
<h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">heapq.heappush(heap, item)      <span class="comment"># 压入元素，O(log n)</span></span><br><span class="line">heapq.heappop(heap)             <span class="comment"># 弹出最小元素，O(log n)</span></span><br><span class="line">heapq.heapify(lst)              <span class="comment"># 原地把列表转成堆，O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高效组合操作</span></span><br><span class="line">heapq.heappushpop(heap, item)   <span class="comment"># 先推入再弹出（更高效的一步）</span></span><br><span class="line">heapq.heapreplace(heap, item)   <span class="comment"># 先弹出最小再推入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实用函数</span></span><br><span class="line">heapq.nsmallest(n, iterable)    <span class="comment"># 返回n个最小元素</span></span><br><span class="line">heapq.nlargest(n, iterable)     <span class="comment"># 返回n个最大元素</span></span><br><span class="line">heapq.merge(*iterables)         <span class="comment"># 合并多个已排序可迭代对象（惰性生成）</span></span><br></pre></td></tr></table></figure>

<h3 id="大根堆实现技巧-1"><a href="#大根堆实现技巧-1" class="headerlink" title="大根堆实现技巧"></a>大根堆实现技巧</h3><p>由于 Python 的 heapq 只提供小根堆，实现大根堆需要使用负数技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大根堆实现</span></span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]:</span><br><span class="line">    heapq.heappush(heap, -x)    <span class="comment"># 插入负数</span></span><br><span class="line"></span><br><span class="line">max_val = -heapq.heappop(heap)  <span class="comment"># 弹出并转回正数</span></span><br></pre></td></tr></table></figure>

<h2 id="问题一：合并K个有序链表"><a href="#问题一：合并K个有序链表" class="headerlink" title="问题一：合并K个有序链表"></a>问题一：合并K个有序链表</h2><p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6">https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6</a></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定K个有序链表，将它们合并成一个有序链表。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用<strong>小根堆</strong>维护所有链表的当前头节点，每次取出值最小的节点：</p>
<ol>
<li><strong>初始化</strong>：将所有链表的头节点放入堆中</li>
<li><strong>合并过程</strong>：<ul>
<li>弹出堆顶最小节点，连接到结果链表</li>
<li>如果该节点有下一个节点，将下一个节点入堆</li>
<li>重复直到堆为空</li>
</ul>
</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%B0%8F%E6%A0%B9%E5%A0%86%E7%89%88.png" alt="合并k个有序链表-小根堆版"></p>
<h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">arr: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="comment"># 小根堆，存储节点及其值，用堆结构的话时间复杂度会比O(NlogN)更小</span></span><br><span class="line">    <span class="comment"># Optional[T] 等价于 Union[T, None]</span></span><br><span class="line">    <span class="comment"># 表示这个值可能是 T 类型，也可能是 None</span></span><br><span class="line">    heap = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将所有链表头节点入堆</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> h <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Python的heapq不能直接比较对象，需包装</span></span><br><span class="line">            heapq.heappush(heap, (h.val, <span class="built_in">id</span>(h), h))</span><br><span class="line">            <span class="comment"># heapq 比较规则：它按元组字典序比较。你放入 (val, something, node) 时，先比 val，相等就比第二个元素；如果第二个也相等，就会去比第三个元素（即 ListNode 实例）。</span></span><br><span class="line">            <span class="comment"># 问题：ListNode 没有定义大小比较，直接比较会抛出 TypeError: &#x27;&lt;&#x27; not supported...</span></span><br><span class="line">            <span class="comment"># 加入 id(node)：id 是对象在该进程生命周期内的唯一“身份值”（可比较），作为“决胜键”保证元组能比较出大小，从而避免直接比较 ListNode。 </span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> heap:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 弹出一个节点作为总头部</span></span><br><span class="line">    _, _, h = heapq.heappop(heap)</span><br><span class="line">    pre = h</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将该节点的下一个节点入堆</span></span><br><span class="line">    <span class="keyword">if</span> pre.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        heapq.heappush(heap, (pre.<span class="built_in">next</span>.val, <span class="built_in">id</span>(pre.<span class="built_in">next</span>), pre.<span class="built_in">next</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 继续合并过程</span></span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        _, _, cur = heapq.heappop(heap)</span><br><span class="line">        pre.<span class="built_in">next</span> = cur      <span class="comment"># 连接链表</span></span><br><span class="line">        pre = cur          <span class="comment"># pre后移</span></span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            heapq.heappush(heap, (cur.<span class="built_in">next</span>.val, <span class="built_in">id</span>(cur.<span class="built_in">next</span>), cur.<span class="built_in">next</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">    <span class="comment"># 对 heapq 来说，一个 item 就是一个可比较的对象。这里把一个三元组 (pre.next.val, id(pre.next), pre.next) 当作 item 放入堆。</span></span><br><span class="line">    <span class="comment"># 比较顺序（字典序）：</span></span><br><span class="line">    <span class="comment"># 先比第 1 位 pre.next.val（值越小，优先级越高）</span></span><br><span class="line">    <span class="comment"># 若相等，再比第 2 位 id(pre.next)（保证能比较出大小，避免去比较 ListNode 本身）</span></span><br><span class="line">    <span class="comment"># 只在前两位都相等时，才会看第 3 位 pre.next（但通常不会用到，因为 id 已经唯一）</span></span><br></pre></td></tr></table></figure>

<h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><p><strong>元组比较机制</strong>：</p>
<ul>
<li>heapq 按元组字典序比较：<code>(val, something, node)</code></li>
<li>先比较 <code>val</code>，相等时比较第二个元素</li>
<li>加入 <code>id(node)</code> 作为”决胜键”，避免直接比较 ListNode 对象</li>
</ul>
<p><strong>为什么需要 id(node)</strong>：</p>
<ul>
<li>ListNode 没有定义大小比较，直接比较会抛出 TypeError</li>
<li><code>id()</code> 返回对象的唯一标识符，可以进行比较</li>
<li>保证元组能比较出大小，避免直接比较 ListNode</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log K)，其中 N 是所有节点总数，K 是链表个数</li>
<li><strong>空间复杂度</strong>：O(K)，堆中最多存储 K 个节点<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="合并k个有序链表-复杂度分析"></li>
</ul>
<h2 id="问题二：最多线段重合问题"><a href="#问题二：最多线段重合问题" class="headerlink" title="问题二：最多线段重合问题"></a>问题二：最多线段重合问题</h2><p><strong>测试链接</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37">https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/">https://leetcode.cn/problems/meeting-rooms-ii/</a></li>
</ul>
<h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定n条线段，每条线段有起点和终点，求最多同时重合的线段数量。</p>
<h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用<strong>扫描线算法 + 小根堆</strong>：</p>
<ol>
<li><strong>排序</strong>：将所有线段按起点排序</li>
<li><strong>扫描</strong>：从左到右处理每条线段</li>
<li><strong>维护堆</strong>：堆中存储当前重合线段的结束时间</li>
<li><strong>清理</strong>：移除已结束的线段（结束点 ≤ 当前起点）</li>
<li><strong>更新</strong>：添加当前线段，更新最大重合数</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E6%9C%80%E5%A4%A7%E9%87%8D%E5%90%88%E7%BA%BF%E6%AE%B5%E6%95%B0.png" alt="最大重合线段数"></p>
<h3 id="核心实现-1"><a href="#核心实现-1" class="headerlink" title="核心实现"></a>核心实现</h3><ul>
<li><p>想象每条线段根据开始和结束位置，放在x轴上，然后有一根竖线，从左到右划过x轴，竖线压中的线段上的点，就需要把当前点放入到某个组里。</p>
</li>
<li><p>请问，从左到右划的过程，你最多需要准备几个组？最多重合几条线段，就需要几个组。这些组不断复用空间，放入不同的点。但是最大重合了多少，你就需要准备几个组。</p>
</li>
<li><p><strong>重要</strong>：我之前一直在纠结为什么不要考虑后面重复合并， 但是我们这个代码已经考虑了后面重复合并，因为我们是把结束点加入到堆里，而不是把线段加入到堆里。因此即便这条线段的结束点和后面的线段的开始点重合，我们也会把这条线段的结束点加入到堆里，则以这个为标准对数轴进行扫描，又因为小根堆是根据开始点进行从小大排序的，所以能够保证后面的线段初始点严格小于当前线段的初始点，不会忽略到后面的线段重合，这个是个离散的逐点扫描的过程。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # 时间复杂度：O(NlogN) ，n条线段，平均比较次数是logN，所以是O(NlogN)</span></span><br><span class="line"><span class="string">    # 空间复杂度：O(N)，因为需要存储每条线段的结束点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    size = <span class="number">0</span>  <span class="comment"># 堆的清空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 所有线段根据开始位置排序</span></span><br><span class="line">    sorted_lines = <span class="built_in">sorted</span>(line[:n], key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 最大重合数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 步骤1：清理已结束的线段</span></span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span> <span class="keyword">and</span> heap[<span class="number">0</span>] &lt;= sorted_lines[i][<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># 堆顶是最早结束的线段</span></span><br><span class="line">            <span class="comment"># 如果它的结束点 ≤ 当前线段的起点，说明已经不重合了</span></span><br><span class="line">            pop()  <span class="comment"># 移除这个已结束的线段</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤2：加入当前线段</span></span><br><span class="line">        add(sorted_lines[i][<span class="number">1</span>])  <span class="comment"># 把当前线段的结束点加入堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 步骤3：更新答案</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, size)  <span class="comment"># 当前堆的大小 = 当前重合的线段数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法可视化"><a href="#算法可视化" class="headerlink" title="算法可视化"></a>算法可视化</h3><p>想象一根竖线从左到右扫过数轴：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线段1: |-------|</span><br><span class="line">线段2:    |-----|</span><br><span class="line">线段3:      |---|</span><br><span class="line">线段4:        |-----|</span><br><span class="line"></span><br><span class="line">扫描过程：</span><br><span class="line">时刻1: |          重合数 = 1</span><br><span class="line">时刻2:   |        重合数 = 2  </span><br><span class="line">时刻3:     |      重合数 = 3 (最大值)</span><br><span class="line">时刻4:       |    重合数 = 2</span><br></pre></td></tr></table></figure>

<h3 id="手写堆实现"><a href="#手写堆实现" class="headerlink" title="手写堆实现"></a>手写堆实现</h3><p>为了提高效率，使用数组实现小根堆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">10001</span></span><br><span class="line">heap = [<span class="number">0</span>] * MAXN  <span class="comment"># 存储结束点</span></span><br><span class="line">size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    heap[size] = x</span><br><span class="line">    i = size</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 上浮调整</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> heap[i] &lt; heap[(i - <span class="number">1</span>) // <span class="number">2</span>]:</span><br><span class="line">        swap(i, (i - <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        i = (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>():</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    swap(<span class="number">0</span>, size - <span class="number">1</span>)</span><br><span class="line">    size -= <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 下沉调整</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:</span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> l + <span class="number">1</span> &lt; size <span class="keyword">and</span> heap[l + <span class="number">1</span>] &lt; heap[l] <span class="keyword">else</span> l</span><br><span class="line">        best = best <span class="keyword">if</span> heap[best] &lt; heap[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(i, best)</span><br><span class="line">        i = best</span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    heap[i], heap[j] = heap[j], heap[i]</span><br></pre></td></tr></table></figure>

<h3 id="变种问题"><a href="#变种问题" class="headerlink" title="变种问题"></a>变种问题</h3><h4 id="会议室问题"><a href="#会议室问题" class="headerlink" title="会议室问题"></a>会议室问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minMeetingRooms</span>(<span class="params">meeting</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(meeting)</span><br><span class="line">    meeting.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  <span class="comment"># 按起始时间排序</span></span><br><span class="line">    heap = []  <span class="comment"># 小根堆，会议的结束时间</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> heap[<span class="number">0</span>] &lt;= meeting[i][<span class="number">0</span>]:  <span class="comment"># 堆顶会议已结束</span></span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        heapq.heappush(heap, meeting[i][<span class="number">1</span>])      <span class="comment"># 当前会议结束时间入堆</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(heap))                <span class="comment"># 记录最大会议室数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="分组问题"><a href="#分组问题" class="headerlink" title="分组问题"></a>分组问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minGroups</span>(<span class="params">meeting</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(meeting)</span><br><span class="line">    meeting.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    heap = []</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> heap[<span class="number">0</span>] &lt; meeting[i][<span class="number">0</span>]:  <span class="comment"># 注意此处是 &lt;，题意不同</span></span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        heapq.heappush(heap, meeting[i][<span class="number">1</span>])</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(heap))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p><strong>关键区别</strong>：会议室问题用 <code>&lt;=</code>（会议可以无缝衔接），分组问题用 <code>&lt;</code>（需要间隔）。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log N)，排序 + 每个元素平均 log N 次堆操作</li>
<li><strong>空间复杂度</strong>：O(N)，存储线段结束点的堆</li>
</ul>
<h2 id="问题三：将数组和减半的最少操作次数"><a href="#问题三：将数组和减半的最少操作次数" class="headerlink" title="问题三：将数组和减半的最少操作次数"></a>问题三：将数组和减半的最少操作次数</h2><p><strong>测试链接</strong>：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/">https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/</a></p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组，每次操作可以将任意一个元素减半，求使数组总和减少到原来一半所需的最少操作次数。</p>
<h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用<strong>贪心策略 + 大根堆</strong>：</p>
<ol>
<li><strong>贪心原理</strong>：每次选择当前最大的元素进行减半，减少量最大</li>
<li><strong>堆维护</strong>：用大根堆维护当前所有元素</li>
<li><strong>操作过程</strong>：不断取出最大元素减半，直到总减少量达到目标</li>
</ol>
<h3 id="方法一：基于-heapq"><a href="#方法一：基于-heapq" class="headerlink" title="方法一：基于 heapq"></a>方法一：基于 heapq</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">halveArray1</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 大根堆（用负数模拟）</span></span><br><span class="line">    heap = []</span><br><span class="line">    sum_val = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        heapq.heappush(heap, -<span class="built_in">float</span>(num))  <span class="comment"># 负数模拟大根堆</span></span><br><span class="line">        sum_val += num</span><br><span class="line">    </span><br><span class="line">    sum_val /= <span class="number">2</span>  <span class="comment"># 要减少到总和一半</span></span><br><span class="line">    ans = <span class="number">0</span>       <span class="comment"># 操作次数</span></span><br><span class="line">    minus = <span class="number">0</span>     <span class="comment"># 已减少的和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> minus &lt; sum_val:</span><br><span class="line">        cur = -heapq.heappop(heap) / <span class="number">2</span>  <span class="comment"># 取出最大数、减半</span></span><br><span class="line">        heapq.heappush(heap, -cur)      <span class="comment"># 新值放回堆</span></span><br><span class="line">        minus += cur                    <span class="comment"># 记录减少量</span></span><br><span class="line">        ans += <span class="number">1</span>                        <span class="comment"># 操作次数加1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="方法二：手写堆-精度优化"><a href="#方法二：手写堆-精度优化" class="headerlink" title="方法二：手写堆 + 精度优化"></a>方法二：手写堆 + 精度优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">heap_arr = [<span class="number">0</span>] * MAXN</span><br><span class="line">size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">halveArray2</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    size = <span class="built_in">len</span>(nums)</span><br><span class="line">    sum_val = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化大根堆，左移20位保证精度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heap_arr[i] = <span class="built_in">int</span>(nums[i]) &lt;&lt; <span class="number">20</span>  <span class="comment"># 左移20位放大</span></span><br><span class="line">        sum_val += heap_arr[i]</span><br><span class="line">        heapify(i)  <span class="comment"># 调整堆</span></span><br><span class="line">    </span><br><span class="line">    sum_val //= <span class="number">2</span>  <span class="comment"># 目标减少量</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    minus = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> minus &lt; sum_val:</span><br><span class="line">        heap_arr[<span class="number">0</span>] //= <span class="number">2</span>    <span class="comment"># 堆顶减半</span></span><br><span class="line">        minus += heap_arr[<span class="number">0</span>]</span><br><span class="line">        heapify(<span class="number">0</span>)</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">global</span> size</span><br><span class="line">    l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; size:</span><br><span class="line">        best = l + <span class="number">1</span> <span class="keyword">if</span> l + <span class="number">1</span> &lt; size <span class="keyword">and</span> heap_arr[l + <span class="number">1</span>] &gt; heap_arr[l] <span class="keyword">else</span> l</span><br><span class="line">        best = best <span class="keyword">if</span> heap_arr[best] &gt; heap_arr[i] <span class="keyword">else</span> i</span><br><span class="line">        <span class="keyword">if</span> best == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(best, i)</span><br><span class="line">        i = best</span><br><span class="line">        l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    heap_arr[i], heap_arr[j] = heap_arr[j], heap_arr[i]</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(8)/class27-%E5%A0%86%E7%BB%93%E6%9E%84%E5%B8%B8%E8%A7%81%E9%A2%98/%E7%BB%BC%E5%90%88%E5%87%8F%E5%B0%91%E4%B8%80%E5%8D%8A%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C-%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95.png" alt="综合减少一半最少操作-优化方法"></p>
<h3 id="关键优化技术"><a href="#关键优化技术" class="headerlink" title="关键优化技术"></a>关键优化技术</h3><h4 id="精度处理"><a href="#精度处理" class="headerlink" title="精度处理"></a>精度处理</h4><p><strong>问题</strong>：浮点数运算有精度损失，可能导致结果错误</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>将所有数左移20位（乘以 2²⁰）</li>
<li>用整数运算模拟浮点数运算</li>
<li><code>int(32位) × 2²⁰ &lt; long(64位)</code>，不会溢出</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>手写堆 vs heapq</strong>：</p>
<ul>
<li>heapq 基于 Python 列表，有额外开销</li>
<li>手写数组堆效率更高，常数因子更小</li>
</ul>
<h3 id="算法正确性证明"><a href="#算法正确性证明" class="headerlink" title="算法正确性证明"></a>算法正确性证明</h3><p><strong>贪心策略的正确性</strong>：</p>
<ul>
<li>每次选择最大元素减半，获得的减少量最大</li>
<li>假设最优解不是每次选最大元素，可以证明交换操作不会使结果变差</li>
<li>因此贪心策略能得到最优解</li>
</ul>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(N log N)，每个元素最多被操作 log(max_value) 次。若傻傻地每个元素都缩1&#x2F;2，一定能达成目标；显然操作的元素个数一定小于n</li>
<li><strong>空间复杂度</strong>：O(N)，存储堆的空间</li>
</ul>
<h2 id="堆结构应用总结"><a href="#堆结构应用总结" class="headerlink" title="堆结构应用总结"></a>堆结构应用总结</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><table>
<thead>
<tr>
<th>问题类型</th>
<th>堆类型</th>
<th>核心思想</th>
<th>典型例题</th>
</tr>
</thead>
<tbody><tr>
<td>合并有序序列</td>
<td>小根堆</td>
<td>维护多个序列的当前最小值</td>
<td>合并K个有序链表</td>
</tr>
<tr>
<td>区间重合问题</td>
<td>小根堆</td>
<td>扫描线 + 维护结束时间</td>
<td>最多线段重合</td>
</tr>
<tr>
<td>贪心选择</td>
<td>大根堆</td>
<td>每次选择当前最值进行操作</td>
<td>数组和减半</td>
</tr>
<tr>
<td>Top-K问题</td>
<td>小根堆</td>
<td>维护K个最大值</td>
<td>第K大元素</td>
</tr>
<tr>
<td>任务调度</td>
<td>小根堆</td>
<td>按优先级处理任务</td>
<td>CPU任务调度</td>
</tr>
</tbody></table>
<h3 id="实现选择"><a href="#实现选择" class="headerlink" title="实现选择"></a>实现选择</h3><table>
<thead>
<tr>
<th>情况</th>
<th>推荐实现</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>原型开发</td>
<td>heapq</td>
<td>简单易用，标准库</td>
</tr>
<tr>
<td>性能要求高</td>
<td>手写堆</td>
<td>效率更高，常数因子小</td>
</tr>
<tr>
<td>需要大根堆</td>
<td>负数技巧</td>
<td>Python只有小根堆</td>
</tr>
<tr>
<td>精度要求高</td>
<td>整数模拟</td>
<td>避免浮点数误差</td>
</tr>
</tbody></table>
<h3 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h3><ol>
<li><strong>对象比较问题</strong>：自定义对象作为堆元素时，需要实现比较方法或使用包装</li>
<li><strong>精度问题</strong>：浮点数运算可能有误差，关键场合使用整数</li>
<li><strong>堆类型混淆</strong>：Python默认小根堆，大根堆需要取负数</li>
<li><strong>边界条件</strong>：空堆操作、单元素情况需要特殊处理</li>
</ol>
<h3 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><ol>
<li><strong>预分配空间</strong>：手写堆时预分配数组空间</li>
<li><strong>避免频繁内存操作</strong>：使用数组而非动态列表</li>
<li><strong>批量操作</strong>：<code>heapify</code> 比逐个插入效率高</li>
<li><strong>精度与性能平衡</strong>：根据需求选择合适的数据类型</li>
</ol>
<p>堆结构是解决很多算法问题的重要工具，在实际使用中，要根据具体问题选择合适的实现方式和优化策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89-%20%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F&%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89-%20%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F&%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（7）- 随机排序&随机选择算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-07 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-07T08:42:46+08:00">2025-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-10 14:32:18" itemprop="dateModified" datetime="2025-08-10T14:32:18+08:00">2025-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了随机快速排序和随机选择算法的原理与实现，涵盖了荷兰国旗问题优化、时间复杂度分析等内容，包括了class023 -&gt; class024的内容</p>
<h1 id="023【必备】随机快速排序"><a href="#023【必备】随机快速排序" class="headerlink" title="023【必备】随机快速排序"></a>023【必备】随机快速排序</h1><h2 id="快速排序的基本思想"><a href="#快速排序的基本思想" class="headerlink" title="快速排序的基本思想"></a>快速排序的基本思想</h2><p>快速排序是一种高效的分治排序算法，其核心思想是：</p>
<ol>
<li><strong>选择基准元素（pivot）</strong>：从数组中选择一个元素作为基准值pivot</li>
<li><strong>数组划分</strong>：将数组重新排列，使得所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面</li>
<li><strong>递归排序</strong>：对基准值两侧的子数组递归地应用快速排序</li>
</ol>
<h2 id="随机化的重要性"><a href="#随机化的重要性" class="headerlink" title="随机化的重要性"></a>随机化的重要性</h2><p><strong>为什么需要随机化？</strong></p>
<ul>
<li><strong>普通快速排序</strong>：固定选择位置（如最右元素）作为基准，最坏情况时间复杂度为O(n²)</li>
<li><strong>随机快速排序</strong>：随机选择基准元素，期望时间复杂度为O(n log n)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机选择基准元素是关键</span></span><br><span class="line">x = arr[random.randint(l, r)]  <span class="comment"># 在[l,r]范围内随机选择</span></span><br></pre></td></tr></table></figure>


<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<h2 id="经典快速排序实现（不推荐）"><a href="#经典快速排序实现（不推荐）" class="headerlink" title="经典快速排序实现（不推荐）"></a>经典快速排序实现（不推荐）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort1</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="comment"># l == r，只有一个数</span></span><br><span class="line">    <span class="comment"># l &gt; r，范围不存在，不用管</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 随机这一下，常数时间比较大</span></span><br><span class="line">    <span class="comment"># 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">    <span class="comment"># l......r 随机选一个位置，x这个值，做划分</span></span><br><span class="line">    x = arr[random.randint(l, r)]</span><br><span class="line">    mid = partition1(l, r, x) <span class="comment">#会返回x的下标即index</span></span><br><span class="line">    quickSort1(l, mid - <span class="number">1</span>)</span><br><span class="line">    quickSort1(mid + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"><span class="comment"># 划分数组 &lt;=x放左边，&gt;x放右边</span></span><br><span class="line"><span class="comment"># 并且确保划分完成后&lt;=x区域的最后一个数字是x</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition1</span>(<span class="params">l, r, x</span>):</span><br><span class="line">    <span class="comment"># a : arr[l....a-1]范围是&lt;=x的区域</span></span><br><span class="line">    <span class="comment"># xi : 记录在&lt;=x的区域上任何一个x的位置，哪一个都可以</span></span><br><span class="line">    a = l            <span class="comment"># 初始化指针a，表示&lt;=x区域的右边界，初值为l</span></span><br><span class="line">    xi = <span class="number">0</span>           <span class="comment"># 初始化xi，用于记录&lt;=x区域内某一个x的位置（后面需要与a-1交换）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):   <span class="comment"># 从l遍历到r，依次考察每个元素，每一步都会i++（重要，所以这里的代码没有显式写i++）</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= x:         <span class="comment"># 如果当前元素小于等于x</span></span><br><span class="line">            swap(a, i)          <span class="comment"># 把当前元素交换到a位置（即&lt;=x区的后面）</span></span><br><span class="line">            <span class="keyword">if</span> arr[a] == x:     <span class="comment"># 如果新放到a位置的元素等于x</span></span><br><span class="line">                xi = a          <span class="comment"># 记录下这个位置为xi</span></span><br><span class="line">            a += <span class="number">1</span>              <span class="comment"># &lt;=x区往右扩展一位</span></span><br><span class="line">    swap(xi, a - <span class="number">1</span>)             <span class="comment"># 把&lt;=x区域里某个x与区域最后一个元素交换，保证x落在最后</span></span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>                <span class="comment"># 返回&lt;=x区域的最后一个下标（即x最终所在的位置）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">i, j</span>):</span><br><span class="line">    tmp = arr[i]        <span class="comment"># 先把arr[i]暂存到tmp</span></span><br><span class="line">    arr[i] = arr[j]     <span class="comment"># arr[i]赋值为arr[j]</span></span><br><span class="line">    arr[j] = tmp        <span class="comment"># arr[j]赋值为tmp，实现arr[i]和arr[j]交换</span></span><br></pre></td></tr></table></figure>

<p><strong>经典版本的问题</strong>：</p>
<ul>
<li>经典快排每次只排掉一个等于pivot的元素，重复元素多时递归深度大，容易爆栈突变为，pivot 只确定了它自己的最终位置，如果有很多元素等于 pivot，只有一个会归位，剩下的还在“乱序”的子区间里。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(7)/class23-%E9%9A%8F%E6%9C%BA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/partition%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3-%E7%BB%8F%E5%85%B8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="partition函数理解-经典快速排序"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(7)/class23-%E9%9A%8F%E6%9C%BA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/partition%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3-%E6%94%B9%E8%BF%9B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="partition函数理解-改进快速排序"></p>
<h2 id="荷兰国旗问题优化版（推荐）"><a href="#荷兰国旗问题优化版（推荐）" class="headerlink" title="荷兰国旗问题优化版（推荐）"></a>荷兰国旗问题优化版（推荐）</h2><p>荷兰国旗问题是快速排序的重要优化，将数组分为三个区域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[小于x的区域] [等于x的区域] [大于x的区域]</span><br></pre></td></tr></table></figure>
<p>能够一次处理所有等于pivot的元素，递归层数大大降低，所以不会爆栈，每次把所有等于pivot的数都一次性放到中间，只对小于和大于pivot的区间递归</p>
<h3 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h3><ol>
<li><strong>一次性处理所有相等元素</strong>：将所有等于pivot的元素都放到正确位置</li>
<li><strong>减少递归层数</strong>：只需要对小于和大于pivot的区域递归</li>
<li><strong>避免栈溢出</strong>：特别适合处理有大量重复元素的数组</li>
</ol>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort2</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 随机这一下，常数时间比较大</span></span><br><span class="line">    <span class="comment"># 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">    x = arr[random.randint(l, r)]</span><br><span class="line">    partition2(l, r, x)</span><br><span class="line">    <span class="comment"># 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">    <span class="comment"># 这里用临时变量记录first、last</span></span><br><span class="line">    left = first[<span class="number">0</span>]</span><br><span class="line">    right = last[<span class="number">0</span>]</span><br><span class="line">    quickSort2(l, left - <span class="number">1</span>)</span><br><span class="line">    quickSort2(right + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 荷兰国旗问题</span></span><br><span class="line">first = [<span class="number">0</span>]  <span class="comment"># 用list模拟全局变量</span></span><br><span class="line">last = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"><span class="comment"># 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line"><span class="comment"># 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition2</span>(<span class="params">l, r, x</span>):</span><br><span class="line">    first[<span class="number">0</span>] = l</span><br><span class="line">    last[<span class="number">0</span>] = r</span><br><span class="line">    i = l</span><br><span class="line">    <span class="keyword">while</span> i &lt;= last[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> arr[i] == x:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[i] &lt; x:</span><br><span class="line">            swap(first[<span class="number">0</span>], i)</span><br><span class="line">            first[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            swap(i, last[<span class="number">0</span>])</span><br><span class="line">            last[<span class="number">0</span>] -= <span class="number">1</span> <span class="comment">#i不变的原因是交换后 i 位置上的新元素还没考察过</span></span><br><span class="line"><span class="comment">#前两种情况i++的原因是x作为基准，在i位置上，顶着左边区域向右推进，此外快速排序算法不需要随机元素的index</span></span><br></pre></td></tr></table></figure>

<h3 id="荷兰国旗问题详细演示"><a href="#荷兰国旗问题详细演示" class="headerlink" title="荷兰国旗问题详细演示"></a>荷兰国旗问题详细演示</h3><p>以数组 <code>[7, 2, 6, 3, 1, 5, 4]</code>，pivot&#x3D;3 为例：</p>
<p><strong>初始状态</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [7, 2, 6, 3, 1, 5, 4]</span><br><span class="line">first = 0, last = 6, i = 0</span><br></pre></td></tr></table></figure>

<p><strong>Step 1</strong>：<code>arr[0] = 7 &gt; 3</code></p>
<ul>
<li>与 <code>arr[6]</code> 交换：<code>[4, 2, 6, 3, 1, 5, 7]</code></li>
<li><code>last = 5</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 2</strong>：<code>arr[0] = 4 &gt; 3</code></p>
<ul>
<li>与 <code>arr[5]</code> 交换：<code>[5, 2, 6, 3, 1, 4, 7]</code></li>
<li><code>last = 4</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 3</strong>：<code>arr[0] = 5 &gt; 3</code></p>
<ul>
<li>与 <code>arr[4]</code> 交换：<code>[1, 2, 6, 3, 5, 4, 7]</code></li>
<li><code>last = 3</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 4</strong>：<code>arr[0] = 1 &lt; 3</code></p>
<ul>
<li>与 <code>arr[0]</code> 交换（自己）：不变</li>
<li><code>first = 1</code>，<code>i = 1</code></li>
</ul>
<p><strong>Step 5</strong>：<code>arr[1] = 2 &lt; 3</code></p>
<ul>
<li>与 <code>arr[1]</code> 交换（自己）：不变</li>
<li><code>first = 2</code>，<code>i = 2</code></li>
</ul>
<p><strong>Step 6</strong>：<code>arr[2] = 6 &gt; 3</code></p>
<ul>
<li>与 <code>arr[3]</code> 交换：<code>[1, 2, 3, 6, 5, 4, 7]</code></li>
<li><code>last = 2</code>，<code>i</code> 不变</li>
</ul>
<p><strong>Step 7</strong>：<code>arr[2] = 3 == 3</code></p>
<ul>
<li><code>i = 3</code>，此时 <code>i &gt; last</code>，循环结束</li>
</ul>
<p><strong>最终结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [1, 2, 3, 6, 5, 4, 7]</span><br><span class="line">[0, 1]: 小于3的区域 [1, 2]</span><br><span class="line">[2, 2]: 等于3的区域 [3]</span><br><span class="line">[3, 6]: 大于3的区域 [6, 5, 4, 7]</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="随机快速排序的复杂度"><a href="#随机快速排序的复杂度" class="headerlink" title="随机快速排序的复杂度"></a>随机快速排序的复杂度</h3><p><strong>时间复杂度：O(n log n)</strong> （期望）</p>
<ul>
<li>每层的划分操作需要O(n)时间</li>
<li>随机选择使得平均递归深度为O(log n)</li>
<li>总时间复杂度：O(n) × O(log n) &#x3D; O(n log n)</li>
</ul>
<p><strong>空间复杂度：O(log n)</strong> （期望）</p>
<ul>
<li>来自递归调用栈的深度</li>
<li>最好情况：每次平分，深度为O(log n)</li>
<li>最坏情况：退化为链式递归，深度为O(n)</li>
</ul>
<h3 id="与普通快速排序对比"><a href="#与普通快速排序对比" class="headerlink" title="与普通快速排序对比"></a>与普通快速排序对比</h3><p><strong>普通快速排序</strong></p>
<ul>
<li>普通快速排序的时间复杂度O(n^2)：固定流程考虑最坏情况（极端不平衡，每次都选到最小或最大元素为主元），每次只能划分出一个元素，剩下的 n-1 继续递归；额外空间复杂度O(n)取得是最坏情况递归的栈的深度。</li>
<li>最好情况：T(n) &#x3D; 2 * T(n&#x2F;2) + O(n) &#x3D; O(n * logn),空间是O(logn)取得是递归的栈的深度。</li>
<li>因为固定流程的话，可以构造出特定的数据，导致每次固定取最右最左的元素都是最差情况。</li>
</ul>
<p><strong>随机快速排序</strong></p>
<ul>
<li>随机快速排序，时间复杂度O(n * logn)随机取得是期望理论上每次能比较均匀划分为两半，递归深度约为 log𝑛，每一层的划分操作需要 O(n) 时间。额外空间复杂度O(logn)取得是递归的栈的深度，运气好每次都是区间二分，参考中序二叉树</li>
<li>取期望，每个位置取1&#x2F;N的权重，最后能证明期望时间复杂度是O(n * logn)，额外空间复杂度O(logn)</li>
<li>关于复杂度的分析，进行定性的说明，定量证明略，因为证明较为复杂，算法导论-7.4.2有详细证明</li>
</ul>
<table>
<thead>
<tr>
<th>算法类型</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>空间复杂度（平均）</th>
<th>空间复杂度（最坏）</th>
</tr>
</thead>
<tbody><tr>
<td>普通快排</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>随机快排</td>
<td>O(n log n)</td>
<td>O(n log n)*</td>
<td>O(log n)</td>
<td>O(log n)*</td>
</tr>
</tbody></table>
<p>*期望意义下</p>
<h1 id="024【必备】随机选择算法"><a href="#024【必备】随机选择算法" class="headerlink" title="024【必备】随机选择算法"></a>024【必备】随机选择算法</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>无序数组中第K大的元素问题</strong>：</p>
<ul>
<li>给定整数数组 <code>nums</code> 和整数 <code>k</code></li>
<li>返回数组中第 <code>k</code> 个最大的元素</li>
<li>要求时间复杂度为 O(n)</li>
</ul>
<p><strong>关键转换</strong>：第K大 &#x3D; 第(len-k)小（python中）。事实上，若下标从0开始时，第K大等于第(len-k)小（即下标为len-k的元素）；如果下标从1开始，则用len+1-k</p>
<h2 id="随机选择算法原理"><a href="#随机选择算法原理" class="headerlink" title="随机选择算法原理"></a>随机选择算法原理</h2><p>随机选择算法是快速排序的变种，核心思想：</p>
<ol>
<li><strong>只关心目标位置</strong>：不需要完全排序，只需要找到第K大的元素</li>
<li><strong>单侧递归</strong>：每次只需要在包含目标位置的一侧继续查找</li>
<li><strong>随机化优化</strong>：通过随机选择pivot避免最坏情况</li>
</ol>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSelect</span>:</span><br><span class="line">    first = <span class="number">0</span>  <span class="comment"># 等于区域的左边界</span></span><br><span class="line">    last = <span class="number">0</span>   <span class="comment"># 等于区域的右边界</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找第K大元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 转换为找第(len-k)小的元素</span></span><br><span class="line">        <span class="keyword">return</span> RandomizedSelect.randomizedSelect(nums, <span class="built_in">len</span>(nums) - k)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomizedSelect</span>(<span class="params">arr, i</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        连递归都没用，所以时间复杂度是O(n)左右的量级</span></span><br><span class="line"><span class="string">        在数组中找到如果排序后在位置i的元素</span></span><br><span class="line"><span class="string">        时间复杂度：O(n)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:<span class="comment">#不断二分的过程中，l和r上是仍然有范围的，直到没有范围才终止</span></span><br><span class="line">            <span class="comment"># 随机这一下，常数时间比较大</span></span><br><span class="line">            <span class="comment"># 但只有这一下随机，才能在概率上把时间复杂度收敛到O(n)</span></span><br><span class="line">            pivot = arr[l + <span class="built_in">int</span>(random.random() * (r - l + <span class="number">1</span>))]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用荷兰国旗问题进行划分</span></span><br><span class="line">            RandomizedSelect.partition(arr, l, r, pivot)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 因为左右两侧只需要走一侧</span></span><br><span class="line">            <span class="comment"># 所以不需要临时变量记录全局的first、last，直接用即可</span></span><br><span class="line">            <span class="comment"># 等于的区域即first，last包住的位置，i小于first则去左侧，i大于last则去右侧</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; RandomizedSelect.first:</span><br><span class="line">                r = RandomizedSelect.first - <span class="number">1</span>  <span class="comment"># 目标在左侧，pivot左边变成r</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; RandomizedSelect.last:</span><br><span class="line">                l = RandomizedSelect.last + <span class="number">1</span>   <span class="comment"># 目标在右侧，pivot右边变成l</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = arr[i]  <span class="comment"># 找到目标</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, l, r, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;荷兰国旗问题划分&quot;&quot;&quot;</span></span><br><span class="line">        RandomizedSelect.first = l</span><br><span class="line">        RandomizedSelect.last = r</span><br><span class="line">        i = l</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt;= RandomizedSelect.last:</span><br><span class="line">            <span class="keyword">if</span> arr[i] == x:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i] &lt; x:</span><br><span class="line">                RandomizedSelect.swap(arr, RandomizedSelect.first, i)</span><br><span class="line">                RandomizedSelect.first += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                RandomizedSelect.swap(arr, i, RandomizedSelect.last)</span><br><span class="line">                RandomizedSelect.last -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;交换数组元素&quot;&quot;&quot;</span></span><br><span class="line">        arr[i], arr[j] = arr[j], arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="算法执行示例"><a href="#算法执行示例" class="headerlink" title="算法执行示例"></a>算法执行示例</h2><p>以数组 <code>[7, 2, 6, 3, 1, 5, 4]</code>，查找第4小元素（下标为3）为例：</p>
<p><strong>第一轮</strong>：</p>
<ul>
<li>随机选择 <code>pivot = 3</code></li>
<li>划分后：<code>[1, 2, 3, 6, 5, 4, 7]</code></li>
<li>等于区域：<code>first = 2, last = 2</code></li>
<li>目标下标3 &gt; last&#x3D;2，继续在右侧 <code>[6, 5, 4, 7]</code> 查找</li>
</ul>
<p><strong>第二轮</strong>：</p>
<ul>
<li>在右侧区域随机选择 <code>pivot = 4</code></li>
<li>划分后相对位置：<code>[4, 5, 6, 7]</code>（实际在原数组的3,4,5,6位置）</li>
<li>等于区域：<code>first = 3, last = 3</code></li>
<li>目标下标3 &#x3D;&#x3D; first &#x3D;&#x3D; last，找到答案 <code>arr[3] = 4</code></li>
</ul>
<h2 id="时间复杂度证明（定性分析）"><a href="#时间复杂度证明（定性分析）" class="headerlink" title="时间复杂度证明（定性分析）"></a>时间复杂度证明（定性分析）</h2><p><strong>为什么是O(n)？</strong></p>
<p>每次划分后，下一次只需要处理一侧的数据：</p>
<ul>
<li>第一次处理：n个元素</li>
<li>第二次处理：n&#x2F;2个元素（期望）</li>
<li>第三次处理：n&#x2F;4个元素（期望）</li>
<li>…</li>
</ul>
<p>总时间：<code>n + n/2 + n/4 + n/8 + ... ≈ 2n</code></p>
<p>因此期望时间复杂度为 <strong>O(n)</strong>。</p>
<h2 id="与其他算法的比较"><a href="#与其他算法的比较" class="headerlink" title="与其他算法的比较"></a>与其他算法的比较</h2><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>完全排序</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>简单但过度</td>
</tr>
<tr>
<td>堆排序K次</td>
<td>O(n + k log n)</td>
<td>O(1)</td>
<td>适合K很小的情况</td>
</tr>
<tr>
<td>随机选择</td>
<td>O(n)</td>
<td>O(1)</td>
<td>最优解</td>
</tr>
<tr>
<td>BFPRT算法</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>理论最优但常数大</td>
</tr>
</tbody></table>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ol>
<li><strong>Top-K问题</strong>：找出数组中最大&#x2F;最小的K个元素</li>
<li><strong>中位数查找</strong>：快速找到数组的中位数</li>
<li><strong>分位数计算</strong>：统计学中的百分位数计算</li>
<li><strong>数据分析</strong>：快速找到数据集中的特定排名元素</li>
</ol>
<h3 id="关键要点总结"><a href="#关键要点总结" class="headerlink" title="关键要点总结"></a>关键要点总结</h3><ol>
<li><p><strong>随机化的重要性</strong>：</p>
<ul>
<li>避免最坏情况的发生</li>
<li>使算法在期望意义下达到最优复杂度</li>
</ul>
</li>
<li><p><strong>荷兰国旗问题的优势</strong>：</p>
<ul>
<li>一次性处理所有相等元素</li>
<li>减少递归&#x2F;迭代次数</li>
<li>提高算法稳定性</li>
</ul>
</li>
<li><p><strong>单侧处理的效率</strong>：</p>
<ul>
<li>与完全排序不同，只需要处理包含目标的一侧</li>
<li>大大减少了计算量</li>
</ul>
</li>
<li><p><strong>工程实践建议</strong>：</p>
<ul>
<li>对于一般规模的数据，随机选择算法是首选</li>
<li>当需要多次查询不同K值时，可以考虑先排序</li>
<li>在对稳定性要求极高的场合，可以考虑BFPRT算法</li>
</ul>
</li>
</ol>
<p>这两个算法（随机快速排序和随机选择）是分治算法的经典应用，展示了随机化在算法设计中的重要作用。掌握这些算法不仅有助于解决实际问题，也为理解更复杂的分治算法奠定了基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（6）- 递归、归并排序与归并分治</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-06 08:42:46" itemprop="dateCreated datePublished" datetime="2025-08-06T08:42:46+08:00">2025-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-07 14:18:07" itemprop="dateModified" datetime="2025-08-07T14:18:07+08:00">2025-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a>  </p>
<p>记录的是class020→class022，包括了递归的本质理解、Master公式的应用、归并排序的递归与非递归实现，以及归并分治思想在解决小和问题和翻转对问题中的应用。</p>
<h1 id="020【必备】递归和Master公式"><a href="#020【必备】递归和Master公式" class="headerlink" title="020【必备】递归和Master公式"></a>020【必备】递归和Master公式</h1><h2 id="递归的本质理解"><a href="#递归的本质理解" class="headerlink" title="递归的本质理解"></a>递归的本质理解</h2><h3 id="思想层面的递归"><a href="#思想层面的递归" class="headerlink" title="思想层面的递归"></a>思想层面的递归</h3><p>递归不是玄学，它是一种**”大事化小”**的思维方式。对于新手来说，<strong>画调用图</strong>是理解递归的关键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;给定一个数组，在arr[l...r]范围上，返回最大值&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> f(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arr, l, r</span>):</span><br><span class="line">    <span class="comment"># arr[l...r] 范围上的最大值</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="comment"># 递归基：当左右下标相等时，区间只有一个数，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[l]</span><br><span class="line">    m = (l + r) // <span class="number">2</span>  <span class="comment"># 找到中点</span></span><br><span class="line">    lmax = f(arr, l, m)        <span class="comment"># 递归求左半部分最大值</span></span><br><span class="line">    rmax = f(arr, m + <span class="number">1</span>, r)    <span class="comment"># 递归求右半部分最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(lmax, rmax)     <span class="comment"># 返回左右部分的最大值</span></span><br></pre></td></tr></table></figure>

<p><strong>递归的三个关键点</strong>：</p>
<ol>
<li><strong>明确递归要干什么</strong>：这里是”返回 arr[l…r] 的最大值”</li>
<li><strong>找递归的终止条件</strong>：这里是”l &#x3D;&#x3D; r”，即区间只有一个数  </li>
<li><strong>思考如何缩小规模</strong>：这里是分别递归处理左区间和右区间</li>
</ol>
<h3 id="实际层面的递归"><a href="#实际层面的递归" class="headerlink" title="实际层面的递归"></a>实际层面的递归</h3><p>递归底层利用<strong>系统栈</strong>来实现：</p>
<ul>
<li>当函数调用发生时，系统会将函数的状态（参数、局部变量、返回地址）压入栈中</li>
<li>当函数返回时，系统从栈中弹出状态，恢复到调用点继续执行</li>
<li>这个过程是<strong>可视化的</strong>，所以所有递归函数都可以改成非递归</li>
</ul>
<p><strong>递归改非递归的必要性</strong>：</p>
<ul>
<li><strong>工程实践</strong>：几乎一定要改，除非确定递归深度不会太大</li>
<li><strong>算法竞赛</strong>：能通过就不改，时间紧迫时优先保证正确性</li>
</ul>
<p><strong>形象比喻</strong>：</p>
<ul>
<li><strong>迭代</strong>像是擂台赛：一个个来，逐步解决</li>
<li><strong>递归</strong>像是季后赛：分组对战，逐层淘汰<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E5%88%86%E6%AD%A5.png" alt="递归过程分步"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E9%80%92%E5%BD%92%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="递归时的数据结构"></li>
</ul>
<h2 id="Master公式详解"><a href="#Master公式详解" class="headerlink" title="Master公式详解"></a>Master公式详解</h2><p>Master公式用于分析<strong>分治算法</strong>的时间复杂度，适用于所有子问题规模相同的递归。</p>
<h3 id="公式形式"><a href="#公式形式" class="headerlink" title="公式形式"></a>公式形式</h3><p>$$T(n) &#x3D; a \times T(\frac{n}{b}) + O(n^c)$$</p>
<p>其中：</p>
<ul>
<li><strong>a</strong>：子问题被调用的次数</li>
<li><strong>b</strong>：子问题规模（数据量变为原来的1&#x2F;b）  </li>
<li><strong>c</strong>：除去子问题之外的时间复杂度指数</li>
</ul>
<h3 id="判断标准"><a href="#判断标准" class="headerlink" title="判断标准"></a>判断标准</h3><p>设 $\log_b(a) &#x3D; d$，则：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$d &lt; c$</td>
<td>$O(n^c)$</td>
<td>合并工作量占主导</td>
</tr>
<tr>
<td>$d &gt; c$</td>
<td>$O(n^d)$</td>
<td>递归调用占主导</td>
</tr>
<tr>
<td>$d &#x3D; c$</td>
<td>$O(n^c \log n)$</td>
<td>两者平衡</td>
</tr>
</tbody></table>
<h3 id="经典例子分析"><a href="#经典例子分析" class="headerlink" title="经典例子分析"></a>经典例子分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序：T(n) = 2*T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"># a=2, b=2, c=1</span></span><br><span class="line"><span class="comment"># log₂(2) = 1 = c，所以复杂度为 O(n*logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找：T(n) = 1*T(n/2) + O(1)  </span></span><br><span class="line"><span class="comment"># a=1, b=2, c=0</span></span><br><span class="line"><span class="comment"># log₂(1) = 0 = c，所以复杂度为 O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速排序最好情况：T(n) = 2*T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"># 结果同归并排序：O(n*logn)</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>对于 $T(n) &#x3D; 2 \times T(\frac{n}{2}) + O(n \log n)$：</p>
<ul>
<li>这不符合标准Master公式形式，结果是 $O(n \times (\log n)^2)$，需要特殊记忆，证明过程较复杂，这种递归式常见于“分治 + 合并时需要二分&#x2F;复杂统计”的问题，比如“翻转对”、“区间对统计”，主定理告知其复杂度为 $O(n \log^2 n)$</li>
</ul>
<h1 id="021【必备】归并排序"><a href="#021【必备】归并排序" class="headerlink" title="021【必备】归并排序"></a>021【必备】归并排序</h1><h2 id="归并排序原理"><a href="#归并排序原理" class="headerlink" title="归并排序原理"></a>归并排序原理</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li><strong>左部分排好序、右部分排好序</strong></li>
<li><strong>利用merge过程让左右整体有序</strong></li>
<li><strong>merge过程</strong>：谁小拷贝谁，直到左右两部分数字耗尽，拷贝回原数组</li>
</ol>
<h3 id="为什么归并排序比O-n²-排序快？"><a href="#为什么归并排序比O-n²-排序快？" class="headerlink" title="为什么归并排序比O(n²)排序快？"></a>为什么归并排序比O(n²)排序快？</h3><p><strong>比较行为没有浪费！</strong></p>
<p>对比三种原始排序（选择、冒泡、插入）：</p>
<ul>
<li>每次1到N-1次比较只能确定一个位置</li>
<li>大量比较工作被浪费，效率低下</li>
</ul>
<p>归并排序中：</p>
<ul>
<li>每次比较都有意义，用于合并两个有序序列</li>
<li>比较结果被充分利用，没有浪费</li>
<li>系统栈不会太深</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%88%E4%B8%8D%E4%BC%9A%E6%B7%B1.png" alt="归并排序的栈不会深"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class20-%E9%80%92%E5%BD%92%E5%92%8Cmaster%E5%85%AC%E5%BC%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%88%E4%B8%8D%E4%BC%9A%E6%B7%B12.png" alt="归并排序的栈不会深2"></p>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a></p>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">MAXN = <span class="number">100001</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXN      <span class="comment"># 原数组</span></span><br><span class="line">help_arr = [<span class="number">0</span>] * MAXN <span class="comment"># 辅助数组</span></span><br><span class="line">n = <span class="number">0</span>                 <span class="comment"># 数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort1</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序递归版</span></span><br><span class="line"><span class="string">    T(n) = 2 * T(n/2) + O(n)</span></span><br><span class="line"><span class="string">    根据master公式，时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    空间复杂度O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:  <span class="comment"># 递归终止条件：只剩一个元素</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    mergeSort1(l, m)      <span class="comment"># 递归排序左半部分</span></span><br><span class="line">    mergeSort1(m + <span class="number">1</span>, r)  <span class="comment"># 递归排序右半部分</span></span><br><span class="line">    merge(l, m, r)        <span class="comment"># 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个有序区间 arr[l...m] 和 arr[m+1...r]</span></span><br><span class="line"><span class="string">    时间复杂度O(n)，其中n = r - l + 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = l      <span class="comment"># help数组写指针</span></span><br><span class="line">    a = l      <span class="comment"># 左侧起始指针</span></span><br><span class="line">    b = m + <span class="number">1</span>  <span class="comment"># 右侧起始指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双指针合并过程</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b] </span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 写回原数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[i] = help_arr[i]</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    归并排序非递归版</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)：外层循环O(logn)，内层归并O(n)</span></span><br><span class="line"><span class="string">    空间复杂度O(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    step = <span class="number">1</span>  <span class="comment"># 步长初始化为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> step &lt; n:  <span class="comment"># 外层控制步长，共O(logn)次</span></span><br><span class="line">        l = <span class="number">0</span>  <span class="comment"># 每轮从左端开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt; n:  <span class="comment"># 内层处理每一组</span></span><br><span class="line">            m = l + step - <span class="number">1</span>      <span class="comment"># 计算中点</span></span><br><span class="line">            <span class="keyword">if</span> m + <span class="number">1</span> &gt;= n:        <span class="comment"># 右半部分越界，跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            r = <span class="built_in">min</span>(l + (step &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, n - <span class="number">1</span>)  <span class="comment"># 计算右边界</span></span><br><span class="line">            merge(l, m, r)        <span class="comment"># 合并</span></span><br><span class="line">            l = r + <span class="number">1</span>             <span class="comment"># 移动到下一组</span></span><br><span class="line">            </span><br><span class="line">        step &lt;&lt;= <span class="number">1</span>  <span class="comment"># 步长翻倍</span></span><br></pre></td></tr></table></figure>

<h3 id="非递归实现的核心思路"><a href="#非递归实现的核心思路" class="headerlink" title="非递归实现的核心思路"></a>非递归实现的核心思路</h3><ol>
<li><strong>step表示每次要合并的有序段长度</strong>，初始为1（每个元素自己是有序段）</li>
<li><strong>每一轮成对合并</strong>长度为step的有序段，合并成长度为2*step的有序段</li>
<li><strong>下一轮step翻倍</strong>，继续两两合并</li>
<li><strong>重复直到step &gt;&#x3D; n</strong>，整个数组有序</li>
</ol>
<p><strong>过程示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数组: [3, 8, 7, 6, 4, 5, 1, 2]</span><br><span class="line"></span><br><span class="line">step=1: [3,8] [6,7] [4,5] [1,2] → [3,8,6,7,4,5,1,2]</span><br><span class="line">step=2: [3,6,7,8] [1,2,4,5] → [3,6,7,8,1,2,4,5] </span><br><span class="line">step=4: [1,2,3,4,5,6,7,8] → [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure>

<h2 id="merge过程详解"><a href="#merge过程详解" class="headerlink" title="merge过程详解"></a>merge过程详解</h2><h3 id="双指针合并策略"><a href="#双指针合并策略" class="headerlink" title="双指针合并策略"></a>双指针合并策略</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并过程详解：</span></span><br><span class="line"><span class="string">    1. 双指针扫描：a指向左部分，b指向右部分</span></span><br><span class="line"><span class="string">    2. 比较合并：较小值写入help_arr，对应指针右移</span></span><br><span class="line"><span class="string">    3. 剩余处理：一边扫完后，另一边直接复制</span></span><br><span class="line"><span class="string">    4. 写回原数组：完成排序合并</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = l      <span class="comment"># help_arr写入位置</span></span><br><span class="line">    a = l      <span class="comment"># 左部分起点</span></span><br><span class="line">    b = m + <span class="number">1</span>  <span class="comment"># 右部分起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 两两比较，选择较小值</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余元素（必有一边先结束）</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-log-n"><a href="#时间复杂度：O-n-log-n" class="headerlink" title="时间复杂度：O(n log n)"></a>时间复杂度：O(n log n)</h3><ul>
<li><strong>递归层数</strong>：log₂(n)层，每次将问题规模减半</li>
<li><strong>每层工作量</strong>：O(n)，所有元素都要参与一次合并</li>
<li><strong>总复杂度</strong>：O(n) × O(log n) &#x3D; O(n log n)</li>
</ul>
<h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O(n)"></a>空间复杂度：O(n)</h3><ul>
<li><strong>辅助数组</strong>：需要与原数组等长的help_arr</li>
<li><strong>递归栈</strong>：最大深度O(log n)，但主要空间开销是辅助数组</li>
<li><strong>原地归并</strong>：理论上可以做到O(1)空间，但时间复杂度会退化到O(n²)</li>
</ul>
<h1 id="022【必备】归并分治"><a href="#022【必备】归并分治" class="headerlink" title="022【必备】归并分治"></a>022【必备】归并分治</h1><h2 id="归并分治的核心思想"><a href="#归并分治的核心思想" class="headerlink" title="归并分治的核心思想"></a>归并分治的核心思想</h2><p>归并分治是在归并排序基础上的拓展，用来解决更复杂的问题。</p>
<h3 id="应用条件判断"><a href="#应用条件判断" class="headerlink" title="应用条件判断"></a>应用条件判断</h3><p>一个问题能用归并分治解决，需要满足：</p>
<ol>
<li><strong>大范围答案 &#x3D; 左部分答案 + 右部分答案 + 跨越左右产生的答案</strong></li>
<li><strong>计算”跨越左右产生的答案”时，左右各自有序能带来计算便利性</strong></li>
<li><strong>如果以上两点成立，该问题很可能被归并分治解决</strong></li>
</ol>
<p><strong>求解过程</strong>：在归并排序过程中加入统计逻辑，利用左右有序的特性获得计算便利性。</p>
<h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定数组arr，对于每个位置i，求出其左边所有小于等于arr[i]的数的累加和，所有位置的累加和即为数组的”小和”。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组: [1, 3, 5, 2, 4, 6]</span><br><span class="line"></span><br><span class="line">位置0(1): 左边小于等于1的数 → 0</span><br><span class="line">位置1(3): 左边小于等于3的数 → 1  </span><br><span class="line">位置2(5): 左边小于等于5的数 → 1+3 = 4</span><br><span class="line">位置3(2): 左边小于等于2的数 → 1</span><br><span class="line">位置4(4): 左边小于等于4的数 → 1+3+2 = 6</span><br><span class="line">位置5(6): 左边小于等于6的数 → 1+3+5+2+4 = 15</span><br><span class="line"></span><br><span class="line">小和 = 0+1+4+1+6+15 = 27</span><br></pre></td></tr></table></figure>


<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class22-%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/%E5%88%86%E6%B2%BB%E6%8C%87%E9%92%88%E6%BB%91%E5%8A%A8.png" alt="分治指针滑动"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(6)/class22-%E5%BD%92%E5%B9%B6%E5%88%86%E6%B2%BB/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%E6%8B%86%E5%88%86%E6%88%90%E5%AD%90%E9%97%AE%E9%A2%98.png" alt="小和问题拆分成子问题"></p>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469">https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469</a></p>
<h3 id="归并分治解法"><a href="#归并分治解法" class="headerlink" title="归并分治解法"></a>归并分治解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">smallSum</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回arr[l...r]范围上小和的累加和，同时让arr[l..r]变有序</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 递归统计左右部分和跨区部分的小和</span></span><br><span class="line">    <span class="keyword">return</span> smallSum(l, m) + smallSum(m + <span class="number">1</span>, r) + merge(l, m, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    统计跨左右产生的小和，同时完成合并</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span>        <span class="comment"># 累计小和</span></span><br><span class="line">    i = l          <span class="comment"># 左侧指针</span></span><br><span class="line">    sum_left = <span class="number">0</span>   <span class="comment"># 累计左侧小于等于当前右侧元素的和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计跨区贡献：对每个右侧元素，统计左侧贡献</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 左侧所有 &lt;= arr[j] 的元素都对arr[j]有贡献</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= m <span class="keyword">and</span> arr[i] &lt;= arr[j]:</span><br><span class="line">            sum_left += arr[i]  <span class="comment"># 累加左侧贡献</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans += sum_left  <span class="comment"># arr[j]的左侧贡献总和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常归并过程</span></span><br><span class="line">    i = l</span><br><span class="line">    a = l</span><br><span class="line">    b = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法关键思路"><a href="#算法关键思路" class="headerlink" title="算法关键思路"></a>算法关键思路</h3><p><strong>为什么要在merge过程中统计？</strong></p>
<ol>
<li><strong>左右有序的便利性</strong>：因为左右都有序，可以用双指针线性扫描</li>
<li><strong>避免重复计算</strong>：每个跨区的小和贡献只需要计算一次</li>
<li><strong>时间复杂度优势</strong>：总体保持O(n log n)，而暴力解法是O(n²)</li>
</ol>
<p><strong>核心技巧</strong>：</p>
<ul>
<li>对于右半部分的每个元素arr[j]，左半部分所有 ≤ arr[j] 的元素都会对小和产生贡献</li>
<li>由于左半部分有序，可以用指针i从左向右扫描，累加贡献值</li>
<li>指针i只会前进不会后退，总的扫描时间为O(n)</li>
</ul>
<h2 id="翻转对问题"><a href="#翻转对问题" class="headerlink" title="翻转对问题"></a>翻转对问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定数组nums，如果i&lt;j且nums[i]&gt;2*nums[j]，我们就将(i,j)称作一个重要翻转对。求数组中翻转对的总数量。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组: [1,3,2,3,1]</span><br><span class="line">翻转对: (1,4)→3&gt;2*1, (3,4)→3&gt;2*1</span><br><span class="line">答案: 2</span><br></pre></td></tr></table></figure>
<p> <strong>测试链接</strong> ：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-pairs/">https://leetcode.cn/problems/reverse-pairs/</a></p>
<h3 id="归并分治解法-1"><a href="#归并分治解法-1" class="headerlink" title="归并分治解法"></a>归并分治解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计翻转对的主函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> counts(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counts</span>(<span class="params">arr, l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    统计l...r范围上翻转对的数量，同时让l...r范围变有序</span></span><br><span class="line"><span class="string">    时间复杂度O(n * logn)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 递归统计左右两边和跨区部分的翻转对数量</span></span><br><span class="line">    <span class="keyword">return</span> counts(arr, l, m) + counts(arr, m + <span class="number">1</span>, r) + merge(arr, l, m, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, l, m, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计跨区翻转对并完成合并&quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 翻转对计数</span></span><br><span class="line">    j = m + <span class="number">1</span>  <span class="comment"># 右边数组起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计跨区翻转对</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, m + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 找到右侧第一个不满足 arr[i] &gt; 2*arr[j] 的位置</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= r <span class="keyword">and</span> arr[i] &gt; <span class="number">2</span> * arr[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当前i能形成的翻转对数量 = j - (m+1)</span></span><br><span class="line">        ans += j - m - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正常merge过程（与归并排序相同）</span></span><br><span class="line">    i = l</span><br><span class="line">    a = l</span><br><span class="line">    b = m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m <span class="keyword">and</span> b &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arr[a] &lt;= arr[b]:</span><br><span class="line">            help_arr[i] = arr[a]</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            help_arr[i] = arr[b]</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= m:</span><br><span class="line">        help_arr[i] = arr[a]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt;= r:</span><br><span class="line">        help_arr[i] = arr[b]</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        arr[idx] = help_arr[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="算法关键思路-1"><a href="#算法关键思路-1" class="headerlink" title="算法关键思路"></a>算法关键思路</h3><p><strong>统计策略</strong>：</p>
<ol>
<li><strong>利用左右部分独立有序</strong>：对于左半部分的每个元素arr[i]，在右半部分找到满足arr[i] &gt; 2*arr[j]的所有j</li>
<li><strong>指针单向移动</strong>：左右部分都是有序的，指针j只需要前进，不需要回退  </li>
<li><strong>计数技巧</strong>：当找到第一个不满足条件的j时，说明j前面的所有元素都满足条件</li>
</ol>
<p><strong>时间复杂度分析</strong>：</p>
<ul>
<li>每个元素只会被访问一次，总的统计时间：O(n)，符合归并分治的要求</li>
</ul>
<h2 id="归并分治总结"><a href="#归并分治总结" class="headerlink" title="归并分治总结"></a>归并分治总结</h2><h3 id="适用问题特征"><a href="#适用问题特征" class="headerlink" title="适用问题特征"></a>适用问题特征</h3><ol>
<li><strong>可分解性</strong>：问题可以分解为左部分 + 右部分 + 跨区部分</li>
<li><strong>有序性便利</strong>：跨区部分的计算在左右有序时能够优化</li>
<li><strong>线性合并</strong>：跨区计算的时间复杂度为O(n)</li>
</ol>
<h3 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide_conquer</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span> base_case</span><br><span class="line">    </span><br><span class="line">    m = (l + r) // <span class="number">2</span></span><br><span class="line">    left_ans = divide_conquer(l, m)</span><br><span class="line">    right_ans = divide_conquer(m + <span class="number">1</span>, r)</span><br><span class="line">    cross_ans = merge_and_count(l, m, r)  <span class="comment"># 关键：统计跨区答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left_ans + right_ans + cross_ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_and_count</span>(<span class="params">l, m, r</span>):</span><br><span class="line">    <span class="comment"># 1. 利用左右有序性，统计跨区答案</span></span><br><span class="line">    cross_count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># ... 统计逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 正常的归并排序merge过程</span></span><br><span class="line">    <span class="comment"># ... 合并逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cross_count</span><br></pre></td></tr></table></figure>

<h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h3><ol>
<li><strong>小和问题</strong>：统计左侧小于等于当前元素的累加和</li>
<li><strong>翻转对问题</strong>：统计满足特定大小关系的数对</li>
<li><strong>最近点对问题</strong>：二维空间中最近两点距离（高难度）</li>
<li><strong>逆序对问题</strong>：统计数组中的逆序对数量</li>
</ol>
<h3 id="与其他算法的关系"><a href="#与其他算法的关系" class="headerlink" title="与其他算法的关系"></a>与其他算法的关系</h3><ul>
<li><strong>线段树</strong>：也可以解决类似问题，但常数因子可能更大</li>
<li><strong>树状数组</strong>：适合在线查询修改，离线场景下归并分治更简洁</li>
<li><strong>分块算法</strong>：另一种分治思想，将在后续课程中介绍</li>
</ul>
<p>归并分治是一种优雅而强大的算法思想，它将复杂问题通过分治和有序性的结合，优雅地降低了时间复杂度。掌握这种思想对于解决许多看似困难的问题都有很大帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（5）- 算法笔试中处理输入和输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-08-05 08:42:46 / Modified: 16:37:24" itemprop="dateCreated datePublished" datetime="2025-08-05T08:42:46+08:00">2025-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a></p>
<p>是class019的内容，本笔记重点介绍Python在算法竞赛和笔试中的高效输入输出处理技巧，包含子矩阵最大累加和问题的完整实现，以及与Java的性能对比分析。</p>
<h1 id="019【必备】算法笔试中处理输入和输出"><a href="#019【必备】算法笔试中处理输入和输出" class="headerlink" title="019【必备】算法笔试中处理输入和输出"></a>019【必备】算法笔试中处理输入和输出</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在算法竞赛和大厂笔试中，输入输出的处理效率往往是程序性能的关键瓶颈。Python虽然在执行速度上不如C++和Java，但通过合理的IO优化技巧，同样可以在大多数场景下取得良好的性能表现。</p>
<h3 id="Python-vs-Java-IO性能对比"><a href="#Python-vs-Java-IO性能对比" class="headerlink" title="Python vs Java IO性能对比"></a>Python vs Java IO性能对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Python</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认IO</strong></td>
<td><code>input()</code>、<code>print()</code> 较慢</td>
<td><code>Scanner</code>、<code>System.out</code> 较慢</td>
</tr>
<tr>
<td><strong>高效IO</strong></td>
<td><code>sys.stdin.read()</code>、批量输出</td>
<td><code>BufferedReader</code>、<code>PrintWriter</code></td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>自动垃圾回收，相对简单</td>
<td>需要考虑静态空间分配</td>
</tr>
<tr>
<td><strong>大整数</strong></td>
<td>原生支持任意精度</td>
<td>需要<code>BigInteger</code>类</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>语法简洁，容易上手</td>
<td>类型安全，但代码较长</td>
</tr>
</tbody></table>
<h2 id="Python编程风格选择"><a href="#Python编程风格选择" class="headerlink" title="Python编程风格选择"></a>Python编程风格选择</h2><h3 id="填函数风格（OJ平台推荐）"><a href="#填函数风格（OJ平台推荐）" class="headerlink" title="填函数风格（OJ平台推荐）"></a>填函数风格（OJ平台推荐）</h3><p>适用于LeetCode、牛客网等在线判题平台，平台会自动处理输入输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfSubMatrix</span>(<span class="params">self, mat, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        只需实现核心算法逻辑</span></span><br><span class="line"><span class="string">        平台自动调用并验证结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.maxSumSubmatrix(mat, n, n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubmatrix</span>(<span class="params">self, mat, rows, cols</span>):</span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            arr = [<span class="number">0</span>] * cols  <span class="comment"># 辅助数组</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, rows):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                    arr[k] += mat[j][k]</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, <span class="variable language_">self</span>.maxSumSubarray(arr))</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubarray</span>(<span class="params">self, arr</span>):</span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            cur += num</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, cur)</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, <span class="number">0</span>)  <span class="comment"># 负数时重置为0</span></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<h3 id="ACM风格（竞赛笔试推荐）"><a href="#ACM风格（竞赛笔试推荐）" class="headerlink" title="ACM风格（竞赛笔试推荐）"></a>ACM风格（竞赛笔试推荐）</h3><p>适用于ACM竞赛、大厂笔试等需要自己处理输入输出的场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    完整的输入输出处理</span></span><br><span class="line"><span class="string">    需要自己解析数据格式</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines = sys.stdin.read().split()</span><br><span class="line">    ptr = <span class="number">0</span></span><br><span class="line">    output = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ptr &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">        n = <span class="built_in">int</span>(lines[ptr])</span><br><span class="line">        ptr += <span class="number">1</span></span><br><span class="line">        m = <span class="built_in">int</span>(lines[ptr])</span><br><span class="line">        ptr += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建矩阵</span></span><br><span class="line">        mat = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            row = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                row.append(<span class="built_in">int</span>(lines[ptr]))</span><br><span class="line">                ptr += <span class="number">1</span></span><br><span class="line">            mat.append(row)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算结果</span></span><br><span class="line">        result = maxSumSubmatrix(mat, n, m)</span><br><span class="line">        output.append(<span class="built_in">str</span>(result))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量输出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(output))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="高效输入输出技巧"><a href="#高效输入输出技巧" class="headerlink" title="高效输入输出技巧"></a>高效输入输出技巧</h2><h3 id="输入优化策略"><a href="#输入优化策略" class="headerlink" title="输入优化策略"></a>输入优化策略</h3><h4 id="推荐：一次性读取大数据"><a href="#推荐：一次性读取大数据" class="headerlink" title="推荐：一次性读取大数据"></a>推荐：一次性读取大数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最高效：适用于已知数据量的场景</span></span><br><span class="line">lines = sys.stdin.read().split()</span><br><span class="line">ptr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐个解析数据</span></span><br><span class="line"><span class="keyword">while</span> ptr &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">    n = <span class="built_in">int</span>(lines[ptr])</span><br><span class="line">    ptr += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 处理数据...</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li>IO次数最少，效率最高</li>
<li>相当于Java的<code>BufferedReader</code>一次性读取</li>
<li>适合大数据量场景</li>
</ul>
<h4 id="可选：按行读取"><a href="#可选：按行读取" class="headerlink" title="可选：按行读取"></a>可选：按行读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用：需要按行处理不同格式数据</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    parts = line.strip().split()</span><br><span class="line">    total = <span class="built_in">sum</span>(<span class="built_in">int</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> parts)</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>每行数据格式不同</li>
<li>无法提前确定数据量</li>
<li>相当于Java的逐行<code>readLine()</code></li>
</ul>
<h4 id="不推荐：频繁调用input"><a href="#不推荐：频繁调用input" class="headerlink" title="不推荐：频繁调用input()"></a>不推荐：频繁调用input()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 效率低：类似Java的Scanner</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 大数据时很慢</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 每次都要系统调用</span></span><br></pre></td></tr></table></figure>

<h3 id="输出优化策略"><a href="#输出优化策略" class="headerlink" title="输出优化策略"></a>输出优化策略</h3><h4 id="推荐：批量输出"><a href="#推荐：批量输出" class="headerlink" title="推荐：批量输出"></a>推荐：批量输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 收集所有结果，最后一次性输出</span></span><br><span class="line">output = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    result = solve(data[i])</span><br><span class="line">    output.append(<span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(output))  <span class="comment"># 一次性输出</span></span><br></pre></td></tr></table></figure>

<h4 id="不推荐：频繁print"><a href="#不推荐：频繁print" class="headerlink" title="不推荐：频繁print()"></a>不推荐：频繁print()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次print都会刷新缓冲区，效率低</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">print</span>(solve(data[i]))  <span class="comment"># 大数据时很慢</span></span><br></pre></td></tr></table></figure>

<h3 id="内存优化：静态空间vs动态空间"><a href="#内存优化：静态空间vs动态空间" class="headerlink" title="内存优化：静态空间vs动态空间"></a>内存优化：静态空间vs动态空间</h3><h4 id="推荐：静态空间分配"><a href="#推荐：静态空间分配" class="headerlink" title="推荐：静态空间分配"></a>推荐：静态空间分配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局预分配，避免频繁内存分配</span></span><br><span class="line">MAXN = <span class="number">201</span></span><br><span class="line">MAXM = <span class="number">201</span></span><br><span class="line">mat = [[<span class="number">0</span>] * MAXM <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]  <span class="comment"># 静态矩阵</span></span><br><span class="line">arr = [<span class="number">0</span>] * MAXM  <span class="comment"># 静态辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    <span class="comment"># 复用已分配的空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            mat[i][j] = read_next_int()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用前先清空</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        arr[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="不推荐：频繁动态分配"><a href="#不推荐：频繁动态分配" class="headerlink" title="不推荐：频繁动态分配"></a>不推荐：频繁动态分配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="comment"># 每次都重新分配内存</span></span><br><span class="line">    mat = []  <span class="comment"># 动态创建</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        row = []  <span class="comment"># 每行都新建</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            row.append(read_next_int())</span><br><span class="line">        mat.append(row)</span><br></pre></td></tr></table></figure>

<h2 id="子矩阵最大累加和问题详解"><a href="#子矩阵最大累加和问题详解" class="headerlink" title="子矩阵最大累加和问题详解"></a>子矩阵最大累加和问题详解</h2><h3 id="问题描述与算法思路"><a href="#问题描述与算法思路" class="headerlink" title="问题描述与算法思路"></a>问题描述与算法思路</h3><p><strong>问题</strong>：给定包含正数、负数、零的矩阵，求累加和最大的子矩阵。</p>
<p><strong>核心思想</strong>：将二维问题转化为一维最大子数组和问题</p>
<ol>
<li>枚举子矩阵的上下边界（第i行到第j行）</li>
<li>将每列在这个范围内的元素累加，得到一维数组</li>
<li>对一维数组使用Kadane算法求最大子数组和</li>
</ol>
<h3 id="完整实现（填函数风格）"><a href="#完整实现（填函数风格）" class="headerlink" title="完整实现（填函数风格）"></a>完整实现（填函数风格）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_FillFunction</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfSubMatrix</span>(<span class="params">self, mat, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;主方法，求n×n矩阵的最大子矩阵和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.maxSumSubmatrix(mat, n, n)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubmatrix</span>(<span class="params">mat, n, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;求子矩阵的最大累加和&quot;&quot;&quot;</span></span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举上边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            arr = [<span class="number">0</span>] * m  <span class="comment"># 辅助数组，每次重置</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举下边界（从i到n-1）</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="comment"># 将第j行累加到辅助数组</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    arr[k] += mat[j][k]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 求当前辅助数组的最大子数组和</span></span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, Code01_FillFunction.maxSumSubarray(arr, m))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumSubarray</span>(<span class="params">arr, m</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Kadane算法求最大子数组和&quot;&quot;&quot;</span></span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            cur += arr[i]</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, cur)</span><br><span class="line">            cur = <span class="number">0</span> <span class="keyword">if</span> cur &lt; <span class="number">0</span> <span class="keyword">else</span> cur  <span class="comment"># 负数时重置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<p><strong>算法复杂度</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n² × m)</li>
<li><strong>空间复杂度</strong>：O(m)</li>
</ul>
<h3 id="ACM风格实现（静态空间优化）"><a href="#ACM风格实现（静态空间优化）" class="headerlink" title="ACM风格实现（静态空间优化）"></a>ACM风格实现（静态空间优化）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态空间分配，避免频繁内存分配</span></span><br><span class="line">MAXN = <span class="number">201</span></span><br><span class="line">MAXM = <span class="number">201</span></span><br><span class="line">mat = [[<span class="number">0</span>] * MAXM <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MAXN)]</span><br><span class="line">arr = [<span class="number">0</span>] * MAXM</span><br><span class="line">n = m = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> n, m</span><br><span class="line">    tokens = sys.stdin.read().split()</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    output = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(tokens):</span><br><span class="line">        n = <span class="built_in">int</span>(tokens[idx])</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        m = <span class="built_in">int</span>(tokens[idx])</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 读取矩阵数据到静态空间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                mat[i][j] = <span class="built_in">int</span>(tokens[idx])</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算结果并收集输出</span></span><br><span class="line">        output.append(<span class="built_in">str</span>(maxSumSubmatrix()))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 批量输出所有结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(output))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxSumSubmatrix</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用静态空间的子矩阵最大和算法&quot;&quot;&quot;</span></span><br><span class="line">    max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 清空辅助数组（复用静态空间）</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            arr[x] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="comment"># 累加第j行到辅助数组</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                arr[k] += mat[j][k]</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, maxSumSubarray())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxSumSubarray</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一维最大子数组和&quot;&quot;&quot;</span></span><br><span class="line">    max_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        cur += arr[i]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, cur)</span><br><span class="line">        cur = <span class="number">0</span> <span class="keyword">if</span> cur &lt; <span class="number">0</span> <span class="keyword">else</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以矩阵为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[-90, 48, 78],</span><br><span class="line"> [ 64,-40, 64], </span><br><span class="line"> [-81, -7, 66]]</span><br></pre></td></tr></table></figure>

<p><strong>枚举过程</strong>：</p>
<ol>
<li><strong>i&#x3D;0, j&#x3D;0</strong>（第0行）：arr&#x3D;[-90, 48, 78] → 最大子数组和&#x3D;126</li>
<li><strong>i&#x3D;0, j&#x3D;1</strong>（第0-1行）：arr&#x3D;[-26, 8, 142] → 最大子数组和&#x3D;150  </li>
<li><strong>i&#x3D;0, j&#x3D;2</strong>（第0-2行）：arr&#x3D;[-107, 1, 208] → 最大子数组和&#x3D;209</li>
<li><strong>i&#x3D;1, j&#x3D;1</strong>（第1行）：arr&#x3D;[64, -40, 64] → 最大子数组和&#x3D;88</li>
<li><strong>i&#x3D;1, j&#x3D;2</strong>（第1-2行）：arr&#x3D;[-17, -47, 130] → 最大子数组和&#x3D;130</li>
<li><strong>i&#x3D;2, j&#x3D;2</strong>（第2行）：arr&#x3D;[-81, -7, 66] → 最大子数组和&#x3D;66</li>
</ol>
<p><strong>最终结果</strong>：209（来自第0-2行，第2-2列的子矩阵）</p>
<h2 id="Python高级IO优化"><a href="#Python高级IO优化" class="headerlink" title="Python高级IO优化"></a>Python高级IO优化</h2><h3 id="FastReader快读类"><a href="#FastReader快读类" class="headerlink" title="FastReader快读类"></a>FastReader快读类</h3><p>FastReader 是一个极致追求输入速度的工具，适用于数据量极大的算法竞赛场景。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>极速读取输入，尤其是大量数字（如百万级数据）。</li>
<li>通过 <strong>一次性读取大块数据（8KB）</strong> 到内存，减少系统I&#x2F;O调用次数。</li>
<li>按字节处理并手动解析数字，比标准 input() 或 sys.stdin.readline() 更快。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>缓冲区：用 self.buffer 存储从输入流一次性读取的大块数据。</li>
<li>按字节解析：用 readByte 方法逐字节读取，跳过非数字字符，自己实现整数解析（包括负数）。</li>
<li>高效：只处理数字和符号，省略 split、strip 等高层方法，极致优化输入。</li>
</ul>
<p><strong>典型用法</strong><br>适合极端大数据输入、对时间卡得很紧的OJ平台。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastReader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file=sys.stdin</span>):</span><br><span class="line">        <span class="variable language_">self</span>.file = file</span><br><span class="line">        <span class="variable language_">self</span>.buffer = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;一次性读取8KB数据到缓冲区&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer = <span class="variable language_">self</span>.file.read(<span class="number">8192</span>)</span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readByte</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个字节&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.idx &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.buffer):</span><br><span class="line">            <span class="variable language_">self</span>._read()</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buffer == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        byte = <span class="variable language_">self</span>.buffer[<span class="variable language_">self</span>.idx]</span><br><span class="line">        <span class="variable language_">self</span>.idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(byte)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readInt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;快速读取整数&quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        minus = <span class="literal">False</span></span><br><span class="line">        b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 跳过非数字字符</span></span><br><span class="line">        <span class="keyword">while</span> b != -<span class="number">1</span> <span class="keyword">and</span> (b &lt; <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> b &gt; <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">and</span> b != <span class="built_in">ord</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> b == <span class="built_in">ord</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            minus = <span class="literal">True</span></span><br><span class="line">            b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 读取数字</span></span><br><span class="line">        <span class="keyword">while</span> b != -<span class="number">1</span> <span class="keyword">and</span> (<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) &lt;= b &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>)):</span><br><span class="line">            num = num * <span class="number">10</span> + (b - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            b = <span class="variable language_">self</span>.readByte()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -num <span class="keyword">if</span> minus <span class="keyword">else</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readLong</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取长整数（Python中与int相同）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.readInt()</span><br></pre></td></tr></table></figure>

<h3 id="FastWriter快写类"><a href="#FastWriter快写类" class="headerlink" title="FastWriter快写类"></a>FastWriter快写类</h3><p>FastWriter 是一个高效输出工具，适用于需要频繁输出、输出量大的场合。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>减少输出次数：把所有输出内容先缓存在内存里，最后统一输出，减少系统调用。</li>
<li>链式调用和兼容Java风格，用起来很方便。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>缓冲区：所有待输出内容先存入 self.buffer 列表。</li>
<li>批量输出：调用 flush() 时，一次性将所有内容写入输出流。</li>
<li>兼容性：支持 write（写字符串）、writeln&#x2F;println（写一行），用法灵活。</li>
</ul>
<p><strong>典型用法</strong></p>
<p>适合数据量大、频繁输出的算法题&#x2F;竞赛场景，防止 print() 太慢导致超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastWriter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file=sys.stdout</span>):</span><br><span class="line">        <span class="variable language_">self</span>.file = file</span><br><span class="line">        <span class="variable language_">self</span>.buffer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;写入字符串到缓冲区&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer.append(<span class="built_in">str</span>(s))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># 支持链式调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeln</span>(<span class="params">self, s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;写入一行&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer.append(<span class="built_in">str</span>(s) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">println</span>(<span class="params">self, s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;兼容Java习惯的方法名&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.writeln(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flush</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;刷新缓冲区，实际写入文件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buffer:</span><br><span class="line">            <span class="variable language_">self</span>.file.write(<span class="string">&quot;&quot;</span>.join(<span class="variable language_">self</span>.buffer))</span><br><span class="line">            <span class="variable language_">self</span>.file.flush()</span><br><span class="line">            <span class="variable language_">self</span>.buffer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;关闭写入器&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.flush()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.file != sys.stdout:</span><br><span class="line">            <span class="variable language_">self</span>.file.close()</span><br></pre></td></tr></table></figure>

<h3 id="Kattio类（Python版）"><a href="#Kattio类（Python版）" class="headerlink" title="Kattio类（Python版）"></a>Kattio类（Python版）</h3><p>Kattio 类是一个高效的输入输出（I&#x2F;O）工具类，最初流行于 Java 的竞赛编程圈。它的 Python 版本（如你上面给出的代码）主要是用来简化和加快处理标准输入输出，尤其适合数据量较大、输入格式“特殊”或需要频繁读取单个数据的场景，比如各类算法竞赛、OJ（Online Judge）平台等。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>高效读取输入：普通的 input() 在数据量大时会变慢，Kattio 通过缓冲和一次性读取一行数据，提升了读取效率。</li>
<li>简化输入格式处理：常见的输入格式如多行多列、混合类型（int、float、str）都能方便读取，不用每次都写 split、map 一大堆。</li>
<li>输出简便：带有封装的 println 方法，输出不再需要手动 print(…, file&#x3D;…)。</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>维护一个缓冲区（self.buffer），每次读取一整行并分割成单词。</li>
<li>提供 next() 方法按顺序读取下一个字符串，nextInt() 读取下一个整数，nextDouble() 读取下一个浮点数等。</li>
<li>适配输入和输出流（默认为标准输入输出，但也可以重定向到文件），并提供 close 方法在需要时关闭流。</li>
</ul>
<p>参考Java版Kattio的Python实现，处理特殊输入格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kattio</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    高效IO类，适用于特殊格式输入</span></span><br><span class="line"><span class="string">    效率略低于FastReader，但兼容性更好</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_stream=sys.stdin, output_stream=sys.stdout</span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">input</span> = input_stream</span><br><span class="line">        <span class="variable language_">self</span>.output = output_stream</span><br><span class="line">        <span class="variable language_">self</span>.buffer = []</span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fill_buffer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;填充缓冲区&quot;&quot;&quot;</span></span><br><span class="line">        line = <span class="variable language_">self</span>.<span class="built_in">input</span>.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer = line.strip().split()</span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个字符串&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.idx &gt;= <span class="built_in">len</span>(<span class="variable language_">self</span>.buffer):</span><br><span class="line">            <span class="variable language_">self</span>._fill_buffer()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.buffer:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        result = <span class="variable language_">self</span>.buffer[<span class="variable language_">self</span>.idx]</span><br><span class="line">        <span class="variable language_">self</span>.idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextInt</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个整数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="variable language_">self</span>.<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextLong</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个长整数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="variable language_">self</span>.<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextDouble</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取下一个浮点数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(<span class="variable language_">self</span>.<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">println</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;输出一行&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(s, file=<span class="variable language_">self</span>.output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;关闭IO流&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.<span class="built_in">input</span> != sys.stdin:</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">input</span>.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.output != sys.stdout:</span><br><span class="line">            <span class="variable language_">self</span>.output.close()</span><br></pre></td></tr></table></figure>

<h2 id="Python常用数据结构快速参考"><a href="#Python常用数据结构快速参考" class="headerlink" title="Python常用数据结构快速参考"></a>Python常用数据结构快速参考</h2><h3 id="基础容器操作"><a href="#基础容器操作" class="headerlink" title="基础容器操作"></a>基础容器操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表（动态数组）</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.append(<span class="number">4</span>)              <span class="comment"># O(1) 尾部添加</span></span><br><span class="line">arr.insert(<span class="number">0</span>, <span class="number">0</span>)           <span class="comment"># O(n) 头部插入</span></span><br><span class="line">arr.pop()                  <span class="comment"># O(1) 尾部删除</span></span><br><span class="line">arr.pop(<span class="number">0</span>)                 <span class="comment"># O(n) 头部删除</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])              <span class="comment"># O(1) 随机访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双端队列（可当栈或队列）</span></span><br><span class="line">dq = deque()</span><br><span class="line">dq.append(<span class="number">1</span>)               <span class="comment"># 队尾入队</span></span><br><span class="line">dq.appendleft(<span class="number">2</span>)           <span class="comment"># 队首入队</span></span><br><span class="line">dq.pop()                   <span class="comment"># 队尾出队</span></span><br><span class="line">dq.popleft()               <span class="comment"># 队首出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作</span></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)             <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)             <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">print</span>(s1 - s2)             <span class="comment"># 差集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典操作</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)       <span class="comment"># 默认值为0</span></span><br><span class="line">d[<span class="string">&quot;key&quot;</span>] += <span class="number">1</span>              <span class="comment"># 自动初始化并自增</span></span><br></pre></td></tr></table></figure>

<h3 id="排序与查找"><a href="#排序与查找" class="headerlink" title="排序与查找"></a>排序与查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">arr.sort()                           <span class="comment"># 原地升序排序</span></span><br><span class="line">arr.sort(reverse=<span class="literal">True</span>)               <span class="comment"># 原地降序排序</span></span><br><span class="line">sorted_arr = <span class="built_in">sorted</span>(arr)             <span class="comment"># 返回新的排序数组</span></span><br><span class="line">custom_sorted = <span class="built_in">sorted</span>(arr, key=<span class="keyword">lambda</span> x: -x)  <span class="comment"># 自定义排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>]  <span class="comment"># 必须有序</span></span><br><span class="line">idx = bisect.bisect_left(arr, <span class="number">4</span>)     <span class="comment"># 查找插入位置</span></span><br><span class="line">idx = bisect.bisect_right(arr, <span class="number">4</span>)    <span class="comment"># 查找插入位置（右侧）</span></span><br></pre></td></tr></table></figure>

<h3 id="大整数与高精度"><a href="#大整数与高精度" class="headerlink" title="大整数与高精度"></a>大整数与高精度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python原生支持任意精度整数</span></span><br><span class="line">big_num = <span class="number">10</span>**<span class="number">100</span>                    <span class="comment"># 10的100次方</span></span><br><span class="line">result = big_num * big_num           <span class="comment"># 自动处理大整数运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高精度除法</span></span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line">decimal.getcontext().prec = <span class="number">50</span>       <span class="comment"># 设置精度</span></span><br><span class="line">a = decimal.Decimal(<span class="string">&#x27;1&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实战技巧与注意事项"><a href="#实战技巧与注意事项" class="headerlink" title="实战技巧与注意事项"></a>实战技巧与注意事项</h2><h3 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 避免在循环中重复计算</span></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):  <span class="comment"># 每次都计算len(arr)</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法  </span></span><br><span class="line">arr_len = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(arr_len):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用局部变量访问全局数据</span></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        result += global_data[i]  <span class="comment"># 每次都查找全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    local_data = global_data  <span class="comment"># 本地化全局变量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        result += local_data[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 字符串拼接优化</span></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s += <span class="built_in">str</span>(i)  <span class="comment"># 每次都创建新字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">parts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    parts.append(<span class="built_in">str</span>(i))</span><br><span class="line">s = <span class="string">&quot;&quot;</span>.join(parts)</span><br></pre></td></tr></table></figure>

<h3 id="常见陷阱与解决方案"><a href="#常见陷阱与解决方案" class="headerlink" title="常见陷阱与解决方案"></a>常见陷阱与解决方案</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 递归深度限制</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10000</span>)  <span class="comment"># 设置递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 浮点数精度问题</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_equal</span>(<span class="params">a, b, eps=<span class="number">1e-9</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt; eps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 列表初始化陷阱</span></span><br><span class="line"><span class="comment"># 错误：所有行共享同一个列表</span></span><br><span class="line">matrix = [[<span class="number">0</span>] * m] * n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：每行都是独立的列表</span></span><br><span class="line">matrix = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 字典默认值</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># 使用defaultdict避免KeyError</span></span><br><span class="line">count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">count[key] += <span class="number">1</span>  <span class="comment"># 自动初始化为0</span></span><br></pre></td></tr></table></figure>

<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件编译式调试</span></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_print</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;DEBUG:&quot;</span>, *args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入输出重定向（本地测试）</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    sys.stdin = <span class="built_in">open</span>(<span class="string">&#x27;input.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    sys.stdout = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时器</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="comment"># ... 算法代码 ...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;执行时间: <span class="subst">&#123;time.time() - start_time:<span class="number">.3</span>f&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数据结构与算法自学笔记（4）- 二叉树相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-04 14:42:46" itemprop="dateCreated datePublished" datetime="2025-08-04T14:42:46+08:00">2025-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:01:37" itemprop="dateModified" datetime="2025-08-05T16:01:37+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Notes/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参照的是左程云的课程：<a target="_blank" rel="noopener" href="https://space.bilibili.com/8888480/lists/3509640?type=series">https://space.bilibili.com/8888480/lists/3509640?type=series</a><br>本笔记包括了二叉树的基础概念、三种遍历方式的递归实现和非递归实现，涵盖了先序、中序、后序遍历的原理与代码实现，包括了class017 -&gt; class018的内容</p>
<h1 id="017【入门】二叉树及其三种序的递归实现"><a href="#017【入门】二叉树及其三种序的递归实现" class="headerlink" title="017【入门】二叉树及其三种序的递归实现"></a>017【入门】二叉树及其三种序的递归实现</h1><h2 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h2><p>二叉树是一种重要的树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树是许多高级数据结构和算法的基础。</p>
<h3 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = v         <span class="comment"># 节点的值</span></span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span>     <span class="comment"># 左子节点</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span>    <span class="comment"># 右子节点</span></span><br></pre></td></tr></table></figure>

<h3 id="递归序的概念"><a href="#递归序的概念" class="headerlink" title="递归序的概念"></a>递归序的概念</h3><p>递归序是理解二叉树遍历的关键概念。对于任意二叉树节点，递归过程会经过该节点三次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 第1次到达该节点 - 刚进入该节点</span></span><br><span class="line">    f(head.left)   <span class="comment"># 递归处理左子树</span></span><br><span class="line">    <span class="comment"># 第2次到达该节点 - 左子树处理完毕</span></span><br><span class="line">    f(head.right)  <span class="comment"># 递归处理右子树</span></span><br><span class="line">    <span class="comment"># 第3次到达该节点 - 右子树处理完毕</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/f%E5%87%BD%E6%95%B0.png" alt="f函数"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E7%90%86%E8%A7%A3f%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%80%92%E5%BD%92%E5%BA%8F.png" alt="理解f函数"></p>
<p>根据在这三个时机中选择处理节点的时机不同，就形成了三种不同的遍历方式。</p>
<h2 id="二叉树的三种递归遍历"><a href="#二叉树的三种递归遍历" class="headerlink" title="二叉树的三种递归遍历"></a>二叉树的三种递归遍历</h2><h3 id="先序遍历（Pre-order-Traversal）"><a href="#先序遍历（Pre-order-Traversal）" class="headerlink" title="先序遍历（Pre-order Traversal）"></a>先序遍历（Pre-order Traversal）</h3><p>先序遍历的顺序是：<strong>根节点 → 左子树 → 右子树</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    先序遍历：在第1次到达节点时处理</span></span><br><span class="line"><span class="string">    应用场景：复制二叉树、表达式树求值、目录树打印</span></span><br><span class="line"><span class="string">    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 先处理当前节点</span></span><br><span class="line">    BinaryTreeTraversalRecursion.preOrder(head.left)   <span class="comment"># 再遍历左子树</span></span><br><span class="line">    BinaryTreeTraversalRecursion.preOrder(head.right)  <span class="comment"># 最后遍历右子树</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E5%85%88%E5%BA%8F.png" alt="先序"></p>
<h3 id="中序遍历（In-order-Traversal）"><a href="#中序遍历（In-order-Traversal）" class="headerlink" title="中序遍历（In-order Traversal）"></a>中序遍历（In-order Traversal）</h3><p>中序遍历的顺序是：<strong>左子树 → 根节点 → 右子树</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历：在第2次到达节点时处理</span></span><br><span class="line"><span class="string">    应用场景：二叉搜索树排序（得到有序序列）、表达式树转中缀表达式</span></span><br><span class="line"><span class="string">    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    BinaryTreeTraversalRecursion.inOrder(head.left)   <span class="comment"># 先遍历左子树</span></span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 再处理当前节点</span></span><br><span class="line">    BinaryTreeTraversalRecursion.inOrder(head.right)  <span class="comment"># 最后遍历右子树</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E4%B8%AD%E5%BA%8F.png" alt="中序"></p>
<h3 id="后序遍历（Post-order-Traversal）"><a href="#后序遍历（Post-order-Traversal）" class="headerlink" title="后序遍历（Post-order Traversal）"></a>后序遍历（Post-order Traversal）</h3><p>后序遍历的顺序是：<strong>左子树 → 右子树 → 根节点</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历：在第3次到达节点时处理</span></span><br><span class="line"><span class="string">    应用场景：计算目录大小、删除二叉树、表达式树计算</span></span><br><span class="line"><span class="string">    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    BinaryTreeTraversalRecursion.posOrder(head.left)   <span class="comment"># 先遍历左子树</span></span><br><span class="line">    BinaryTreeTraversalRecursion.posOrder(head.right)  <span class="comment"># 再遍历右子树</span></span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 最后处理当前节点</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class17%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E5%BA%8F/%E5%90%8E%E5%BA%8F.png" alt="后序"></p>
<h2 id="递归遍历的示例执行"><a href="#递归遍历的示例执行" class="headerlink" title="递归遍历的示例执行"></a>递归遍历的示例执行</h2><p>以下面的二叉树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \ / \</span><br><span class="line">4  5 6  7</span><br></pre></td></tr></table></figure>

<h3 id="执行结果对比"><a href="#执行结果对比" class="headerlink" title="执行结果对比"></a>执行结果对比</h3><ul>
<li><strong>先序遍历结果</strong>：1 2 4 5 3 6 7</li>
<li><strong>中序遍历结果</strong>：4 2 5 1 6 3 7  </li>
<li><strong>后序遍历结果</strong>：4 5 2 6 7 3 1</li>
</ul>
<h3 id="递归调用过程分析"><a href="#递归调用过程分析" class="headerlink" title="递归调用过程分析"></a>递归调用过程分析</h3><p>以先序遍历为例，递归调用的过程：</p>
<ol>
<li>访问节点1，打印1</li>
<li>递归进入左子树（节点2）<ul>
<li>访问节点2，打印2</li>
<li>递归进入左子树（节点4）<ul>
<li>访问节点4，打印4</li>
<li>左右子树为空，返回</li>
</ul>
</li>
<li>递归进入右子树（节点5）<ul>
<li>访问节点5，打印5</li>
<li>左右子树为空，返回</li>
</ul>
</li>
</ul>
</li>
<li>递归进入右子树（节点3）<ul>
<li>类似过程…</li>
</ul>
</li>
</ol>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>所有递归遍历算法的时间复杂度都是 <strong>O(n)</strong>，其中n是二叉树的节点数。每个节点都会被访问恰好一次。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>额外空间复杂度：O(h)</strong>，其中h是树的高度。</p>
<ul>
<li><strong>最好情况</strong>（完全平衡的二叉树）：h &#x3D; ⌊log₂n⌋，空间复杂度为O(log n)</li>
<li><strong>最坏情况</strong>（完全不平衡的树，退化为链表）：h &#x3D; n，空间复杂度为O(n)</li>
<li><strong>平均情况</strong>：对于随机二叉树，h &#x3D; O(log n)</li>
</ul>
<p>空间消耗主要来自递归调用栈，栈的最大深度等于树的高度。</p>
<h2 id="三种遍历方式的应用场景"><a href="#三种遍历方式的应用场景" class="headerlink" title="三种遍历方式的应用场景"></a>三种遍历方式的应用场景</h2><h3 id="先序遍历的典型应用"><a href="#先序遍历的典型应用" class="headerlink" title="先序遍历的典型应用"></a>先序遍历的典型应用</h3><ol>
<li><strong>复制二叉树</strong>：先创建根节点，再递归复制左右子树</li>
<li><strong>表达式树求值</strong>：先处理操作符，再处理操作数</li>
<li><strong>目录树打印</strong>：先打印目录名，再打印子目录内容</li>
<li><strong>序列化二叉树</strong>：将树结构转换为字符串格式</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制二叉树示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyTree</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 先创建新节点（先序特点）</span></span><br><span class="line">    newNode = TreeNode(root.val)</span><br><span class="line">    newNode.left = copyTree(root.left)    <span class="comment"># 递归复制左子树</span></span><br><span class="line">    newNode.right = copyTree(root.right)  <span class="comment"># 递归复制右子树</span></span><br><span class="line">    <span class="keyword">return</span> newNode</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历的典型应用"><a href="#中序遍历的典型应用" class="headerlink" title="中序遍历的典型应用"></a>中序遍历的典型应用</h3><ol>
<li><strong>二叉搜索树排序</strong>：中序遍历BST得到有序序列</li>
<li><strong>表达式树转中缀表达式</strong>：按照运算符优先级添加括号</li>
<li><strong>验证二叉搜索树</strong>：检查中序遍历结果是否为递增序列</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证二叉搜索树示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node, values</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        inorder(node.left, values)</span><br><span class="line">        values.append(node.val)  <span class="comment"># 中序收集值</span></span><br><span class="line">        inorder(node.right, values)</span><br><span class="line">    </span><br><span class="line">    values = []</span><br><span class="line">    inorder(root, values)</span><br><span class="line">    <span class="comment"># 检查是否严格递增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(values[i] &lt; values[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历的典型应用"><a href="#后序遍历的典型应用" class="headerlink" title="后序遍历的典型应用"></a>后序遍历的典型应用</h3><ol>
<li><strong>计算目录大小</strong>：先计算子目录大小，再计算当前目录</li>
<li><strong>删除二叉树</strong>：先删除子节点，再删除父节点</li>
<li><strong>表达式树计算</strong>：先计算子表达式，再计算根表达式</li>
<li><strong>计算树的高度</strong>：先计算子树高度，再计算当前树高度</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算二叉树高度示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 先计算左右子树高度（后序特点）</span></span><br><span class="line">    leftHeight = maxDepth(root.left)</span><br><span class="line">    rightHeight = maxDepth(root.right)</span><br><span class="line">    <span class="comment"># 再计算当前树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方式选择指南"><a href="#遍历方式选择指南" class="headerlink" title="遍历方式选择指南"></a>遍历方式选择指南</h2><table>
<thead>
<tr>
<th>需求场景</th>
<th>推荐遍历方式</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>复制&#x2F;构建树结构</td>
<td>先序遍历</td>
<td>需要先创建根节点</td>
</tr>
<tr>
<td>获取有序数据</td>
<td>中序遍历</td>
<td>BST的中序遍历有序</td>
</tr>
<tr>
<td>释放&#x2F;计算资源</td>
<td>后序遍历</td>
<td>需要先处理子节点</td>
</tr>
<tr>
<td>树的序列化</td>
<td>先序遍历</td>
<td>便于重建树结构</td>
</tr>
<tr>
<td>表达式求值</td>
<td>后序遍历</td>
<td>需要先计算子表达式</td>
</tr>
</tbody></table>
<h2 id="递归实现的优缺点"><a href="#递归实现的优缺点" class="headerlink" title="递归实现的优缺点"></a>递归实现的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>代码简洁</strong>：逻辑清晰，易于理解和实现</li>
<li><strong>自然表达</strong>：完美匹配树的递归定义</li>
<li><strong>易于扩展</strong>：容易添加额外的处理逻辑</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>栈溢出风险</strong>：深度递归可能导致栈溢出</li>
<li><strong>性能开销</strong>：函数调用的开销相对较大</li>
<li><strong>难以控制</strong>：无法方便地暂停或恢复遍历过程</li>
</ol>
<p>在实际应用中，对于一般规模的二叉树，递归实现是首选方案。当树的深度可能很大时，需要考虑使用非递归实现来避免栈溢出问题。</p>
<hr>
<h1 id="018【入门】二叉树遍历的非递归实现和复杂度分析"><a href="#018【入门】二叉树遍历的非递归实现和复杂度分析" class="headerlink" title="018【入门】二叉树遍历的非递归实现和复杂度分析"></a>018【入门】二叉树遍历的非递归实现和复杂度分析</h1><h2 id="非递归实现的必要性"><a href="#非递归实现的必要性" class="headerlink" title="非递归实现的必要性"></a>非递归实现的必要性</h2><p>递归实现虽然简洁易懂，但在处理大型树时可能导致栈溢出。非递归实现使用显式栈来模拟递归过程，提供了更好的控制性和避免栈溢出的优势。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>用显式的栈数据结构来模拟系统递归调用栈的行为，手动管理遍历过程中的状态信息。</p>
<h2 id="先序遍历的非递归实现"><a href="#先序遍历的非递归实现" class="headerlink" title="先序遍历的非递归实现"></a>先序遍历的非递归实现</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>先序遍历要求”根-左-右”的访问顺序。使用栈时，由于栈是LIFO（后进先出）结构，需要先压入右子节点，再压入左子节点，这样弹栈时就是先处理左子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    先序遍历非递归实现</span></span><br><span class="line"><span class="string">    核心思路：使用一个栈。每次先访问节点本身，再依次压入右、左子节点（注意顺序，先右后左），这样弹栈时总是优先处理左子树，实现“中-左-右”顺序</span></span><br><span class="line"><span class="string">    时间复杂度：O(n)，每个节点进栈出栈各一次</span></span><br><span class="line"><span class="string">    空间复杂度：O(h)，h为树的高度</span></span><br><span class="line"><span class="string">    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(head)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            head = stack.pop()        <span class="comment"># 弹出栈顶节点</span></span><br><span class="line">            <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 立即打印（先序特点）</span></span><br><span class="line">            <span class="comment"># 关键：先压右子节点，再压左子节点</span></span><br><span class="line">            <span class="comment"># 这样弹栈时就是先处理左子树，再处理右子树</span></span><br><span class="line">            <span class="keyword">if</span> head.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.right)</span><br><span class="line">            <span class="keyword">if</span> head.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.left)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class18%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/%E5%85%88%E5%BA%8F.png" alt="先序2"></p>
<h3 id="执行过程示例"><a href="#执行过程示例" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以树 <code>1(2(4,5),3(6,7))</code> 为例：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>栈状态</th>
<th>弹出节点</th>
<th>打印</th>
<th>压入节点</th>
</tr>
</thead>
<tbody><tr>
<td>初始</td>
<td>[1]</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>[3,2]</td>
<td>1</td>
<td>1</td>
<td>3,2</td>
</tr>
<tr>
<td>2</td>
<td>[3,5,4]</td>
<td>2</td>
<td>2</td>
<td>5,4</td>
</tr>
<tr>
<td>3</td>
<td>[3,5]</td>
<td>4</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>[3]</td>
<td>5</td>
<td>5</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>[7,6]</td>
<td>3</td>
<td>3</td>
<td>7,6</td>
</tr>
<tr>
<td>6</td>
<td>[7]</td>
<td>6</td>
<td>6</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td>[]</td>
<td>7</td>
<td>7</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>输出结果</strong>：1 2 4 5 3 6 7</p>
<h2 id="中序遍历的非递归实现"><a href="#中序遍历的非递归实现" class="headerlink" title="中序遍历的非递归实现"></a>中序遍历的非递归实现</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>中序遍历要求”左-根-右”的访问顺序。需要先沿着左子树走到底，将路径上的所有节点压栈，然后开始弹栈处理节点，并转向右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inOrder</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历非递归实现</span></span><br><span class="line"><span class="string">    核心思路：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。</span></span><br><span class="line"><span class="string">    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 当前节点不为空，压栈并继续向左</span></span><br><span class="line">                stack.append(head)</span><br><span class="line">                head = head.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当前节点为空，说明左子树遍历完毕</span></span><br><span class="line">                head = stack.pop()        <span class="comment"># 弹出栈顶节点</span></span><br><span class="line">                <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 打印节点值（中序特点）</span></span><br><span class="line">                head = head.right         <span class="comment"># 转向右子树</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h3 id="算法状态分析"><a href="#算法状态分析" class="headerlink" title="算法状态分析"></a>算法状态分析</h3><p>中序遍历的非递归实现有两种状态：</p>
<ol>
<li><strong>下降状态</strong>：<code>head != None</code>，沿左子树向下走并压栈</li>
<li><strong>上升状态</strong>：<code>head == None</code>，弹栈处理节点并转向右子树</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(4)/class18%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/%E4%B8%AD%E5%BA%8F.png" alt="中序2"></p>
<h3 id="执行过程示例-1"><a href="#执行过程示例-1" class="headerlink" title="执行过程示例"></a>执行过程示例</h3><p>以树 <code>1(2(4,5),3(6,7))</code> 为例：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>head</th>
<th>栈状态</th>
<th>操作</th>
<th>打印</th>
</tr>
</thead>
<tbody><tr>
<td>初始</td>
<td>1</td>
<td>[]</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>[1]</td>
<td>压栈1，左移</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>[1,2]</td>
<td>压栈2，左移</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>None</td>
<td>[1,2,4]</td>
<td>压栈4，左移</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>[1,2]</td>
<td>弹栈4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>None</td>
<td>[1,2]</td>
<td>4右移(None)</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>[1]</td>
<td>弹栈2</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>5</td>
<td>[1]</td>
<td>2右移到5</td>
<td>-</td>
</tr>
<tr>
<td>8</td>
<td>None</td>
<td>[1,5]</td>
<td>压栈5，左移</td>
<td>-</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>输出结果</strong>：4 2 5 1 6 3 7</p>
<h2 id="后序遍历的非递归实现"><a href="#后序遍历的非递归实现" class="headerlink" title="后序遍历的非递归实现"></a>后序遍历的非递归实现</h2><p>后序遍历是最复杂的，因为需要确保在访问根节点之前，左右子树都已经被完全访问。提供两种实现方法：</p>
<h3 id="方法一：使用两个栈"><a href="#方法一：使用两个栈" class="headerlink" title="方法一：使用两个栈"></a>方法一：使用两个栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posOrderTwoStacks</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历非递归实现 - 双栈法</span></span><br><span class="line"><span class="string">    核心思路：第一个栈实现&quot;中-右-左&quot;遍历，结果压入第二个栈</span></span><br><span class="line"><span class="string">    最后弹出第二个栈得到&quot;左-右-中&quot;的后序遍历结果</span></span><br><span class="line"><span class="string">    即：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。</span></span><br><span class="line"><span class="string">    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []      <span class="comment"># 主栈：用于遍历</span></span><br><span class="line">        collect = []    <span class="comment"># 收集栈：用于收集结果</span></span><br><span class="line">        stack.append(head)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            head = stack.pop()</span><br><span class="line">            collect.append(head)      <span class="comment"># 收集节点到第二个栈</span></span><br><span class="line">            <span class="comment"># 注意：这里先压左子节点，再压右子节点</span></span><br><span class="line">            <span class="comment"># 这样遍历顺序就是&quot;中-右-左&quot;</span></span><br><span class="line">            <span class="keyword">if</span> head.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.left)</span><br><span class="line">            <span class="keyword">if</span> head.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(head.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反向弹出收集栈，得到&quot;左-右-中&quot;顺序</span></span><br><span class="line">        <span class="keyword">while</span> collect:</span><br><span class="line">            <span class="built_in">print</span>(collect.pop().val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h4 id="双栈法原理解析"><a href="#双栈法原理解析" class="headerlink" title="双栈法原理解析"></a>双栈法原理解析</h4><ol>
<li><strong>第一阶段</strong>：用第一个栈实现”中-右-左”遍历，类似先序遍历但左右子节点入栈顺序相反</li>
<li><strong>第二阶段</strong>：将第一阶段的结果压入第二个栈</li>
<li><strong>第三阶段</strong>：弹出第二个栈，得到”左-右-中”的后序遍历结果</li>
</ol>
<p><strong>关键洞察</strong>：”中-右-左”的逆序正好是”左-右-中”</p>
<h3 id="方法二：使用一个栈"><a href="#方法二：使用一个栈" class="headerlink" title="方法二：使用一个栈"></a>方法二：使用一个栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posOrderOneStack</span>(<span class="params">h</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历非递归实现 - 单栈法</span></span><br><span class="line"><span class="string">    核心思路：通过记录最近访问的节点，确保每个节点在其左右子树都被访问后才访问自己，从而严格实现“左-右-中”的后序遍历。</span></span><br><span class="line"><span class="string">    每个节点最多入栈两次，效率更高</span></span><br><span class="line"><span class="string">    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> h <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(h)</span><br><span class="line">        <span class="comment"># h的含义：最近一次处理（打印）的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack[-<span class="number">1</span>]  <span class="comment"># 查看栈顶元素但不弹出</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况1：有左子树且左子树未被处理过</span></span><br><span class="line">            <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h != cur.left <span class="keyword">and</span> h != cur.right:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="comment"># 情况2：有右子树且右子树未被处理过</span></span><br><span class="line">            <span class="keyword">elif</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h != cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            <span class="comment"># 情况3：左右子树都没有或都已处理完毕</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(cur.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                h = stack.pop()  <span class="comment"># 更新h为刚刚处理的节点</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h4 id="单栈法状态管理"><a href="#单栈法状态管理" class="headerlink" title="单栈法状态管理"></a>单栈法状态管理</h4><p><strong>核心变量h的含义变化</strong>：</p>
<ul>
<li><strong>初始时</strong>：h指向根节点（但实际表示”还没有处理过任何节点”）</li>
<li><strong>处理过程中</strong>：h始终指向最近一次处理（打印）的节点</li>
<li><strong>判断逻辑</strong>：通过比较当前节点的子节点与h的关系，判断子树是否已被处理</li>
</ul>
<p><strong>三种处理情况</strong>：</p>
<ol>
<li><strong>有左子树且未处理</strong>：<code>cur.left != None and h != cur.left and h != cur.right</code></li>
<li><strong>有右子树且未处理</strong>：<code>cur.right != None and h != cur.right</code></li>
<li><strong>可以处理当前节点</strong>：左右子树都不存在或都已处理完毕</li>
</ol>
<h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>所有非递归遍历算法的时间复杂度都是 <strong>O(n)</strong>：</p>
<ul>
<li><strong>先序和中序</strong>：每个节点进栈出栈各一次</li>
<li><strong>后序双栈法</strong>：每个节点进栈出栈总共两次（每个栈一次）</li>
<li><strong>后序单栈法</strong>：每个节点最多进栈两次，出栈一次</li>
</ul>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>额外空间复杂度对比</strong>：</p>
<table>
<thead>
<tr>
<th>实现方法</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>先序非递归</td>
<td>O(h)</td>
<td>一个栈，最大深度为树高</td>
</tr>
<tr>
<td>中序非递归</td>
<td>O(h)</td>
<td>一个栈，最大深度为树高</td>
</tr>
<tr>
<td>后序双栈法</td>
<td>O(n)</td>
<td>收集栈最坏情况存储所有节点</td>
</tr>
<tr>
<td>后序单栈法</td>
<td>O(h)</td>
<td>一个栈，最大深度为树高</td>
</tr>
<tr>
<td>递归实现</td>
<td>O(h)</td>
<td>系统调用栈，深度为树高</td>
</tr>
</tbody></table>
<p>其中h为树的高度：</p>
<ul>
<li><strong>最好情况</strong>：h &#x3D; O(log n)（平衡树）</li>
<li><strong>最坏情况</strong>：h &#x3D; O(n)（退化为链表）</li>
</ul>
<h2 id="实现方法选择建议"><a href="#实现方法选择建议" class="headerlink" title="实现方法选择建议"></a>实现方法选择建议</h2><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>实现难度</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td>先序非递归</td>
<td>O(n)</td>
<td>O(h)</td>
<td>简单</td>
<td>通用推荐</td>
</tr>
<tr>
<td>中序非递归</td>
<td>O(n)</td>
<td>O(h)</td>
<td>中等</td>
<td>BST相关问题</td>
</tr>
<tr>
<td>后序双栈法</td>
<td>O(n)</td>
<td>O(n)</td>
<td>简单</td>
<td>理解后序遍历逻辑</td>
</tr>
<tr>
<td>后序单栈法</td>
<td>O(n)</td>
<td>O(h)</td>
<td>困难</td>
<td>空间要求严格的场景</td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ol>
<li><strong>实际应用</strong>：根据具体需求选择，一般情况下递归实现更简洁</li>
<li><strong>性能要求高</strong>：选择非递归实现，避免函数调用开销</li>
<li><strong>内存受限</strong>：后序遍历优选单栈法，其他遍历方式空间复杂度相当</li>
</ol>
<h2 id="非递归实现的优势"><a href="#非递归实现的优势" class="headerlink" title="非递归实现的优势"></a>非递归实现的优势</h2><ol>
<li><strong>避免栈溢出</strong>：可以处理任意深度的树</li>
<li><strong>更好控制</strong>：可以方便地暂停、恢复遍历过程</li>
<li><strong>性能优化</strong>：减少函数调用开销</li>
<li><strong>状态保存</strong>：便于在遍历过程中保存额外信息</li>
</ol>
<p>非递归实现虽然代码复杂度较高，但在处理大规模数据或有特殊要求的场景中具有重要意义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="AgioPan">
      <meta itemprop="description" content="Solving equations, decoding life, exploring minds.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AgioPan">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/" class="post-title-link" itemprop="url">Academic Paper learning & Translation Records</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-04 14:00:00" itemprop="dateCreated datePublished" datetime="2025-08-04T14:00:00+08:00">2025-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-05 16:19:17" itemprop="dateModified" datetime="2025-08-05T16:19:17+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Review/" itemprop="url" rel="index"><span itemprop="name">Review</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Review/Translation/" itemprop="url" rel="index"><span itemprop="name">Translation</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文档用于记录自己读过的学术论文和亲自翻译的论文内容。每篇论文包含简要说明和个人理解，部分论文附有飞书文档或doi链接</p>
<hr>
<h1 id="翻译论文记录"><a href="#翻译论文记录" class="headerlink" title="翻译论文记录"></a>翻译论文记录</h1><h2 id="P´olya’s-Random-Walk-Theorem"><a href="#P´olya’s-Random-Walk-Theorem" class="headerlink" title="P´olya’s Random Walk Theorem"></a>P´olya’s Random Walk Theorem</h2><p>当时是为了随机过程的pre，然后翻译并推了一遍polya随机游走定理，记录一下。</p>
<p><strong>原文标题</strong>：P´olya’s Random Walk Theorem<br><strong>作者</strong>：Jonathan Novak<br><strong>出处</strong>：The American Mathematical Monthly, 2014•Taylor &amp; Francis<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://doi.org/10.48550/arXiv.1301.3916">点此查看全文</a><br><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/ILmQd6LHVoVouHxrqzbcUFLqnid?from=from_copylink">点此查看翻译版</a></p>
<h2 id="MDS-TSNE-UMAP"><a href="#MDS-TSNE-UMAP" class="headerlink" title="MDS&#x2F;TSNE&#x2F;UMAP"></a>MDS&#x2F;TSNE&#x2F;UMAP</h2><p>longlongago之前把生物信息里比较常用的三种降维算法都学和推了一遍，分别是MDS（multidimensional scaling）多维尺度分析、t-SNE（t-distributed Stochastic Neighbor Embedding）和UMAP（Uniform Manifold Approximation and Projection），记录一下翻译版。</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/SP81dw744o2KXBxNtlkc8eXQnxo?from=from_copylink">点此查看整合的笔记</a></p>
<h3 id="MDS"><a href="#MDS" class="headerlink" title="MDS"></a>MDS</h3><p>Multidimensional scaling，简称MDS，中文翻译成多维尺度分析。其原理是利用成对样本间的相似性，去构建合适的低维空间，使得样本在此空间的距离和在高维空间中的样本间的相似性尽可能的保持一致。我们可以用这种方式来可视化数据分布，PCA是MDS中特殊的一种。</p>
<p>感觉有点像层次分析法，比较早用于心理学&amp;社会科学上的一些相似性分析。以下公式为简单的优化思想，理论上可以从欧式距离推广到各种距离如曼哈顿、马氏等等。</p>
<p>原始文献有点太古老了，所以看的是csdn上的专栏：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&utm_medium=referral">https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&amp;utm_medium=referral</a></p>
<ul>
<li>Kruskal, J. B. (1964). “Multidimensional Scaling by Optimizing Goodness of Fit to a Nonmetric Hypothesis.” Psychometrika, 29(1), 1-27.</li>
<li>Shepard, R. N. (1962). “The Analysis of Proximities: Multidimensional Scaling with an Unknown Distance Function.” Psychometrika, 27(2), 125-140.</li>
</ul>
<h3 id="TSNE"><a href="#TSNE" class="headerlink" title="TSNE"></a>TSNE</h3><p>t-sne感觉是比较fashion的概率方法，很有意思。找了一篇论文<a target="_blank" rel="noopener" href="https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf</a></p>
<p><strong>原文标题</strong>：Visualizing Data using t-SNE<br><strong>作者</strong>：Laurens van der Maaten， Geoffrey Hinton<br><strong>出处</strong>：Journal of Machine Learning Research 9 (2008) 2579-2605<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">点此查看全文</a></p>
<h3 id="UMAP"><a href="#UMAP" class="headerlink" title="UMAP"></a>UMAP</h3><p>UMAP没有看太懂，主要是我没学过拓扑，但是其中模糊数学的部分很有意思，这篇论文刚刚发预印本的时候模糊数学还挺火的，现在不行了。</p>
<p><strong>原文标题</strong>：Uniform manifold approximation and projection<br><strong>作者</strong>：John Healy， Leland McInnes<br><strong>出处</strong>：Nature Reviews Methods Primers volume 4, Article number: 82 (2024)<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1802.03426">点此查看全文</a></p>
<h2 id="注意力机制相关"><a href="#注意力机制相关" class="headerlink" title="注意力机制相关"></a>注意力机制相关</h2><p>包括注意力机制到transformer的自注意力及其后续的变体，还有ESM3几何注意力机制、rfdiffusion的IGSO3等等。</p>
<h3 id="注意力机制的发展"><a href="#注意力机制的发展" class="headerlink" title="注意力机制的发展"></a>注意力机制的发展</h3><p>longlongago之前学深度学习补的：</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/ZhcAdjXrpoRE0exteQDc1WDZnDg?from=from_copylink">点此查看整合的笔记</a></p>
<h3 id="几何注意力机制"><a href="#几何注意力机制" class="headerlink" title="几何注意力机制"></a>几何注意力机制</h3><p>ESM3有用到，ESM3模型处理蛋白质结构信息的两种主要方法：几何注意力（Geometric Attention）和结构标记（Structure Tokens）。</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/NvxrdQV10oc6dAxO58jcRg2mnud?from=from_copylink">点此查看整合的笔记</a></p>
<h3 id="IGSO3"><a href="#IGSO3" class="headerlink" title="IGSO3"></a>IGSO3</h3><p>当时看rfdiffusion被吓坏了，这个证明真的很吓人</p>
<p><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/FSKFdRxOUoIyuWxeZ9DcizWfn9b?from=from_copylink">点此查看整合的笔记</a></p>
<h2 id="倾向性得分在观察性研究中因果效应分析的核心作用"><a href="#倾向性得分在观察性研究中因果效应分析的核心作用" class="headerlink" title="倾向性得分在观察性研究中因果效应分析的核心作用"></a>倾向性得分在观察性研究中因果效应分析的核心作用</h2><p>文理学院统计系汇报的pre，看完了之后连统计学都不想学了，数学和统计完全是两个学科啊！感觉自己喜欢的是统计计算而不是数理统计和传统的统计inference，润了润了润去计算了</p>
<p><strong>原文标题</strong>：The central role of the propensity score in observational studies for causal effect<br><strong>作者</strong>：PAUL R. ROSENBAUM, DONALD B. RUBIN<br><strong>出处</strong>：Biometrilca (1083), 70, 1, pp. 41-55<br><strong>doi号</strong>：<a target="_blank" rel="noopener" href="https://academic.oup.com/biomet/article-abstract/70/1/41/240879?login=false">点此查看全文</a><br><strong>飞书链接</strong>：<a target="_blank" rel="noopener" href="https://cqpqhy5koc9.feishu.cn/docx/Zp95d0fS6om1iexY3AqcibQCnyh?from=from_copylink">点此查看翻译版</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" href="/default-index/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AgioPan"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">AgioPan</p>
  <div class="site-description" itemprop="description">Solving equations, decoding life, exploring minds.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Agio910" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Agio910" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://orcid.org/0009-0005-1485-9515" title="orcid → https:&#x2F;&#x2F;orcid.org&#x2F;0009-0005-1485-9515" rel="noopener" target="_blank"><i class="fab fa-orcid fa-fw"></i>orcid</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:202111079094@mail.bnu.edu.cn" title="E-Mail → mailto:202111079094@mail.bnu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AgioPan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
