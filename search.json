[{"title":"24 Spring - 概率论课程判断题留档","url":"/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/","content":"  longlongago之前的概率论判断题作业，记录一下\nPDF file","categories":["Coursework"],"tags":["概率论","样本空间","随机变量","数字特征"]},{"title":"25 Fall - 哲学导论课程论文","url":"/2025/02/13/25%E7%A7%8B-%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BA%E6%96%87%E7%95%99%E6%A1%A3/","content":"  第一次有课程拿100分，留档记录一下课程论文，内容主要和确定性理论比较相关，以及对极端怀疑论的反驳。\nPDF file","categories":["Coursework"],"tags":["philosophy","确定性理论","维特根斯坦","怀疑论"]},{"title":"Longitudinal associations between family conflict and depression among family members：Evidence from CFPS, 2016-2020.","url":"/2025/02/25/Longitudinal%20associations%20between%20family%20conflict,%20intergenerational%20transmission,%20and%20adolescents%E2%80%99%20depressive%20symptoms%20evidence%20from%20China%20Family%20Panel%20studies/","content":"  I am honored to be the co-first author of this paper, and my main for data processing, data analysis, visualization, and paper writing.  Based on the 2016-2020 China Family Tracking Survey (CFPS) data, the study analyzed 1,772 adolescents and their parents over a four-year period, and for the first time systematically revealed the bidirectional mechanism of family conflict and adolescent depressive symptoms and the intergenerational transmission pathway. The study found that: （1） family conflict significantly exacerbates adolescent depression, and adolescent depression will in turn aggravate family conflict, forming a vicious cycle; （2） mothers’ depression has a particularly prominent impact on adolescent mental health, and adolescent depression may further trigger fathers’ depression; （3） mothers’ education level is an important protective factor against adolescent depression, and mothers with high levels of education can significantly reduce the risk of their children’s depression. risk. These findings provide key scientific support for the development of family-centered mental health intervention strategies, which are important for breaking the intergenerational transmission of depression and improving family functioning.\nPDF file","categories":["Publication"],"tags":["mental health","structural equation modeling","longitudinal study"]},{"title":"The Applications of Large Language Models in Mental Health Scoping Review.","url":"/2025/05/10/The%20Applications%20of%20Large%20Language%20Models%20in%20Mental%20Health%20Scoping%20Review/","content":"  I am honored to be the co-first author of this paper, and my main contrbution are data extraction and visualization.  Based on the 2019-2024 scoping review of 95 peer-reviewed articles, this study mapped the landscape of large language models (LLMs) applications in mental health across three key domains. The analysis revealed that LLMs are predominantly utilized for screening and detection of mental disorders (71%), with particular emphasis on depression detection (35%) and suicide risk prediction (13%). Additionally, LLMs demonstrate significant potential in supporting clinical treatments (33%) and facilitating mental health counseling and education (12%). Comparative assessments indicate that LLMs exhibit superior capabilities in information processing and natural language response generation relative to traditional non-transformer models and human performance in specific contexts. The research identified distinct advantages among different LLM architectures for various mental health applications, highlighting their promising role in addressing critical challenges in global mental healthcare, including detection efficiency, treatment effectiveness, privacy protection, and access to specialized care. These findings provide essential scientific evidence for the development and implementation of LLM-enhanced mental health interventions, which may significantly improve early detection rates and expand access to mental healthcare resources.\nPDF file","categories":["Publication"],"tags":["mental health","large language models","application","comparison"]},{"title":"吴恩达机器学习课程资料归档","url":"/2025/08/03/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E4%BB%B6%E7%95%99%E6%A1%A3/","content":"大概是24年暑假期间一周速通学完了吴恩达的机器学习，真真真是深入浅出，言简意赅， 记录一下吴恩达机器学习课程相关的PDF资料、讲义、笔记等，方便日后复习与查阅。\n课程链接吴恩达机器学习（B站全套）\n课堂上的PDF笔记\n\n网盘整体的文件通过网盘分享的文件：A最新版 吴恩达机器学习Deeplearning.ai链接: https://pan.baidu.com/s/1RGHnExutISizVeFNNR4OnQ?pwd=ue7m 提取码: ue7m \n","categories":["Review","Online course"],"tags":["机器学习","吴恩达","Review","监督学习","无监督学习"]},{"title":"数据结构与算法自学笔记（3）- 队列和栈相关","url":"/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%20%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9B%B8%E5%85%B3/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了栈和队列的基础实现、相互转换以及最小栈等核心内容，涵盖了链表实现、数组实现、循环队列等多种实现方式,包括了class013 -&gt; class016的内容。\n\n013【入门】队列和栈-链表、数组实现队列的基本概念队列（Queue）是一种先进先出（FIFO, First In First Out）的线性数据结构。元素从队尾（rear）插入，从队首（front）删除。\n队列的基本操作\nenqueue&#x2F;offer: 入队，将元素添加到队尾\ndequeue&#x2F;poll: 出队，从队首移除元素\nfront&#x2F;peek: 查看队首元素，但不移除\nisEmpty: 判断队列是否为空\nsize: 获取队列中元素个数\n\n队列的实现方式方式一：基于双端队列（deque）实现Python内置的collections.deque提供了高效的双端操作，但常数时间较慢。\nfrom collections import dequeclass Queue1:    &quot;&quot;&quot;    基于Python内置deque实现的队列    内部使用双向链表，常数操作较慢但使用简单    &quot;&quot;&quot;    def __init__(self):        self.queue = deque()  # 内部存储使用deque（双端队列）    def is_empty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return not self.queue    def offer(self, num):        &quot;&quot;&quot;向队列中加入元素，加到队尾&quot;&quot;&quot;        self.queue.append(num)    def poll(self):        &quot;&quot;&quot;从队列头部弹出元素&quot;&quot;&quot;        return self.queue.popleft()    def peek(self):        &quot;&quot;&quot;返回队列头的元素但不弹出&quot;&quot;&quot;        return self.queue[0]    def size(self):        &quot;&quot;&quot;返回队列中元素个数&quot;&quot;&quot;        return len(self.queue)\n\n方式二：基于固定数组实现在已知操作次数上限的情况下，使用固定数组实现具有更好的常数时间性能。\nclass Queue2:    &quot;&quot;&quot;    基于固定数组实现的队列    适用于已知加入操作总次数上限的场景    常数时间性能更好，是实际刷题中最常用的方式    &quot;&quot;&quot;    def __init__(self, n):        &quot;&quot;&quot;        初始化队列        参数: n - 加入操作的总次数上限        &quot;&quot;&quot;        self.queue = [0] * n  # 固定大小数组        self.l = 0  # 队首指针        self.r = 0  # 队尾指针    def is_empty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.l == self.r    def offer(self, num):        &quot;&quot;&quot;入队操作&quot;&quot;&quot;        self.queue[self.r] = num  # 在队尾位置插入元素        self.r += 1  # 队尾指针后移    def poll(self):        &quot;&quot;&quot;出队操作&quot;&quot;&quot;        num = self.queue[self.l]  # 取队首元素        self.l += 1  # 队首指针后移        return num    def head(self):        &quot;&quot;&quot;返回队首元素&quot;&quot;&quot;        return self.queue[self.l]    def tail(self):        &quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;        return self.queue[self.r - 1]    def size(self):        &quot;&quot;&quot;队列当前元素个数，区间[l, r)&quot;&quot;&quot;        return self.r - self.l\n\n栈的基本概念栈（Stack）是一种后进先出（LIFO, Last In First Out）的线性数据结构。元素只能从栈顶插入和删除。\n栈的基本操作\npush: 压栈，将元素添加到栈顶\npop: 弹栈，从栈顶移除元素\npeek&#x2F;top: 查看栈顶元素，但不移除\nisEmpty: 判断栈是否为空\nsize: 获取栈中元素个数\n\n栈的实现方式方式一：基于动态数组实现class Stack1:    &quot;&quot;&quot;    基于Python内置列表实现的栈    使用动态数组，常数时间不是最优但使用简单    &quot;&quot;&quot;    def __init__(self):        self.stack = []  # 用列表模拟栈    def is_empty(self):        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return len(self.stack) == 0    def push(self, num):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.stack.append(num)    def pop(self):        &quot;&quot;&quot;弹栈操作&quot;&quot;&quot;        return self.stack.pop()    def peek(self):        &quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;        return self.stack[-1]    def size(self):        &quot;&quot;&quot;返回栈的大小&quot;&quot;&quot;        return len(self.stack)\n\n方式二：基于固定数组实现class Stack2:    &quot;&quot;&quot;    基于固定数组实现的栈    适用于已知同时在栈里元素个数上限的场景    常数时间性能更好，空间可以复用    &quot;&quot;&quot;    def __init__(self, n):        &quot;&quot;&quot;        初始化栈        参数: n - 同时在栈里的元素个数上限        &quot;&quot;&quot;        self.stack = [0] * n  # 固定大小数组        self.size_ = 0  # 当前栈元素个数    def is_empty(self):        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return self.size_ == 0    def push(self, num):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.stack[self.size_] = num  # 在当前size位置插入        self.size_ += 1  # 元素个数+1    def pop(self):        &quot;&quot;&quot;弹栈操作&quot;&quot;&quot;        self.size_ -= 1  # 元素个数-1，先减后取值        return self.stack[self.size_]  # 返回弹出的元素    def peek(self):        &quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;        return self.stack[self.size_ - 1]    def size(self):        &quot;&quot;&quot;返回栈大小&quot;&quot;&quot;        return self.size_\n\n循环队列循环队列是队列的一种特殊实现，通过循环使用固定大小的数组来避免空间浪费。\nclass MyCircularQueue:    &quot;&quot;&quot;    循环队列实现    测试链接: https://leetcode.cn/problems/design-circular-queue/    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.queue = [0] * k  # 固定大小数组        self.l = 0  # 队首指针        self.r = 0  # 队尾指针        self.size = 0  # 当前元素个数        self.limit = k  # 容量上限    def enQueue(self, value):        &quot;&quot;&quot;        入队操作        返回: 成功返回True，队列满返回False        &quot;&quot;&quot;        if self.isFull():            return False  # 队列已满        else:            self.queue[self.r] = value  # 队尾插入元素            # 队尾指针循环移动            self.r = 0 if self.r == self.limit - 1 else self.r + 1            self.size += 1  # 元素个数+1            return True    def deQueue(self):        &quot;&quot;&quot;        出队操作        返回: 成功返回True，队列空返回False        &quot;&quot;&quot;        if self.isEmpty():            return False  # 队列为空        else:            # 队首指针循环移动            self.l = 0 if self.l == self.limit - 1 else self.l + 1            self.size -= 1  # 元素个数-1            return True    def Front(self):        &quot;&quot;&quot;返回队首元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.queue[self.l]    def Rear(self):        &quot;&quot;&quot;返回队尾元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            # 计算队尾指针的实际位置            last = self.limit - 1 if self.r == 0 else self.r - 1            return self.queue[last]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n\n014【入门】队列和栈入门题目-栈和队列相互实现用栈实现队列队列是先进先出（FIFO），而栈是后进先出（LIFO）。要用栈实现队列，需要使用两个栈来模拟队列的行为。\n算法思想使用两个栈：\n\n输入栈（in_stack）：负责接收新元素的push操作\n输出栈（out_stack）：负责输出元素的pop和peek操作\n\n关键规则\n倒数据条件：只有当输出栈为空时，才能从输入栈倒数据\n倒数据原则：如果要倒数据，必须将输入栈的数据全部倒完\n时间复杂度：虽然单次操作可能是O(n)，但均摊时间复杂度是O(1)\n\nclass MyQueue:    &quot;&quot;&quot;    用栈实现队列    测试链接: https://leetcode.cn/problems/implement-queue-using-stacks/    时间复杂度: 均摊O(1)    &quot;&quot;&quot;    def __init__(self):        self.in_stack = []     # 输入栈，负责push        self.out_stack = []    # 输出栈，负责pop/peek    def inToOut(self):        &quot;&quot;&quot;        倒数据操作：从输入栈将数据倒入输出栈        核心规则：        1) 输出栈空了，才能倒数据        2) 如果倒数据，输入栈必须倒完        &quot;&quot;&quot;        if not self.out_stack:                     # 只有输出栈为空才能倒            while self.in_stack:                   # 输入栈必须倒完                self.out_stack.append(self.in_stack.pop())    def push(self, x: int):        &quot;&quot;&quot;入队操作：新元素加入输入栈&quot;&quot;&quot;        self.in_stack.append(x)                    # 新元素压入输入栈        self.inToOut()                             # 检查是否需要倒数据    def pop(self) -&gt; int:        &quot;&quot;&quot;出队操作：从输出栈弹出元素&quot;&quot;&quot;        self.inToOut()                             # 确保输出栈有数据        return self.out_stack.pop()                # 弹出队首元素    def peek(self) -&gt; int:        &quot;&quot;&quot;查看队首元素：不移除，只查看&quot;&quot;&quot;        self.inToOut()                             # 确保输出栈有数据        return self.out_stack[-1]                  # 返回栈顶即队首    def empty(self) -&gt; bool:        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return not self.in_stack and not self.out_stack  # 两个栈都空才是空队列\n\n时间复杂度分析虽然inToOut()操作在最坏情况下需要O(n)时间，但通过均摊分析：\n\n每个元素最多被移动两次（输入栈→输出栈→出队列）\nn次操作的总时间复杂度为O(n)\n均摊时间复杂度为O(1)\n\n用队列实现栈栈是后进先出（LIFO），队列是先进先出（FIFO）。要用队列实现栈，需要在每次push操作后重新排列队列中的元素。\n算法思想使用一个双端队列（deque），在每次push新元素后，将队列中原有的元素依次移动到新元素后面，确保新元素总是在队首位置。\nfrom collections import dequeclass MyStack:    &quot;&quot;&quot;    用双端队列实现栈    测试链接: https://leetcode.cn/problems/implement-stack-using-queues/    &quot;&quot;&quot;    def __init__(self):        self.queue = deque()                       # 用deque实现队列    def push(self, x: int):        &quot;&quot;&quot;        压栈操作        时间复杂度: O(n)        核心思想: 新元素入队后，将前面所有元素重新排列到新元素后面        &quot;&quot;&quot;        n = len(self.queue)                        # 记录当前队列长度        self.queue.append(x)                       # 新元素加入队尾                # 将前面的n个元素依次移动到队尾        for _ in range(n):            self.queue.append(self.queue.popleft())    def pop(self) -&gt; int:        &quot;&quot;&quot;弹栈操作：弹出队首元素，即栈顶元素&quot;&quot;&quot;        return self.queue.popleft()    def top(self) -&gt; int:        &quot;&quot;&quot;查看栈顶元素：返回队首元素&quot;&quot;&quot;        return self.queue[0]    def empty(self) -&gt; bool:        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return not self.queue\n\n操作示例假设依次push元素1, 2, 3：\n初始状态: []push(1): [1]push(2): [2] -&gt; [2,1] (将1移动到2后面)push(3): [3,2,1] -&gt; [3,2,1] (将2,1依次移动到3后面)\n\n最终队列状态为[3,2,1]，队首元素3就是栈顶元素，符合LIFO特性。\n\n015【入门】栈的入门题目-最小栈最小栈问题最小栈要求实现一个栈，除了基本的栈操作外，还要能够在O(1)时间内获取栈中的最小元素。\n问题分析核心挑战是如何在保持基本栈操作O(1)时间复杂度的同时，追踪当前栈中的最小值。当栈顶元素（恰好是最小值）被弹出时，需要快速知道剩余元素中的最小值。\n解决方案：辅助栈法使用两个栈：\n\n数据栈（data）：存储实际数据\n最小值栈（min）：存储对应位置的最小值\n\n实现方法一：基于列表class MinStack1:    &quot;&quot;&quot;    最小栈实现方法一：使用Python列表    测试链接: https://leetcode.cn/problems/min-stack/    时间复杂度: 所有操作均为O(1)    &quot;&quot;&quot;    def __init__(self):        self.data = []  # 数据栈，存储实际元素        self.min = []   # 最小值栈，存储对应位置的最小值    def push(self, val):        &quot;&quot;&quot;        压栈操作        核心思想: 每次压栈时，同时在最小值栈中记录当前的最小值        &quot;&quot;&quot;        self.data.append(val)  # 将val压入数据栈                if not self.min or val &lt;= self.min[-1]:  # 如果最小栈为空或val是新的最小值            self.min.append(val)  # 将val压入最小栈        else:  # 否则val不是最小值            self.min.append(self.min[-1])  # 将当前最小值再次压入最小栈    def pop(self):        &quot;&quot;&quot;弹栈操作：同时弹出两个栈的栈顶元素&quot;&quot;&quot;        self.data.pop()  # 弹出数据栈栈顶        self.min.pop()   # 弹出最小栈栈顶    def top(self):        &quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;        return self.data[-1]  # 返回数据栈栈顶元素    def getMin(self):        &quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;        return self.min[-1]   # 返回最小栈栈顶元素\n\n工作原理示例假设依次压入元素：5, 2, 7, 1, 3\n\n\n\n操作\n数据栈\n最小栈\n说明\n\n\n\npush(5)\n[5]\n[5]\n5是第一个元素，也是最小值\n\n\npush(2)\n[5,2]\n[5,2]\n2比5小，成为新的最小值\n\n\npush(7)\n[5,2,7]\n[5,2,2]\n7比2大，最小值仍是2\n\n\npush(1)\n[5,2,7,1]\n[5,2,2,1]\n1比2小，成为新的最小值\n\n\npush(3)\n[5,2,7,1,3]\n[5,2,2,1,1]\n3比1大，最小值仍是1\n\n\n实现方法二：基于固定数组class MinStack2:    &quot;&quot;&quot;    最小栈实现方法二：使用固定大小数组    适用于已知最大容量的场景，常数时间性能更好    &quot;&quot;&quot;    def __init__(self):        # 根据leetcode测试数据实验得出的容量上限        # 如果测试数据增加导致溢出，需要调大此值        self.MAXN = 8001        self.data = [0] * self.MAXN  # 数据数组        self.min = [0] * self.MAXN   # 最小值数组        self.size = 0  # 当前栈大小    def push(self, val):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.data[self.size] = val  # 在size位置存储val                if self.size == 0 or val &lt;= self.min[self.size - 1]:  # 第一个元素或新的最小值            self.min[self.size] = val  # 存储val作为最小值        else:  # val不是最小值            self.min[self.size] = self.min[self.size - 1]  # 复制前一个最小值                self.size += 1  # 栈大小加1    def pop(self):        &quot;&quot;&quot;弹栈操作：只需将size减1，不需要实际删除数据&quot;&quot;&quot;        self.size -= 1    def top(self):        &quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;        return self.data[self.size - 1]    def getMin(self):        &quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;        return self.min[self.size - 1]\n\n复杂度分析时间复杂度\npush操作：O(1) - 只需要常数次比较和赋值\npop操作：O(1) - 只需要移动指针或减少计数\ntop操作：O(1) - 直接访问数组元素\ngetMin操作：O(1) - 直接访问最小值栈顶\n\n空间复杂度\n总空间复杂度：O(n) - 需要两个栈存储数据\n额外空间：O(n) - 最小值栈的空间开销\n\n优化思考虽然辅助栈法简单易懂，但存在空间冗余。可以考虑以下优化：\n\n稀疏存储：最小值栈只在最小值更新时才压入新值\n差值存储：存储与最小值的差值而非绝对值\n链表实现：在节点中直接存储当前最小值\n\n\n数据结构选择指南性能对比\n\n\n实现方式\n时间复杂度\n空间复杂度\n常数因子\n适用场景\n\n\n\nPython内置容器\nO(1)均摊\nO(n)\n较大\n快速原型，不追求极致性能\n\n\n固定数组\nO(1)\nO(n)\n较小\n已知容量上限，追求性能\n\n\n双栈&#x2F;双队列\nO(1)均摊\nO(n)\n中等\n功能转换，教学示例\n\n\n016【入门】双端队列-双链表和固定数组实现双端队列的基本概念双端队列（Deque，Double-ended Queue）是一种特殊的线性数据结构，允许在队列的两端进行插入和删除操作。与普通队列只能在一端插入、另一端删除不同，双端队列提供了更大的灵活性。\n双端队列的基本操作\ninsertFront: 在队首插入元素\ninsertLast: 在队尾插入元素  \ndeleteFront: 删除队首元素\ndeleteLast: 删除队尾元素\ngetFront: 获取队首元素\ngetRear: 获取队尾元素\nisEmpty: 判断队列是否为空\nisFull: 判断队列是否已满\n\n循环双端队列的实现循环双端队列是双端队列的一种特殊实现，使用固定大小的数组并通过循环索引来管理队列的边界。\n实现方式一：基于Python列表class MyCircularDeque1:    &quot;&quot;&quot;    基于Python列表实现的循环双端队列    内部使用动态数组，操作简单但常数时间较慢    测试链接: https://leetcode.cn/problems/design-circular-deque/    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环双端队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.deque = []  # 用列表模拟双端队列        self.size = 0    # 当前队列大小        self.limit = k   # 队列容量    def insertFront(self, value):        &quot;&quot;&quot;        在队首插入元素        时间复杂度: O(n) - 需要移动所有现有元素        &quot;&quot;&quot;        if self.isFull():            return False        else:            self.deque.insert(0, value)  # 在索引0位置插入，其他元素后移            self.size += 1            return True    def insertLast(self, value):        &quot;&quot;&quot;        在队尾插入元素        时间复杂度: O(1)均摊        &quot;&quot;&quot;        if self.isFull():            return False        else:            self.deque.append(value)  # 直接添加到列表末尾            self.size += 1            return True    def deleteFront(self):        &quot;&quot;&quot;        删除队首元素        时间复杂度: O(n) - 需要移动所有剩余元素        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            self.size -= 1            self.deque.pop(0)  # 删除索引0的元素，其他元素前移            return True    def deleteLast(self):        &quot;&quot;&quot;        删除队尾元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            self.size -= 1            self.deque.pop()  # 删除列表末尾元素            return True    def getFront(self):        &quot;&quot;&quot;获取队首元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[0]    def getRear(self):        &quot;&quot;&quot;获取队尾元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[-1]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n实现方式二：基于固定数组class MyCircularDeque2:    &quot;&quot;&quot;    基于固定数组实现的循环双端队列    使用循环索引管理队列边界，常数时间性能更好    适用于已知容量上限的场景    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环双端队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.deque = [0] * k  # 固定长度数组        self.l = 0            # 队首指针        self.r = 0            # 队尾指针        self.size = 0         # 当前队列大小        self.limit = k        # 队列容量    def insertFront(self, value):        &quot;&quot;&quot;        在队首插入元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isFull():            return False        else:            if self.isEmpty():                # 空队列情况，队首和队尾指针都指向同一位置                self.l = self.r = 0                self.deque[0] = value            else:                # 队首指针向前移动（循环）                self.l = self.l - 1 if self.l != 0 else self.limit - 1                self.deque[self.l] = value            self.size += 1            return True    def insertLast(self, value):        &quot;&quot;&quot;        在队尾插入元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isFull():            return False        else:            if self.isEmpty():                # 空队列情况                self.l = self.r = 0                self.deque[0] = value            else:                # 队尾指针向后移动（循环）                self.r = 0 if self.r == self.limit - 1 else self.r + 1                self.deque[self.r] = value            self.size += 1            return True    def deleteFront(self):        &quot;&quot;&quot;        删除队首元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            if self.size == 1:                # 删除后队列变空，可选择重置指针                pass  # 这里不重置l和r，因为逻辑上没有影响            # 队首指针向后移动（循环）            self.l = 0 if self.l == self.limit - 1 else self.l + 1            self.size -= 1            return True    def deleteLast(self):        &quot;&quot;&quot;        删除队尾元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            if self.size == 1:                # 删除后队列变空                pass  # 不重置指针            # 队尾指针向前移动（循环）            self.r = self.limit - 1 if self.r == 0 else self.r - 1            self.size -= 1            return True    def getFront(self):        &quot;&quot;&quot;获取队首元素&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[self.l]    def getRear(self):        &quot;&quot;&quot;获取队尾元素&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[self.r]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n循环索引的关键理解指针移动规律在固定数组实现中，关键是理解循环索引的移动：\n# 向后移动（队尾插入，队首删除）next_index = 0 if current_index == limit - 1 else current_index + 1# 向前移动（队首插入，队尾删除）  prev_index = limit - 1 if current_index == 0 else current_index - 1\n\n边界情况处理\n空队列插入：第一个元素插入时，队首和队尾指针都指向同一位置\n单元素删除：删除唯一元素后队列变空，但指针位置不需要重置\n满队列检测：通过size变量而非指针位置来判断队列是否已满\n\n性能分析时间复杂度对比\n\n\n操作\n列表实现\n数组实现\n说明\n\n\n\ninsertFront\nO(n)\nO(1)\n列表需要移动所有元素\n\n\ninsertLast\nO(1)均摊\nO(1)\n列表可能需要扩容\n\n\ndeleteFront\nO(n)\nO(1)\n列表需要移动所有元素\n\n\ndeleteLast\nO(1)\nO(1)\n两种实现都是常数时间\n\n\ngetFront&#x2F;getRear\nO(1)\nO(1)\n直接索引访问\n\n\n空间复杂度\n列表实现：O(k)，但可能因为动态扩容导致额外开销\n数组实现：O(k)，固定空间，无额外开销\n\n应用场景双端队列的典型应用\n滑动窗口问题：需要在窗口两端进行操作\n回文检测：从两端向中间检查字符\n撤销&#x2F;重做功能：需要在两端添加和删除操作记录\n广度优先搜索变种：某些图算法需要双向扩展\n\n与其他数据结构的对比\n\n\n数据结构\n队首操作\n队尾操作\n适用场景\n\n\n\n普通队列\n删除O(1)\n插入O(1)\nFIFO场景\n\n\n栈\n插入&#x2F;删除O(1)\n无操作\nLIFO场景\n\n\n双端队列\n插入&#x2F;删除O(1)\n插入&#x2F;删除O(1)\n需要两端操作\n\n\n动态数组\n插入O(n)，删除O(n)\n插入O(1)均摊，删除O(1)\n随机访问\n\n\n双端队列提供了比普通队列和栈更大的灵活性，在需要两端操作的算法中具有重要作用。固定数组的循环实现虽然代码复杂度稍高，但提供了最优的时间和空间性能。刷题中优先选择固定数组实现，性能更好，实际工程中如果容量不确定，可以考虑列表实现或者动态扩容的数组；此外，固定数据能使得内存使用更可控。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","队列","栈","节点遍历","列表","数组"]},{"title":"数据结构与算法自学笔记（1）- 二进制&位运算&排序算法&二分搜索","url":"/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%20%E4%BA%8C%E8%BF%9B%E5%88%B6&%E4%BD%8D%E8%BF%90%E7%AE%97&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了class002 -&gt; class 007的内容，涵盖了社会实验模拟、位运算、基础排序算法、算法验证方法、二分搜索以及复杂度分析等核心内容。\n原代码是java版，我改成了python\n\n002【入门】从社会实验到入门提醒基尼系数的理论基础基尼系数是经济学中衡量收入分配不平等程度的重要指标，其数学定义为：\n$$G &#x3D; \\frac{\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{n}|x_i - x_j|}{2n\\sum_{i&#x3D;1}^{n}x_i}$$\n其中 $x_i$ 表示第 $i$ 个个体的财富值，$n$ 为总人数。\n基尼系数的经济学意义\nG &#x3D; 0：完全平等，所有人财富相同\nG &#x3D; 1：完全不平等，一人拥有全部财富  \nG &#x3D; 0.4-0.5：国际公认的贫富差距警戒线\nG &gt; 0.5：社会可能面临动荡风险\n\n财富分配模拟实验通过计算机模拟研究在完全随机的财富转移过程中，社会财富分配的自然演化规律。\nimport numpy as npimport randomdef calculate_gini(wealth):    &quot;&quot;&quot;    计算基尼系数的函数    参数: wealth - 财富分布列表    返回: 基尼系数值    &quot;&quot;&quot;    n = len(wealth)                        # 获取人数    sum_of_wealth = sum(wealth)            # 计算总财富    sum_of_absolute_differences = 0        # 初始化财富差异总和        # 计算所有个体间财富差异的绝对值之和    for i in range(n):        for j in range(n):            sum_of_absolute_differences += abs(wealth[i] - wealth[j])        # 根据基尼系数公式计算并返回结果    return sum_of_absolute_differences / (2 * n * sum_of_wealth)def experiment(n, t):    &quot;&quot;&quot;    财富分配模拟实验    参数: n - 人数, t - 模拟轮数    &quot;&quot;&quot;    wealth = [100] * n                     # 初始化每人财富为100        for _ in range(t):                     # 进行t轮模拟        has_money = [w &gt; 0 for w in wealth]  # 判断每个人是否有钱可转        transfers = []                     # 记录本轮转账列表                for j in range(n):                 # 遍历每个人            if has_money[j]:               # 如果该人有钱                other = j                  # 初始化接收者为自己                while other == j:          # 确保接收者不是自己                    other = random.randint(0, n - 1)  # 随机选择其他人                transfers.append((j, other))          # 记录转账关系                # 统一执行所有转账，避免执行顺序影响结果        for giver, receiver in transfers:            wealth[giver] -= 1             # 转出者财富减1            wealth[receiver] += 1          # 接收者财富加1        wealth.sort()                          # 按财富排序便于观察分布        # 输出结果分析    print(&quot;财富分布(从贫穷到富有):&quot;)    for idx, w in enumerate(wealth):        print(int(w), end=&#x27; &#x27;)        if idx % 10 == 9:                  # 每10个数换行            print()    print()    print(&quot;社会基尼系数:&quot;, calculate_gini(wealth))\n\n实验意义与启示\n随机性中的必然性：即使在完全公平的随机转移规则下，财富差距仍会自然产生\n马太效应：财富分配存在自然的分化趋势\n社会政策启示：需要主动的调节机制来维护社会公平\n\n\n003【入门】二进制和位运算计算机数值表示系统正数的二进制表示正数采用标准的二进制表示法，最高位为符号位（0表示正数）。\n负数的补码表示负数采用补码（Two’s Complement）表示：\n\n原码按位取反\n结果加1\n\n$$\\text{负数补码} &#x3D; \\sim(\\text{原码}) + 1$$\ndef print_binary(num):    &quot;&quot;&quot;    打印32位二进制表示    参数: num - 要打印的整数    &quot;&quot;&quot;    s = &#x27;&#x27;                                 # 初始化二进制字符串    for i in range(31, -1, -1):           # 从最高位到最低位遍历        # 通过位与运算判断第i位是否为1        s += &#x27;1&#x27; if (num &amp; (1 &lt;&lt; i)) != 0 else &#x27;0&#x27;    print(s)                              # 输出32位二进制表示# 演示正负数的二进制表示if __name__ == &quot;__main__&quot;:    a = 78                                # 正数示例    print(f&quot;正数&#123;a&#125;的二进制表示:&quot;)    print_binary(a)        b = -6                                # 负数示例      print(f&quot;负数&#123;b&#125;的二进制表示:&quot;)    print_binary(b)        # 验证补码计算    print(f&quot;~&#123;a&#125; + 1 = &#123;~a + 1&#125;&quot;)        # 计算a的相反数    print_binary(~a + 1)\n\n核心位运算操作基本位运算符详解def bitwise_operations_demo():    &quot;&quot;&quot;位运算操作演示&quot;&quot;&quot;    &#x27;&#x27;&#x27;0b 是Python中表示二进制数字的前缀。&#x27;&#x27;&#x27;    g = 0b0001010                         # 二进制字面量：10    h = 0b0001100                         # 二进制字面量：12        print(&quot;操作数g:&quot;, bin(g))    print(&quot;操作数h:&quot;, bin(h))        # 按位或运算：有1则1    print(&quot;g | h  =&quot;, bin(g | h))         # 0b1110 = 14        # 按位与运算：全1则1      print(&quot;g &amp; h  =&quot;, bin(g &amp; h))         # 0b1000 = 8        # 按位异或运算：不同则1    print(&quot;g ^ h  =&quot;, bin(g ^ h))         # 0b0110 = 6def shift_operations_demo():    &quot;&quot;&quot;移位运算演示&quot;&quot;&quot;    i = 0b0011010                         # 二进制：26    print(f&quot;原数: &#123;i&#125;, 二进制: &#123;bin(i)&#125;&quot;)        # 左移运算：相当于乘以2的幂次    print(f&quot;&#123;i&#125; &lt;&lt; 1 = &#123;i &lt;&lt; 1&#125;&quot;)        # 26 * 2 = 52    print(f&quot;&#123;i&#125; &lt;&lt; 2 = &#123;i &lt;&lt; 2&#125;&quot;)        # 26 * 4 = 104      print(f&quot;&#123;i&#125; &lt;&lt; 3 = &#123;i &lt;&lt; 3&#125;&quot;)        # 26 * 8 = 208        # 右移运算：相当于除以2的幂次（向下取整）    k = 10    print(f&quot;&#123;k&#125; &gt;&gt; 1 = &#123;k &gt;&gt; 1&#125;&quot;)        # 10 / 2 = 5    print(f&quot;&#123;k&#125; &gt;&gt; 2 = &#123;k &gt;&gt; 2&#125;&quot;)        # 10 / 4 = 2    print(f&quot;&#123;k&#125; &gt;&gt; 3 = &#123;k &gt;&gt; 3&#125;&quot;)        # 10 / 8 = 1\n\n逻辑运算与位运算的重要区别def return_true():    print(&quot;执行了return_true函数&quot;)    return Truedef return_false():    print(&quot;执行了return_false函数&quot;)     return Falsedef logical_vs_bitwise():    &quot;&quot;&quot;演示逻辑运算与位运算的区别&quot;&quot;&quot;    print(&quot;=== 位运算测试 ===&quot;)    # 位运算：两个函数都会被调用    test1 = return_true() | return_false()    print(f&quot;位运算结果: &#123;test1&#125;&quot;)        print(&quot;=== 逻辑运算测试 ===&quot;)     # 逻辑运算：存在短路求值，第二个函数可能不被调用    test2 = return_true() or return_false()    print(f&quot;逻辑运算结果: &#123;test2&#125;&quot;)\n\n位运算的实际应用\n快速乘除法：左移代替乘法，右移代替除法\n奇偶性判断：num &amp; 1 == 0 判断偶数。这是因为：num &amp; 1 只保留 num 的二进制最低位，其余全部变成0。\n集合操作：用位掩码表示集合的并、交、差运算\n状态压缩：在动态规划中压缩状态空间\n\n\n004【入门】选择、冒泡、插入排序理解python中的class：什么是“实例化类”？\n类（class）：可以理解为一个“模具”或者“模板”，描述一类对象应该有哪些属性和行为。\n实例（instance）：就是根据这个“模具”制造出来的一个具体的“物品”。\n实例化：把类变成实例（对象）的过程，叫做实例化。\n\n选择排序（Selection Sort）算法思想每次从未排序部分选择最小（或最大）元素，将其放置到已排序部分的末尾。\n时间复杂度分析\n比较次数：$\\sum_{i&#x3D;0}^{n-2}(n-1-i) &#x3D; \\frac{n(n-1)}{2} &#x3D; O(n^2)$\n交换次数：$O(n)$\n总体复杂度：$O(n^2)$\n\nclass SortingAlgorithms:        @staticmethod    def swap(arr, i, j):        &quot;&quot;&quot;        交换数组中两个位置的元素        参数: arr - 数组, i,j - 要交换的索引        &quot;&quot;&quot;        arr[i], arr[j] = arr[j], arr[i]  # Python的元组赋值交换        @staticmethod    def selection_sort(arr):        &quot;&quot;&quot;        选择排序实现        时间复杂度: O(n²), 空间复杂度: O(1)        不稳定排序        &quot;&quot;&quot;        if arr is None or len(arr) &lt; 2:   # 边界条件检查            return                # 外层循环控制已排序部分的边界        for i in range(len(arr) - 1):            min_index = i                  # 假设当前位置为最小值                        # 内层循环在未排序部分寻找真正的最小值            for j in range(i + 1, len(arr)):                if arr[j] &lt; arr[min_index]:  # 找到更小的元素                    min_index = j           # 更新最小值索引                        # 将找到的最小值与当前位置交换            SortingAlgorithms.swap(arr, i, min_index)\n\n冒泡排序（Bubble Sort）算法思想重复遍历数组，比较相邻元素并在必要时交换，使得大元素逐渐”冒泡”到数组末尾。\n@staticmethoddef bubble_sort(arr):    &quot;&quot;&quot;    冒泡排序实现    时间复杂度: O(n²), 空间复杂度: O(1)      稳定排序    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:   # 边界条件检查        return        # 外层循环控制未排序部分的右边界    for end in range(len(arr) - 1, 0, -1):        # 内层循环进行相邻元素比较和交换        for i in range(end):            if arr[i] &gt; arr[i + 1]:    # 如果前面元素大于后面元素                SortingAlgorithms.swap(arr, i, i + 1)  # 交换位置                # 经过一轮后，最大元素&quot;冒泡&quot;到末尾\n\n冒泡排序的优化@staticmethod  def bubble_sort_optimized(arr):    &quot;&quot;&quot;    优化版冒泡排序：添加提前终止条件    如果某轮遍历中没有发生交换，说明数组已有序    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return            for end in range(len(arr) - 1, 0, -1):        swapped = False               # 标记本轮是否发生交换        for i in range(end):            if arr[i] &gt; arr[i + 1]:                SortingAlgorithms.swap(arr, i, i + 1)                swapped = True        # 发生了交换                if not swapped:               # 如果本轮没有交换            break                     # 数组已有序，提前结束\n\n插入排序（Insertion Sort）算法思想将数组分为已排序和未排序两部分，依次将未排序元素插入到已排序部分的正确位置。\n@staticmethoddef insertion_sort(arr):    &quot;&quot;&quot;    插入排序实现    时间复杂度: 最坏O(n²), 最好O(n), 平均O(n²)    空间复杂度: O(1)    稳定排序，对小规模或近似有序数据效率高    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:   # 边界条件检查        return        # 从第二个元素开始，逐个插入到已排序部分    for i in range(1, len(arr)):        # 从当前位置向前比较，寻找插入位置        for j in range(i - 1, -1, -1):            if arr[j] &gt; arr[j + 1]:    # 如果前面元素大于后面元素                SortingAlgorithms.swap(arr, j, j + 1)  # 交换位置            else:                break                  # 找到正确位置，提前结束内层循环\n\n插入排序的另一种实现@staticmethoddef insertion_sort_v2(arr):    &quot;&quot;&quot;    插入排序的另一种实现：先保存要插入的元素，然后移动其他元素    减少交换次数，提高效率    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return            for i in range(1, len(arr)):        key = arr[i]                  # 保存要插入的元素        j = i - 1                     # 从已排序部分的末尾开始                # 向右移动大于key的元素        while j &gt;= 0 and arr[j] &gt; key:            arr[j + 1] = arr[j]       # 元素后移            j -= 1                arr[j + 1] = key              # 插入key到正确位置\n\n排序算法性能对比\n\n\n算法\n时间复杂度(最好)\n时间复杂度(平均)\n时间复杂度(最坏)\n空间复杂度\n稳定性\n\n\n\n选择排序\n$O(n^2)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n不稳定\n\n\n冒泡排序\n$O(n)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n稳定\n\n\n插入排序\n$O(n)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n稳定\n\n\n\n005【入门】对数器-验证的重要手段对数器的理论基础对数器（Logarithmic Validator）是一种系统性验证算法正确性的重要工具，通过大量随机测试用例来检验算法实现的可靠性。\n对数器设计的六个核心原则\n确定待测算法a：需要验证正确性的高效算法\n实现简单算法b：复杂度可能不优但逻辑简单、容易验证正确的算法  \n构建随机样本生成器：能够产生各种边界情况的测试数据\n对比验证：在相同输入下比较两种算法的输出结果\n错误定位：当发现不一致时，人工分析并修正错误\n大规模验证：通过大量测试建立对算法正确性的信心\n\n对数器实现框架（以上节课的三种排序方法为例）import randomclass AlgorithmValidator:    &quot;&quot;&quot;算法验证器类&quot;&quot;&quot;        @staticmethod    def random_array(n, v):        &quot;&quot;&quot;        生成随机数组        参数: n - 数组长度, v - 元素值域[1,v]        返回: 长度为n的随机数组        &quot;&quot;&quot;        # 使用列表推导式生成随机数组        return [random.randint(1, v) for _ in range(n)]        @staticmethod    def copy_array(arr):        &quot;&quot;&quot;        数组深拷贝        参数: arr - 原数组        返回: 原数组的副本        &quot;&quot;&quot;        return arr[:]                     # 切片操作创建新列表        @staticmethod      def arrays_equal(arr1, arr2):        &quot;&quot;&quot;        比较两个数组是否相等        参数: arr1, arr2 - 待比较的数组        返回: 布尔值表示是否相等        &quot;&quot;&quot;        if len(arr1) != len(arr2):        # 长度不等直接返回False            return False                # 逐元素比较        for a, b in zip(arr1, arr2):            if a != b:                return False        return True        @staticmethod    def comprehensive_sort_test():        &quot;&quot;&quot;        排序算法综合测试        使用对数器方法验证多种排序算法的正确性        &quot;&quot;&quot;        # 测试参数配置        N = 200                          # 数组最大长度        V = 1000                         # 元素最大值        test_times = 50000               # 测试次数                print(&quot;算法验证开始...&quot;)                for test_round in range(test_times):            # 生成随机测试用例            n = random.randint(0, N - 1)  # 随机数组长度            arr = AlgorithmValidator.random_array(n, V)                        # 创建多个数组副本用于不同算法测试            arr_selection = AlgorithmValidator.copy_array(arr)            arr_bubble = AlgorithmValidator.copy_array(arr)              arr_insertion = AlgorithmValidator.copy_array(arr)            arr_builtin = AlgorithmValidator.copy_array(arr)                        # 应用不同排序算法            SortingAlgorithms.selection_sort(arr_selection)            SortingAlgorithms.bubble_sort(arr_bubble)            SortingAlgorithms.insertion_sort(arr_insertion)            arr_builtin.sort()            # Python内置排序作为标准答案                        # 结果一致性验证            if not (AlgorithmValidator.arrays_equal(arr_selection, arr_builtin) and                    AlgorithmValidator.arrays_equal(arr_bubble, arr_builtin) and                      AlgorithmValidator.arrays_equal(arr_insertion, arr_builtin)):                                # 发现错误时输出详细信息                print(&quot;发现算法错误!&quot;)                print(f&quot;测试轮次: &#123;test_round + 1&#125;&quot;)                print(f&quot;原始数组: &#123;arr&#125;&quot;)                print(f&quot;选择排序: &#123;arr_selection&#125;&quot;)                print(f&quot;冒泡排序: &#123;arr_bubble&#125;&quot;)                print(f&quot;插入排序: &#123;arr_insertion&#125;&quot;)                print(f&quot;内置排序: &#123;arr_builtin&#125;&quot;)                return False                            # 每完成1000次测试输出进度            if (test_round + 1) % 1000 == 0:                print(f&quot;已完成 &#123;test_round + 1&#125; 次测试...&quot;)                print(&quot;所有测试通过！算法实现正确。&quot;)        return True\n\n对数器方法的优势\n自动化验证：减少人工测试的工作量和错误率\n覆盖边界情况：随机生成能够触及各种极端情况\n置信度建立：大量测试通过后可以高度确信算法正确性\n错误定位：一旦发现问题能够提供具体的错误样例\n\n\n006【入门】二分搜索二分搜索的数学基础二分搜索基于分治思想，每次将搜索空间减半，时间复杂度为 $O(\\log n)$。\n设数组长度为 $n$，经过 $k$ 次二分后搜索空间大小为 $\\frac{n}{2^k}$，当搜索空间减小到1时：\n$$\\frac{n}{2^k} &#x3D; 1 \\Rightarrow k &#x3D; \\log_2 n$$\n基础二分搜索问题：判断有序数组中是否存在目标值def binary_search_exist(arr, target):    &quot;&quot;&quot;    在有序数组中查找目标值是否存在    参数: arr - 有序数组, target - 目标值    返回: True/False 表示是否存在    时间复杂度: O(log n), 空间复杂度: O(1)    &quot;&quot;&quot;    if arr is None or len(arr) == 0:      # 边界条件：空数组        return False        left, right = 0, len(arr) - 1         # 初始化搜索边界[left, right]        while left &lt;= right:                  # 搜索空间非空时继续        # 防止整数溢出的中点计算方法        mid = left + (right - left) // 2   # 等价于 (left + right) // 2                if arr[mid] == target:            # 找到目标值            return True        elif arr[mid] &gt; target:           # 目标值在左半部分            right = mid - 1               # 收缩右边界        else:                             # 目标值在右半部分              left = mid + 1                # 收缩左边界        return False                          # 搜索完毕未找到\n\n暴力验证方法def linear_search_exist(arr, target):    &quot;&quot;&quot;    线性搜索验证方法    用于对数器验证二分搜索的正确性    &quot;&quot;&quot;    for element in arr:                   # 遍历数组每个元素        if element == target:             # 找到目标值            return True    return False                          # 未找到目标值\n\n二分搜索的边界查找变种查找左边界：&gt;&#x3D;target的最左位置def binary_search_left_bound(arr, target):    &quot;&quot;&quot;    在有序数组中查找 &gt;= target 的最左位置    参数: arr - 有序数组, target - 目标值    返回: 满足条件的最左索引，不存在返回-1    &quot;&quot;&quot;    if arr is None or len(arr) == 0:        return -1        left, right = 0, len(arr) - 1    ans = -1                              # 记录答案，初始化为-1表示未找到        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] &gt;= target:            # 当前元素满足条件            ans = mid                     # 更新答案            right = mid - 1               # 继续在左半部分寻找更左的位置        else:                             # 当前元素小于target            left = mid + 1                # 在右半部分继续搜索        return ansdef linear_search_left_bound(arr, target):    &quot;&quot;&quot;线性搜索验证：查找&gt;=target的最左位置&quot;&quot;&quot;    for i in range(len(arr)):             # 从左到右遍历        if arr[i] &gt;= target:              # 找到第一个满足条件的位置            return i    return -1                             # 未找到\n\n查找右边界：&lt;&#x3D;target的最右位置def binary_search_right_bound(arr, target):    &quot;&quot;&quot;    在有序数组中查找 &lt;= target 的最右位置    参数: arr - 有序数组, target - 目标值      返回: 满足条件的最右索引，不存在返回-1    &quot;&quot;&quot;    if arr is None or len(arr) == 0:        return -1        left, right = 0, len(arr) - 1    ans = -1                              # 记录答案        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] &lt;= target:            # 当前元素满足条件            ans = mid                     # 更新答案            left = mid + 1                # 继续在右半部分寻找更右的位置        else:                             # 当前元素大于target            right = mid - 1               # 在左半部分继续搜索        return ansdef linear_search_right_bound(arr, target):    &quot;&quot;&quot;线性搜索验证：查找&lt;=target的最右位置&quot;&quot;&quot;    for i in range(len(arr) - 1, -1, -1): # 从右到左遍历        if arr[i] &lt;= target:              # 找到第一个满足条件的位置            return i    return -1                             # 未找到\n\n峰值元素查找问题定义在数组中找到任意一个峰值元素（比左右邻居都大的元素），假设边界外的元素为负无穷。\ndef find_peak_element(arr):    &quot;&quot;&quot;    查找数组中的峰值元素    参数: arr - 整数数组（相邻元素不相等）    返回: 任意峰值元素的索引    时间复杂度: O(log n)    &quot;&quot;&quot;    n = len(arr)        # 边界情况处理    if n == 1:                            # 单元素数组        return 0    if arr[0] &gt; arr[1]:                   # 第一个元素是峰值        return 0      if arr[n-1] &gt; arr[n-2]:              # 最后一个元素是峰值        return n - 1        # 在 [1, n-2] 范围内二分搜索    left, right = 1, n - 2        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid-1] &gt; arr[mid]:         # 左邻居更大，峰值在左半部分            right = mid - 1        elif arr[mid] &lt; arr[mid+1]:       # 右邻居更大，峰值在右半部分              left = mid + 1        else:                             # arr[mid-1] &lt; arr[mid] &gt; arr[mid+1]            return mid                    # 找到峰值        return -1                             # 理论上不会到达这里\n\n峰值查找的正确性证明定理：在满足相邻元素不相等的数组中，上述算法一定能找到峰值。\n证明：\n\n边界已处理端点峰值。\n二分查找时，每次都能缩小到含有峰值的半区。\n因为每次都“爬坡”，必然最终会达到一个峰值。\n相邻元素不等消除了平台的歧义。\n因此，算法在O(log n)时间内一定能找到一个峰值。\n\n二分搜索验证框架def test_binary_search_algorithms():    &quot;&quot;&quot;二分搜索算法综合测试&quot;&quot;&quot;    N = 100                               # 数组最大长度    V = 1000                              # 元素值域    test_times = 500000                   # 测试次数        print(&quot;二分搜索算法测试开始...&quot;)        for _ in range(test_times):        # 生成随机有序数组        n = random.randint(0, N - 1)        arr = [random.randint(1, V) for _ in range(n)]        arr.sort()                        # 确保数组有序                target = random.randint(0, V - 1) # 随机目标值                # 验证基础二分搜索        if binary_search_exist(arr, target) != linear_search_exist(arr, target):            print(&quot;基础二分搜索错误!&quot;)            return False                # 验证左边界查找            if binary_search_left_bound(arr, target) != linear_search_left_bound(arr, target):            print(&quot;左边界查找错误!&quot;)            return False                    # 验证右边界查找        if binary_search_right_bound(arr, target) != linear_search_right_bound(arr, target):            print(&quot;右边界查找错误!&quot;)            return False        print(&quot;所有二分搜索测试通过!&quot;)    return True\n\n\n007【入门】时间复杂度和空间复杂度时间复杂度的数学基础渐近记号系统设 $f(n)$ 和 $g(n)$ 为定义在正整数集上的函数：\n\n大O记号 $O(g(n))$：$f(n) &#x3D; O(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \\geq n_0$ 有 $f(n) \\leq c \\cdot g(n)$\n大Ω记号 $\\Omega(g(n))$：$f(n) &#x3D; \\Omega(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \\geq n_0$ 有 $f(n) \\geq c \\cdot g(n)$  \n大Θ记号 $\\Theta(g(n))$：$f(n) &#x3D; \\Theta(g(n))$ 当且仅当 $f(n) &#x3D; O(g(n))$ 且 $f(n) &#x3D; \\Omega(g(n))$\n\n其实和泛函的函数的范数有点像，也就是这个映射算是有界的那种感觉。\n常见复杂度级别$$O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$$\n复杂嵌套循环分析等差数列型循环def quadratic_complexity_demo(N):    &quot;&quot;&quot;    演示O(n²)时间复杂度    等差数列求和：1 + 2 + ... + n = n(n+1)/2 = O(n²)    &quot;&quot;&quot;    operations = 0                        # 记录操作次数        for i in range(1, N + 1):            # 外层循环：i从1到N        for j in range(i, N + 1):        # 内层循环：j从i到N            operations += 1               # 模拟一次基本操作            # 当i=1时，内层执行N次            # 当i=2时，内层执行N-1次              # ...            # 当i=N时，内层执行1次            # 总计：N + (N-1) + ... + 1 = N(N+1)/2        print(f&quot;N=&#123;N&#125;, 总操作次数=&#123;operations&#125;, 理论值=&#123;N*(N+1)//2&#125;&quot;)    return operations\n\n调和级数型循环def n_log_n_complexity_demo(N):    &quot;&quot;&quot;    演示O(n log n)时间复杂度      调和级数：1 + 1/2 + 1/3 + ... + 1/n ≈ ln(n) = O(log n)    &quot;&quot;&quot;    operations = 0                        # 记录操作次数        for i in range(1, N + 1):            # 外层循环：i从1到N        j = i                             # 内层循环起始值        while j &lt;= N:                     # 按i的倍数递增            operations += 1               # 模拟一次基本操作            j += i                        # j = i, 2i, 3i, ...            # 当i=1时，内层执行N次（N/1）            # 当i=2时，内层执行N/2次            # 当i=3时，内层执行N/3次            # ...            # 总计：N(1 + 1/2 + 1/3 + ... + 1/N) = N·H_N ≈ N log N        print(f&quot;N=&#123;N&#125;, 总操作次数=&#123;operations&#125;&quot;)    return operations\n\n复杂度实验验证import timedef complexity_benchmark():    &quot;&quot;&quot;    通过实际运行时间验证复杂度分析    &quot;&quot;&quot;    test_sizes = [1000, 2000, 4000, 8000]   # 测试规模        print(&quot;=== 复杂度实验验证 ===&quot;)    print(&quot;规模\\tO(n²)时间\\tO(n log n)时间\\t比率&quot;)        for N in test_sizes:        # 测试O(n²)算法        start_time = time.time()        quadratic_complexity_demo(N)        quadratic_time = time.time() - start_time                # 测试O(n log n)算法          start_time = time.time()        n_log_n_complexity_demo(N)        n_log_n_time = time.time() - start_time                ratio = quadratic_time / n_log_n_time if n_log_n_time &gt; 0 else float(&#x27;inf&#x27;)        print(f&quot;&#123;N&#125;\\t&#123;quadratic_time:.4f&#125;s\\t&#123;n_log_n_time:.4f&#125;s\\t&#123;ratio:.2f&#125;&quot;)\n\n单循环冒泡排序的复杂度分析def single_loop_bubble_sort(arr):    &quot;&quot;&quot;    使用单个循环实现冒泡排序    虽然只有一个while循环，但时间复杂度仍然是O(n²)    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return        n = len(arr)    end = n - 1                           # 未排序部分的右边界    i = 0                                 # 当前比较位置        while end &gt; 0:                        # 外层逻辑：控制轮次        if arr[i] &gt; arr[i + 1]:          # 相邻元素比较            arr[i], arr[i + 1] = arr[i + 1], arr[i]  # 交换                if i &lt; end - 1:                   # 当前轮次未结束            i += 1                        # 移动到下一个比较位置        else:                             # 当前轮次结束            end -= 1                      # 缩小未排序范围            i = 0                         # 重置比较位置            # 虽然是单循环，但逻辑上等价于双层嵌套            # 时间复杂度仍为O(n²)\n\n空间复杂度分析动态数组的均摊复杂度分析def dynamic_array_analysis():    &quot;&quot;&quot;    动态数组扩容的均摊复杂度分析    &quot;&quot;&quot;    arr = []                              # 初始空数组    operations = []                       # 记录每次操作的代价        for i in range(16):                   # 插入16个元素        old_capacity = len(arr)           # 当前容量        arr.append(i)                     # 插入元素                # 模拟扩容过程        if len(arr) &gt; old_capacity:       # 发生了扩容            # Python的list实际扩容策略比较复杂，这里简化为2倍扩容            cost = old_capacity            # 扩容代价：复制所有旧元素        else:            cost = 1                      # 普通插入代价                operations.append(cost)        print(f&quot;插入元素&#123;i&#125;, 当前大小=&#123;len(arr)&#125;, 本次代价=&#123;cost&#125;&quot;)        total_cost = sum(operations)    average_cost = total_cost / len(operations)    print(f&quot;总代价=&#123;total_cost&#125;, 平均代价=&#123;average_cost:.2f&#125;&quot;)        # 数学分析：    # 扩容发生在容量为1,2,4,8,...时    # 总扩容代价：0 + 1 + 2 + 4 + 8 + ... &lt; 2n    # 总插入代价：n      # 均摊代价：(2n + n) / n = 3 = O(1)\n\n递归算法的空间复杂度def recursive_space_analysis(n):    &quot;&quot;&quot;    递归算法空间复杂度分析    计算阶乘的递归实现    &quot;&quot;&quot;    if n &lt;= 1:                           # 基础情况        return 1        # 每次递归调用占用O(1)空间    # 最大递归深度为n，所以空间复杂度为O(n)    return n * recursive_space_analysis(n - 1)def iterative_space_analysis(n):    &quot;&quot;&quot;    迭代版本的阶乘计算    空间复杂度为O(1)    &quot;&quot;&quot;    result = 1                           # 只使用常数额外空间    for i in range(1, n + 1):        result *= i    return result\n\n复杂度分析的实用技巧主定理（Master Theorem）对于递归关系 $T(n) &#x3D; aT(\\frac{n}{b}) + f(n)$，其中 $a \\geq 1, b &gt; 1$：\n\n如果 $f(n) &#x3D; O(n^{\\log_b a - \\epsilon})$，则 $T(n) &#x3D; \\Theta(n^{\\log_b a})$\n如果 $f(n) &#x3D; \\Theta(n^{\\log_b a})$，则 $T(n) &#x3D; \\Theta(n^{\\log_b a} \\log n)$  \n如果 $f(n) &#x3D; \\Omega(n^{\\log_b a + \\epsilon})$，则 $T(n) &#x3D; \\Theta(f(n))$\n\n均摊分析方法\n聚合分析：分析一系列操作的总代价\n核算法：为每种操作分配均摊代价\n势能法：定义势能函数分析代价分布\n\n实际性能考虑因素def practical_performance_factors():    &quot;&quot;&quot;    影响实际性能的因素    &quot;&quot;&quot;    print(&quot;影响算法实际性能的因素：&quot;)    print(&quot;1. 常数因子：O(n)算法的常数可能很大&quot;)    print(&quot;2. 数据规模：小规模时简单算法可能更快&quot;)      print(&quot;3. 内存访问模式：缓存友好的算法性能更好&quot;)    print(&quot;4. 分支预测：减少条件分支可提高性能&quot;)    print(&quot;5. 编译器优化：现代编译器能显著优化代码&quot;)    print(&quot;6. 硬件特性：利用SIMD等特性可大幅提速&quot;)\n\n\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","算法","二分搜索","排序算法","时间复杂度"]},{"title":"数据结构与算法自学笔记（5）- 算法笔试中处理输入和输出","url":"/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n是class019的内容，本笔记重点介绍Python在算法竞赛和笔试中的高效输入输出处理技巧，包含子矩阵最大累加和问题的完整实现，以及与Java的性能对比分析。\n019【必备】算法笔试中处理输入和输出概述在算法竞赛和大厂笔试中，输入输出的处理效率往往是程序性能的关键瓶颈。Python虽然在执行速度上不如C++和Java，但通过合理的IO优化技巧，同样可以在大多数场景下取得良好的性能表现。\nPython vs Java IO性能对比\n\n\n特性\nPython\nJava\n\n\n\n默认IO\ninput()、print() 较慢\nScanner、System.out 较慢\n\n\n高效IO\nsys.stdin.read()、批量输出\nBufferedReader、PrintWriter\n\n\n内存管理\n自动垃圾回收，相对简单\n需要考虑静态空间分配\n\n\n大整数\n原生支持任意精度\n需要BigInteger类\n\n\n编程复杂度\n语法简洁，容易上手\n类型安全，但代码较长\n\n\nPython编程风格选择填函数风格（OJ平台推荐）适用于LeetCode、牛客网等在线判题平台，平台会自动处理输入输出。\nclass Solution:    def sumOfSubMatrix(self, mat, n):        &quot;&quot;&quot;        只需实现核心算法逻辑        平台自动调用并验证结果        &quot;&quot;&quot;        return self.maxSumSubmatrix(mat, n, n)        def maxSumSubmatrix(self, mat, rows, cols):        max_sum = float(&#x27;-inf&#x27;)        for i in range(rows):            arr = [0] * cols  # 辅助数组            for j in range(i, rows):                for k in range(cols):                    arr[k] += mat[j][k]                max_sum = max(max_sum, self.maxSumSubarray(arr))        return max_sum        def maxSumSubarray(self, arr):        max_sum = float(&#x27;-inf&#x27;)        cur = 0        for num in arr:            cur += num            max_sum = max(max_sum, cur)            cur = max(cur, 0)  # 负数时重置为0        return max_sum\n\nACM风格（竞赛笔试推荐）适用于ACM竞赛、大厂笔试等需要自己处理输入输出的场景。\nimport sysdef main():    &quot;&quot;&quot;    完整的输入输出处理    需要自己解析数据格式    &quot;&quot;&quot;    lines = sys.stdin.read().split()    ptr = 0    output = []        while ptr &lt; len(lines):        n = int(lines[ptr])        ptr += 1        m = int(lines[ptr])        ptr += 1                # 构建矩阵        mat = []        for i in range(n):            row = []            for j in range(m):                row.append(int(lines[ptr]))                ptr += 1            mat.append(row)                # 计算结果        result = maxSumSubmatrix(mat, n, m)        output.append(str(result))        # 批量输出    print(&#x27;\\n&#x27;.join(output))if __name__ == &#x27;__main__&#x27;:    main()\n\n高效输入输出技巧输入优化策略推荐：一次性读取大数据import sys# 最高效：适用于已知数据量的场景lines = sys.stdin.read().split()ptr = 0# 逐个解析数据while ptr &lt; len(lines):    n = int(lines[ptr])    ptr += 1    # 处理数据...\n\n优点：\n\nIO次数最少，效率最高\n相当于Java的BufferedReader一次性读取\n适合大数据量场景\n\n可选：按行读取# 适用：需要按行处理不同格式数据for line in sys.stdin:    parts = line.strip().split()    total = sum(int(num) for num in parts)    print(total)\n\n适用场景：\n\n每行数据格式不同\n无法提前确定数据量\n相当于Java的逐行readLine()\n\n不推荐：频繁调用input()# 效率低：类似Java的Scannern = int(input())  # 大数据时很慢for i in range(n):    x = int(input())  # 每次都要系统调用\n\n输出优化策略推荐：批量输出# 收集所有结果，最后一次性输出output = []for i in range(n):    result = solve(data[i])    output.append(str(result))print(&#x27;\\n&#x27;.join(output))  # 一次性输出\n\n不推荐：频繁print()# 每次print都会刷新缓冲区，效率低for i in range(n):    print(solve(data[i]))  # 大数据时很慢\n\n内存优化：静态空间vs动态空间推荐：静态空间分配# 全局预分配，避免频繁内存分配MAXN = 201MAXM = 201mat = [[0] * MAXM for _ in range(MAXN)]  # 静态矩阵arr = [0] * MAXM  # 静态辅助数组def solve():    global n, m    # 复用已分配的空间    for i in range(n):        for j in range(m):            mat[i][j] = read_next_int()        # 使用前先清空    for i in range(m):        arr[i] = 0\n\n不推荐：频繁动态分配def solve():    # 每次都重新分配内存    mat = []  # 动态创建    for i in range(n):        row = []  # 每行都新建        for j in range(m):            row.append(read_next_int())        mat.append(row)\n\n子矩阵最大累加和问题详解问题描述与算法思路问题：给定包含正数、负数、零的矩阵，求累加和最大的子矩阵。\n核心思想：将二维问题转化为一维最大子数组和问题\n\n枚举子矩阵的上下边界（第i行到第j行）\n将每列在这个范围内的元素累加，得到一维数组\n对一维数组使用Kadane算法求最大子数组和\n\n完整实现（填函数风格）class Code01_FillFunction:    def sumOfSubMatrix(self, mat, n):        &quot;&quot;&quot;主方法，求n×n矩阵的最大子矩阵和&quot;&quot;&quot;        return self.maxSumSubmatrix(mat, n, n)    @staticmethod    def maxSumSubmatrix(mat, n, m):        &quot;&quot;&quot;求子矩阵的最大累加和&quot;&quot;&quot;        max_sum = float(&#x27;-inf&#x27;)                # 枚举上边界        for i in range(n):            arr = [0] * m  # 辅助数组，每次重置                        # 枚举下边界（从i到n-1）            for j in range(i, n):                # 将第j行累加到辅助数组                for k in range(m):                    arr[k] += mat[j][k]                                # 求当前辅助数组的最大子数组和                max_sum = max(max_sum, Code01_FillFunction.maxSumSubarray(arr, m))                return max_sum    @staticmethod    def maxSumSubarray(arr, m):        &quot;&quot;&quot;Kadane算法求最大子数组和&quot;&quot;&quot;        max_sum = float(&#x27;-inf&#x27;)        cur = 0                for i in range(m):            cur += arr[i]            max_sum = max(max_sum, cur)            cur = 0 if cur &lt; 0 else cur  # 负数时重置                return max_sum\n\n算法复杂度：\n\n时间复杂度：O(n² × m)\n空间复杂度：O(m)\n\nACM风格实现（静态空间优化）import sys# 静态空间分配，避免频繁内存分配MAXN = 201MAXM = 201mat = [[0] * MAXM for _ in range(MAXN)]arr = [0] * MAXMn = m = 0def main():    global n, m    tokens = sys.stdin.read().split()    idx = 0    output = []        while idx &lt; len(tokens):        n = int(tokens[idx])        idx += 1        m = int(tokens[idx])        idx += 1                # 读取矩阵数据到静态空间        for i in range(n):            for j in range(m):                mat[i][j] = int(tokens[idx])                idx += 1                # 计算结果并收集输出        output.append(str(maxSumSubmatrix()))        # 批量输出所有结果    print(&#x27;\\n&#x27;.join(output))def maxSumSubmatrix():    &quot;&quot;&quot;使用静态空间的子矩阵最大和算法&quot;&quot;&quot;    max_sum = float(&#x27;-inf&#x27;)        for i in range(n):        # 清空辅助数组（复用静态空间）        for x in range(m):            arr[x] = 0                    for j in range(i, n):            # 累加第j行到辅助数组            for k in range(m):                arr[k] += mat[j][k]            max_sum = max(max_sum, maxSumSubarray())        return max_sumdef maxSumSubarray():    &quot;&quot;&quot;一维最大子数组和&quot;&quot;&quot;    max_sum = float(&#x27;-inf&#x27;)    cur = 0        for i in range(m):        cur += arr[i]        max_sum = max(max_sum, cur)        cur = 0 if cur &lt; 0 else cur        return max_sumif __name__ == &#x27;__main__&#x27;:    main()\n\n执行过程示例以矩阵为例：\n[[-90, 48, 78], [ 64,-40, 64],  [-81, -7, 66]]\n\n枚举过程：\n\ni&#x3D;0, j&#x3D;0（第0行）：arr&#x3D;[-90, 48, 78] → 最大子数组和&#x3D;126\ni&#x3D;0, j&#x3D;1（第0-1行）：arr&#x3D;[-26, 8, 142] → 最大子数组和&#x3D;150  \ni&#x3D;0, j&#x3D;2（第0-2行）：arr&#x3D;[-107, 1, 208] → 最大子数组和&#x3D;209\ni&#x3D;1, j&#x3D;1（第1行）：arr&#x3D;[64, -40, 64] → 最大子数组和&#x3D;88\ni&#x3D;1, j&#x3D;2（第1-2行）：arr&#x3D;[-17, -47, 130] → 最大子数组和&#x3D;130\ni&#x3D;2, j&#x3D;2（第2行）：arr&#x3D;[-81, -7, 66] → 最大子数组和&#x3D;66\n\n最终结果：209（来自第0-2行，第2-2列的子矩阵）\nPython高级IO优化FastReader快读类FastReader 是一个极致追求输入速度的工具，适用于数据量极大的算法竞赛场景。\n主要作用\n\n极速读取输入，尤其是大量数字（如百万级数据）。\n通过 一次性读取大块数据（8KB） 到内存，减少系统I&#x2F;O调用次数。\n按字节处理并手动解析数字，比标准 input() 或 sys.stdin.readline() 更快。\n\n工作原理\n\n缓冲区：用 self.buffer 存储从输入流一次性读取的大块数据。\n按字节解析：用 readByte 方法逐字节读取，跳过非数字字符，自己实现整数解析（包括负数）。\n高效：只处理数字和符号，省略 split、strip 等高层方法，极致优化输入。\n\n典型用法适合极端大数据输入、对时间卡得很紧的OJ平台。\nimport sysclass FastReader:    def __init__(self, file=sys.stdin):        self.file = file        self.buffer = &quot;&quot;        self.idx = 0    def _read(self):        &quot;&quot;&quot;一次性读取8KB数据到缓冲区&quot;&quot;&quot;        self.buffer = self.file.read(8192)        self.idx = 0    def readByte(self):        &quot;&quot;&quot;读取下一个字节&quot;&quot;&quot;        if self.idx &gt;= len(self.buffer):            self._read()            if self.buffer == &quot;&quot;:                return -1        byte = self.buffer[self.idx]        self.idx += 1        return ord(byte)    def readInt(self):        &quot;&quot;&quot;快速读取整数&quot;&quot;&quot;        num = 0        minus = False        b = self.readByte()                # 跳过非数字字符        while b != -1 and (b &lt; ord(&#x27;0&#x27;) or b &gt; ord(&#x27;9&#x27;)) and b != ord(&#x27;-&#x27;):            b = self.readByte()                    if b == ord(&#x27;-&#x27;):            minus = True            b = self.readByte()                    # 读取数字        while b != -1 and (ord(&#x27;0&#x27;) &lt;= b &lt;= ord(&#x27;9&#x27;)):            num = num * 10 + (b - ord(&#x27;0&#x27;))            b = self.readByte()                    return -num if minus else num    def readLong(self):        &quot;&quot;&quot;读取长整数（Python中与int相同）&quot;&quot;&quot;        return self.readInt()\n\nFastWriter快写类FastWriter 是一个高效输出工具，适用于需要频繁输出、输出量大的场合。\n主要作用\n\n减少输出次数：把所有输出内容先缓存在内存里，最后统一输出，减少系统调用。\n链式调用和兼容Java风格，用起来很方便。\n\n工作原理\n\n缓冲区：所有待输出内容先存入 self.buffer 列表。\n批量输出：调用 flush() 时，一次性将所有内容写入输出流。\n兼容性：支持 write（写字符串）、writeln&#x2F;println（写一行），用法灵活。\n\n典型用法\n适合数据量大、频繁输出的算法题&#x2F;竞赛场景，防止 print() 太慢导致超时。\nimport sysclass FastWriter:    def __init__(self, file=sys.stdout):        self.file = file        self.buffer = []    def write(self, s):        &quot;&quot;&quot;写入字符串到缓冲区&quot;&quot;&quot;        self.buffer.append(str(s))        return self  # 支持链式调用    def writeln(self, s=&quot;&quot;):        &quot;&quot;&quot;写入一行&quot;&quot;&quot;        self.buffer.append(str(s) + &quot;\\n&quot;)        return self    def println(self, s=&quot;&quot;):        &quot;&quot;&quot;兼容Java习惯的方法名&quot;&quot;&quot;        return self.writeln(s)    def flush(self):        &quot;&quot;&quot;刷新缓冲区，实际写入文件&quot;&quot;&quot;        if self.buffer:            self.file.write(&quot;&quot;.join(self.buffer))            self.file.flush()            self.buffer = []    def close(self):        &quot;&quot;&quot;关闭写入器&quot;&quot;&quot;        self.flush()        if self.file != sys.stdout:            self.file.close()\n\nKattio类（Python版）Kattio 类是一个高效的输入输出（I&#x2F;O）工具类，最初流行于 Java 的竞赛编程圈。它的 Python 版本（如你上面给出的代码）主要是用来简化和加快处理标准输入输出，尤其适合数据量较大、输入格式“特殊”或需要频繁读取单个数据的场景，比如各类算法竞赛、OJ（Online Judge）平台等。\n主要作用\n\n高效读取输入：普通的 input() 在数据量大时会变慢，Kattio 通过缓冲和一次性读取一行数据，提升了读取效率。\n简化输入格式处理：常见的输入格式如多行多列、混合类型（int、float、str）都能方便读取，不用每次都写 split、map 一大堆。\n输出简便：带有封装的 println 方法，输出不再需要手动 print(…, file&#x3D;…)。\n\n工作原理\n\n维护一个缓冲区（self.buffer），每次读取一整行并分割成单词。\n提供 next() 方法按顺序读取下一个字符串，nextInt() 读取下一个整数，nextDouble() 读取下一个浮点数等。\n适配输入和输出流（默认为标准输入输出，但也可以重定向到文件），并提供 close 方法在需要时关闭流。\n\n参考Java版Kattio的Python实现，处理特殊输入格式：\nimport sysfrom typing import Optionalclass Kattio:    &quot;&quot;&quot;    高效IO类，适用于特殊格式输入    效率略低于FastReader，但兼容性更好    &quot;&quot;&quot;    def __init__(self, input_stream=sys.stdin, output_stream=sys.stdout):        self.input = input_stream        self.output = output_stream        self.buffer = []        self.idx = 0    def _fill_buffer(self):        &quot;&quot;&quot;填充缓冲区&quot;&quot;&quot;        line = self.input.readline()        if line == &#x27;&#x27;:            return        self.buffer = line.strip().split()        self.idx = 0    def next(self) -&gt; Optional[str]:        &quot;&quot;&quot;读取下一个字符串&quot;&quot;&quot;        while self.idx &gt;= len(self.buffer):            self._fill_buffer()            if not self.buffer:                return None        result = self.buffer[self.idx]        self.idx += 1        return result    def nextInt(self) -&gt; int:        &quot;&quot;&quot;读取下一个整数&quot;&quot;&quot;        return int(self.next())    def nextLong(self) -&gt; int:        &quot;&quot;&quot;读取下一个长整数&quot;&quot;&quot;        return int(self.next())    def nextDouble(self) -&gt; float:        &quot;&quot;&quot;读取下一个浮点数&quot;&quot;&quot;        return float(self.next())    def println(self, s):        &quot;&quot;&quot;输出一行&quot;&quot;&quot;        print(s, file=self.output)    def close(self):        &quot;&quot;&quot;关闭IO流&quot;&quot;&quot;        if self.input != sys.stdin:            self.input.close()        if self.output != sys.stdout:            self.output.close()\n\nPython常用数据结构快速参考基础容器操作from collections import deque, defaultdictimport bisect# 列表（动态数组）arr = [1, 2, 3]arr.append(4)              # O(1) 尾部添加arr.insert(0, 0)           # O(n) 头部插入arr.pop()                  # O(1) 尾部删除arr.pop(0)                 # O(n) 头部删除print(arr[1])              # O(1) 随机访问# 双端队列（可当栈或队列）dq = deque()dq.append(1)               # 队尾入队dq.appendleft(2)           # 队首入队dq.pop()                   # 队尾出队dq.popleft()               # 队首出队# 集合操作s1 = &#123;1, 2, 3&#125;s2 = &#123;2, 3, 4&#125;print(s1 | s2)             # 并集print(s1 &amp; s2)             # 交集print(s1 - s2)             # 差集# 字典操作d = defaultdict(int)       # 默认值为0d[&quot;key&quot;] += 1              # 自动初始化并自增\n\n排序与查找# 排序arr = [3, 1, 4, 1, 5]arr.sort()                           # 原地升序排序arr.sort(reverse=True)               # 原地降序排序sorted_arr = sorted(arr)             # 返回新的排序数组custom_sorted = sorted(arr, key=lambda x: -x)  # 自定义排序# 二分查找arr = [1, 2, 4, 7, 9]  # 必须有序idx = bisect.bisect_left(arr, 4)     # 查找插入位置idx = bisect.bisect_right(arr, 4)    # 查找插入位置（右侧）\n\n大整数与高精度# Python原生支持任意精度整数big_num = 10**100                    # 10的100次方result = big_num * big_num           # 自动处理大整数运算# 高精度除法import decimaldecimal.getcontext().prec = 50       # 设置精度a = decimal.Decimal(&#x27;1&#x27;) / decimal.Decimal(&#x27;3&#x27;)\n\n实战技巧与注意事项性能优化技巧# 1. 避免在循环中重复计算# 错误写法for i in range(n):    for j in range(len(arr)):  # 每次都计算len(arr)        pass# 正确写法  arr_len = len(arr)for i in range(n):    for j in range(arr_len):        pass# 2. 使用局部变量访问全局数据# 错误写法def process():    for i in range(n):        result += global_data[i]  # 每次都查找全局变量# 正确写法def process():    local_data = global_data  # 本地化全局变量    for i in range(n):        result += local_data[i]# 3. 字符串拼接优化# 错误写法s = &quot;&quot;for i in range(n):    s += str(i)  # 每次都创建新字符串# 正确写法parts = []for i in range(n):    parts.append(str(i))s = &quot;&quot;.join(parts)\n\n常见陷阱与解决方案# 1. 递归深度限制import syssys.setrecursionlimit(10000)  # 设置递归深度限制# 2. 浮点数精度问题import mathdef is_equal(a, b, eps=1e-9):    return abs(a - b) &lt; eps# 3. 列表初始化陷阱# 错误：所有行共享同一个列表matrix = [[0] * m] * n# 正确：每行都是独立的列表matrix = [[0] * m for _ in range(n)]# 4. 字典默认值from collections import defaultdict# 使用defaultdict避免KeyErrorcount = defaultdict(int)count[key] += 1  # 自动初始化为0\n\n调试技巧# 条件编译式调试DEBUG = Falsedef debug_print(*args):    if DEBUG:        print(&quot;DEBUG:&quot;, *args)# 输入输出重定向（本地测试）import sysif DEBUG:    sys.stdin = open(&#x27;input.txt&#x27;, &#x27;r&#x27;)    sys.stdout = open(&#x27;output.txt&#x27;, &#x27;w&#x27;)# 计时器import timestart_time = time.time()# ... 算法代码 ...print(f&quot;执行时间: &#123;time.time() - start_time:.3f&#125;秒&quot;)\n\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","输入输出(IO)","高效编程","子矩阵问题"]},{"title":"数据结构与算法自学笔记（6）- 递归、归并排序与归并分治","url":"/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series  \n记录的是class020→class022，包括了递归的本质理解、Master公式的应用、归并排序的递归与非递归实现，以及归并分治思想在解决小和问题和翻转对问题中的应用。\n020【必备】递归和Master公式递归的本质理解思想层面的递归递归不是玄学，它是一种**”大事化小”**的思维方式。对于新手来说，画调用图是理解递归的关键。\ndef max_value(arr):    &#x27;&#x27;&#x27;给定一个数组，在arr[l...r]范围上，返回最大值&#x27;&#x27;&#x27;    return f(arr, 0, len(arr) - 1)def f(arr, l, r):    # arr[l...r] 范围上的最大值    if l == r:        # 递归基：当左右下标相等时，区间只有一个数，直接返回        return arr[l]    m = (l + r) // 2  # 找到中点    lmax = f(arr, l, m)        # 递归求左半部分最大值    rmax = f(arr, m + 1, r)    # 递归求右半部分最大值    return max(lmax, rmax)     # 返回左右部分的最大值\n\n递归的三个关键点：\n\n明确递归要干什么：这里是”返回 arr[l…r] 的最大值”\n找递归的终止条件：这里是”l &#x3D;&#x3D; r”，即区间只有一个数  \n思考如何缩小规模：这里是分别递归处理左区间和右区间\n\n实际层面的递归递归底层利用系统栈来实现：\n\n当函数调用发生时，系统会将函数的状态（参数、局部变量、返回地址）压入栈中\n当函数返回时，系统从栈中弹出状态，恢复到调用点继续执行\n这个过程是可视化的，所以所有递归函数都可以改成非递归\n\n递归改非递归的必要性：\n\n工程实践：几乎一定要改，除非确定递归深度不会太大\n算法竞赛：能通过就不改，时间紧迫时优先保证正确性\n\n形象比喻：\n\n迭代像是擂台赛：一个个来，逐步解决\n递归像是季后赛：分组对战，逐层淘汰\n\nMaster公式详解Master公式用于分析分治算法的时间复杂度，适用于所有子问题规模相同的递归。\n公式形式$$T(n) &#x3D; a \\times T(\\frac{n}{b}) + O(n^c)$$\n其中：\n\na：子问题被调用的次数\nb：子问题规模（数据量变为原来的1&#x2F;b）  \nc：除去子问题之外的时间复杂度指数\n\n判断标准设 $\\log_b(a) &#x3D; d$，则：\n\n\n\n条件\n时间复杂度\n说明\n\n\n\n$d &lt; c$\n$O(n^c)$\n合并工作量占主导\n\n\n$d &gt; c$\n$O(n^d)$\n递归调用占主导\n\n\n$d &#x3D; c$\n$O(n^c \\log n)$\n两者平衡\n\n\n经典例子分析# 归并排序：T(n) = 2*T(n/2) + O(n)# a=2, b=2, c=1# log₂(2) = 1 = c，所以复杂度为 O(n*logn)# 二分查找：T(n) = 1*T(n/2) + O(1)  # a=1, b=2, c=0# log₂(1) = 0 = c，所以复杂度为 O(logn)# 快速排序最好情况：T(n) = 2*T(n/2) + O(n)# 结果同归并排序：O(n*logn)\n\n特殊情况对于 $T(n) &#x3D; 2 \\times T(\\frac{n}{2}) + O(n \\log n)$：\n\n这不符合标准Master公式形式，结果是 $O(n \\times (\\log n)^2)$，需要特殊记忆，证明过程较复杂，这种递归式常见于“分治 + 合并时需要二分&#x2F;复杂统计”的问题，比如“翻转对”、“区间对统计”，主定理告知其复杂度为 $O(n \\log^2 n)$\n\n021【必备】归并排序归并排序原理核心思想\n左部分排好序、右部分排好序\n利用merge过程让左右整体有序\nmerge过程：谁小拷贝谁，直到左右两部分数字耗尽，拷贝回原数组\n\n为什么归并排序比O(n²)排序快？比较行为没有浪费！\n对比三种原始排序（选择、冒泡、插入）：\n\n每次1到N-1次比较只能确定一个位置\n大量比较工作被浪费，效率低下\n\n归并排序中：\n\n每次比较都有意义，用于合并两个有序序列\n比较结果被充分利用，没有浪费\n系统栈不会太深\n\n\n 测试链接 ：https://www.luogu.com.cn/problem/P1177\n递归实现MAXN = 100001arr = [0] * MAXN      # 原数组help_arr = [0] * MAXN # 辅助数组n = 0                 # 数组长度def mergeSort1(l, r):    &quot;&quot;&quot;    归并排序递归版    T(n) = 2 * T(n/2) + O(n)    根据master公式，时间复杂度O(n * logn)    空间复杂度O(n)    &quot;&quot;&quot;    if l == r:  # 递归终止条件：只剩一个元素        return    m = (l + r) // 2  # 计算中点    mergeSort1(l, m)      # 递归排序左半部分    mergeSort1(m + 1, r)  # 递归排序右半部分    merge(l, m, r)        # 合并def merge(l, m, r):    &quot;&quot;&quot;    合并两个有序区间 arr[l...m] 和 arr[m+1...r]    时间复杂度O(n)，其中n = r - l + 1    &quot;&quot;&quot;    i = l      # help数组写指针    a = l      # 左侧起始指针    b = m + 1  # 右侧起始指针        # 双指针合并过程    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]             b += 1        i += 1        # 处理剩余元素    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1            # 写回原数组    for i in range(l, r + 1):        arr[i] = help_arr[i]\n\n非递归实现def mergeSort2():    &quot;&quot;&quot;    归并排序非递归版    时间复杂度O(n * logn)：外层循环O(logn)，内层归并O(n)    空间复杂度O(n)    &quot;&quot;&quot;    global n    step = 1  # 步长初始化为1        while step &lt; n:  # 外层控制步长，共O(logn)次        l = 0  # 每轮从左端开始                while l &lt; n:  # 内层处理每一组            m = l + step - 1      # 计算中点            if m + 1 &gt;= n:        # 右半部分越界，跳出                break            r = min(l + (step &lt;&lt; 1) - 1, n - 1)  # 计算右边界            merge(l, m, r)        # 合并            l = r + 1             # 移动到下一组                    step &lt;&lt;= 1  # 步长翻倍\n\n非递归实现的核心思路\nstep表示每次要合并的有序段长度，初始为1（每个元素自己是有序段）\n每一轮成对合并长度为step的有序段，合并成长度为2*step的有序段\n下一轮step翻倍，继续两两合并\n重复直到step &gt;&#x3D; n，整个数组有序\n\n过程示例：\n原数组: [3, 8, 7, 6, 4, 5, 1, 2]step=1: [3,8] [6,7] [4,5] [1,2] → [3,8,6,7,4,5,1,2]step=2: [3,6,7,8] [1,2,4,5] → [3,6,7,8,1,2,4,5] step=4: [1,2,3,4,5,6,7,8] → [1,2,3,4,5,6,7,8]\n\nmerge过程详解双指针合并策略def merge(l, m, r):    &quot;&quot;&quot;    合并过程详解：    1. 双指针扫描：a指向左部分，b指向右部分    2. 比较合并：较小值写入help_arr，对应指针右移    3. 剩余处理：一边扫完后，另一边直接复制    4. 写回原数组：完成排序合并    &quot;&quot;&quot;    i = l      # help_arr写入位置    a = l      # 左部分起点    b = m + 1  # 右部分起点        # 两两比较，选择较小值    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]            b += 1        i += 1        # 处理剩余元素（必有一边先结束）    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1        # 拷贝回原数组    for idx in range(l, r + 1):        arr[idx] = help_arr[idx]\n\n复杂度分析时间复杂度：O(n log n)\n递归层数：log₂(n)层，每次将问题规模减半\n每层工作量：O(n)，所有元素都要参与一次合并\n总复杂度：O(n) × O(log n) &#x3D; O(n log n)\n\n空间复杂度：O(n)\n辅助数组：需要与原数组等长的help_arr\n递归栈：最大深度O(log n)，但主要空间开销是辅助数组\n原地归并：理论上可以做到O(1)空间，但时间复杂度会退化到O(n²)\n\n022【必备】归并分治归并分治的核心思想归并分治是在归并排序基础上的拓展，用来解决更复杂的问题。\n应用条件判断一个问题能用归并分治解决，需要满足：\n\n大范围答案 &#x3D; 左部分答案 + 右部分答案 + 跨越左右产生的答案\n计算”跨越左右产生的答案”时，左右各自有序能带来计算便利性\n如果以上两点成立，该问题很可能被归并分治解决\n\n求解过程：在归并排序过程中加入统计逻辑，利用左右有序的特性获得计算便利性。\n小和问题问题描述给定数组arr，对于每个位置i，求出其左边所有小于等于arr[i]的数的累加和，所有位置的累加和即为数组的”小和”。\n例子：\n数组: [1, 3, 5, 2, 4, 6]位置0(1): 左边小于等于1的数 → 0位置1(3): 左边小于等于3的数 → 1  位置2(5): 左边小于等于5的数 → 1+3 = 4位置3(2): 左边小于等于2的数 → 1位置4(4): 左边小于等于4的数 → 1+3+2 = 6位置5(6): 左边小于等于6的数 → 1+3+5+2+4 = 15小和 = 0+1+4+1+6+15 = 27\n\n\n\n 测试链接 ：https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469\n归并分治解法def smallSum(l, r):    &quot;&quot;&quot;    返回arr[l...r]范围上小和的累加和，同时让arr[l..r]变有序    时间复杂度O(n * logn)    &quot;&quot;&quot;    if l == r:        return 0    m = (l + r) // 2    # 递归统计左右部分和跨区部分的小和    return smallSum(l, m) + smallSum(m + 1, r) + merge(l, m, r)def merge(l, m, r):    &quot;&quot;&quot;    统计跨左右产生的小和，同时完成合并    &quot;&quot;&quot;    ans = 0        # 累计小和    i = l          # 左侧指针    sum_left = 0   # 累计左侧小于等于当前右侧元素的和        # 统计跨区贡献：对每个右侧元素，统计左侧贡献    for j in range(m + 1, r + 1):        # 左侧所有 &lt;= arr[j] 的元素都对arr[j]有贡献        while i &lt;= m and arr[i] &lt;= arr[j]:            sum_left += arr[i]  # 累加左侧贡献            i += 1        ans += sum_left  # arr[j]的左侧贡献总和        # 正常归并过程    i = l    a = l    b = m + 1    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]            b += 1        i += 1    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1    for idx in range(l, r + 1):        arr[idx] = help_arr[idx]        return ans\n\n算法关键思路为什么要在merge过程中统计？\n\n左右有序的便利性：因为左右都有序，可以用双指针线性扫描\n避免重复计算：每个跨区的小和贡献只需要计算一次\n时间复杂度优势：总体保持O(n log n)，而暴力解法是O(n²)\n\n核心技巧：\n\n对于右半部分的每个元素arr[j]，左半部分所有 ≤ arr[j] 的元素都会对小和产生贡献\n由于左半部分有序，可以用指针i从左向右扫描，累加贡献值\n指针i只会前进不会后退，总的扫描时间为O(n)\n\n翻转对问题问题描述给定数组nums，如果i&lt;j且nums[i]&gt;2*nums[j]，我们就将(i,j)称作一个重要翻转对。求数组中翻转对的总数量。\n例子：\n数组: [1,3,2,3,1]翻转对: (1,4)→3&gt;2*1, (3,4)→3&gt;2*1答案: 2\n 测试链接 ：https://leetcode.cn/problems/reverse-pairs/\n归并分治解法def reversePairs(arr):    &quot;&quot;&quot;统计翻转对的主函数&quot;&quot;&quot;    return counts(arr, 0, len(arr) - 1)def counts(arr, l, r):    &quot;&quot;&quot;    统计l...r范围上翻转对的数量，同时让l...r范围变有序    时间复杂度O(n * logn)    &quot;&quot;&quot;    if l == r:        return 0    m = (l + r) // 2    # 递归统计左右两边和跨区部分的翻转对数量    return counts(arr, l, m) + counts(arr, m + 1, r) + merge(arr, l, m, r)def merge(arr, l, m, r):    &quot;&quot;&quot;统计跨区翻转对并完成合并&quot;&quot;&quot;    ans = 0  # 翻转对计数    j = m + 1  # 右边数组起点        # 统计跨区翻转对    for i in range(l, m + 1):        # 找到右侧第一个不满足 arr[i] &gt; 2*arr[j] 的位置        while j &lt;= r and arr[i] &gt; 2 * arr[j]:            j += 1        # 当前i能形成的翻转对数量 = j - (m+1)        ans += j - m - 1        # 正常merge过程（与归并排序相同）    i = l    a = l    b = m + 1    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]            b += 1        i += 1    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1    for idx in range(l, r + 1):        arr[idx] = help_arr[idx]        return ans\n\n算法关键思路统计策略：\n\n利用左右部分独立有序：对于左半部分的每个元素arr[i]，在右半部分找到满足arr[i] &gt; 2*arr[j]的所有j\n指针单向移动：左右部分都是有序的，指针j只需要前进，不需要回退  \n计数技巧：当找到第一个不满足条件的j时，说明j前面的所有元素都满足条件\n\n时间复杂度分析：\n\n每个元素只会被访问一次，总的统计时间：O(n)，符合归并分治的要求\n\n归并分治总结适用问题特征\n可分解性：问题可以分解为左部分 + 右部分 + 跨区部分\n有序性便利：跨区部分的计算在左右有序时能够优化\n线性合并：跨区计算的时间复杂度为O(n)\n\n解题模板def divide_conquer(l, r):    if l == r:        return base_case        m = (l + r) // 2    left_ans = divide_conquer(l, m)    right_ans = divide_conquer(m + 1, r)    cross_ans = merge_and_count(l, m, r)  # 关键：统计跨区答案        return left_ans + right_ans + cross_ansdef merge_and_count(l, m, r):    # 1. 利用左右有序性，统计跨区答案    cross_count = 0    # ... 统计逻辑        # 2. 正常的归并排序merge过程    # ... 合并逻辑        return cross_count\n\n常见应用\n小和问题：统计左侧小于等于当前元素的累加和\n翻转对问题：统计满足特定大小关系的数对\n最近点对问题：二维空间中最近两点距离（高难度）\n逆序对问题：统计数组中的逆序对数量\n\n与其他算法的关系\n线段树：也可以解决类似问题，但常数因子可能更大\n树状数组：适合在线查询修改，离线场景下归并分治更简洁\n分块算法：另一种分治思想，将在后续课程中介绍\n\n归并分治是一种优雅而强大的算法思想，它将复杂问题通过分治和有序性的结合，优雅地降低了时间复杂度。掌握这种思想对于解决许多看似困难的问题都有很大帮助。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","递归","归并排序","分治算法","Master公式"]},{"title":"数据结构与算法自学笔记（8）- 堆结构&哈希表&堆结构相关习题","url":"/2025/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89-%20%E5%A0%86%E7%BB%93%E6%9E%84&%E5%93%88%E5%B8%8C%E8%A1%A8&%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/","content":"前言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记涵盖了堆的基本概念与堆排序、哈希表的实现以及堆结构的一些相关习题，包括了class025→027的内容。\n025【必备】堆结构和堆排序堆的基本概念什么是堆堆是一种特殊的完全二叉树结构，通常用数组来实现存储。堆有以下特性：\n\n结构性质：堆是完全二叉树，即除了最后一层，其他层都是满的，最后一层从左到右连续填充\n堆序性质：\n大根堆：任何一个子树内部的最大值一定在顶部（父节点 ≥ 子节点）\n小根堆：任何一个子树内部的最小值一定在顶部（父节点 ≤ 子节点）\n\n\n\n堆的数组表示堆使用数组实现，通过下标关系来表示父子关系：\n# 对于下标为 i 的节点：parent = (i - 1) // 2    # 父节点下标left_child = i * 2 + 1   # 左孩子下标  right_child = i * 2 + 2  # 右孩子下标# 判断是否有孩子节点：# 如果 left_child &gt;= size，则没有左孩子# 如果 right_child &gt;= size，则没有右孩子\n\n堆的核心操作堆有两个核心调整操作，时间复杂度都是 O(log n)：\n\nheapInsert（向上调整）：新元素插入后向上调整维持堆性质\nheapify（向下调整）：删除堆顶后向下调整维持堆性质\n\n堆的核心算法实现heapInsert - 向上调整当在堆的末尾插入新元素时，需要向上调整以维持堆的性质：\ndef heapInsert(i):    &quot;&quot;&quot;    i位置的数，向上调整大根堆    时间复杂度：O(logn)    &quot;&quot;&quot;    while arr[i] &gt; arr[(i - 1) // 2]:  # 当前节点大于父节点时        swap(i, (i - 1) // 2)          # 与父节点交换        i = (i - 1) // 2               # 更新当前位置为父节点位置\n\n算法流程：\n\n比较当前节点与其父节点的值\n如果当前节点更大（大根堆），则交换\n向上移动到父节点位置，重复过程\n直到满足堆性质或到达根节点\n\n测试链接：https://www.luogu.com.cn/problem/P1177\n\nheapify - 向下调整当删除堆顶元素后，需要向下调整以维持堆的性质：\ndef heapify(i, size):    &quot;&quot;&quot;    i位置的数，向下调整大根堆    当前堆的大小为size    时间复杂度：O(logn)    &quot;&quot;&quot;    l = i * 2 + 1  # 左孩子    while l &lt; size:  # 如果左孩子存在        # 选出左右孩子中更大的那个        best = l + 1 if (l + 1 &lt; size and arr[l + 1] &gt; arr[l]) else l        # 当前节点和最强孩子之间，选出最强的        best = best if arr[best] &gt; arr[i] else i        if best == i:  # 如果当前节点最大，调整完成            break        swap(best, i)  # 交换        i = best       # 移动到交换后的位置        l = i * 2 + 1  # 更新左孩子# 1.找到更大的子节点：比较左右子节点，选出值更大的那个# 2.与父节点比较：将较大的子节点与当前父节点比较# 3.决定是否交换：如果子节点更大就交换，否则停止调整# 4.继续向下：交换后继续对新位置进行同样的操作\n\n算法流程：\n\n找到更大的子节点：比较左右子节点，选出值更大的那个\n与父节点比较：将较大的子节点与当前父节点比较\n决定是否交换：如果子节点更大就交换，否则停止调整\n继续向下：交换后继续对新位置进行同样的操作\n\n堆排序的两种实现方法一：从顶到底建堆（经典版本）def heapSort1():    &quot;&quot;&quot;    完全二叉树的节点为N的话，高度是log_2(N)的水平    从顶到底建立大根堆，从顶到底建立大根堆，O(n * logn)，每次排好一个数，排n个数要n次，每排一个数时间复杂度是logn，排n个数当然是nlogn    依次弹出堆内最大值并排好序，O(n * logn)    整体时间复杂度O(n * logn)    &quot;&quot;&quot;    # 建堆阶段：从第一个元素开始，依次插入    for i in range(n):        heapInsert(i)  # 每个元素向上调整        # 排序阶段：不断取出最大值    size = n    while size &gt; 1:        swap(0, size - 1)  # 将最大值（堆顶）放到数组末尾        size -= 1          # 减少堆的大小        heapify(0, size)   # 对新的堆顶进行向下调整\n\n时间复杂度分析：\n\n建堆阶段：log₁ + log₂ + log₃ + ... + logₙ =（收敛于） O(n logn)\n排序阶段：每次调整 O(log n)，共 n-1 次，总计 O(n logn)\n总时间复杂度：O(n logn)\n\n\n方法二：从底到顶建堆（优化版本）def heapSort2():    &quot;&quot;&quot;    从底到顶建立大根堆，O(n)     依次弹出堆内最大值并排好序，O(n * logn)    整体时间复杂度O(n * logn)    &quot;&quot;&quot;    # 建堆阶段：从最后一个非叶子节点开始，向前调整    for i in range(n - 1, -1, -1):        heapify(i, n)        # 排序阶段：与方法一相同    size = n    while size &gt; 1:        swap(0, size - 1)        size -= 1        heapify(0, size)# 这种方法更像修理一栋破房子，从最下面的楼层开始修。建堆阶段只需要O(n)时间，具体是从最后一个非叶子节点开始逐个向前调整，每个节点只需要&quot;向下看&quot;把不合格的子节点换上来，由于采用从底向上的策略效率更高。# 排序阶段的做法与方法1相同，先取堆顶元素放到合适位置，然后重新调整剩余元素成堆并重复进行。整体而言方法2更优，因为它的建堆过程比方法1快了一个数量级，从O(n logn)优化到了O(n)\n为什么从底到顶建堆更快？\n从底到顶建堆的时间复杂度是 O(n)，这是因为：\n\n叶子节点无需调整：完全二叉树中约有 n&#x2F;2 个叶子节点，它们天然满足堆性质\n调整距离递减：越靠近叶子的节点，需要向下调整的最大距离越小\n数学分析：可以证明总的调整代价是一个等比数列，收敛到 O(n)\n\n两种方法的对比：\n\n\n\n建堆方法\n建堆复杂度\n排序复杂度\n总复杂度\n特点\n\n\n\n从顶到底\nO(n logn)\nO(n logn)\nO(n logn)\n逐个插入元素”爬楼梯”\n\n\n从底到顶\nO(n)\nO(n logn)\nO(n logn)\n从下往上”修房子”\n\n\n完整代码实现import sysimport randomMAXN = 100001arr = [0] * MAXNn = 0def main():    global n    data = sys.stdin.read().split()    n = int(data[0])    for i in range(n):        arr[i] = int(data[i + 1])        heapSort2()  # 使用优化版本        # 高效输出    sys.stdout.write(&#x27; &#x27;.join(str(arr[i]) for i in range(n - 1)))    sys.stdout.write(&#x27; &#x27; + str(arr[n - 1]) + &#x27;\\n&#x27;)def heapInsert(i):    while arr[i] &gt; arr[(i - 1) // 2]:        swap(i, (i - 1) // 2)        i = (i - 1) // 2def heapify(i, size):    l = i * 2 + 1    while l &lt; size:        best = l + 1 if (l + 1 &lt; size and arr[l + 1] &gt; arr[l]) else l        best = best if arr[best] &gt; arr[i] else i        if best == i:            break        swap(best, i)        i = best        l = i * 2 + 1def swap(i, j):    arr[i], arr[j] = arr[j], arr[i]def heapSort1():    for i in range(n):        heapInsert(i)    size = n    while size &gt; 1:        swap(0, size - 1)        size -= 1        heapify(0, size)def heapSort2():    for i in range(n - 1, -1, -1):        heapify(i, n)    size = n    while size &gt; 1:        swap(0, size - 1)        size -= 1        heapify(0, size)if __name__ == &quot;__main__&quot;:    main()\n\n堆排序的特点总结优点\n时间复杂度稳定：无论什么数据，时间复杂度都是 O(n logn)\n原地排序：额外空间复杂度 O(1)，直接在原数组上建堆\n不稳定但可预测：虽然不是稳定排序，但性能可预测\n\n缺点\n不稳定：相同元素的相对位置可能改变\n常数因子较大：虽然渐进复杂度优秀，但实际运行时常数因子比快排大\n缓存友好性差：堆调整过程中的访问模式对CPU缓存不太友好\n\n应用场景\n优先队列：堆是实现优先队列的最佳数据结构\nTop-K 问题：找出最大或最小的K个元素\n实时数据流：需要实时维护最值的场景\n任务调度：按优先级处理任务\n\n重要提示堆结构比堆排序有用得多，尤其是和比较器结合之后。堆排序只是堆数据结构的一个应用，堆在实际开发中更多用于实现优先队列、解决Top-K问题等场景。\n026【必备】哈希表、有序表和比较器的用法哈希表（Hash Table）的基本概念什么是哈希表？哈希表是一种数据结构，它通过键（key）来直接访问存储在值（value）中的数据，实现快速查找、插入和删除操作。\n大概约等于python中的字典啦\n核心思想\n将数据存储在数组中\n通过哈希函数将key转换为数组索引\n理想情况下，查找、插入、删除的时间复杂度都是O(1)\n\n工作原理Key → 哈希函数 → 数组索引 → 存储位置\n\n哈希表的特点\n时间复杂度：增、删、改、查时间为O(1)，但是大常数\n空间换时间：用额外的空间来换取时间效率\n两种形式：\nHashSet：只存储键，用于判断元素是否存在\nHashMap：存储键值对，根据键快速找到对应的值\n\n\n\nPython中的哈希表实现字符串的比较机制Python中字符串有特殊的驻留机制，需要注意is和==的区别：\n# 字符串比较str1 = str(&quot;Hello&quot;) str2 = str(&quot;Hello&quot;)  # 不同内存地址，但是内容都是Hello# 比较对象身份（内存地址）print(str1 is str2)   # 可能是True（驻留机制）# 比较值（内容）print(str1 == str2)   # True，内容一样# 动态生成的字符串s3 = &#x27;&#x27;.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])print(s1 == s3)  # Trueprint(s1 is s3)  # False，复杂或动态生成的字符串，is一般是False\n\n重要概念：\n\n字符串驻留：Python对于短小、常用的字符串可能会优化，放到同一个内存地址\n内容比较 vs 身份比较：==比较内容，is比较内存地址\n\nset操作（HashSet）# set判断元素是否相等靠内容，不看对象idstr1 = str(&quot;Hello&quot;) str2 = str(&quot;Hello&quot;)  # 不同内存地址，但是内容都是Hellos = set()s.add(str1)print(&quot;Hello&quot; in s)     # Trueprint(str2 in s)        # Trues.add(str2)print(len(s))           # 1，因为set里不会存储重复元素s.discard(str1)         # 删除等价元素（内容相等的字符串都会被删掉）s.clear()               # 清空所有元素print(len(s) == 0)      # True\n\ndict操作（HashMap）# dict操作map1 = dict()map1[str1] = &quot;World&quot;    # str1是key，&quot;World&quot;是valueprint(&quot;Hello&quot; in map1)  # Trueprint(str2 in map1)     # Trueprint(map1.get(str2))   # Worldprint(map1.get(&quot;你好&quot;) is None)  # Trueif &quot;Hello&quot; in map1:    del map1[&quot;Hello&quot;]print(len(map1))        # 0map1.clear()print(len(map1) == 0)   # True\n\n哈希表的优化策略数组替代哈希表当key的范围是固定的、可控的情况下，可以用数组结构替代哈希表结构：\n# 哈希表实现map2 = dict()map2[56] = 7285map2[34] = 3671263map2[17] = 716311map2[24] = 1263161# 数组替代实现（速度更快）arr = [0] * 100arr[56] = 7285arr[34] = 3671263arr[17] = 716311arr[24] = 1263161\n\n优势：\n\n速度更快：直接数组访问，无需哈希计算\n空间可控：预知范围，精确分配空间\n无哈希冲突：避免了哈希表的冲突处理\n\n自定义对象作为Keyclass Student:    def __init__(self, age, name):        self.age = age        self.name = names1 = Student(17, &quot;张三&quot;)s2 = Student(17, &quot;张三&quot;)map3 = dict()map3[s1] = &quot;这是张三&quot;print(s1 in map3)  # Trueprint(s2 in map3)  # False，Python默认不同对象hash不同map3[s2] = &quot;这是另一个张三&quot;print(len(map3))   # 2，s1和s2是不同的对象，字典中有两个键值对\n\n重要提示：Python自定义对象没有实现__eq__和__hash__时，默认按对象id判定。\n有序表（TreeMap&#x2F;TreeSet）Python中的有序表模拟Python没有内置的TreeMap，需要用其他方式模拟：\nimport heapq# 用dict+排序模拟TreeMaptree_map = dict()tree_map[5] = &quot;这是5&quot;tree_map[7] = &quot;这是7&quot;tree_map[1] = &quot;这是1&quot;tree_map[2] = &quot;这是2&quot;tree_map[3] = &quot;这是3&quot;tree_map[4] = &quot;这是4&quot;tree_map[8] = &quot;这是8&quot;print(1 in tree_map)        # Trueprint(10 in tree_map)       # Falseprint(tree_map.get(4))      # 这是4tree_map[4] = &quot;张三是4&quot;print(tree_map.get(4))      # 张三是4tree_map.pop(4, None)       # 删除key为4的键值对print(tree_map.get(4) is None)  # True\n\n有序表的特殊操作# firstKey 和 lastKey 需要排序keys = sorted(tree_map.keys())print(keys[0])      # firstKey: 1print(keys[-1])     # lastKey: 8# floorKey: 所有的key，&lt;= 4且最近的key是什么def floor_key(k):    return max([x for x in tree_map if x &lt;= k], default=None)# ceilingKey: 所有的key，&gt;= 4且最近的key是什么def ceiling_key(k):    return min([x for x in tree_map if x &gt;= k], default=None)print(floor_key(4))    # 3print(ceiling_key(4))  # 5\n\n操作解释：\n\n删除前：1, 2, 3, [4], 5, 7, 8\n删除后：1, 2, 3, 5, 7, 8\nfloor_key(4)：找到 ≤ 4 的最大值，可选值：[1, 2, 3]，最大值：3\nceiling_key(4)：找到 ≥ 4 的最小值，可选值：[5, 7, 8]，最小值：5\n\nTreeSet模拟# TreeSet模拟：用set+排序（去重且有序）s = set()s.add(3)s.add(3)s.add(4)s.add(4)print(&quot;有序表大小:&quot;, len(s))  # 2，因为set里不会存储重复元素# 以有序弹出for item in sorted(s):    print(item)  # 3 4\n\n优先队列（堆）小根堆# 小根堆heap1 = []heapq.heappush(heap1, 3)heapq.heappush(heap1, 3)heapq.heappush(heap1, 4)heapq.heappush(heap1, 4)print(&quot;堆大小:&quot;, len(heap1))  # 4while heap1:    print(heapq.heappop(heap1))  # 3 3 4 4\n\n大根堆实现技巧# 大根堆trick：使用负数heap2 = []for x in [3, 3, 4, 4]:    heapq.heappush(heap2, -x)print(&quot;堆大小:&quot;, len(heap2))  # 4while heap2:    print(-heapq.heappop(heap2))  # 4 4 3 3\n\n核心技巧：Python的heapq只提供小根堆，要实现大根堆可以将所有元素取负数。\n比较器的使用基本比较器概念任何比较器都有统一的规则：\n\n返回负数：认为第一个对象优先级更高\n返回正数：认为第二个对象优先级更高\n返回0：两个对象优先级相等\n\n员工类的排序示例from functools import cmp_to_keyclass Employee:    def __init__(self, company, age):        self.company = company        self.age = age    def __repr__(self):        return f&quot;Employee(&#123;self.company&#125;, &#123;self.age&#125;)&quot;# 员工比较器，按年龄升序def employee_comparator(o1, o2):    return o1.age - o2.age# 创建员工对象s1 = Employee(2, 27)s2 = Employee(1, 60)s3 = Employee(4, 19)s4 = Employee(3, 23)s5 = Employee(1, 35)s6 = Employee(3, 55)arr = [s1, s2, s3, s4, s5, s6]# 按年龄升序排序arr.sort(key=cmp_to_key(employee_comparator))for e in arr:    print(f&quot;&#123;e.company&#125;, &#123;e.age&#125;&quot;)\n\n多种排序方式# 按年龄降序排序（lambda表达式）arr.sort(key=lambda x: -x.age)for e in arr:    print(f&quot;&#123;e.company&#125;, &#123;e.age&#125;&quot;)# 多级排序：先按公司编号，再按年龄arr.sort(key=lambda x: (x.company, x.age))for e in arr:    print(f&quot;&#123;e.company&#125;, &#123;e.age&#125;&quot;)\n\n自定义对象的去重策略按年龄去重class EmployeeByAge(Employee):    def __eq__(self, other):        return self.age == other.age  # 只看年龄        def __hash__(self):        return hash(self.age)treeSet1 = set()for e in arr:    treeSet1.add(EmployeeByAge(e.company, e.age))print(len(treeSet1))  # 6# 会去重，因为age一样的员工被认为是同一个treeSet1.add(EmployeeByAge(2, 27))print(len(treeSet1))  # 6\n\n按多个属性去重class EmployeeByAll(Employee):    def __eq__(self, other):        if not isinstance(other, EmployeeByAll):            return False        return (self.company == other.company and                 self.age == other.age and                 repr(self) == repr(other))        def __hash__(self):        return hash((self.company, self.age, repr(self)))treeSet2 = set()for e in arr:    treeSet2.add(EmployeeByAll(e.company, e.age))print(len(treeSet2))  # 6# 不会去重，因为repr不同（内存地址不同）treeSet2.add(EmployeeByAll(2, 27))print(len(treeSet2))  # 7\n\n重要概念：\n\n__eq__方法：定义对象间的相等性比较，当使用==操作符时调用\n__hash__方法：定义对象的哈希值，用于在集合和字典中作为键\n\n字符串的字典序比较# 字典序比较str1 = &quot;abcde&quot;str2 = &quot;ks&quot;print(str1.__lt__(str2) - str1.__gt__(str2))  # -1print(str2.__lt__(str1) - str2.__gt__(str1))  # 1# 或者直接用比较运算符print((str1 &gt; str2) - (str1 &lt; str2))  # -1print((str2 &gt; str1) - (str2 &lt; str1))  # 1\n\n字典序规则：按字符的ASCII码逐位比较，先遇到不同字符的位置决定大小关系。\n数据结构选择指南性能对比表\n\n\n数据结构\n查找\n插入\n删除\n有序性\n去重\n适用场景\n\n\n\nset\nO(1)\nO(1)\nO(1)\n❌\n✅\n快速查重、集合运算\n\n\ndict\nO(1)\nO(1)\nO(1)\n❌\n✅\n键值映射、缓存\n\n\n数组\nO(1)\nO(1)\nO(1)\n❌\n❌\nkey范围可控时替代哈希表\n\n\n排序列表\nO(log n)\nO(n)\nO(n)\n✅\n❌\n需要有序且查找频繁\n\n\nheapq\nO(1)\nO(log n)\nO(log n)\n部分\n❌\n优先队列、Top-K问题\n\n\n使用建议\n快速查找、去重：使用set\n键值映射：使用dict\nkey范围固定：考虑数组替代哈希表\n需要有序：使用排序+二分查找或第三方库\n优先队列：使用heapq\n自定义排序：实现比较器或使用key参数\n\n实际应用场景场景1：统计词频# 使用dict统计text = &quot;hello world hello python&quot;word_count = &#123;&#125;for word in text.split():    word_count[word] = word_count.get(word, 0) + 1print(word_count)  # &#123;&#x27;hello&#x27;: 2, &#x27;world&#x27;: 1, &#x27;python&#x27;: 1&#125;\n\n场景2：去重并保持顺序# 使用dict保持插入顺序的去重def dedupe_keep_order(items):    seen = &#123;&#125;    result = []    for item in items:        if item not in seen:            seen[item] = True            result.append(item)    return resultitems = [1, 2, 3, 2, 4, 1, 5]print(dedupe_keep_order(items))  # [1, 2, 3, 4, 5]\n\n场景3：Top-K问题import heapqdef find_top_k(nums, k):    # 使用小根堆，维护k个最大元素    heap = []    for num in nums:        if len(heap) &lt; k:            heapq.heappush(heap, num)        elif num &gt; heap[0]:            heapq.heapreplace(heap, num)    return sorted(heap, reverse=True)nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]print(find_top_k(nums, 3))  # [9, 6, 5]\n\n总结\n哈希表：提供O(1)的查找、插入、删除，但有较大常数因子\n有序表：在Python中需要模拟实现，适合需要有序性的场景\n比较器：统一的优先级比较规则，负数表示第一个对象优先级更高\n优化策略：key范围可控时用数组替代哈希表，性能更好\n实际应用：根据具体需求选择合适的数据结构，考虑时间复杂度和空间复杂度的权衡\n\n027【必备】堆结构常见题Python heapq 模块详解heapq 基本概念heapq 是 Python 标准库提供的”二叉堆”实现工具，基于列表实现的最小堆（min-heap）。它能在 O(log n) 时间内插入与弹出最小元素，heap[0] 永远是当前最小值。\n常用 APIimport heapq# 基本操作heapq.heappush(heap, item)      # 压入元素，O(log n)heapq.heappop(heap)             # 弹出最小元素，O(log n)heapq.heapify(lst)              # 原地把列表转成堆，O(n)# 高效组合操作heapq.heappushpop(heap, item)   # 先推入再弹出（更高效的一步）heapq.heapreplace(heap, item)   # 先弹出最小再推入# 实用函数heapq.nsmallest(n, iterable)    # 返回n个最小元素heapq.nlargest(n, iterable)     # 返回n个最大元素heapq.merge(*iterables)         # 合并多个已排序可迭代对象（惰性生成）\n\n大根堆实现技巧由于 Python 的 heapq 只提供小根堆，实现大根堆需要使用负数技巧：\n# 大根堆实现heap = []for x in [3, 1, 4, 1, 5]:    heapq.heappush(heap, -x)    # 插入负数max_val = -heapq.heappop(heap)  # 弹出并转回正数\n\n问题一：合并K个有序链表测试链接：https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6\n问题描述给定K个有序链表，将它们合并成一个有序链表。\n算法思路使用小根堆维护所有链表的当前头节点，每次取出值最小的节点：\n\n初始化：将所有链表的头节点放入堆中\n合并过程：\n弹出堆顶最小节点，连接到结果链表\n如果该节点有下一个节点，将下一个节点入堆\n重复直到堆为空\n\n\n\n\n核心实现import heapqfrom typing import List, Optionalclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextdef mergeKLists(arr: List[Optional[ListNode]]) -&gt; Optional[ListNode]:    # 小根堆，存储节点及其值，用堆结构的话时间复杂度会比O(NlogN)更小    # Optional[T] 等价于 Union[T, None]    # 表示这个值可能是 T 类型，也可能是 None    heap = []        # 将所有链表头节点入堆    for h in arr:        if h is not None:            # Python的heapq不能直接比较对象，需包装            heapq.heappush(heap, (h.val, id(h), h))            # heapq 比较规则：它按元组字典序比较。你放入 (val, something, node) 时，先比 val，相等就比第二个元素；如果第二个也相等，就会去比第三个元素（即 ListNode 实例）。            # 问题：ListNode 没有定义大小比较，直接比较会抛出 TypeError: &#x27;&lt;&#x27; not supported...            # 加入 id(node)：id 是对象在该进程生命周期内的唯一“身份值”（可比较），作为“决胜键”保证元组能比较出大小，从而避免直接比较 ListNode。     if not heap:        return None        # 弹出一个节点作为总头部    _, _, h = heapq.heappop(heap)    pre = h        # 将该节点的下一个节点入堆    if pre.next is not None:        heapq.heappush(heap, (pre.next.val, id(pre.next), pre.next))        # 继续合并过程    while heap:        _, _, cur = heapq.heappop(heap)        pre.next = cur      # 连接链表        pre = cur          # pre后移        if cur.next is not None:            heapq.heappush(heap, (cur.next.val, id(cur.next), cur.next))        return h    # 对 heapq 来说，一个 item 就是一个可比较的对象。这里把一个三元组 (pre.next.val, id(pre.next), pre.next) 当作 item 放入堆。    # 比较顺序（字典序）：    # 先比第 1 位 pre.next.val（值越小，优先级越高）    # 若相等，再比第 2 位 id(pre.next)（保证能比较出大小，避免去比较 ListNode 本身）    # 只在前两位都相等时，才会看第 3 位 pre.next（但通常不会用到，因为 id 已经唯一）\n\n关键技术点元组比较机制：\n\nheapq 按元组字典序比较：(val, something, node)\n先比较 val，相等时比较第二个元素\n加入 id(node) 作为”决胜键”，避免直接比较 ListNode 对象\n\n为什么需要 id(node)：\n\nListNode 没有定义大小比较，直接比较会抛出 TypeError\nid() 返回对象的唯一标识符，可以进行比较\n保证元组能比较出大小，避免直接比较 ListNode\n\n复杂度分析\n时间复杂度：O(N log K)，其中 N 是所有节点总数，K 是链表个数\n空间复杂度：O(K)，堆中最多存储 K 个节点\n\n问题二：最多线段重合问题测试链接：\n\nhttps://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37\nhttps://leetcode.cn/problems/meeting-rooms-ii/\n\n问题描述给定n条线段，每条线段有起点和终点，求最多同时重合的线段数量。\n算法思路使用扫描线算法 + 小根堆：\n\n排序：将所有线段按起点排序\n扫描：从左到右处理每条线段\n维护堆：堆中存储当前重合线段的结束时间\n清理：移除已结束的线段（结束点 ≤ 当前起点）\n更新：添加当前线段，更新最大重合数\n\n\n核心实现\n想象每条线段根据开始和结束位置，放在x轴上，然后有一根竖线，从左到右划过x轴，竖线压中的线段上的点，就需要把当前点放入到某个组里。\n\n请问，从左到右划的过程，你最多需要准备几个组？最多重合几条线段，就需要几个组。这些组不断复用空间，放入不同的点。但是最大重合了多少，你就需要准备几个组。\n\n重要：我之前一直在纠结为什么不要考虑后面重复合并， 但是我们这个代码已经考虑了后面重复合并，因为我们是把结束点加入到堆里，而不是把线段加入到堆里。因此即便这条线段的结束点和后面的线段的开始点重合，我们也会把这条线段的结束点加入到堆里，则以这个为标准对数轴进行扫描，又因为小根堆是根据开始点进行从小大排序的，所以能够保证后面的线段初始点严格小于当前线段的初始点，不会忽略到后面的线段重合，这个是个离散的逐点扫描的过程。\n\n\nimport heapqdef compute():    &quot;&quot;&quot;    # 时间复杂度：O(NlogN) ，n条线段，平均比较次数是logN，所以是O(NlogN)    # 空间复杂度：O(N)，因为需要存储每条线段的结束点&quot;&quot;&quot;    global size    size = 0  # 堆的清空        # 所有线段根据开始位置排序    sorted_lines = sorted(line[:n], key=lambda x: x[0])        ans = 0  # 最大重合数    for i in range(n):        # 步骤1：清理已结束的线段        while size &gt; 0 and heap[0] &lt;= sorted_lines[i][0]:            # 堆顶是最早结束的线段            # 如果它的结束点 ≤ 当前线段的起点，说明已经不重合了            pop()  # 移除这个已结束的线段                # 步骤2：加入当前线段        add(sorted_lines[i][1])  # 把当前线段的结束点加入堆                # 步骤3：更新答案        ans = max(ans, size)  # 当前堆的大小 = 当前重合的线段数        return ans\n\n算法可视化想象一根竖线从左到右扫过数轴：\n线段1: |-------|线段2:    |-----|线段3:      |---|线段4:        |-----|扫描过程：时刻1: |          重合数 = 1时刻2:   |        重合数 = 2  时刻3:     |      重合数 = 3 (最大值)时刻4:       |    重合数 = 2\n\n手写堆实现为了提高效率，使用数组实现小根堆：\nMAXN = 10001heap = [0] * MAXN  # 存储结束点size = 0def add(x):    global size    heap[size] = x    i = size    size += 1    # 上浮调整    while i &gt; 0 and heap[i] &lt; heap[(i - 1) // 2]:        swap(i, (i - 1) // 2)        i = (i - 1) // 2def pop():    global size    swap(0, size - 1)    size -= 1    i = 0    l = 1    # 下沉调整    while l &lt; size:        best = l + 1 if l + 1 &lt; size and heap[l + 1] &lt; heap[l] else l        best = best if heap[best] &lt; heap[i] else i        if best == i:            break        swap(i, best)        i = best        l = i * 2 + 1def swap(i, j):    heap[i], heap[j] = heap[j], heap[i]\n\n变种问题会议室问题def minMeetingRooms(meeting):    n = len(meeting)    meeting.sort(key=lambda x: x[0])  # 按起始时间排序    heap = []  # 小根堆，会议的结束时间    ans = 0        for i in range(n):        while heap and heap[0] &lt;= meeting[i][0]:  # 堆顶会议已结束            heapq.heappop(heap)        heapq.heappush(heap, meeting[i][1])      # 当前会议结束时间入堆        ans = max(ans, len(heap))                # 记录最大会议室数量        return ans\n\n分组问题def minGroups(meeting):    n = len(meeting)    meeting.sort(key=lambda x: x[0])    heap = []    ans = 0        for i in range(n):        while heap and heap[0] &lt; meeting[i][0]:  # 注意此处是 &lt;，题意不同            heapq.heappop(heap)        heapq.heappush(heap, meeting[i][1])        ans = max(ans, len(heap))        return ans\n\n关键区别：会议室问题用 &lt;=（会议可以无缝衔接），分组问题用 &lt;（需要间隔）。\n复杂度分析\n时间复杂度：O(N log N)，排序 + 每个元素平均 log N 次堆操作\n空间复杂度：O(N)，存储线段结束点的堆\n\n问题三：将数组和减半的最少操作次数测试链接：https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/\n问题描述给定一个数组，每次操作可以将任意一个元素减半，求使数组总和减少到原来一半所需的最少操作次数。\n算法思路使用贪心策略 + 大根堆：\n\n贪心原理：每次选择当前最大的元素进行减半，减少量最大\n堆维护：用大根堆维护当前所有元素\n操作过程：不断取出最大元素减半，直到总减少量达到目标\n\n方法一：基于 heapqimport heapqdef halveArray1(nums):    # 大根堆（用负数模拟）    heap = []    sum_val = 0        for num in nums:        heapq.heappush(heap, -float(num))  # 负数模拟大根堆        sum_val += num        sum_val /= 2  # 要减少到总和一半    ans = 0       # 操作次数    minus = 0     # 已减少的和        while minus &lt; sum_val:        cur = -heapq.heappop(heap) / 2  # 取出最大数、减半        heapq.heappush(heap, -cur)      # 新值放回堆        minus += cur                    # 记录减少量        ans += 1                        # 操作次数加1        return ans\n\n方法二：手写堆 + 精度优化MAXN = 100001heap_arr = [0] * MAXNsize = 0def halveArray2(nums):    global size    size = len(nums)    sum_val = 0        # 初始化大根堆，左移20位保证精度    for i in range(size - 1, -1, -1):        heap_arr[i] = int(nums[i]) &lt;&lt; 20  # 左移20位放大        sum_val += heap_arr[i]        heapify(i)  # 调整堆        sum_val //= 2  # 目标减少量    ans = 0    minus = 0        while minus &lt; sum_val:        heap_arr[0] //= 2    # 堆顶减半        minus += heap_arr[0]        heapify(0)        ans += 1        return ansdef heapify(i):    global size    l = i * 2 + 1    while l &lt; size:        best = l + 1 if l + 1 &lt; size and heap_arr[l + 1] &gt; heap_arr[l] else l        best = best if heap_arr[best] &gt; heap_arr[i] else i        if best == i:            break        swap(best, i)        i = best        l = i * 2 + 1def swap(i, j):    heap_arr[i], heap_arr[j] = heap_arr[j], heap_arr[i]\n\n关键优化技术精度处理问题：浮点数运算有精度损失，可能导致结果错误\n解决方案：\n\n将所有数左移20位（乘以 2²⁰）\n用整数运算模拟浮点数运算\nint(32位) × 2²⁰ &lt; long(64位)，不会溢出\n\n性能优化手写堆 vs heapq：\n\nheapq 基于 Python 列表，有额外开销\n手写数组堆效率更高，常数因子更小\n\n算法正确性证明贪心策略的正确性：\n\n每次选择最大元素减半，获得的减少量最大\n假设最优解不是每次选最大元素，可以证明交换操作不会使结果变差\n因此贪心策略能得到最优解\n\n复杂度分析\n时间复杂度：O(N log N)，每个元素最多被操作 log(max_value) 次。若傻傻地每个元素都缩1&#x2F;2，一定能达成目标；显然操作的元素个数一定小于n\n空间复杂度：O(N)，存储堆的空间\n\n堆结构应用总结适用场景\n\n\n问题类型\n堆类型\n核心思想\n典型例题\n\n\n\n合并有序序列\n小根堆\n维护多个序列的当前最小值\n合并K个有序链表\n\n\n区间重合问题\n小根堆\n扫描线 + 维护结束时间\n最多线段重合\n\n\n贪心选择\n大根堆\n每次选择当前最值进行操作\n数组和减半\n\n\nTop-K问题\n小根堆\n维护K个最大值\n第K大元素\n\n\n任务调度\n小根堆\n按优先级处理任务\nCPU任务调度\n\n\n实现选择\n\n\n情况\n推荐实现\n原因\n\n\n\n原型开发\nheapq\n简单易用，标准库\n\n\n性能要求高\n手写堆\n效率更高，常数因子小\n\n\n需要大根堆\n负数技巧\nPython只有小根堆\n\n\n精度要求高\n整数模拟\n避免浮点数误差\n\n\n常见陷阱\n对象比较问题：自定义对象作为堆元素时，需要实现比较方法或使用包装\n精度问题：浮点数运算可能有误差，关键场合使用整数\n堆类型混淆：Python默认小根堆，大根堆需要取负数\n边界条件：空堆操作、单元素情况需要特殊处理\n\n性能优化技巧\n预分配空间：手写堆时预分配数组空间\n避免频繁内存操作：使用数组而非动态列表\n批量操作：heapify 比逐个插入效率高\n精度与性能平衡：根据需求选择合适的数据类型\n\n堆结构是解决很多算法问题的重要工具，在实际使用中，要根据具体问题选择合适的实现方式和优化策略。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","堆结构","哈希表","比较器","heapq模块"]},{"title":"数据结构与算法自学笔记（7）- 随机排序&随机选择算法","url":"/2025/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89-%20%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F&%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了随机快速排序和随机选择算法的原理与实现，涵盖了荷兰国旗问题优化、时间复杂度分析等内容，包括了class023 -&gt; class024的内容\n023【必备】随机快速排序快速排序的基本思想快速排序是一种高效的分治排序算法，其核心思想是：\n\n选择基准元素（pivot）：从数组中选择一个元素作为基准值pivot\n数组划分：将数组重新排列，使得所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面\n递归排序：对基准值两侧的子数组递归地应用快速排序\n\n随机化的重要性为什么需要随机化？\n\n普通快速排序：固定选择位置（如最右元素）作为基准，最坏情况时间复杂度为O(n²)\n随机快速排序：随机选择基准元素，期望时间复杂度为O(n log n)\n\n# 随机选择基准元素是关键x = arr[random.randint(l, r)]  # 在[l,r]范围内随机选择\n\n\n 测试链接 ：https://www.luogu.com.cn/problem/P1177\n经典快速排序实现（不推荐）def quickSort1(l, r):    # l == r，只有一个数    # l &gt; r，范围不存在，不用管    if l &gt;= r:        return    # 随机这一下，常数时间比较大    # 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)    # l......r 随机选一个位置，x这个值，做划分    x = arr[random.randint(l, r)]    mid = partition1(l, r, x) #会返回x的下标即index    quickSort1(l, mid - 1)    quickSort1(mid + 1, r)# 已知arr[l....r]范围上一定有x这个值# 划分数组 &lt;=x放左边，&gt;x放右边# 并且确保划分完成后&lt;=x区域的最后一个数字是xdef partition1(l, r, x):    # a : arr[l....a-1]范围是&lt;=x的区域    # xi : 记录在&lt;=x的区域上任何一个x的位置，哪一个都可以    a = l            # 初始化指针a，表示&lt;=x区域的右边界，初值为l    xi = 0           # 初始化xi，用于记录&lt;=x区域内某一个x的位置（后面需要与a-1交换）    for i in range(l, r + 1):   # 从l遍历到r，依次考察每个元素，每一步都会i++（重要，所以这里的代码没有显式写i++）        if arr[i] &lt;= x:         # 如果当前元素小于等于x            swap(a, i)          # 把当前元素交换到a位置（即&lt;=x区的后面）            if arr[a] == x:     # 如果新放到a位置的元素等于x                xi = a          # 记录下这个位置为xi            a += 1              # &lt;=x区往右扩展一位    swap(xi, a - 1)             # 把&lt;=x区域里某个x与区域最后一个元素交换，保证x落在最后    return a - 1                # 返回&lt;=x区域的最后一个下标（即x最终所在的位置）def swap(i, j):    tmp = arr[i]        # 先把arr[i]暂存到tmp    arr[i] = arr[j]     # arr[i]赋值为arr[j]    arr[j] = tmp        # arr[j]赋值为tmp，实现arr[i]和arr[j]交换\n\n经典版本的问题：\n\n经典快排每次只排掉一个等于pivot的元素，重复元素多时递归深度大，容易爆栈突变为，pivot 只确定了它自己的最终位置，如果有很多元素等于 pivot，只有一个会归位，剩下的还在“乱序”的子区间里。\n\n\n荷兰国旗问题优化版（推荐）荷兰国旗问题是快速排序的重要优化，将数组分为三个区域：\n[小于x的区域] [等于x的区域] [大于x的区域]\n能够一次处理所有等于pivot的元素，递归层数大大降低，所以不会爆栈，每次把所有等于pivot的数都一次性放到中间，只对小于和大于pivot的区间递归\n核心优势\n一次性处理所有相等元素：将所有等于pivot的元素都放到正确位置\n减少递归层数：只需要对小于和大于pivot的区域递归\n避免栈溢出：特别适合处理有大量重复元素的数组\n\n实现代码def quickSort2(l, r):    if l &gt;= r:        return    # 随机这一下，常数时间比较大    # 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)    x = arr[random.randint(l, r)]    partition2(l, r, x)    # 为了防止底层的递归过程覆盖全局变量    # 这里用临时变量记录first、last    left = first[0]    right = last[0]    quickSort2(l, left - 1)    quickSort2(right + 1, r)# 荷兰国旗问题first = [0]  # 用list模拟全局变量last = [0]# 已知arr[l....r]范围上一定有x这个值# 划分数组 &lt;x放左边，==x放中间，&gt;x放右边# 把全局变量first, last，更新成==x区域的左右边界def partition2(l, r, x):    first[0] = l    last[0] = r    i = l    while i &lt;= last[0]:        if arr[i] == x:            i += 1        elif arr[i] &lt; x:            swap(first[0], i)            first[0] += 1            i += 1        else:            swap(i, last[0])            last[0] -= 1 #i不变的原因是交换后 i 位置上的新元素还没考察过#前两种情况i++的原因是x作为基准，在i位置上，顶着左边区域向右推进，此外快速排序算法不需要随机元素的index\n\n荷兰国旗问题详细演示以数组 [7, 2, 6, 3, 1, 5, 4]，pivot&#x3D;3 为例：\n初始状态：\narr = [7, 2, 6, 3, 1, 5, 4]first = 0, last = 6, i = 0\n\nStep 1：arr[0] = 7 &gt; 3\n\n与 arr[6] 交换：[4, 2, 6, 3, 1, 5, 7]\nlast = 5，i 不变\n\nStep 2：arr[0] = 4 &gt; 3\n\n与 arr[5] 交换：[5, 2, 6, 3, 1, 4, 7]\nlast = 4，i 不变\n\nStep 3：arr[0] = 5 &gt; 3\n\n与 arr[4] 交换：[1, 2, 6, 3, 5, 4, 7]\nlast = 3，i 不变\n\nStep 4：arr[0] = 1 &lt; 3\n\n与 arr[0] 交换（自己）：不变\nfirst = 1，i = 1\n\nStep 5：arr[1] = 2 &lt; 3\n\n与 arr[1] 交换（自己）：不变\nfirst = 2，i = 2\n\nStep 6：arr[2] = 6 &gt; 3\n\n与 arr[3] 交换：[1, 2, 3, 6, 5, 4, 7]\nlast = 2，i 不变\n\nStep 7：arr[2] = 3 == 3\n\ni = 3，此时 i &gt; last，循环结束\n\n最终结果：\narr = [1, 2, 3, 6, 5, 4, 7][0, 1]: 小于3的区域 [1, 2][2, 2]: 等于3的区域 [3][3, 6]: 大于3的区域 [6, 5, 4, 7]\n\n时间复杂度分析随机快速排序的复杂度时间复杂度：O(n log n) （期望）\n\n每层的划分操作需要O(n)时间\n随机选择使得平均递归深度为O(log n)\n总时间复杂度：O(n) × O(log n) &#x3D; O(n log n)\n\n空间复杂度：O(log n) （期望）\n\n来自递归调用栈的深度\n最好情况：每次平分，深度为O(log n)\n最坏情况：退化为链式递归，深度为O(n)\n\n与普通快速排序对比普通快速排序\n\n普通快速排序的时间复杂度O(n^2)：固定流程考虑最坏情况（极端不平衡，每次都选到最小或最大元素为主元），每次只能划分出一个元素，剩下的 n-1 继续递归；额外空间复杂度O(n)取得是最坏情况递归的栈的深度。\n最好情况：T(n) &#x3D; 2 * T(n&#x2F;2) + O(n) &#x3D; O(n * logn),空间是O(logn)取得是递归的栈的深度。\n因为固定流程的话，可以构造出特定的数据，导致每次固定取最右最左的元素都是最差情况。\n\n随机快速排序\n\n随机快速排序，时间复杂度O(n * logn)随机取得是期望理论上每次能比较均匀划分为两半，递归深度约为 log𝑛，每一层的划分操作需要 O(n) 时间。额外空间复杂度O(logn)取得是递归的栈的深度，运气好每次都是区间二分，参考中序二叉树\n取期望，每个位置取1&#x2F;N的权重，最后能证明期望时间复杂度是O(n * logn)，额外空间复杂度O(logn)\n关于复杂度的分析，进行定性的说明，定量证明略，因为证明较为复杂，算法导论-7.4.2有详细证明\n\n\n\n\n算法类型\n时间复杂度（平均）\n时间复杂度（最坏）\n空间复杂度（平均）\n空间复杂度（最坏）\n\n\n\n普通快排\nO(n log n)\nO(n²)\nO(log n)\nO(n)\n\n\n随机快排\nO(n log n)\nO(n log n)*\nO(log n)\nO(log n)*\n\n\n*期望意义下\n024【必备】随机选择算法问题描述无序数组中第K大的元素问题：\n\n给定整数数组 nums 和整数 k\n返回数组中第 k 个最大的元素\n要求时间复杂度为 O(n)\n\n关键转换：第K大 &#x3D; 第(len-k)小（python中）。事实上，若下标从0开始时，第K大等于第(len-k)小（即下标为len-k的元素）；如果下标从1开始，则用len+1-k\n随机选择算法原理随机选择算法是快速排序的变种，核心思想：\n\n只关心目标位置：不需要完全排序，只需要找到第K大的元素\n单侧递归：每次只需要在包含目标位置的一侧继续查找\n随机化优化：通过随机选择pivot避免最坏情况\n\n 测试链接 ：https://leetcode.cn/problems/kth-largest-element-in-an-array/\n实现代码class RandomizedSelect:    first = 0  # 等于区域的左边界    last = 0   # 等于区域的右边界    @staticmethod    def findKthLargest(nums, k):        &quot;&quot;&quot;找第K大元素&quot;&quot;&quot;        # 转换为找第(len-k)小的元素        return RandomizedSelect.randomizedSelect(nums, len(nums) - k)    @staticmethod    def randomizedSelect(arr, i):        &quot;&quot;&quot;        连递归都没用，所以时间复杂度是O(n)左右的量级        在数组中找到如果排序后在位置i的元素        时间复杂度：O(n)        &quot;&quot;&quot;        ans = 0        l = 0        r = len(arr) - 1                while l &lt;= r:#不断二分的过程中，l和r上是仍然有范围的，直到没有范围才终止            # 随机这一下，常数时间比较大            # 但只有这一下随机，才能在概率上把时间复杂度收敛到O(n)            pivot = arr[l + int(random.random() * (r - l + 1))]                        # 使用荷兰国旗问题进行划分            RandomizedSelect.partition(arr, l, r, pivot)                        # 因为左右两侧只需要走一侧            # 所以不需要临时变量记录全局的first、last，直接用即可            # 等于的区域即first，last包住的位置，i小于first则去左侧，i大于last则去右侧            if i &lt; RandomizedSelect.first:                r = RandomizedSelect.first - 1  # 目标在左侧，pivot左边变成r            elif i &gt; RandomizedSelect.last:                l = RandomizedSelect.last + 1   # 目标在右侧，pivot右边变成l            else:                ans = arr[i]  # 找到目标                break                        return ans    @staticmethod    def partition(arr, l, r, x):        &quot;&quot;&quot;荷兰国旗问题划分&quot;&quot;&quot;        RandomizedSelect.first = l        RandomizedSelect.last = r        i = l                while i &lt;= RandomizedSelect.last:            if arr[i] == x:                i += 1            elif arr[i] &lt; x:                RandomizedSelect.swap(arr, RandomizedSelect.first, i)                RandomizedSelect.first += 1                i += 1            else:                RandomizedSelect.swap(arr, i, RandomizedSelect.last)                RandomizedSelect.last -= 1    @staticmethod    def swap(arr, i, j):        &quot;&quot;&quot;交换数组元素&quot;&quot;&quot;        arr[i], arr[j] = arr[j], arr[i]\n\n算法执行示例以数组 [7, 2, 6, 3, 1, 5, 4]，查找第4小元素（下标为3）为例：\n第一轮：\n\n随机选择 pivot = 3\n划分后：[1, 2, 3, 6, 5, 4, 7]\n等于区域：first = 2, last = 2\n目标下标3 &gt; last&#x3D;2，继续在右侧 [6, 5, 4, 7] 查找\n\n第二轮：\n\n在右侧区域随机选择 pivot = 4\n划分后相对位置：[4, 5, 6, 7]（实际在原数组的3,4,5,6位置）\n等于区域：first = 3, last = 3\n目标下标3 &#x3D;&#x3D; first &#x3D;&#x3D; last，找到答案 arr[3] = 4\n\n时间复杂度证明（定性分析）为什么是O(n)？\n每次划分后，下一次只需要处理一侧的数据：\n\n第一次处理：n个元素\n第二次处理：n&#x2F;2个元素（期望）\n第三次处理：n&#x2F;4个元素（期望）\n…\n\n总时间：n + n/2 + n/4 + n/8 + ... ≈ 2n\n因此期望时间复杂度为 O(n)。\n与其他算法的比较\n\n\n算法\n时间复杂度\n空间复杂度\n特点\n\n\n\n完全排序\nO(n log n)\nO(1)\n简单但过度\n\n\n堆排序K次\nO(n + k log n)\nO(1)\n适合K很小的情况\n\n\n随机选择\nO(n)\nO(1)\n最优解\n\n\nBFPRT算法\nO(n)\nO(log n)\n理论最优但常数大\n\n\n实际应用场景\nTop-K问题：找出数组中最大&#x2F;最小的K个元素\n中位数查找：快速找到数组的中位数\n分位数计算：统计学中的百分位数计算\n数据分析：快速找到数据集中的特定排名元素\n\n关键要点总结\n随机化的重要性：\n\n避免最坏情况的发生\n使算法在期望意义下达到最优复杂度\n\n\n荷兰国旗问题的优势：\n\n一次性处理所有相等元素\n减少递归&#x2F;迭代次数\n提高算法稳定性\n\n\n单侧处理的效率：\n\n与完全排序不同，只需要处理包含目标的一侧\n大大减少了计算量\n\n\n工程实践建议：\n\n对于一般规模的数据，随机选择算法是首选\n当需要多次查询不同K值时，可以考虑先排序\n在对稳定性要求极高的场合，可以考虑BFPRT算法\n\n\n\n这两个算法（随机快速排序和随机选择）是分治算法的经典应用，展示了随机化在算法设计中的重要作用。掌握这些算法不仅有助于解决实际问题，也为理解更复杂的分治算法奠定了基础。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","分治算法","随机算法","荷兰国旗问题"]},{"title":"25 Spring - 模式识别笔记(1)","url":"/2025/03/07/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/","content":"引言Word2Vec Embedding 技术Word2Vec 是一种用于将单词映射到向量空间的技术，通过训练语料库来学习单词的语义关系。核心思想是将单词转换为一个高维向量，使得语义相近的单词在向量空间中距离较近。\nWord2Vec 过程\n输入文本（例如：”我”、”是”、”中国”、”人民”）\n嵌入层（Embedding）：将单词转换为向量表示\n训练：使用 Skip-gram 或 CBOW 模型进行训练\n输出向量：得到语义空间中的词向量表示\n\n在黑板上的示例中，展示了单词如何通过 Word2Vec 进行向量化，并且最终映射到一个 n 维向量空间中。\n\nK-Means 聚类算法K-Means 是一种常见的无监督学习算法，主要用于数据聚类。其基本思想是：\n\n给定样本集合 $S$，包含样本 $S_1, S_2, \\dots, S_k$。\n设定 $k$ 个聚类中心 $C_1, C_2, \\dots, C_k$。\n将样本 $f$ 分配给最近的聚类中心 $C_k$。\n\n数学定义定义样本 $f$ 归属于最接近的簇：\n$$U_k^* &#x3D;\\begin{cases}1, &amp; f \\in S_k \\0, &amp; \\text{otherwise}\\end{cases}$$\n其中，样本 $f$ 的归属取决于其与聚类中心 $C_k$ 的欧式距离：\n$$| f - C_k |^2$$\n因此，每个样本都会归属于离它最近的簇。\nK-Means 迭代步骤\n随机初始化 $k$ 个聚类中心 $C_1, C_2, \\dots, C_k$。\n计算每个样本到聚类中心的距离，并将其分配到最近的簇。\n更新聚类中心，使其成为簇中所有样本的平均值。\n重复步骤 2 和 3，直到聚类中心不再发生变化或达到迭代次数上限。\n\n\n总结\nWord2Vec 将单词映射到向量空间，使语义相似的单词在向量空间中更接近。  \nK-Means 通过反复迭代，将数据点划分到不同的簇中进行聚类分析。\n\n这两者结合在自然语言处理 (NLP) 中可用于 文本分类、聚类分析 等任务。例如，先用 Word2Vec 将文本转换为向量，然后使用 K-Means 进行文本聚类。\nkmeans算法的定义独热编码（One-Hot Encoding）在 K-Means 聚类算法中，我们使用独热编码（One-Hot Encoding）来表示样本所属的类别：\n\n若样本 $f$ 属于第 $k$ 个簇，则其独热编码表示为\n$$\\mathbf{U}^* &#x3D; (0, 0, \\dots, 1, \\dots, 0)$$\n其中只有第 $k$ 维的值为 1，其余维度为 0。\n\n例如：\n\n若 $f \\in S_1$：$$\\mathbf{U}^* &#x3D; (1, 0, 0, \\dots, 0)$$\n若 $f \\in S_k$：$$\\mathbf{U}^* &#x3D; (0, 0, \\dots, 1, \\dots, 0)$$\n\n\n\n\nK-Means 目标函数在 K-Means 算法中，我们的目标是最小化样本点到其分配的聚类中心的距离平方和：\n$$\\mathbf{U}^* &#x3D; \\arg\\min_{\\mathbf{U} \\in \\mathcal{U}} \\sum_{k&#x3D;1}^{K}U_k (f - C_k)^2$$\n其中：\n\n$\\mathcal{U}$ 是所有可能的独热编码集合：\n\n  \n  $$\\mathcal{U} = \\left\\{ \\mathbf{u} = (U_1, U_2, \\dots, U_K) \\,\\middle|\\, \\sum_{k=1}^{K} U_k = 1, \\quad 0 \\leq U_k \\leq 1 \\right\\}$$\n\n  表示每个样本点只能属于一个簇。\n\n定理及其证明定理（Thm）对于任意样本 $f$ 和聚类中心 $C_1, C_2, \\dots, C_K$，定义：\n\n$$\nU_k^* =\n\\begin{cases} \n1, & k = \\arg\\min\\limits_{R=1,2,\\dots,K} (f - C_R)^2 \\\\\n0, & \\text{else}\n\\end{cases}\n$$\n\n\n即，样本 $f$ 应该被分配到使得 $(f - C_k)^2$（最小值唯一） 最小的簇 $C_k$。\n证明（Proof）\n定义\n$$m &#x3D; \\min_{k \\in {1,2,\\dots,K}} {(f - C_k)^2}$$\n由于 $U_k$ 是独热编码，所有可能的 $U_k$ 满足\n$$\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$$\n\n目标函数展开：\n$$\\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \\geq\\ \\sum_{k&#x3D;1}^{K} U_k \\cdot m$$\n由于 $\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1,$ 代入可得：\n$$\\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \\geq m$$\n\n取 $U_k^*$ 使得 $k$ 取最小距离的索引，则：\n$$\\sum_{k&#x3D;1}^{K} U_k^* (f - C_k)^2 &#x3D; m.$$\n这说明只有当 $U_k^$ 取最优独热编码时，目标函数才能取到最小值 $m$ ，从而证明了 $U_k^$ 具有唯一最优解。\n\n\n\n结论\n独热编码 用于表示样本所属的类别，每个样本只能属于一个簇。  \n目标函数 通过最小化样本到其最近聚类中心的距离平方和，确定最优分类。  \n定理证明 说明了最佳分配方案是将样本分配到使得 $(f - C_k)^2$ 最小的簇。\n\n这一定理是 K-Means 算法的核心之一，保证了算法在每一步迭代中都能使目标函数收敛到一个局部最优解。\n–\n连续情况下的 K-Means 聚类定义在离散情况下，我们用有限个样本点 $f$ 进行聚类，而在连续情况下，需要对整个定义域 $\\Omega$ 进行考虑。\n目标函数扩展到连续情况\n设函数 $f: \\Omega \\to \\mathbb{R}$，其中 $\\Omega$ 是定义域，$f(x)$ 是定义在 $\\Omega$ 上的连续函数。  \n\n目标是在整个 $\\Omega$ 上最小化聚类误差：\n$$\\min_{\\mathbf{U}(x) \\in \\mathcal{U}} \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} U_k(x) (f(x) - C_k)^2$$\n其中：\n\n$C_1, C_2, \\dots, C_K$ 为 $K$ 个聚类中心。  \n$U_k(x)$ 表示位置 $x$ 归属于第 $k$ 个聚类中心的程度。\n\n\n\n\n约束条件为了保证每个点 $x$ 仅归属于一个聚类簇，引入约束：\n\n$$\n\\mathcal{U} = \\left\\{ \\mathbf{U}(x) = (U_1(x), U_2(x), \\dots, U_K(x)) \\,\\middle|\\, \\sum_{k=1}^{K} U_k(x) = 1, \\quad 0 \\leq U_k(x) \\leq 1, \\quad \\forall x \\in \\Omega \\right\\}\n$$\n\n\n\n这意味着：\n\n每个 $x$ 只能属于一个簇（即某个 $U_k(x)$ 取 1，其余取 0）。\n$U_k(x)$ 的取值范围在 $[0,1]$ 之间。\n\n\n直观解释从黑板上的示意图可以看出：\n\n$x \\in \\Omega$ 表示数据点在连续空间中的分布。\n$f(x)$ 代表数据点的特征值。\n目标是将这些数据点划分到不同的簇 $C_1, C_2, \\dots, C_K$ 中，使得同一簇中的点具有较小的方差。\n\n\n结论\n在连续情况下，K-Means 的目标函数和约束条件从离散样本点扩展到了整个定义域 $\\Omega$。  \n目标仍然是最小化数据点到聚类中心的平方误差。  \n约束条件确保每个点 $x$ 只能归属于一个簇。  \n这种扩展形式在实际应用中可用于处理连续空间中的数据，如图像分割或概率密度估计。\n\n\nK-Means 迭代优化过程K-Means 算法的目标是最小化聚类误差 $E(\\mathbf{U}, \\mathbf{C})$，即样本点到其聚类中心的平方误差和。它采用 迭代优化 的方式，在每次迭代中交替更新 簇分配 和 聚类中心，直到收敛。\n定义\n聚类中心向量：\n$$\\mathbf{C} &#x3D; (C_1, C_2, \\dots, C_K)^T.$$\n\nK-Means 的优化目标：\n$$\\min_{\\mathbf{U} \\in \\mathcal{U}, \\mathbf{C}} E(\\mathbf{U}, \\mathbf{C}).$$\n\n\nStep 1：更新簇分配 $\\mathbf{U}$$$\\mathbf{U}^{t+1} &#x3D; \\arg\\min_{\\mathbf{U} \\in \\mathcal{U}} E(\\mathbf{U}, \\mathbf{C}^t).$$\n其中，$U_k^{t+1}(x)$ 按照最近邻准则更新：\n\n$$\nU_k^{t+1}(x) =\n\\begin{cases}\n1, & k = \\arg\\min\\limits_{\\,k' \\in \\{1,2,\\dots,K\\}} \\bigl(f(x) - C_{k'}^t\\bigr)^2 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n\n\n即，将样本 $x$ 归到当前最近的聚类中心 $C_k^t$。\nStep 2：更新聚类中心 $\\mathbf{C}$$$\\mathbf{C}^{t+1} &#x3D; \\arg\\min_{\\mathbf{C}} E(\\mathbf{U}^{t+1}, \\mathbf{C}).$$\n聚类中心的更新公式：\n$$C_k &#x3D; \\frac{\\sum\\limits_{x \\in \\Omega} U_k^{t+1}(x) , f(x)}{|\\Omega_k|},$$\n其中：\n\n$\\Omega_k$ 是当前属于第 $k$ 个簇的所有样本点集合。\n上式表示：新的聚类中心是该簇内所有样本的加权平均值。\n也可以把$\\Omega_k$替换成$\\sum_{x \\in \\Omega} U_k^{t+1} (x) :&#x3D; \\Omega^{t+1}_{k}$\n\n总结\nStep 1：更新簇分配，使得每个点归属于与其最近的聚类中心。  \nStep 2：更新聚类中心，使其为簇内所有点的均值。  \n这两步交替进行，直到聚类中心不再变化，算法收敛。\n\n\n目标函数关于聚类中心的推导以下演示 Step 2（更新聚类中心）中，如何对目标函数关于聚类中心 $C_k$ 求导并得到更新公式。为简化，只对离散情形展示，连续情形可将求和替换为积分，思路相同。\n目标函数拆分K-Means 的目标函数（离散情形）：\n$$E(\\mathbf{U}, \\mathbf{C})&#x3D; \\sum_{k&#x3D;1}^{K} \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n我们先单独关注属于簇 $k$ 的部分：\n$$E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n在更新 $C_k$ 时，$U_k(x)$ 固定，只需对 $C_k$ 进行最优化。\n对 $C_k$ 求偏导令\n$$E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n对 $C_k$ 求导并令其为 0：\n$$\\frac{\\partial}{\\partial C_k} E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} 2 U_k(x)  \\bigl(C_k - f(x)\\bigr).$$\n令其为 0，可得：\n$$\\sum_{x \\in \\Omega} U_k(x)\\bigl(C_k - f(x)\\bigr) &#x3D; 0$$\n解方程，得到更新公式整理可得：\n$$C_k \\sum_{x \\in \\Omega} U_k(x)&#x3D; \\sum_{x \\in \\Omega} U_k(x)f(x)$$\n若分母不为 0（该簇有样本），则\n$$C_k &#x3D; \\frac{\\sum\\limits_{x \\in \\Omega} U_k(x) f(x)}{\\sum\\limits_{x \\in \\Omega} U_k(x)}$$\n这就是 K-Means 中聚类中心的更新公式。在常见的离散数据立场下，上式意味着“该簇内所有样本特征的加权平均值”，权值由 $U_k(x)$ 决定。若 $U_k(x)$ 只取 0 或 1（硬划分），则退化为简单的算术平均。\n\n注：\n\n在连续情况下，将“求和”换为对 $\\Omega$ 的积分即可：\n$$C_k &#x3D; \\frac{\\int_{\\Omega} U_k(x)f(x)\\mathrm{d}x}{\\int_{\\Omega} U_k(x)\\mathrm{d}x}$$\n\n当 $U_k(x)$ 只取 0 或 1，即标准 K-Means，公式变为簇内样本的算术平均。\n\n\n\n\nK-Means 能量单调下降（不增）性以下笔记基于课堂板书，展示 K-Means 迭代过程中目标函数（也称“能量”或“误差”）如何在每一步都单调下降（或不增），从而收敛到局部最优解。\n引理 &#x2F; 定理描述\n定理：由 K-Means 算法产生的迭代序列 $(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)})$ 满足\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr),$$\n即每次迭代更新后，目标函数 $E(\\cdot)$ 不会增大，从而保证了算法的单调收敛性。\n\n目标函数回顾离散情形下的 K-Means 目标函数：\n$$E\\bigl(\\mathbf{u}, \\mathbf{c}\\bigr)&#x3D; \\sum_{k&#x3D;1}^{K} \\sum_{x \\in \\Omega}U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n迭代过程（两步更新）\nStep 1：更新 $\\mathbf{u}^{(t+1)}$固定 $\\mathbf{c}^{(t)}$，令\n$$\\mathbf{u}^{(t+1)}&#x3D; \\arg\\min_{\\mathbf{u} \\in \\mathcal{U}}  E\\bigl(\\mathbf{u}, \\mathbf{c}^{(t)}\\bigr)$$\n由于独热编码的性质，每个样本 $x$ 归于距离最近的中心 $C_k^{(t)}$。这样得到\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr)$$\n\nStep 2：更新 $\\mathbf{c}^{(t+1)}$固定 $\\mathbf{u}^{(t+1)}$，令\n$$\\mathbf{c}^{(t+1)}&#x3D; \\arg\\min_{\\mathbf{c}}  E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}\\bigr).$$\n对每个 $C_k$ 求导并令其为 0，得到聚类中心是该簇内样本的加权平均。于是\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t)}\\bigr)$$\n\n\n能量严格下降的证明思路上两步结合，可得：\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr)$$\n这说明每一轮迭代后，目标函数都会朝着不增的方向变化，从而收敛到某个局部最优或鞍点。\n结论\nK-Means 通过交替最小化簇分配 $\\mathbf{u}$ 和聚类中心 $\\mathbf{c}$，使目标函数在每次迭代中不增。  \n因此，算法单调地收敛到一个局部最优解（或鞍点）。\n\n这便是 K-Means 能量单调下降 的主要证明思路，也是该算法能保证在有限步内收敛的关键原因。\n","categories":["Notes","Course"],"tags":["机器学习","模式识别","K-Means聚类"]},{"title":"25 Spring - 模式识别笔记(2)","url":"/2025/05/10/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/","content":"模式识别笔记汇总本次笔记主要关于K-Means 及其变分问题、熵不等式、Softmax&#x2F;Softmin 函数、数值稳定化、以及泛函与方向导数等内容。\n\nK-Means 基本原理与能量函数K-Means 能量函数的定义K-Means 算法的能量函数（目标函数）定义如下：\n$$E(\\vec{U}, \\vec{C})&#x3D; \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} \\bigl(f(x) - C_k\\bigr)^2  U_k(x)$$\n其中：\n\n$ f(x) $ 表示数据点 $ x $ 的特征值；\n$ C_k $ 表示第 $ k $ 个聚类中心；\n$ U_k(x) $ 为归属矩阵的元素，表示数据点 $ x $ 是否属于第 $ k $ 个簇（在硬分类中，取值为 0 或 1）。\n\n然后定义\n$$\\langle \\overrightarrow{O}, \\overrightarrow{u} \\rangle &#x3D; \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} O_k(x) \\cdot u_k(x)$$\n其中误差函数为：\n$$O_k(x) &#x3D; \\bigl(f(x) - C_k\\bigr)^2$$\n该能量函数也可用内积的形式表示：\n$$E(\\vec{U}, \\vec{C}) &#x3D; \\langle \\vec{O}, \\vec{U} \\rangle$$\n其中 $\\vec{O}$ 为一个误差向量。\n\nK-Means 算法的迭代更新规则K-Means 算法通过两步交替迭代来最小化能量函数 $E(\\vec{U}, \\vec{C})$：\n\n更新归属矩阵 $\\vec{U}^{t+1}$：\n$$\\vec{U}^{t+1} &#x3D; \\arg \\min_{\\vec{U}}  E(\\vec{U}, \\vec{C}^t)$$\n具体到每个样本点 $x$ 的更新规则为：\n  \n   $$\n   U_k^{t+1}(x)= \n   \\begin{cases}\n   1, & \\text{if} k = \\arg \\min_{k \\in \\{1, \\dots, K\\}} (f(x) - C_k^t)^2 \\\\\n   0, & \\text{otherwise}\n   \\end{cases}\n   $$\n     \n\n即将每个数据点分配给距离其最近的簇中心。\n\n更新聚类中心 $\\vec{C}^{t+1}$：\n$$\\vec{C}^{t+1} &#x3D; \\arg \\min_{\\vec{C}}  E\\bigl(\\vec{U}^{t+1}, \\vec{C}\\bigr)$$\n即对每个簇的样本求均值，作为新的聚类中心。\n\n\n\n误差函数与误差向量定义误差函数：\n$$O_k(x) &#x3D; \\bigl(f(x) - C_k\\bigr)^2$$\n令\n$$\\vec{O}(x) &#x3D; \\bigl(O_1(x), O_2(x), \\dots, O_K(x)\\bigr)^\\mathsf{T},$$\n则 $\\vec{O}$ 是一个向量值函数，映射\n$$\\vec{O}: \\Omega \\subseteq \\mathbb{R}^2 \\to \\mathbb{R}^K.$$\n\n备注\nK-Means 采用硬聚类方式，每个数据点只能属于一个簇，$U_k(x) \\in {0,1}$。\n优化目标：在每次迭代中，先更新 $\\vec{U}$，再更新 $\\vec{C}$，直至收敛。\n计算复杂度：主要与数据点数 $N$ 和簇数 $K$ 有关，通常为 $O(NKT)$（$T$ 为迭代次数）。\n\n\nK-Means 的变分问题与熵的性质K-Means 变分问题我们希望最小化下述能量函数：\n$$\\min_{\\vec{U}, \\vec{C}} E(\\vec{U}, \\vec{C})$$\n其中 $\\vec{U}$ 为归属矩阵，$\\vec{C}$ 为聚类中心。\n除硬划分之外，还可使用许多优化或正则化技巧，例如引入软分类思想（softmax &#x2F; softmin）的方法。\n\n熵的性质在分析 K-Means 变分问题时，引入熵的一条不等式，用于约束归属矩阵的对数项：\n$$-\\ln K\\le \\langle \\vec{U}, \\ln \\vec{U} \\rangle\\le 0$$\n其中：\n\n$U_k$ 表示数据点对第 $k$ 个簇的归属概率（软分类时可在 $[0,1]$ 之间）；\n$\\langle \\vec{U}, \\ln \\vec{U}\\rangle &#x3D; \\sum_{k&#x3D;1}^{K} U_k \\ln U_k$ 是熵相关的项。\n\n该不等式可以用 Jensen 不等式等方法证明。等号成立的两种情况为：\n\n左边等号：所有 $U_k &#x3D; \\frac{1}{K}$，即均匀分布；\n右边等号：某一个 $U_k&#x3D;1$，其它为 0，即完全硬分类。\n\n\n变分方法的直观解释\n最优化角度：寻找最优的 $\\vec{U}, \\vec{C}$ 使得数据点与簇中心的总体误差最小；\n信息论角度：考虑信息熵约束，避免过度偏向某一簇，从而获得更合理的簇划分。\n\n\n备注\n熵的约束：对归属矩阵 $ \\vec{U} $ 提供了额外的正则约束。\n与 EM（期望最大化）算法中的软聚类思想存在对应关系。\n\n\n熵不等式的证明这里给出熵不等式：\n$$-\\ln K\\leq \\langle \\vec{U}, \\ln \\vec{U} \\rangle\\leq 0$$\n的推导思路详述如下：\n证明 $f(u)&#x3D;-\\ln u$ 是凸函数：函数 $f(u) &#x3D; -\\ln u$ 的一阶导数和二阶导数分别为：\n$$f’(u) &#x3D; -\\frac{1}{u},\\quadf’’(u) &#x3D; \\frac{1}{u^2} &gt; 0 \\quad (u&gt;0)$$\n由于 $f’’(u) &gt; 0$，可知 $f(u)$ 是凸函数。\n计算极限 $\\lim\\limits_{u\\to0^+} u \\ln u$：令 $g(u) &#x3D; -u \\ln u$，求其极限：\n$$\\lim_{u\\to0^+} u \\ln u &#x3D; \\lim_{u\\to0^+} \\frac{\\ln u}{1&#x2F;u}$$\n利用洛必达法则，分子求导得$1&#x2F;u$，分母求导得 $-1&#x2F;u^2$，因此：\n$$\\lim_{u\\to0^+} \\frac{\\ln u}{1&#x2F;u} &#x3D; \\lim_{u\\to0^+} \\frac{1&#x2F;u}{-1&#x2F;u^2} &#x3D; \\lim_{u\\to0^+} -u &#x3D; 0$$\n所以：\n$$\\lim_{u\\to0^+} u \\ln u &#x3D; 0.$$\n这表明当 $u \\to 0$ 时，$u \\ln u$ 趋于 0。\n用 Jensen 不等式推导熵不等式：由于 $f(x)&#x3D;-\\ln x$ 是凸函数，因此对于满足 $\\sum_{k&#x3D;1}^{K} \\alpha_k &#x3D; 1$ 且 $ 0 \\leq \\alpha_k \\leq 1$ 的权重  $\\alpha_{k} $ ，有：\n$$\\left( \\sum_{k&#x3D;1}^{K} \\alpha_k x_k \\right) \\leq \\sum_{k&#x3D;1}^{K} \\alpha_k f(x_k)$$\n取 $\\alpha_k &#x3D; U_k$，$x_k &#x3D; \\frac{1}{U_k}$，则：\n$$-ln \\left( \\sum_{k&#x3D;1}^{K} U_k \\cdot \\frac{1}{U_k} \\right) \\leq \\sum_{k&#x3D;1}^{K} U_k (-\\ln \\frac{1}{U_k})$$\n由于 $\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$，所以：\n$$-ln K \\leq \\sum_{k&#x3D;1}^{K} U_k \\ln U_k \\leq 0$$\n即\n$$ln K \\geq -\\langle \\vec{U}, \\ln \\vec{U} \\rangle$$\n等号成立的条件：\n左边等号成立条件：当所有 $U_k$ 相等，即 $U_k &#x3D; 1&#x2F;K$ 时，左侧等号成立。\n右边等号成立条件：当仅有一个 $U_k&#x3D;1$，其余 $U_k&#x3D;0$ 时，右侧等号成立。\n\n熵不等式在 K-Means 变分问题中的作用：该不等式用于限制聚类的过度集中，即防止所有数据点都归属于同一簇。同时，它也鼓励一定程度的分散度，使簇划分更加均匀，从而优化聚类效果。\n\nK-Means 的变分问题扩展在传统 K-Means 的能量函数 $E(\\vec{U}, \\vec{C})$ 基础上，引入一项基于熵的正则化：\n$$\\min_{\\vec{u}\\in U}\\Bigl[E(\\vec{u}, \\vec{C})+\\varepsilon \\langle \\vec{u}, \\ln \\vec{u}\\rangle\\Bigr]$$\n其中 $\\varepsilon &gt; 0$ 为权衡系数（正则化参数）。当 $\\varepsilon \\to 0$ 时，该模型接近传统 K-Means 硬分类；当 $\\varepsilon$ 较大时，模型更倾向于软聚类。\n更新过程：\n\n$\\vec{u}^{t+1} &#x3D; \\arg \\min_{\\vec{u}} \\bigl[E(\\vec{u}, \\vec{C}^t) - \\varepsilon H(\\vec{u})\\bigr]$ (变成了严格凸)\n$\\vec{C}^{t+1} &#x3D; \\arg \\min_{\\vec{C}} \\bigl[E(\\vec{u}^{t+1}, \\vec{C})\\bigr]$  （与传统 K-Means 相同）\n\n这里的熵项\n$$H(\\vec{u})&#x3D; - \\sum_{k&#x3D;1}^{K} \\sum_{x\\in \\Omega} u_k(x)\\ln u_k(x)$$\n作为“软化”或正则化手段，避免完全的 0-1 硬分类。\n偏导数计算熵项 $H(\\vec{u})$ 可重写为\n$$ -H(\\vec{u}) &#x3D; \\langle \\vec{u}, \\ln \\vec{u} \\rangle.$$\n对于目标函数 $E(\\vec{u}, \\vec{C}) - \\varepsilon H(\\vec{u})$，计算其关于 $u_k$ 的偏导数：\n\n设 $E(\\vec{u}, \\vec{C})$ 关于 $u_k$ 的偏导数为：\n$$\\frac{\\delta E}{\\delta u_k} &#x3D; O_k$$\n\n对于熵项：\n$$\\frac{\\delta (-H)}{\\delta u_k} &#x3D; \\ln u_k + 1$$\n\n结合上述结果，求解极值条件：\n$$O_k - \\varepsilon (\\ln u_k + 1) &#x3D; 0$$\n\n化简得：\n$$u_k &#x3D; \\exp\\left(-\\frac{O_k}{\\varepsilon} - 1\\right)$$\n\n\n这表明更新 $u_k$ 时，其值受 $\\varepsilon$ 控制，较大的 $\\varepsilon$ 使得 $u_k$ 更加平滑，有助于软聚类。\n\n拉格朗日函数与 Softmax 分析拉格朗日函数定义拉格朗日函数：\n$$\\mathcal{L}(\\vec{u}, \\lambda)&#x3D; E(\\vec{u}, \\vec{c})-\\varepsilon H(\\vec{u})+\\sum_{x \\in \\Omega} \\lambda(x)\\Bigl(\\sum_{k&#x3D;1}^{K} u_k(x)-1\\Bigr)$$\n其中：\n\n$H(\\vec{u})$ 是熵项；\n$\\lambda(x)$ 为拉格朗日乘子，用于保证 $\\sum_{k&#x3D;1}^{K} u_k(x)&#x3D;1$。\n\n软分类 (Softmin &#x2F; Softmax) 的推导对 $\\mathcal{L}(\\vec{u}, \\lambda)$ 关于 $u_k$ 取偏导为 0，可得到：\n$$\\ln u_k(x)&#x3D; -\\frac{O_k(x) +\\lambda(x)}{\\varepsilon}$$\n其中 $O_k$ 是某类损失（例如 $(f(x)-C_k)^2$ ）或能量。\n结合约束 $\\sum_{k&#x3D;1}^K u_k(x)&#x3D;1$，可得Softmin形式：\n$$u_k^{t+1}(x)&#x3D; \\frac{\\exp\\Bigl(\\dfrac{-O_k(x)}{\\varepsilon}\\Bigr)}{\\sum_{j&#x3D;1}^{K} \\exp\\Bigl(\\dfrac{-O_j(x)}{\\varepsilon}\\Bigr)}$$\n也可写成softmax形式：\n  \n$$\n\\text{Softmax}_{\\varepsilon}(-\\vec{O}) =\n\\left[\\text{Softmin}_{\\varepsilon}(\\vec{O})\\right]_k\n$$\n  \n\n\n极限问题与分母拆分k-means 硬分类更新公式当不考虑熵正则化时，k-means 的硬分类可写为：\n$$u_k^{t+1}(x) &#x3D;\\begin{cases}    1, &amp; \\text{if } k &#x3D; \\arg \\min_{k \\in {1, \\dots, K}} O_k, \\    0, &amp; \\text{otherwise}.\\end{cases}$$\nSoftmin 的极限考虑\n\n$$\n\\lim_{\\varepsilon \\to 0^+}\n\\frac{\\exp\\bigl(-O_k(x)/\\varepsilon\\bigr)}{\\sum_{j=1}^K \\exp\\bigl(-O_j(x)/\\varepsilon\\bigr)}\n=\\lim_{\\varepsilon \\to 0^+}\\frac{\\exp\\bigl(-O_k(x)+m(x)/\\varepsilon\\bigr)}{\\sum_{j\\in M} \\exp\\bigl(-O_j(x)+m(x)/\\varepsilon\\bigr)+\\sum_{j\\notin M} \\exp\\bigl(-O_j(x)+m(x)/\\varepsilon\\bigr)}\n$$\n\n\n令 $m = \\min \\bigl\\{ O_1(x), O_2(x), \\dots, O_K(x) \\bigr\\}, \\quad M = \\arg\\min_{k \\in \\bigl\\{ 1, \\dots, K \\bigr\\}} O_k(x)$。当 $\\varepsilon \\to 0^+$，对于属于最优集 $M$ 的索引 $k$，$\\exp(-O_k&#x2F;\\varepsilon)$ 主导；而不是最优集的 $\\exp(-O_k&#x2F;\\varepsilon)$ 迅速衰减为 0。因此极限结果为：\n\n$$\n\\lim_{\\varepsilon \\to 0^+}\n\\text{Softmin}_{\\varepsilon}(\\vec{O})\n=\n\\begin{cases}\n1, & \\text{if } k \\in M \\\\\n0, & \\text{if } k \\notin M\n\\end{cases}\n\\quad \\text{where } M = \\left\\{ k \\mid O_k = \\min_j O_j \\right\\}\n$$\n\n\n这与 k-means 硬分类（一次只属于距离最近的簇）相一致。称   $\\min_{\\vec{u}\\in U，\\vec{C}}\\Bigl[E(\\vec{u}, \\vec{C})-\\varepsilon H(u)\\Bigr]$   为softmin&#x2F;softmax的分类的变分优化问题k-means 的光滑化与 Softmax 溢出问题k-means 的光滑化通过在 k-means 能量函数中加入熵项并令 $\\varepsilon&gt;0$，可以将硬分类变为软分类，使其输出变得连续可导。\n\n当 $\\varepsilon \\to 0$，Softmin 退化为 k-means 硬分类；\n当 $\\varepsilon$ 较大时，软分类更加显著。\n\nSoftmax 的数值溢出问题Softmax 标准形式：\n  \n$$\n\\text{Softmax}\\bigl(\\vec{O}\\bigr)_k\n=\n\\frac{e^{O_k}}{\\sum_{j=1}^K e^{O_j}}.\n$$\n  \n\n若 $O_k$ 值过大，$e^{O_k}$ 可能数值溢出。\n解决方案：数值稳定化取   $\\displaystyle M = \\max\\{O_1, O_2, \\dots, O_K\\}$  ，将所有项减去 $M$：\n  \n$$\n\\text{Softmax}(\\vec{O})_k\n=\n\\frac{e^{O_k - M}}{\\sum_{j=1}^K e^{O_j - M}}\n$$\n\n\n这样可防止溢出，保持结果不变。\n\n泛函分析与方向导数泛函与方向导数基本概念在更高层次，令\n  \n$$\nJ: \\mathcal{F} \\to \\mathbb{R}\n$$\n  \n\n是作用于函数空间 $\\mathcal{F}$ 的一个泛函（functional）。对于 $u(x)$ 的变化，可以定义方向导数：\n  \n$$\n\\lim_{h \\to 0}\n\\frac{J\\bigl(x + hv\\bigr) - J(x)}{h}\n=\n\\left.\n\\frac{d}{dh} \nJ\\bigl(x + hv\\bigr)\n\\right|_{h=0}\n$$\n  \n\n方向导数与梯度存在对应关系：若把 $\\nabla J&#x3D;(\\tfrac{\\delta J}{\\delta x_1}，\\tfrac{\\delta J}{\\delta x_2} \\cdot \\cdot \\cdot \\tfrac{\\delta J}{\\delta x_n})$ 类比于有限维中的梯度，则方向导数可理解为梯度在 $v$ 方向的投影。\n\n方向导数与梯度的关系对 $J(U_k)$ 做微分：\n  \n$$\n\\langle \\tfrac{\\delta J}{\\delta U_k},  V_k \\rangle\n=\n\\left.\n\\tfrac{d}{dh}\nJ\\bigl(U_k + hV_k\\bigr)\n\\right|_{h=0}.\n$$\n  \n\n例如，若\n  \n$$\nJ(U_k)\n=\n\\sum_{x\\in \\Omega}\nO_k(x)\\ln U_k(x),\n$$\n  \n\n则\n  \n$$\nJ(U_k + hV_k)\n=\n\\sum_{x\\in \\Omega}\nO_k(x)\\ln\\bigl(U_k(x) + hV_k(x)\\bigr)\n$$\n  \n\n对其在 $h&#x3D;0$ 处求导，可得到对应的偏导，从而确定梯度形式。\n\n九、总结与要点\nK-Means 算法\n\n能量函数：数据点到簇中心的平方误差和；\n经典迭代：硬分类与均值更新交替进行。\n\n\nK-Means 的变分扩展\n\n通过引入熵（软分类），可得到 Softmin &#x2F; Softmax 形式；\n当正则系数 $\\varepsilon \\to 0$ 时，又可退化到原始硬划分结果。\n\n\n熵不等式与数值稳定\n\n熵提供了在聚类中的分布约束；\nSoftmax 需用数值移位避免溢出。\n\n\n泛函与方向导数\n\n在更高阶场景中，可将 K-Means 问题放到泛函分析框架下；\n方向导数、梯度概念可帮助理解对函数空间的优化。\n\n\n\n","categories":["Notes","Course"],"tags":["模式识别","K-Means聚类","熵不等式","变分法"]},{"title":"25 Spring - 模式识别笔记(3)","url":"/2025/06/16/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲前三个part，符号源于课程讲义，整理了关于K-means 聚类及其变分表达、熵正则与空间正则的相关笔记。用markdown在网页上做笔记还是太费劲了，回归latex！\nPDF file","categories":["Notes","Course"],"tags":["模式识别","K-Means聚类","变分法","熵正则","空间正则"]},{"title":"25 Spring - 模式识别笔记(4)","url":"/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲第四个和第五个part，符号源于课程讲义，整理了关于混合模型分类（GMM），EM算法及其变分表示以及MM算法的相关笔记。\nPDF file","categories":["Notes","Course"],"tags":["模式识别","变分法","GMM算法","MM算法"]},{"title":"25 Spring - 模式识别笔记(5)","url":"/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲最后一个part，符号源于课程讲义，整理了关于MLP及其网络训练、反向传播算法的相关笔记。\nPDF file","categories":["Notes","Course"],"tags":["模式识别","神经网络","MLP","反向传播算法"]},{"title":"Academic Paper learning & Translation Records","url":"/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/","content":"引言本文档用于记录自己读过的学术论文和亲自翻译的论文内容。每篇论文包含简要说明和个人理解，部分论文附有飞书文档或doi链接\n\n翻译论文记录P´olya’s Random Walk Theorem当时是为了随机过程的pre，然后翻译并推了一遍polya随机游走定理，记录一下。\n原文标题：P´olya’s Random Walk Theorem作者：Jonathan Novak出处：The American Mathematical Monthly, 2014•Taylor &amp; Francisdoi号：点此查看全文飞书链接：点此查看翻译版\nMDS&#x2F;TSNE&#x2F;UMAPlonglongago之前把生物信息里比较常用的三种降维算法都学和推了一遍，分别是MDS（multidimensional scaling）多维尺度分析、t-SNE（t-distributed Stochastic Neighbor Embedding）和UMAP（Uniform Manifold Approximation and Projection），记录一下翻译版。\n飞书链接：点此查看整合的笔记\nMDSMultidimensional scaling，简称MDS，中文翻译成多维尺度分析。其原理是利用成对样本间的相似性，去构建合适的低维空间，使得样本在此空间的距离和在高维空间中的样本间的相似性尽可能的保持一致。我们可以用这种方式来可视化数据分布，PCA是MDS中特殊的一种。\n感觉有点像层次分析法，比较早用于心理学&amp;社会科学上的一些相似性分析。以下公式为简单的优化思想，理论上可以从欧式距离推广到各种距离如曼哈顿、马氏等等。\n原始文献有点太古老了，所以看的是csdn上的专栏：https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&amp;utm_medium=referral\n\nKruskal, J. B. (1964). “Multidimensional Scaling by Optimizing Goodness of Fit to a Nonmetric Hypothesis.” Psychometrika, 29(1), 1-27.\nShepard, R. N. (1962). “The Analysis of Proximities: Multidimensional Scaling with an Unknown Distance Function.” Psychometrika, 27(2), 125-140.\n\nTSNEt-sne感觉是比较fashion的概率方法，很有意思。找了一篇论文https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf\n原文标题：Visualizing Data using t-SNE作者：Laurens van der Maaten， Geoffrey Hinton出处：Journal of Machine Learning Research 9 (2008) 2579-2605doi号：点此查看全文\nUMAPUMAP没有看太懂，主要是我没学过拓扑，但是其中模糊数学的部分很有意思，这篇论文刚刚发预印本的时候模糊数学还挺火的，现在不行了。\n原文标题：Uniform manifold approximation and projection作者：John Healy， Leland McInnes出处：Nature Reviews Methods Primers volume 4, Article number: 82 (2024)doi号：点此查看全文\n注意力机制相关包括注意力机制到transformer的自注意力及其后续的变体，还有ESM3几何注意力机制、rfdiffusion的IGSO3等等。\n注意力机制的发展longlongago之前学深度学习补的：\n飞书链接：点此查看整合的笔记\n几何注意力机制ESM3有用到，ESM3模型处理蛋白质结构信息的两种主要方法：几何注意力（Geometric Attention）和结构标记（Structure Tokens）。\n飞书链接：点此查看整合的笔记\nIGSO3当时看rfdiffusion被吓坏了，这个证明真的很吓人\n飞书链接：点此查看整合的笔记\n倾向性得分在观察性研究中因果效应分析的核心作用文理学院统计系汇报的pre，看完了之后连统计学都不想学了，数学和统计完全是两个学科啊！感觉自己喜欢的是统计计算而不是数理统计和传统的统计inference，润了润了润去计算了\n原文标题：The central role of the propensity score in observational studies for causal effect作者：PAUL R. ROSENBAUM, DONALD B. RUBIN出处：Biometrilca (1083), 70, 1, pp. 41-55doi号：点此查看全文飞书链接：点此查看翻译版\n","categories":["Review","Translation"],"tags":["Paper Reading","Translation","Academic","Learning"]},{"title":"数据结构与算法自学笔记（2）- 链表相关","url":"/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了class009 -&gt; class012，涵盖了链表的基础概念、反转操作、合并算法、链表运算以及分割技巧等内容。\n\n009【入门】单双链表及其反转链表的基本概念链表是一种线性数据结构，其中元素存储在节点中，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不必连续存储。\n单链表节点定义class ListNode:    &quot;&quot;&quot;    单链表节点类    &quot;&quot;&quot;    def __init__(self, val=0, next=None):        self.val = val                    # 节点存储的数据值        self.next = next                  # 指向下一个节点的指针\n\n双链表节点定义class DoubleListNode:    &quot;&quot;&quot;    双链表节点类    每个节点有两个指针：指向前驱和后继    &quot;&quot;&quot;    def __init__(self, value):        self.value = value                # 节点存储的数据值        self.last = None                  # 指向前一个节点的指针        self.next = None                  # 指向下一个节点的指针\n\n单链表反转算法反转单链表测试链接 : https://leetcode.cn/problems/reverse-linked-list/\n迭代方法实现单链表反转是链表操作中的经典问题，核心思想是改变节点间的指针方向。\nclass ListReverseOperations:    @staticmethod    def reverse_linked_list(head):        &quot;&quot;&quot;        反转单链表 - 迭代实现        时间复杂度: O(n), 空间复杂度: O(1)                参数: head - 链表头节点        返回: 反转后链表的头节点        &quot;&quot;&quot;        pre = None                        # 前驱节点指针，初始为None        next_node = None                  # 临时保存下一个节点                while head is not None:           # 遍历整个链表            next_node = head.next         # 保存下一个节点，防止链表断裂            head.next = pre               # 当前节点指向前驱（反转指针）            pre = head                    # 前驱指针前进到当前节点            head = next_node              # 头指针前进到下一个节点                return pre                        # pre此时指向原链表的尾节点，即新链表的头节点\n\n反转过程图解\n具体在上面的实现中，是利用next向后移动 利用pre改变方指针向\n原链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL第1步: pre=NULL, head=1, next=2      NULL &lt;- 1    2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL             pre  head第2步: pre=1, head=2, next=3        NULL &lt;- 1 &lt;- 2    3 -&gt; 4 -&gt; 5 -&gt; NULL                  pre  head第3步: pre=2, head=3, next=4      NULL &lt;- 1 &lt;- 2 &lt;- 3    4 -&gt; 5 -&gt; NULL                        pre  head最终: NULL &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5                                  pre\n\n递归方法实现@staticmethoddef reverse_linked_list_recursive(head):    &quot;&quot;&quot;    反转单链表 - 递归实现    时间复杂度: O(n), 空间复杂度: O(n) - 递归栈空间        参数: head - 链表头节点    返回: 反转后链表的头节点    &quot;&quot;&quot;    # 基础情况：空链表或单节点链表    if head is None or head.next is None:        return head        # 递归反转剩余部分    new_head = ListReverseOperations.reverse_linked_list_recursive(head.next)        # 反转当前节点与下一个节点的连接    head.next.next = head             # 下一个节点指回当前节点    head.next = None                  # 当前节点的next置空        return new_head                   # 返回新的头节点\n\n双链表反转算法双链表的反转需要同时处理前驱和后继两个指针，相比单链表更加复杂。\n@staticmethoddef reverse_double_list(head):    &quot;&quot;&quot;    反转双链表    时间复杂度: O(n), 空间复杂度: O(1)        参数: head - 双链表头节点    返回: 反转后双链表的头节点    &quot;&quot;&quot;    pre = None                        # 前驱节点指针    next_node = None                  # 临时保存下一个节点        while head is not None:           # 遍历整个双链表        next_node = head.next         # 保存下一个节点                # 交换当前节点的前驱和后继指针        head.next = pre               # next指向前驱        head.last = next_node         # last指向后继                pre = head                    # 前驱指针前进        head = next_node              # 头指针前进        return pre                        # 返回新的头节点\n\n双链表反转的关键点\n指针交换：每个节点的next和last指针需要互换方向\n边界处理：正确处理链表两端的NULL指针\n遍历顺序：确保在修改指针前保存必要的信息\n\n\n010【入门】合并两个有序链表测试链接 : https://leetcode.cn/problems/merge-two-sorted-lists/\n问题描述给定两个已排序的链表，将它们合并成一个新的有序链表。新链表应该通过拼接给定的两个链表的所有节点组成。\n算法思想采用双指针技术，比较两个链表当前节点的值，选择较小的节点添加到结果链表中，然后移动对应的指针。\n实现方案class Solution:    @staticmethod    def merge_two_lists(head1, head2):        &quot;&quot;&quot;        合并两个有序链表        时间复杂度: O(m + n), 空间复杂度: O(1)                参数: head1, head2 - 两个有序链表的头节点        返回: 合并后有序链表的头节点        &quot;&quot;&quot;        # 边界情况处理：其中一个链表为空        if head1 is None or head2 is None:            return head2 if head1 is None else head1                # 确定合并后链表的头节点        if head1.val &lt;= head2.val:            head = head1                  # head1的值更小，作为头节点            cur1 = head1.next             # cur1指向head1的下一个节点            cur2 = head2                  # cur2指向head2的当前节点        else:            head = head2                  # head2的值更小，作为头节点            cur1 = head1                  # cur1指向head1的当前节点            cur2 = head2.next             # cur2指向head2的下一个节点                pre = head                        # pre用于构建结果链表                # 双指针遍历两个链表        while cur1 is not None and cur2 is not None:            if cur1.val &lt;= cur2.val:     # cur1的值更小或相等                pre.next = cur1           # 将cur1连接到结果链表                cur1 = cur1.next          # cur1指针后移            else:                         # cur2的值更小                pre.next = cur2           # 将cur2连接到结果链表                cur2 = cur2.next          # cur2指针后移            pre = pre.next                # 结果链表指针后移                # 处理剩余节点：将未遍历完的链表直接连接到结果链表末尾        pre.next = cur1 if cur1 is not None else cur2                return head                       # 返回合并后链表的头节点\n\n算法优化版本@staticmethoddef merge_two_lists_optimized(head1, head2):    &quot;&quot;&quot;    合并两个有序链表 - 优化版本    使用虚拟头节点简化边界处理    &quot;&quot;&quot;    dummy = ListNode(0)               # 创建虚拟头节点    current = dummy                   # 当前指针指向虚拟头节点        # 双指针遍历两个链表    while head1 is not None and head2 is not None:        if head1.val &lt;= head2.val:            current.next = head1      # 连接较小节点            head1 = head1.next        # 移动head1指针        else:            current.next = head2      # 连接较小节点            head2 = head2.next        # 移动head2指针        current = current.next        # 移动结果链表指针        # 连接剩余节点    current.next = head1 if head1 is not None else head2        return dummy.next                 # 返回真正的头节点\n\n合并过程示例链表1: 1 -&gt; 2 -&gt; 4链表2: 1 -&gt; 3 -&gt; 4合并过程:step1: 比较1和1，选择链表1的1    结果: 1step2: 比较2和1，选择链表2的1    结果: 1 -&gt; 1  step3: 比较2和3，选择链表1的2    结果: 1 -&gt; 1 -&gt; 2step4: 比较4和3，选择链表2的3    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3step5: 比较4和4，选择链表1的4    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4step6: 连接剩余的4              结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n\n\n011【入门】两个链表相加测试链接：https://leetcode.cn/problems/add-two-numbers/\n问题描述给定两个非空链表来表示两个非负整数，数字最高位位于链表开始位置。它们的每个节点只存储一位数字，计算两个数的和并以相同形式返回一个表示和的链表。\n核心思想模拟手工加法运算，从链表尾部开始逐位相加，处理进位问题。\n算法实现class Solution:    @staticmethod    def add_two_numbers(h1, h2):        &quot;&quot;&quot;        两个链表数字相加        时间复杂度: O(max(m,n)), 空间复杂度: O(max(m,n))                参数: h1, h2 - 两个表示数字的链表头节点        返回: 表示和的链表头节点        &quot;&quot;&quot;        ans = None                        # 结果链表头节点        cur = None                        # 当前构建位置指针        carry = 0                         # 进位标志                # 遍历两个链表，直到都为空        while h1 is not None or h2 is not None:            # 获取当前位的数字，如果链表已结束则为0            val1 = h1.val if h1 is not None else 0            val2 = h2.val if h2 is not None else 0                        # 计算当前位的和（包括进位）            total = val1 + val2 + carry            carry = total // 10           # 计算新的进位            digit = total % 10            # 当前位的数字                        # 构建结果链表            if ans is None:               # 第一个节点                ans = ListNode(digit)                cur = ans            else:                         # 后续节点                cur.next = ListNode(digit)                cur = cur.next                        # 移动链表指针            h1 = h1.next if h1 is not None else None            h2 = h2.next if h2 is not None else None                # 处理最后的进位        if carry == 1:            cur.next = ListNode(1)                return ans                        # 返回结果链表头节点\n\n代码修正与优化优化了源代码最后的进位问题\n@staticmethoddef add_two_numbers_corrected(h1, h2):    &quot;&quot;&quot;    两个链表数字相加 - 优化版本，更加通用    &quot;&quot;&quot;    ans = None                        # 结果链表头节点    cur = None                        # 当前构建位置指针    carry = 0                         # 进位标志        while h1 is not None or h2 is not None:        # 安全获取节点值，避免空指针异常        val1 = h1.val if h1 is not None else 0        val2 = h2.val if h2 is not None else 0                # 计算当前位的和        total = val1 + val2 + carry        carry = total // 10           # 新进位        digit = total % 10            # 当前位数字                # 构建结果链表节点        new_node = ListNode(digit)        if ans is None:               # 初始化头节点            ans = cur = new_node        else:                         # 连接新节点            cur.next = new_node            cur = new_node                # 安全移动指针        h1 = h1.next if h1 is not None else None        h2 = h2.next if h2 is not None else None        # 处理最终进位    if carry &gt; 0:        cur.next = ListNode(carry)        return ans\n\n算法示例链表1: 2 -&gt; 4 -&gt; 3  (表示数字342)链表2: 5 -&gt; 6 -&gt; 4  (表示数字465)相加过程:位置0: 2 + 5 + 0(进位) = 7, 进位=0  结果: 7位置1: 4 + 6 + 0(进位) = 10, 进位=1  结果: 7 -&gt; 0位置2: 3 + 4 + 1(进位) = 8, 进位=0  结果: 7 -&gt; 0 -&gt; 8最终结果: 7 -&gt; 0 -&gt; 8 (表示数字807)验证: 342 + 465 = 807 ✓\n\n边界情况处理\n不同长度链表：短链表结束后，继续处理长链表的剩余位\n最高位进位：最后可能产生新的最高位\n空链表：输入验证，确保链表非空\n单位数：正确处理个位数相加的情况\n\n\n012【入门】划分链表测试链接 : https://leetcode.cn/problems/partition-list/\n问题描述给定一个链表和一个特定值x，对链表进行分隔，使得所有小于x的节点都在大于或等于x的节点之前。保持两个分区中每个节点的初始相对位置。\n算法思想使用双链表分离的思想：\n\n创建两个独立的链表：小于x的节点链表和大于等于x的节点链表\n遍历原链表，将节点分别添加到对应的链表中\n最后将两个链表连接起来\n\n实现方案class Solution:    @staticmethod    def partition(head, x):        &quot;&quot;&quot;        划分链表        时间复杂度: O(n), 空间复杂度: O(1)                参数: head - 链表头节点, x - 划分值        返回: 划分后链表的头节点        &quot;&quot;&quot;        # 初始化两个链表的头尾指针        left_head = None                  # 小于x的链表头指针        left_tail = None                  # 小于x的链表尾指针        right_head = None                 # 大于等于x的链表头指针        right_tail = None                 # 大于等于x的链表尾指针                next_node = None                  # 临时保存下一个节点                # 遍历原链表，分离节点        while head is not None:            next_node = head.next         # 保存下一个节点            head.next = None              # 断开当前节点的连接                        if head.val &lt; x:              # 当前节点值小于x                if left_head is None:    # 左链表为空                    left_head = head      # 设置左链表头节点                else:                     # 左链表非空                    left_tail.next = head # 连接到左链表尾部                left_tail = head          # 更新左链表尾指针            else:                         # 当前节点值大于等于x                if right_head is None:   # 右链表为空                    right_head = head     # 设置右链表头节点                else:                     # 右链表非空                    right_tail.next = head # 连接到右链表尾部                right_tail = head         # 更新右链表尾指针                        head = next_node              # 移动到下一个节点                # 连接两个链表        if left_head is None:            # 如果左链表为空            return right_head             # 直接返回右链表        else:                            # 左链表非空            left_tail.next = right_head   # 连接左右链表            return left_head              # 返回左链表头节点\n\n代码修正与完善优化了原代码在遍历阶段的指针指代可能不清晰的问题，修改了if else后的指定\nclass Solution:    @staticmethod    def partition_corrected(head, x):        &quot;&quot;&quot;        划分链表 - 修正版本        修复了原代码的语法错误和逻辑问题        &quot;&quot;&quot;        # 初始化四个指针        left_head = left_tail = None      # 小于x的链表头尾指针        right_head = right_tail = None    # 大于等于x的链表头尾指针                # 遍历原链表        while head is not None:            next_node = head.next         # 保存下一个节点            head.next = None              # 断开当前节点                        if head.val &lt; x:              # 节点值小于x                if left_head is None:    # 第一个小于x的节点                    left_head = left_tail = head                else:                     # 后续小于x的节点                    left_tail.next = head                    left_tail = head            else:                         # 节点值大于等于x                if right_head is None:   # 第一个大于等于x的节点                    right_head = right_tail = head                else:                     # 后续大于等于x的节点                    right_tail.next = head                    right_tail = head                        head = next_node              # 移动到下一个节点                # 合并两个链表        if left_head is None:            # 只有大于等于x的节点            return right_head                left_tail.next = right_head       # 连接两个链表        return left_head                  # 返回结果链表头节点\n\n优化版本：使用虚拟头节点@staticmethoddef partition_optimized(head, x):    &quot;&quot;&quot;    划分链表 - 优化版本    使用虚拟头节点简化代码逻辑，简化了边界处理    &quot;&quot;&quot;    # 创建虚拟头节点    left_dummy = ListNode(0)          # 小于x链表的虚拟头节点    right_dummy = ListNode(0)         # 大于等于x链表的虚拟头节点        left = left_dummy                 # 小于x链表的当前指针    right = right_dummy               # 大于等于x链表的当前指针        # 遍历原链表，分配节点    while head is not None:        if head.val &lt; x:            left.next = head          # 连接到左链表            left = left.next          # 移动左指针        else:            right.next = head         # 连接到右链表            right = right.next        # 移动右指针        head = head.next              # 移动原链表指针        # 断开右链表的尾部连接，防止环    right.next = None        # 连接两个链表    left.next = right_dummy.next        return left_dummy.next            # 返回真正的头节点\n\n算法示例原链表: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2划分值: x = 3分离过程:节点1 &lt; 3: 左链表 = 1节点4 &gt;= 3: 右链表 = 4  节点3 &gt;= 3: 右链表 = 4 -&gt; 3节点2 &lt; 3: 左链表 = 1 -&gt; 2节点5 &gt;= 3: 右链表 = 4 -&gt; 3 -&gt; 5节点2 &lt; 3: 左链表 = 1 -&gt; 2 -&gt; 2最终结果: 1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5\n\n算法特点\n稳定性：保持原有的相对顺序\n原地操作：只调整指针，不创建新节点\n时间效率：单次遍历，O(n)时间复杂度\n空间效率：只使用常数额外空间\n\n应用场景\n链表排序的预处理：快速排序的分区操作\n数据分类：按条件将数据分为两组\n链表重组：根据特定规则重新排列链表节点\n\n\n链表操作技巧拓展核心技巧与模式1. 双指针技术def two_pointer_pattern(head):    &quot;&quot;&quot;    双指针模式：快慢指针、左右指针等    常用于链表中点查找、环检测、倒数第k个节点等    &quot;&quot;&quot;    slow = fast = head                    # 快慢指针初始化    while fast and fast.next:        slow = slow.next                  # 慢指针每次移动1步        fast = fast.next.next             # 快指针每次移动2步    return slow                           # 返回中点或其他目标位置\n\n2. 虚拟头节点def dummy_head_pattern(head):    &quot;&quot;&quot;    虚拟头节点模式：简化头节点的特殊处理    特别适用于可能删除头节点或构建新链表的场景    &quot;&quot;&quot;    dummy = ListNode(0)                   # 创建虚拟头节点    dummy.next = head                     # 连接原链表        # 在这里进行各种操作    # ...        return dummy.next                     # 返回真正的头节点\n\n3. 递归模式def recursive_pattern(head):    &quot;&quot;&quot;    递归模式：将复杂问题分解为子问题    适用于链表反转、删除节点、合并等操作    &quot;&quot;&quot;    # 基础情况    if head is None or head.next is None:        return head        # 递归处理子问题    result = recursive_pattern(head.next)        # 处理当前层    # ...        return result\n\n4. 节点分离与重组def separate_and_merge_pattern(head):    &quot;&quot;&quot;    分离重组模式：将链表按条件分离后重新组合    适用于链表划分、奇偶分离、按值分组等    &quot;&quot;&quot;    # 创建多个子链表的头尾指针    list1_head = list1_tail = None    list2_head = list2_tail = None        while head:        next_node = head.next        head.next = None                  # 断开连接                if condition(head):               # 根据条件分配            # 添加到list1            if list1_head is None:                list1_head = list1_tail = head            else:                list1_tail.next = head                list1_tail = head        else:            # 添加到list2            if list2_head is None:                list2_head = list2_tail = head            else:                list2_tail.next = head                list2_tail = head                head = next_node        # 重新组合链表    if list1_tail:        list1_tail.next = list2_head    return list1_head if list1_head else list2_head\n\n常见错误与注意事项1. 空指针处理# 错误示例def wrong_example(head):    return head.next.val                  # 可能导致空指针异常# 正确示例  def correct_example(head):    if head and head.next:                # 先检查再访问        return head.next.val    return None\n\n2. 内存泄漏防止def prevent_memory_leak(head):    &quot;&quot;&quot;    防止内存泄漏：及时断开不需要的连接    &quot;&quot;&quot;    while head:        next_node = head.next        head.next = None                  # 断开连接，防止环        head = next_node\n\n3. 边界情况处理def handle_edge_cases(head):    &quot;&quot;&quot;    处理边界情况：空链表、单节点链表等    &quot;&quot;&quot;    # 空链表    if head is None:        return None        # 单节点链表    if head.next is None:        return head        # 正常处理逻辑    # ...\n\n性能分析与优化时间复杂度分析\n单次遍历操作：O(n) - 反转、合并、查找等\n嵌套遍历操作：O(n²) - 某些复杂的链表操作\n递归操作：O(n) - 但需要考虑递归栈空间\n\n空间复杂度优化\n原地操作：优先使用指针操作而非创建新节点\n迭代替代递归：在可能的情况下避免递归栈开销\n临时变量最小化：只保存必要的指针变量\n\n实际性能考虑def performance_optimized_merge(h1, h2):    &quot;&quot;&quot;    性能优化的链表合并    减少条件判断和指针操作    &quot;&quot;&quot;    dummy = ListNode(0)    tail = dummy        while h1 and h2:        if h1.val &lt;= h2.val:            tail.next, h1 = h1, h1.next        else:            tail.next, h2 = h2, h2.next        tail = tail.next        # 直接连接剩余部分，无需循环    tail.next = h1 or h2    return dummy.next\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","节点遍历","链表","指针操作"]},{"title":"数据结构与算法自学笔记（4）- 二叉树相关","url":"/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了二叉树的基础概念、三种遍历方式的递归实现和非递归实现，涵盖了先序、中序、后序遍历的原理与代码实现，包括了class017 -&gt; class018的内容\n017【入门】二叉树及其三种序的递归实现二叉树的基本概念二叉树是一种重要的树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树是许多高级数据结构和算法的基础。\n二叉树节点定义class TreeNode:    def __init__(self, v):        self.val = v         # 节点的值        self.left = None     # 左子节点        self.right = None    # 右子节点\n\n递归序的概念递归序是理解二叉树遍历的关键概念。对于任意二叉树节点，递归过程会经过该节点三次：\ndef f(head):    if head is None:        return    # 第1次到达该节点 - 刚进入该节点    f(head.left)   # 递归处理左子树    # 第2次到达该节点 - 左子树处理完毕    f(head.right)  # 递归处理右子树    # 第3次到达该节点 - 右子树处理完毕\n\n根据在这三个时机中选择处理节点的时机不同，就形成了三种不同的遍历方式。\n二叉树的三种递归遍历先序遍历（Pre-order Traversal）先序遍历的顺序是：根节点 → 左子树 → 右子树\n@staticmethoddef preOrder(head):    &quot;&quot;&quot;    先序遍历：在第1次到达节点时处理    应用场景：复制二叉树、表达式树求值、目录树打印    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/    &quot;&quot;&quot;    if head is None:        return    print(head.val, end=&quot; &quot;)  # 先处理当前节点    BinaryTreeTraversalRecursion.preOrder(head.left)   # 再遍历左子树    BinaryTreeTraversalRecursion.preOrder(head.right)  # 最后遍历右子树\n\n中序遍历（In-order Traversal）中序遍历的顺序是：左子树 → 根节点 → 右子树\n@staticmethoddef inOrder(head):    &quot;&quot;&quot;    中序遍历：在第2次到达节点时处理    应用场景：二叉搜索树排序（得到有序序列）、表达式树转中缀表达式    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/    &quot;&quot;&quot;    if head is None:        return    BinaryTreeTraversalRecursion.inOrder(head.left)   # 先遍历左子树    print(head.val, end=&quot; &quot;)  # 再处理当前节点    BinaryTreeTraversalRecursion.inOrder(head.right)  # 最后遍历右子树\n\n后序遍历（Post-order Traversal）后序遍历的顺序是：左子树 → 右子树 → 根节点\n@staticmethoddef posOrder(head):    &quot;&quot;&quot;    后序遍历：在第3次到达节点时处理    应用场景：计算目录大小、删除二叉树、表达式树计算    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if head is None:        return    BinaryTreeTraversalRecursion.posOrder(head.left)   # 先遍历左子树    BinaryTreeTraversalRecursion.posOrder(head.right)  # 再遍历右子树    print(head.val, end=&quot; &quot;)  # 最后处理当前节点\n\n递归遍历的示例执行以下面的二叉树为例：\n    1   / \\  2   3 / \\ / \\4  5 6  7\n\n执行结果对比\n先序遍历结果：1 2 4 5 3 6 7\n中序遍历结果：4 2 5 1 6 3 7  \n后序遍历结果：4 5 2 6 7 3 1\n\n递归调用过程分析以先序遍历为例，递归调用的过程：\n\n访问节点1，打印1\n递归进入左子树（节点2）\n访问节点2，打印2\n递归进入左子树（节点4）\n访问节点4，打印4\n左右子树为空，返回\n\n\n递归进入右子树（节点5）\n访问节点5，打印5\n左右子树为空，返回\n\n\n\n\n递归进入右子树（节点3）\n类似过程…\n\n\n\n复杂度分析时间复杂度所有递归遍历算法的时间复杂度都是 O(n)，其中n是二叉树的节点数。每个节点都会被访问恰好一次。\n空间复杂度额外空间复杂度：O(h)，其中h是树的高度。\n\n最好情况（完全平衡的二叉树）：h &#x3D; ⌊log₂n⌋，空间复杂度为O(log n)\n最坏情况（完全不平衡的树，退化为链表）：h &#x3D; n，空间复杂度为O(n)\n平均情况：对于随机二叉树，h &#x3D; O(log n)\n\n空间消耗主要来自递归调用栈，栈的最大深度等于树的高度。\n三种遍历方式的应用场景先序遍历的典型应用\n复制二叉树：先创建根节点，再递归复制左右子树\n表达式树求值：先处理操作符，再处理操作数\n目录树打印：先打印目录名，再打印子目录内容\n序列化二叉树：将树结构转换为字符串格式\n\n# 复制二叉树示例def copyTree(root):    if root is None:        return None    # 先创建新节点（先序特点）    newNode = TreeNode(root.val)    newNode.left = copyTree(root.left)    # 递归复制左子树    newNode.right = copyTree(root.right)  # 递归复制右子树    return newNode\n\n中序遍历的典型应用\n二叉搜索树排序：中序遍历BST得到有序序列\n表达式树转中缀表达式：按照运算符优先级添加括号\n验证二叉搜索树：检查中序遍历结果是否为递增序列\n\n# 验证二叉搜索树示例def isValidBST(root):    def inorder(node, values):        if node is None:            return        inorder(node.left, values)        values.append(node.val)  # 中序收集值        inorder(node.right, values)        values = []    inorder(root, values)    # 检查是否严格递增    return all(values[i] &lt; values[i+1] for i in range(len(values)-1))\n\n后序遍历的典型应用\n计算目录大小：先计算子目录大小，再计算当前目录\n删除二叉树：先删除子节点，再删除父节点\n表达式树计算：先计算子表达式，再计算根表达式\n计算树的高度：先计算子树高度，再计算当前树高度\n\n# 计算二叉树高度示例def maxDepth(root):    if root is None:        return 0    # 先计算左右子树高度（后序特点）    leftHeight = maxDepth(root.left)    rightHeight = maxDepth(root.right)    # 再计算当前树高度    return max(leftHeight, rightHeight) + 1\n\n遍历方式选择指南\n\n\n需求场景\n推荐遍历方式\n理由\n\n\n\n复制&#x2F;构建树结构\n先序遍历\n需要先创建根节点\n\n\n获取有序数据\n中序遍历\nBST的中序遍历有序\n\n\n释放&#x2F;计算资源\n后序遍历\n需要先处理子节点\n\n\n树的序列化\n先序遍历\n便于重建树结构\n\n\n表达式求值\n后序遍历\n需要先计算子表达式\n\n\n递归实现的优缺点优点\n代码简洁：逻辑清晰，易于理解和实现\n自然表达：完美匹配树的递归定义\n易于扩展：容易添加额外的处理逻辑\n\n缺点\n栈溢出风险：深度递归可能导致栈溢出\n性能开销：函数调用的开销相对较大\n难以控制：无法方便地暂停或恢复遍历过程\n\n在实际应用中，对于一般规模的二叉树，递归实现是首选方案。当树的深度可能很大时，需要考虑使用非递归实现来避免栈溢出问题。\n\n018【入门】二叉树遍历的非递归实现和复杂度分析非递归实现的必要性递归实现虽然简洁易懂，但在处理大型树时可能导致栈溢出。非递归实现使用显式栈来模拟递归过程，提供了更好的控制性和避免栈溢出的优势。\n核心思想用显式的栈数据结构来模拟系统递归调用栈的行为，手动管理遍历过程中的状态信息。\n先序遍历的非递归实现实现原理先序遍历要求”根-左-右”的访问顺序。使用栈时，由于栈是LIFO（后进先出）结构，需要先压入右子节点，再压入左子节点，这样弹栈时就是先处理左子树。\n@staticmethoddef preOrder(head):    &quot;&quot;&quot;    先序遍历非递归实现    核心思路：使用一个栈。每次先访问节点本身，再依次压入右、左子节点（注意顺序，先右后左），这样弹栈时总是优先处理左子树，实现“中-左-右”顺序    时间复杂度：O(n)，每个节点进栈出栈各一次    空间复杂度：O(h)，h为树的高度    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []        stack.append(head)        while stack:            head = stack.pop()        # 弹出栈顶节点            print(head.val, end=&quot; &quot;)  # 立即打印（先序特点）            # 关键：先压右子节点，再压左子节点            # 这样弹栈时就是先处理左子树，再处理右子树            if head.right is not None:                stack.append(head.right)            if head.left is not None:                stack.append(head.left)        print()\n\n执行过程示例以树 1(2(4,5),3(6,7)) 为例：\n\n\n\n步骤\n栈状态\n弹出节点\n打印\n压入节点\n\n\n\n初始\n[1]\n-\n-\n-\n\n\n1\n[3,2]\n1\n1\n3,2\n\n\n2\n[3,5,4]\n2\n2\n5,4\n\n\n3\n[3,5]\n4\n4\n-\n\n\n4\n[3]\n5\n5\n-\n\n\n5\n[7,6]\n3\n3\n7,6\n\n\n6\n[7]\n6\n6\n-\n\n\n7\n[]\n7\n7\n-\n\n\n输出结果：1 2 4 5 3 6 7\n中序遍历的非递归实现实现原理中序遍历要求”左-根-右”的访问顺序。需要先沿着左子树走到底，将路径上的所有节点压栈，然后开始弹栈处理节点，并转向右子树。\n@staticmethoddef inOrder(head):    &quot;&quot;&quot;    中序遍历非递归实现    核心思路：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []        while stack or head is not None:            if head is not None:                # 当前节点不为空，压栈并继续向左                stack.append(head)                head = head.left            else:                # 当前节点为空，说明左子树遍历完毕                head = stack.pop()        # 弹出栈顶节点                print(head.val, end=&quot; &quot;)  # 打印节点值（中序特点）                head = head.right         # 转向右子树        print()\n\n算法状态分析中序遍历的非递归实现有两种状态：\n\n下降状态：head != None，沿左子树向下走并压栈\n上升状态：head == None，弹栈处理节点并转向右子树\n\n\n执行过程示例以树 1(2(4,5),3(6,7)) 为例：\n\n\n\n步骤\nhead\n栈状态\n操作\n打印\n\n\n\n初始\n1\n[]\n-\n-\n\n\n1\n2\n[1]\n压栈1，左移\n-\n\n\n2\n4\n[1,2]\n压栈2，左移\n-\n\n\n3\nNone\n[1,2,4]\n压栈4，左移\n-\n\n\n4\n4\n[1,2]\n弹栈4\n4\n\n\n5\nNone\n[1,2]\n4右移(None)\n-\n\n\n6\n2\n[1]\n弹栈2\n2\n\n\n7\n5\n[1]\n2右移到5\n-\n\n\n8\nNone\n[1,5]\n压栈5，左移\n-\n\n\n…\n…\n…\n…\n…\n\n\n输出结果：4 2 5 1 6 3 7\n后序遍历的非递归实现后序遍历是最复杂的，因为需要确保在访问根节点之前，左右子树都已经被完全访问。提供两种实现方法：\n方法一：使用两个栈@staticmethoddef posOrderTwoStacks(head):    &quot;&quot;&quot;    后序遍历非递归实现 - 双栈法    核心思路：第一个栈实现&quot;中-右-左&quot;遍历，结果压入第二个栈    最后弹出第二个栈得到&quot;左-右-中&quot;的后序遍历结果    即：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []      # 主栈：用于遍历        collect = []    # 收集栈：用于收集结果        stack.append(head)                while stack:            head = stack.pop()            collect.append(head)      # 收集节点到第二个栈            # 注意：这里先压左子节点，再压右子节点            # 这样遍历顺序就是&quot;中-右-左&quot;            if head.left is not None:                stack.append(head.left)            if head.right is not None:                stack.append(head.right)                # 反向弹出收集栈，得到&quot;左-右-中&quot;顺序        while collect:            print(collect.pop().val, end=&quot; &quot;)        print()\n\n双栈法原理解析\n第一阶段：用第一个栈实现”中-右-左”遍历，类似先序遍历但左右子节点入栈顺序相反\n第二阶段：将第一阶段的结果压入第二个栈\n第三阶段：弹出第二个栈，得到”左-右-中”的后序遍历结果\n\n关键洞察：”中-右-左”的逆序正好是”左-右-中”\n方法二：使用一个栈@staticmethoddef posOrderOneStack(h):    &quot;&quot;&quot;    后序遍历非递归实现 - 单栈法    核心思路：通过记录最近访问的节点，确保每个节点在其左右子树都被访问后才访问自己，从而严格实现“左-右-中”的后序遍历。    每个节点最多入栈两次，效率更高    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if h is not None:        stack = []        stack.append(h)        # h的含义：最近一次处理（打印）的节点                while stack:            cur = stack[-1]  # 查看栈顶元素但不弹出                        # 情况1：有左子树且左子树未被处理过            if cur.left is not None and h != cur.left and h != cur.right:                stack.append(cur.left)            # 情况2：有右子树且右子树未被处理过            elif cur.right is not None and h != cur.right:                stack.append(cur.right)            # 情况3：左右子树都没有或都已处理完毕            else:                print(cur.val, end=&quot; &quot;)                h = stack.pop()  # 更新h为刚刚处理的节点        print()\n\n单栈法状态管理核心变量h的含义变化：\n\n初始时：h指向根节点（但实际表示”还没有处理过任何节点”）\n处理过程中：h始终指向最近一次处理（打印）的节点\n判断逻辑：通过比较当前节点的子节点与h的关系，判断子树是否已被处理\n\n三种处理情况：\n\n有左子树且未处理：cur.left != None and h != cur.left and h != cur.right\n有右子树且未处理：cur.right != None and h != cur.right\n可以处理当前节点：左右子树都不存在或都已处理完毕\n\n复杂度分析对比时间复杂度所有非递归遍历算法的时间复杂度都是 O(n)：\n\n先序和中序：每个节点进栈出栈各一次\n后序双栈法：每个节点进栈出栈总共两次（每个栈一次）\n后序单栈法：每个节点最多进栈两次，出栈一次\n\n空间复杂度额外空间复杂度对比：\n\n\n\n实现方法\n空间复杂度\n说明\n\n\n\n先序非递归\nO(h)\n一个栈，最大深度为树高\n\n\n中序非递归\nO(h)\n一个栈，最大深度为树高\n\n\n后序双栈法\nO(n)\n收集栈最坏情况存储所有节点\n\n\n后序单栈法\nO(h)\n一个栈，最大深度为树高\n\n\n递归实现\nO(h)\n系统调用栈，深度为树高\n\n\n其中h为树的高度：\n\n最好情况：h &#x3D; O(log n)（平衡树）\n最坏情况：h &#x3D; O(n)（退化为链表）\n\n实现方法选择建议性能对比\n\n\n方法\n时间复杂度\n空间复杂度\n实现难度\n推荐场景\n\n\n\n先序非递归\nO(n)\nO(h)\n简单\n通用推荐\n\n\n中序非递归\nO(n)\nO(h)\n中等\nBST相关问题\n\n\n后序双栈法\nO(n)\nO(n)\n简单\n理解后序遍历逻辑\n\n\n后序单栈法\nO(n)\nO(h)\n困难\n空间要求严格的场景\n\n\n选择建议\n实际应用：根据具体需求选择，一般情况下递归实现更简洁\n性能要求高：选择非递归实现，避免函数调用开销\n内存受限：后序遍历优选单栈法，其他遍历方式空间复杂度相当\n\n非递归实现的优势\n避免栈溢出：可以处理任意深度的树\n更好控制：可以方便地暂停、恢复遍历过程\n性能优化：减少函数调用开销\n状态保存：便于在遍历过程中保存额外信息\n\n非递归实现虽然代码复杂度较高，但在处理大规模数据或有特殊要求的场景中具有重要意义。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","节点遍历","递归","二叉树","迭代"]}]