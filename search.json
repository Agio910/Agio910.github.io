[{"title":"24 Spring - 概率论课程判断题留档","url":"/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/","content":"  longlongago之前的概率论判断题作业，记录一下\nPDF file","categories":["Coursework"],"tags":["概率论","样本空间","随机变量","数字特征"]},{"title":"25 Fall - 哲学导论课程论文","url":"/2025/02/13/25%E7%A7%8B-%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BA%E6%96%87%E7%95%99%E6%A1%A3/","content":"  第一次有课程拿100分，留档记录一下课程论文，内容主要和确定性理论比较相关，以及对极端怀疑论的反驳。\nPDF file","categories":["Coursework"],"tags":["philosophy","确定性理论","维特根斯坦","怀疑论"]},{"title":"The Applications of Large Language Models in Mental Health Scoping Review.","url":"/2025/05/10/The%20Applications%20of%20Large%20Language%20Models%20in%20Mental%20Health%20Scoping%20Review/","content":"  I am honored to be the co-first author of this paper, and my main contrbution are data extraction and visualization.  Based on the 2019-2024 scoping review of 95 peer-reviewed articles, this study mapped the landscape of large language models (LLMs) applications in mental health across three key domains. The analysis revealed that LLMs are predominantly utilized for screening and detection of mental disorders (71%), with particular emphasis on depression detection (35%) and suicide risk prediction (13%). Additionally, LLMs demonstrate significant potential in supporting clinical treatments (33%) and facilitating mental health counseling and education (12%). Comparative assessments indicate that LLMs exhibit superior capabilities in information processing and natural language response generation relative to traditional non-transformer models and human performance in specific contexts. The research identified distinct advantages among different LLM architectures for various mental health applications, highlighting their promising role in addressing critical challenges in global mental healthcare, including detection efficiency, treatment effectiveness, privacy protection, and access to specialized care. These findings provide essential scientific evidence for the development and implementation of LLM-enhanced mental health interventions, which may significantly improve early detection rates and expand access to mental healthcare resources.\nPDF file","categories":["Publication"],"tags":["mental health","large language models","application","comparison"]},{"title":"Academic Paper learning & Translation Records","url":"/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/","content":"引言本文档用于记录自己读过的学术论文和亲自翻译的论文内容。每篇论文包含简要说明和个人理解，部分论文附有飞书文档或doi链接\n\n翻译论文记录P´olya’s Random Walk Theorem当时是为了随机过程的pre，然后翻译并推了一遍polya随机游走定理，记录一下。\n原文标题：P´olya’s Random Walk Theorem作者：Jonathan Novak出处：The American Mathematical Monthly, 2014•Taylor &amp; Francisdoi号：点此查看全文飞书链接：点此查看翻译版\nMDS&#x2F;TSNE&#x2F;UMAPlonglongago之前把生物信息里比较常用的三种降维算法都学和推了一遍，分别是MDS（multidimensional scaling）多维尺度分析、t-SNE（t-distributed Stochastic Neighbor Embedding）和UMAP（Uniform Manifold Approximation and Projection），记录一下翻译版。\n飞书链接：点此查看整合的笔记\nMDSMultidimensional scaling，简称MDS，中文翻译成多维尺度分析。其原理是利用成对样本间的相似性，去构建合适的低维空间，使得样本在此空间的距离和在高维空间中的样本间的相似性尽可能的保持一致。我们可以用这种方式来可视化数据分布，PCA是MDS中特殊的一种。感觉有点像层次分析法，比较早用于心理学&amp;社会科学上的一些相似性分析。以下公式为简单的优化思想，理论上可以从欧式距离推广到各种距离如曼哈顿、马氏等等。\n原始文献有点太古老了，所以看的是csdn上的专栏：https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&amp;utm_medium=referral\n\nKruskal, J. B. (1964). “Multidimensional Scaling by Optimizing Goodness of Fit to a Nonmetric Hypothesis.” Psychometrika, 29(1), 1-27.\nShepard, R. N. (1962). “The Analysis of Proximities: Multidimensional Scaling with an Unknown Distance Function.” Psychometrika, 27(2), 125-140.\n\nTSNEt-sne感觉是比较fashion的概率方法，很有意思。找了一篇论文https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf原文标题：Visualizing Data using t-SNE作者：Laurens van der Maaten， Geoffrey Hinton出处：Journal of Machine Learning Research 9 (2008) 2579-2605doi号：点此查看全文\nUMAPUMAP没有看太懂，主要是我没学过拓扑，但是其中模糊数学的部分很有意思，这篇论文刚刚发预印本的时候模糊数学还挺火的，现在不行了。\n原文标题：Uniform manifold approximation and projection作者：John Healy， Leland McInnes出处：Nature Reviews Methods Primers volume 4, Article number: 82 (2024)doi号：点此查看全文\n注意力机制相关包括注意力机制到transformer的自注意力及其后续的变体，还有ESM3几何注意力机制、rfdiffusion的IGSO3等等。\n注意力机制的发展longlongago之前学深度学习补的：\n飞书链接：点此查看整合的笔记\n几何注意力机制ESM3有用到，ESM3模型处理蛋白质结构信息的两种主要方法：几何注意力（Geometric Attention）和结构标记（Structure Tokens）。\n飞书链接：点此查看整合的笔记\nIGSO3当时看rfdiffusion被吓坏了，这个证明真的很吓人\n飞书链接：点此查看整合的笔记\n倾向性得分在观察性研究中因果效应分析的核心作用文理学院统计系汇报的pre，看完了之后连统计学都不想学了，数学和统计完全是两个学科啊！感觉自己喜欢的是统计计算而不是数理统计和传统的统计inference，润了润了润去计算了\n原文标题：The central role of the propensity score in observational studies for causal effect作者：PAUL R. ROSENBAUM, DONALD B. RUBIN出处：Biometrilca (1083), 70, 1, pp. 41-55doi号：点此查看全文飞书链接：点此查看翻译版\n","categories":["Review","Translation"],"tags":["Paper Reading","Translation","Academic","Learning"]},{"title":"数据结构与算法自学笔记（1）- 二进制&位运算&排序算法&二分搜索","url":"/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%20%E4%BA%8C%E8%BF%9B%E5%88%B6&%E4%BD%8D%E8%BF%90%E7%AE%97&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了class002 -&gt; class 007的内容，涵盖了社会实验模拟、位运算、基础排序算法、算法验证方法、二分搜索以及复杂度分析等核心内容。\n原代码是java版，我改成了python\n\n002【入门】从社会实验到入门提醒基尼系数的理论基础基尼系数是经济学中衡量收入分配不平等程度的重要指标，其数学定义为：\n$$G &#x3D; \\frac{\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{n}|x_i - x_j|}{2n\\sum_{i&#x3D;1}^{n}x_i}$$\n其中 $x_i$ 表示第 $i$ 个个体的财富值，$n$ 为总人数。\n基尼系数的经济学意义\nG &#x3D; 0：完全平等，所有人财富相同\nG &#x3D; 1：完全不平等，一人拥有全部财富  \nG &#x3D; 0.4-0.5：国际公认的贫富差距警戒线\nG &gt; 0.5：社会可能面临动荡风险\n\n财富分配模拟实验通过计算机模拟研究在完全随机的财富转移过程中，社会财富分配的自然演化规律。\nimport numpy as npimport randomdef calculate_gini(wealth):    &quot;&quot;&quot;    计算基尼系数的函数    参数: wealth - 财富分布列表    返回: 基尼系数值    &quot;&quot;&quot;    n = len(wealth)                        # 获取人数    sum_of_wealth = sum(wealth)            # 计算总财富    sum_of_absolute_differences = 0        # 初始化财富差异总和        # 计算所有个体间财富差异的绝对值之和    for i in range(n):        for j in range(n):            sum_of_absolute_differences += abs(wealth[i] - wealth[j])        # 根据基尼系数公式计算并返回结果    return sum_of_absolute_differences / (2 * n * sum_of_wealth)def experiment(n, t):    &quot;&quot;&quot;    财富分配模拟实验    参数: n - 人数, t - 模拟轮数    &quot;&quot;&quot;    wealth = [100] * n                     # 初始化每人财富为100        for _ in range(t):                     # 进行t轮模拟        has_money = [w &gt; 0 for w in wealth]  # 判断每个人是否有钱可转        transfers = []                     # 记录本轮转账列表                for j in range(n):                 # 遍历每个人            if has_money[j]:               # 如果该人有钱                other = j                  # 初始化接收者为自己                while other == j:          # 确保接收者不是自己                    other = random.randint(0, n - 1)  # 随机选择其他人                transfers.append((j, other))          # 记录转账关系                # 统一执行所有转账，避免执行顺序影响结果        for giver, receiver in transfers:            wealth[giver] -= 1             # 转出者财富减1            wealth[receiver] += 1          # 接收者财富加1        wealth.sort()                          # 按财富排序便于观察分布        # 输出结果分析    print(&quot;财富分布(从贫穷到富有):&quot;)    for idx, w in enumerate(wealth):        print(int(w), end=&#x27; &#x27;)        if idx % 10 == 9:                  # 每10个数换行            print()    print()    print(&quot;社会基尼系数:&quot;, calculate_gini(wealth))\n\n实验意义与启示\n随机性中的必然性：即使在完全公平的随机转移规则下，财富差距仍会自然产生\n马太效应：财富分配存在自然的分化趋势\n社会政策启示：需要主动的调节机制来维护社会公平\n\n\n003【入门】二进制和位运算计算机数值表示系统正数的二进制表示正数采用标准的二进制表示法，最高位为符号位（0表示正数）。\n负数的补码表示负数采用补码（Two’s Complement）表示：\n\n原码按位取反\n结果加1\n\n$$\\text{负数补码} &#x3D; \\sim(\\text{原码}) + 1$$\ndef print_binary(num):    &quot;&quot;&quot;    打印32位二进制表示    参数: num - 要打印的整数    &quot;&quot;&quot;    s = &#x27;&#x27;                                 # 初始化二进制字符串    for i in range(31, -1, -1):           # 从最高位到最低位遍历        # 通过位与运算判断第i位是否为1        s += &#x27;1&#x27; if (num &amp; (1 &lt;&lt; i)) != 0 else &#x27;0&#x27;    print(s)                              # 输出32位二进制表示# 演示正负数的二进制表示if __name__ == &quot;__main__&quot;:    a = 78                                # 正数示例    print(f&quot;正数&#123;a&#125;的二进制表示:&quot;)    print_binary(a)        b = -6                                # 负数示例      print(f&quot;负数&#123;b&#125;的二进制表示:&quot;)    print_binary(b)        # 验证补码计算    print(f&quot;~&#123;a&#125; + 1 = &#123;~a + 1&#125;&quot;)        # 计算a的相反数    print_binary(~a + 1)\n\n核心位运算操作基本位运算符详解def bitwise_operations_demo():    &quot;&quot;&quot;位运算操作演示&quot;&quot;&quot;    &#x27;&#x27;&#x27;0b 是Python中表示二进制数字的前缀。&#x27;&#x27;&#x27;    g = 0b0001010                         # 二进制字面量：10    h = 0b0001100                         # 二进制字面量：12        print(&quot;操作数g:&quot;, bin(g))    print(&quot;操作数h:&quot;, bin(h))        # 按位或运算：有1则1    print(&quot;g | h  =&quot;, bin(g | h))         # 0b1110 = 14        # 按位与运算：全1则1      print(&quot;g &amp; h  =&quot;, bin(g &amp; h))         # 0b1000 = 8        # 按位异或运算：不同则1    print(&quot;g ^ h  =&quot;, bin(g ^ h))         # 0b0110 = 6def shift_operations_demo():    &quot;&quot;&quot;移位运算演示&quot;&quot;&quot;    i = 0b0011010                         # 二进制：26    print(f&quot;原数: &#123;i&#125;, 二进制: &#123;bin(i)&#125;&quot;)        # 左移运算：相当于乘以2的幂次    print(f&quot;&#123;i&#125; &lt;&lt; 1 = &#123;i &lt;&lt; 1&#125;&quot;)        # 26 * 2 = 52    print(f&quot;&#123;i&#125; &lt;&lt; 2 = &#123;i &lt;&lt; 2&#125;&quot;)        # 26 * 4 = 104      print(f&quot;&#123;i&#125; &lt;&lt; 3 = &#123;i &lt;&lt; 3&#125;&quot;)        # 26 * 8 = 208        # 右移运算：相当于除以2的幂次（向下取整）    k = 10    print(f&quot;&#123;k&#125; &gt;&gt; 1 = &#123;k &gt;&gt; 1&#125;&quot;)        # 10 / 2 = 5    print(f&quot;&#123;k&#125; &gt;&gt; 2 = &#123;k &gt;&gt; 2&#125;&quot;)        # 10 / 4 = 2    print(f&quot;&#123;k&#125; &gt;&gt; 3 = &#123;k &gt;&gt; 3&#125;&quot;)        # 10 / 8 = 1\n\n逻辑运算与位运算的重要区别def return_true():    print(&quot;执行了return_true函数&quot;)    return Truedef return_false():    print(&quot;执行了return_false函数&quot;)     return Falsedef logical_vs_bitwise():    &quot;&quot;&quot;演示逻辑运算与位运算的区别&quot;&quot;&quot;    print(&quot;=== 位运算测试 ===&quot;)    # 位运算：两个函数都会被调用    test1 = return_true() | return_false()    print(f&quot;位运算结果: &#123;test1&#125;&quot;)        print(&quot;=== 逻辑运算测试 ===&quot;)     # 逻辑运算：存在短路求值，第二个函数可能不被调用    test2 = return_true() or return_false()    print(f&quot;逻辑运算结果: &#123;test2&#125;&quot;)\n\n位运算的实际应用\n快速乘除法：左移代替乘法，右移代替除法\n奇偶性判断：num &amp; 1 == 0 判断偶数。这是因为：num &amp; 1 只保留 num 的二进制最低位，其余全部变成0。\n集合操作：用位掩码表示集合的并、交、差运算\n状态压缩：在动态规划中压缩状态空间\n\n\n004【入门】选择、冒泡、插入排序理解python中的class：什么是“实例化类”？\n类（class）：可以理解为一个“模具”或者“模板”，描述一类对象应该有哪些属性和行为。\n实例（instance）：就是根据这个“模具”制造出来的一个具体的“物品”。\n实例化：把类变成实例（对象）的过程，叫做实例化。\n\n选择排序（Selection Sort）算法思想每次从未排序部分选择最小（或最大）元素，将其放置到已排序部分的末尾。\n时间复杂度分析\n比较次数：$\\sum_{i&#x3D;0}^{n-2}(n-1-i) &#x3D; \\frac{n(n-1)}{2} &#x3D; O(n^2)$\n交换次数：$O(n)$\n总体复杂度：$O(n^2)$\n\nclass SortingAlgorithms:        @staticmethod    def swap(arr, i, j):        &quot;&quot;&quot;        交换数组中两个位置的元素        参数: arr - 数组, i,j - 要交换的索引        &quot;&quot;&quot;        arr[i], arr[j] = arr[j], arr[i]  # Python的元组赋值交换        @staticmethod    def selection_sort(arr):        &quot;&quot;&quot;        选择排序实现        时间复杂度: O(n²), 空间复杂度: O(1)        不稳定排序        &quot;&quot;&quot;        if arr is None or len(arr) &lt; 2:   # 边界条件检查            return                # 外层循环控制已排序部分的边界        for i in range(len(arr) - 1):            min_index = i                  # 假设当前位置为最小值                        # 内层循环在未排序部分寻找真正的最小值            for j in range(i + 1, len(arr)):                if arr[j] &lt; arr[min_index]:  # 找到更小的元素                    min_index = j           # 更新最小值索引                        # 将找到的最小值与当前位置交换            SortingAlgorithms.swap(arr, i, min_index)\n\n冒泡排序（Bubble Sort）算法思想重复遍历数组，比较相邻元素并在必要时交换，使得大元素逐渐”冒泡”到数组末尾。\n@staticmethoddef bubble_sort(arr):    &quot;&quot;&quot;    冒泡排序实现    时间复杂度: O(n²), 空间复杂度: O(1)      稳定排序    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:   # 边界条件检查        return        # 外层循环控制未排序部分的右边界    for end in range(len(arr) - 1, 0, -1):        # 内层循环进行相邻元素比较和交换        for i in range(end):            if arr[i] &gt; arr[i + 1]:    # 如果前面元素大于后面元素                SortingAlgorithms.swap(arr, i, i + 1)  # 交换位置                # 经过一轮后，最大元素&quot;冒泡&quot;到末尾\n\n冒泡排序的优化@staticmethod  def bubble_sort_optimized(arr):    &quot;&quot;&quot;    优化版冒泡排序：添加提前终止条件    如果某轮遍历中没有发生交换，说明数组已有序    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return            for end in range(len(arr) - 1, 0, -1):        swapped = False               # 标记本轮是否发生交换        for i in range(end):            if arr[i] &gt; arr[i + 1]:                SortingAlgorithms.swap(arr, i, i + 1)                swapped = True        # 发生了交换                if not swapped:               # 如果本轮没有交换            break                     # 数组已有序，提前结束\n\n插入排序（Insertion Sort）算法思想将数组分为已排序和未排序两部分，依次将未排序元素插入到已排序部分的正确位置。\n@staticmethoddef insertion_sort(arr):    &quot;&quot;&quot;    插入排序实现    时间复杂度: 最坏O(n²), 最好O(n), 平均O(n²)    空间复杂度: O(1)    稳定排序，对小规模或近似有序数据效率高    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:   # 边界条件检查        return        # 从第二个元素开始，逐个插入到已排序部分    for i in range(1, len(arr)):        # 从当前位置向前比较，寻找插入位置        for j in range(i - 1, -1, -1):            if arr[j] &gt; arr[j + 1]:    # 如果前面元素大于后面元素                SortingAlgorithms.swap(arr, j, j + 1)  # 交换位置            else:                break                  # 找到正确位置，提前结束内层循环\n\n插入排序的另一种实现@staticmethoddef insertion_sort_v2(arr):    &quot;&quot;&quot;    插入排序的另一种实现：先保存要插入的元素，然后移动其他元素    减少交换次数，提高效率    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return            for i in range(1, len(arr)):        key = arr[i]                  # 保存要插入的元素        j = i - 1                     # 从已排序部分的末尾开始                # 向右移动大于key的元素        while j &gt;= 0 and arr[j] &gt; key:            arr[j + 1] = arr[j]       # 元素后移            j -= 1                arr[j + 1] = key              # 插入key到正确位置\n\n排序算法性能对比\n\n\n算法\n时间复杂度(最好)\n时间复杂度(平均)\n时间复杂度(最坏)\n空间复杂度\n稳定性\n\n\n\n选择排序\n$O(n^2)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n不稳定\n\n\n冒泡排序\n$O(n)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n稳定\n\n\n插入排序\n$O(n)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n稳定\n\n\n\n005【入门】对数器-验证的重要手段对数器的理论基础对数器（Logarithmic Validator）是一种系统性验证算法正确性的重要工具，通过大量随机测试用例来检验算法实现的可靠性。\n对数器设计的六个核心原则\n确定待测算法a：需要验证正确性的高效算法\n实现简单算法b：复杂度可能不优但逻辑简单、容易验证正确的算法  \n构建随机样本生成器：能够产生各种边界情况的测试数据\n对比验证：在相同输入下比较两种算法的输出结果\n错误定位：当发现不一致时，人工分析并修正错误\n大规模验证：通过大量测试建立对算法正确性的信心\n\n对数器实现框架（以上节课的三种排序方法为例）import randomclass AlgorithmValidator:    &quot;&quot;&quot;算法验证器类&quot;&quot;&quot;        @staticmethod    def random_array(n, v):        &quot;&quot;&quot;        生成随机数组        参数: n - 数组长度, v - 元素值域[1,v]        返回: 长度为n的随机数组        &quot;&quot;&quot;        # 使用列表推导式生成随机数组        return [random.randint(1, v) for _ in range(n)]        @staticmethod    def copy_array(arr):        &quot;&quot;&quot;        数组深拷贝        参数: arr - 原数组        返回: 原数组的副本        &quot;&quot;&quot;        return arr[:]                     # 切片操作创建新列表        @staticmethod      def arrays_equal(arr1, arr2):        &quot;&quot;&quot;        比较两个数组是否相等        参数: arr1, arr2 - 待比较的数组        返回: 布尔值表示是否相等        &quot;&quot;&quot;        if len(arr1) != len(arr2):        # 长度不等直接返回False            return False                # 逐元素比较        for a, b in zip(arr1, arr2):            if a != b:                return False        return True        @staticmethod    def comprehensive_sort_test():        &quot;&quot;&quot;        排序算法综合测试        使用对数器方法验证多种排序算法的正确性        &quot;&quot;&quot;        # 测试参数配置        N = 200                          # 数组最大长度        V = 1000                         # 元素最大值        test_times = 50000               # 测试次数                print(&quot;算法验证开始...&quot;)                for test_round in range(test_times):            # 生成随机测试用例            n = random.randint(0, N - 1)  # 随机数组长度            arr = AlgorithmValidator.random_array(n, V)                        # 创建多个数组副本用于不同算法测试            arr_selection = AlgorithmValidator.copy_array(arr)            arr_bubble = AlgorithmValidator.copy_array(arr)              arr_insertion = AlgorithmValidator.copy_array(arr)            arr_builtin = AlgorithmValidator.copy_array(arr)                        # 应用不同排序算法            SortingAlgorithms.selection_sort(arr_selection)            SortingAlgorithms.bubble_sort(arr_bubble)            SortingAlgorithms.insertion_sort(arr_insertion)            arr_builtin.sort()            # Python内置排序作为标准答案                        # 结果一致性验证            if not (AlgorithmValidator.arrays_equal(arr_selection, arr_builtin) and                    AlgorithmValidator.arrays_equal(arr_bubble, arr_builtin) and                      AlgorithmValidator.arrays_equal(arr_insertion, arr_builtin)):                                # 发现错误时输出详细信息                print(&quot;发现算法错误!&quot;)                print(f&quot;测试轮次: &#123;test_round + 1&#125;&quot;)                print(f&quot;原始数组: &#123;arr&#125;&quot;)                print(f&quot;选择排序: &#123;arr_selection&#125;&quot;)                print(f&quot;冒泡排序: &#123;arr_bubble&#125;&quot;)                print(f&quot;插入排序: &#123;arr_insertion&#125;&quot;)                print(f&quot;内置排序: &#123;arr_builtin&#125;&quot;)                return False                            # 每完成1000次测试输出进度            if (test_round + 1) % 1000 == 0:                print(f&quot;已完成 &#123;test_round + 1&#125; 次测试...&quot;)                print(&quot;所有测试通过！算法实现正确。&quot;)        return True\n\n对数器方法的优势\n自动化验证：减少人工测试的工作量和错误率\n覆盖边界情况：随机生成能够触及各种极端情况\n置信度建立：大量测试通过后可以高度确信算法正确性\n错误定位：一旦发现问题能够提供具体的错误样例\n\n\n006【入门】二分搜索二分搜索的数学基础二分搜索基于分治思想，每次将搜索空间减半，时间复杂度为 $O(\\log n)$。\n设数组长度为 $n$，经过 $k$ 次二分后搜索空间大小为 $\\frac{n}{2^k}$，当搜索空间减小到1时：\n$$\\frac{n}{2^k} &#x3D; 1 \\Rightarrow k &#x3D; \\log_2 n$$\n基础二分搜索问题：判断有序数组中是否存在目标值def binary_search_exist(arr, target):    &quot;&quot;&quot;    在有序数组中查找目标值是否存在    参数: arr - 有序数组, target - 目标值    返回: True/False 表示是否存在    时间复杂度: O(log n), 空间复杂度: O(1)    &quot;&quot;&quot;    if arr is None or len(arr) == 0:      # 边界条件：空数组        return False        left, right = 0, len(arr) - 1         # 初始化搜索边界[left, right]        while left &lt;= right:                  # 搜索空间非空时继续        # 防止整数溢出的中点计算方法        mid = left + (right - left) // 2   # 等价于 (left + right) // 2                if arr[mid] == target:            # 找到目标值            return True        elif arr[mid] &gt; target:           # 目标值在左半部分            right = mid - 1               # 收缩右边界        else:                             # 目标值在右半部分              left = mid + 1                # 收缩左边界        return False                          # 搜索完毕未找到\n\n暴力验证方法def linear_search_exist(arr, target):    &quot;&quot;&quot;    线性搜索验证方法    用于对数器验证二分搜索的正确性    &quot;&quot;&quot;    for element in arr:                   # 遍历数组每个元素        if element == target:             # 找到目标值            return True    return False                          # 未找到目标值\n\n二分搜索的边界查找变种查找左边界：&gt;&#x3D;target的最左位置def binary_search_left_bound(arr, target):    &quot;&quot;&quot;    在有序数组中查找 &gt;= target 的最左位置    参数: arr - 有序数组, target - 目标值    返回: 满足条件的最左索引，不存在返回-1    &quot;&quot;&quot;    if arr is None or len(arr) == 0:        return -1        left, right = 0, len(arr) - 1    ans = -1                              # 记录答案，初始化为-1表示未找到        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] &gt;= target:            # 当前元素满足条件            ans = mid                     # 更新答案            right = mid - 1               # 继续在左半部分寻找更左的位置        else:                             # 当前元素小于target            left = mid + 1                # 在右半部分继续搜索        return ansdef linear_search_left_bound(arr, target):    &quot;&quot;&quot;线性搜索验证：查找&gt;=target的最左位置&quot;&quot;&quot;    for i in range(len(arr)):             # 从左到右遍历        if arr[i] &gt;= target:              # 找到第一个满足条件的位置            return i    return -1                             # 未找到\n\n查找右边界：&lt;&#x3D;target的最右位置def binary_search_right_bound(arr, target):    &quot;&quot;&quot;    在有序数组中查找 &lt;= target 的最右位置    参数: arr - 有序数组, target - 目标值      返回: 满足条件的最右索引，不存在返回-1    &quot;&quot;&quot;    if arr is None or len(arr) == 0:        return -1        left, right = 0, len(arr) - 1    ans = -1                              # 记录答案        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] &lt;= target:            # 当前元素满足条件            ans = mid                     # 更新答案            left = mid + 1                # 继续在右半部分寻找更右的位置        else:                             # 当前元素大于target            right = mid - 1               # 在左半部分继续搜索        return ansdef linear_search_right_bound(arr, target):    &quot;&quot;&quot;线性搜索验证：查找&lt;=target的最右位置&quot;&quot;&quot;    for i in range(len(arr) - 1, -1, -1): # 从右到左遍历        if arr[i] &lt;= target:              # 找到第一个满足条件的位置            return i    return -1                             # 未找到\n\n峰值元素查找问题定义在数组中找到任意一个峰值元素（比左右邻居都大的元素），假设边界外的元素为负无穷。\ndef find_peak_element(arr):    &quot;&quot;&quot;    查找数组中的峰值元素    参数: arr - 整数数组（相邻元素不相等）    返回: 任意峰值元素的索引    时间复杂度: O(log n)    &quot;&quot;&quot;    n = len(arr)        # 边界情况处理    if n == 1:                            # 单元素数组        return 0    if arr[0] &gt; arr[1]:                   # 第一个元素是峰值        return 0      if arr[n-1] &gt; arr[n-2]:              # 最后一个元素是峰值        return n - 1        # 在 [1, n-2] 范围内二分搜索    left, right = 1, n - 2        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid-1] &gt; arr[mid]:         # 左邻居更大，峰值在左半部分            right = mid - 1        elif arr[mid] &lt; arr[mid+1]:       # 右邻居更大，峰值在右半部分              left = mid + 1        else:                             # arr[mid-1] &lt; arr[mid] &gt; arr[mid+1]            return mid                    # 找到峰值        return -1                             # 理论上不会到达这里\n\n峰值查找的正确性证明定理：在满足相邻元素不相等的数组中，上述算法一定能找到峰值。\n证明：\n\n边界已处理端点峰值。\n二分查找时，每次都能缩小到含有峰值的半区。\n因为每次都“爬坡”，必然最终会达到一个峰值。\n相邻元素不等消除了平台的歧义。\n因此，算法在O(log n)时间内一定能找到一个峰值。\n\n二分搜索验证框架def test_binary_search_algorithms():    &quot;&quot;&quot;二分搜索算法综合测试&quot;&quot;&quot;    N = 100                               # 数组最大长度    V = 1000                              # 元素值域    test_times = 500000                   # 测试次数        print(&quot;二分搜索算法测试开始...&quot;)        for _ in range(test_times):        # 生成随机有序数组        n = random.randint(0, N - 1)        arr = [random.randint(1, V) for _ in range(n)]        arr.sort()                        # 确保数组有序                target = random.randint(0, V - 1) # 随机目标值                # 验证基础二分搜索        if binary_search_exist(arr, target) != linear_search_exist(arr, target):            print(&quot;基础二分搜索错误!&quot;)            return False                # 验证左边界查找            if binary_search_left_bound(arr, target) != linear_search_left_bound(arr, target):            print(&quot;左边界查找错误!&quot;)            return False                    # 验证右边界查找        if binary_search_right_bound(arr, target) != linear_search_right_bound(arr, target):            print(&quot;右边界查找错误!&quot;)            return False        print(&quot;所有二分搜索测试通过!&quot;)    return True\n\n\n007【入门】时间复杂度和空间复杂度时间复杂度的数学基础渐近记号系统设 $f(n)$ 和 $g(n)$ 为定义在正整数集上的函数：\n\n大O记号 $O(g(n))$：$f(n) &#x3D; O(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \\geq n_0$ 有 $f(n) \\leq c \\cdot g(n)$\n大Ω记号 $\\Omega(g(n))$：$f(n) &#x3D; \\Omega(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \\geq n_0$ 有 $f(n) \\geq c \\cdot g(n)$  \n大Θ记号 $\\Theta(g(n))$：$f(n) &#x3D; \\Theta(g(n))$ 当且仅当 $f(n) &#x3D; O(g(n))$ 且 $f(n) &#x3D; \\Omega(g(n))$\n\n其实和泛函的函数的范数有点像，也就是这个映射算是有界的那种感觉。\n常见复杂度级别$$O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$$\n复杂嵌套循环分析等差数列型循环def quadratic_complexity_demo(N):    &quot;&quot;&quot;    演示O(n²)时间复杂度    等差数列求和：1 + 2 + ... + n = n(n+1)/2 = O(n²)    &quot;&quot;&quot;    operations = 0                        # 记录操作次数        for i in range(1, N + 1):            # 外层循环：i从1到N        for j in range(i, N + 1):        # 内层循环：j从i到N            operations += 1               # 模拟一次基本操作            # 当i=1时，内层执行N次            # 当i=2时，内层执行N-1次              # ...            # 当i=N时，内层执行1次            # 总计：N + (N-1) + ... + 1 = N(N+1)/2        print(f&quot;N=&#123;N&#125;, 总操作次数=&#123;operations&#125;, 理论值=&#123;N*(N+1)//2&#125;&quot;)    return operations\n\n调和级数型循环def n_log_n_complexity_demo(N):    &quot;&quot;&quot;    演示O(n log n)时间复杂度      调和级数：1 + 1/2 + 1/3 + ... + 1/n ≈ ln(n) = O(log n)    &quot;&quot;&quot;    operations = 0                        # 记录操作次数        for i in range(1, N + 1):            # 外层循环：i从1到N        j = i                             # 内层循环起始值        while j &lt;= N:                     # 按i的倍数递增            operations += 1               # 模拟一次基本操作            j += i                        # j = i, 2i, 3i, ...            # 当i=1时，内层执行N次（N/1）            # 当i=2时，内层执行N/2次            # 当i=3时，内层执行N/3次            # ...            # 总计：N(1 + 1/2 + 1/3 + ... + 1/N) = N·H_N ≈ N log N        print(f&quot;N=&#123;N&#125;, 总操作次数=&#123;operations&#125;&quot;)    return operations\n\n复杂度实验验证import timedef complexity_benchmark():    &quot;&quot;&quot;    通过实际运行时间验证复杂度分析    &quot;&quot;&quot;    test_sizes = [1000, 2000, 4000, 8000]   # 测试规模        print(&quot;=== 复杂度实验验证 ===&quot;)    print(&quot;规模\\tO(n²)时间\\tO(n log n)时间\\t比率&quot;)        for N in test_sizes:        # 测试O(n²)算法        start_time = time.time()        quadratic_complexity_demo(N)        quadratic_time = time.time() - start_time                # 测试O(n log n)算法          start_time = time.time()        n_log_n_complexity_demo(N)        n_log_n_time = time.time() - start_time                ratio = quadratic_time / n_log_n_time if n_log_n_time &gt; 0 else float(&#x27;inf&#x27;)        print(f&quot;&#123;N&#125;\\t&#123;quadratic_time:.4f&#125;s\\t&#123;n_log_n_time:.4f&#125;s\\t&#123;ratio:.2f&#125;&quot;)\n\n单循环冒泡排序的复杂度分析def single_loop_bubble_sort(arr):    &quot;&quot;&quot;    使用单个循环实现冒泡排序    虽然只有一个while循环，但时间复杂度仍然是O(n²)    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return        n = len(arr)    end = n - 1                           # 未排序部分的右边界    i = 0                                 # 当前比较位置        while end &gt; 0:                        # 外层逻辑：控制轮次        if arr[i] &gt; arr[i + 1]:          # 相邻元素比较            arr[i], arr[i + 1] = arr[i + 1], arr[i]  # 交换                if i &lt; end - 1:                   # 当前轮次未结束            i += 1                        # 移动到下一个比较位置        else:                             # 当前轮次结束            end -= 1                      # 缩小未排序范围            i = 0                         # 重置比较位置            # 虽然是单循环，但逻辑上等价于双层嵌套            # 时间复杂度仍为O(n²)\n\n空间复杂度分析动态数组的均摊复杂度分析def dynamic_array_analysis():    &quot;&quot;&quot;    动态数组扩容的均摊复杂度分析    &quot;&quot;&quot;    arr = []                              # 初始空数组    operations = []                       # 记录每次操作的代价        for i in range(16):                   # 插入16个元素        old_capacity = len(arr)           # 当前容量        arr.append(i)                     # 插入元素                # 模拟扩容过程        if len(arr) &gt; old_capacity:       # 发生了扩容            # Python的list实际扩容策略比较复杂，这里简化为2倍扩容            cost = old_capacity            # 扩容代价：复制所有旧元素        else:            cost = 1                      # 普通插入代价                operations.append(cost)        print(f&quot;插入元素&#123;i&#125;, 当前大小=&#123;len(arr)&#125;, 本次代价=&#123;cost&#125;&quot;)        total_cost = sum(operations)    average_cost = total_cost / len(operations)    print(f&quot;总代价=&#123;total_cost&#125;, 平均代价=&#123;average_cost:.2f&#125;&quot;)        # 数学分析：    # 扩容发生在容量为1,2,4,8,...时    # 总扩容代价：0 + 1 + 2 + 4 + 8 + ... &lt; 2n    # 总插入代价：n      # 均摊代价：(2n + n) / n = 3 = O(1)\n\n递归算法的空间复杂度def recursive_space_analysis(n):    &quot;&quot;&quot;    递归算法空间复杂度分析    计算阶乘的递归实现    &quot;&quot;&quot;    if n &lt;= 1:                           # 基础情况        return 1        # 每次递归调用占用O(1)空间    # 最大递归深度为n，所以空间复杂度为O(n)    return n * recursive_space_analysis(n - 1)def iterative_space_analysis(n):    &quot;&quot;&quot;    迭代版本的阶乘计算    空间复杂度为O(1)    &quot;&quot;&quot;    result = 1                           # 只使用常数额外空间    for i in range(1, n + 1):        result *= i    return result\n\n复杂度分析的实用技巧主定理（Master Theorem）对于递归关系 $T(n) &#x3D; aT(\\frac{n}{b}) + f(n)$，其中 $a \\geq 1, b &gt; 1$：\n\n如果 $f(n) &#x3D; O(n^{\\log_b a - \\epsilon})$，则 $T(n) &#x3D; \\Theta(n^{\\log_b a})$\n如果 $f(n) &#x3D; \\Theta(n^{\\log_b a})$，则 $T(n) &#x3D; \\Theta(n^{\\log_b a} \\log n)$  \n如果 $f(n) &#x3D; \\Omega(n^{\\log_b a + \\epsilon})$，则 $T(n) &#x3D; \\Theta(f(n))$\n\n均摊分析方法\n聚合分析：分析一系列操作的总代价\n核算法：为每种操作分配均摊代价\n势能法：定义势能函数分析代价分布\n\n实际性能考虑因素def practical_performance_factors():    &quot;&quot;&quot;    影响实际性能的因素    &quot;&quot;&quot;    print(&quot;影响算法实际性能的因素：&quot;)    print(&quot;1. 常数因子：O(n)算法的常数可能很大&quot;)    print(&quot;2. 数据规模：小规模时简单算法可能更快&quot;)      print(&quot;3. 内存访问模式：缓存友好的算法性能更好&quot;)    print(&quot;4. 分支预测：减少条件分支可提高性能&quot;)    print(&quot;5. 编译器优化：现代编译器能显著优化代码&quot;)    print(&quot;6. 硬件特性：利用SIMD等特性可大幅提速&quot;)\n\n\n","categories":["Notes","Algorithm"],"tags":["数据结构","算法","Python","二分搜索","排序算法","时间复杂度"]},{"title":"Longitudinal associations between family conflict and depression among family members：Evidence from CFPS, 2016-2020.","url":"/2025/02/25/Longitudinal%20associations%20between%20family%20conflict,%20intergenerational%20transmission,%20and%20adolescents%E2%80%99%20depressive%20symptoms%20evidence%20from%20China%20Family%20Panel%20studies/","content":"  I am honored to be the co-first author of this paper, and my main for data processing, data analysis, visualization, and paper writing.  Based on the 2016-2020 China Family Tracking Survey (CFPS) data, the study analyzed 1,772 adolescents and their parents over a four-year period, and for the first time systematically revealed the bidirectional mechanism of family conflict and adolescent depressive symptoms and the intergenerational transmission pathway. The study found that: （1） family conflict significantly exacerbates adolescent depression, and adolescent depression will in turn aggravate family conflict, forming a vicious cycle; （2） mothers’ depression has a particularly prominent impact on adolescent mental health, and adolescent depression may further trigger fathers’ depression; （3） mothers’ education level is an important protective factor against adolescent depression, and mothers with high levels of education can significantly reduce the risk of their children’s depression. risk. These findings provide key scientific support for the development of family-centered mental health intervention strategies, which are important for breaking the intergenerational transmission of depression and improving family functioning.\nPDF file","categories":["Publication"],"tags":["mental health","structural equation modeling","longitudinal study"]},{"title":"吴恩达机器学习课程资料归档","url":"/2025/08/03/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E4%BB%B6%E7%95%99%E6%A1%A3/","content":"大概是24年暑假期间一周速通学完了吴恩达的机器学习，真真真是深入浅出，言简意赅， 记录一下吴恩达机器学习课程相关的PDF资料、讲义、笔记等，方便日后复习与查阅。\n课程链接吴恩达机器学习（B站全套）\n课堂上的PDF笔记\n\n网盘整体的文件通过网盘分享的文件：A最新版 吴恩达机器学习Deeplearning.ai链接: https://pan.baidu.com/s/1RGHnExutISizVeFNNR4OnQ?pwd=ue7m 提取码: ue7m \n","categories":["Review","Online course"],"tags":["机器学习","吴恩达","Review","监督学习","无监督学习"]},{"title":"数据结构与算法自学笔记（3）- 队列和栈相关","url":"/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%20%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9B%B8%E5%85%B3/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了栈和队列的基础实现、相互转换以及最小栈等核心内容，涵盖了链表实现、数组实现、循环队列等多种实现方式,包括了class013 -&gt; class016的内容。\n\n013【入门】队列和栈-链表、数组实现队列的基本概念队列（Queue）是一种先进先出（FIFO, First In First Out）的线性数据结构。元素从队尾（rear）插入，从队首（front）删除。\n队列的基本操作\nenqueue&#x2F;offer: 入队，将元素添加到队尾\ndequeue&#x2F;poll: 出队，从队首移除元素\nfront&#x2F;peek: 查看队首元素，但不移除\nisEmpty: 判断队列是否为空\nsize: 获取队列中元素个数\n\n队列的实现方式方式一：基于双端队列（deque）实现Python内置的collections.deque提供了高效的双端操作，但常数时间较慢。\nfrom collections import dequeclass Queue1:    &quot;&quot;&quot;    基于Python内置deque实现的队列    内部使用双向链表，常数操作较慢但使用简单    &quot;&quot;&quot;    def __init__(self):        self.queue = deque()  # 内部存储使用deque（双端队列）    def is_empty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return not self.queue    def offer(self, num):        &quot;&quot;&quot;向队列中加入元素，加到队尾&quot;&quot;&quot;        self.queue.append(num)    def poll(self):        &quot;&quot;&quot;从队列头部弹出元素&quot;&quot;&quot;        return self.queue.popleft()    def peek(self):        &quot;&quot;&quot;返回队列头的元素但不弹出&quot;&quot;&quot;        return self.queue[0]    def size(self):        &quot;&quot;&quot;返回队列中元素个数&quot;&quot;&quot;        return len(self.queue)\n\n方式二：基于固定数组实现在已知操作次数上限的情况下，使用固定数组实现具有更好的常数时间性能。\nclass Queue2:    &quot;&quot;&quot;    基于固定数组实现的队列    适用于已知加入操作总次数上限的场景    常数时间性能更好，是实际刷题中最常用的方式    &quot;&quot;&quot;    def __init__(self, n):        &quot;&quot;&quot;        初始化队列        参数: n - 加入操作的总次数上限        &quot;&quot;&quot;        self.queue = [0] * n  # 固定大小数组        self.l = 0  # 队首指针        self.r = 0  # 队尾指针    def is_empty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.l == self.r    def offer(self, num):        &quot;&quot;&quot;入队操作&quot;&quot;&quot;        self.queue[self.r] = num  # 在队尾位置插入元素        self.r += 1  # 队尾指针后移    def poll(self):        &quot;&quot;&quot;出队操作&quot;&quot;&quot;        num = self.queue[self.l]  # 取队首元素        self.l += 1  # 队首指针后移        return num    def head(self):        &quot;&quot;&quot;返回队首元素&quot;&quot;&quot;        return self.queue[self.l]    def tail(self):        &quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;        return self.queue[self.r - 1]    def size(self):        &quot;&quot;&quot;队列当前元素个数，区间[l, r)&quot;&quot;&quot;        return self.r - self.l\n\n栈的基本概念栈（Stack）是一种后进先出（LIFO, Last In First Out）的线性数据结构。元素只能从栈顶插入和删除。\n栈的基本操作\npush: 压栈，将元素添加到栈顶\npop: 弹栈，从栈顶移除元素\npeek&#x2F;top: 查看栈顶元素，但不移除\nisEmpty: 判断栈是否为空\nsize: 获取栈中元素个数\n\n栈的实现方式方式一：基于动态数组实现class Stack1:    &quot;&quot;&quot;    基于Python内置列表实现的栈    使用动态数组，常数时间不是最优但使用简单    &quot;&quot;&quot;    def __init__(self):        self.stack = []  # 用列表模拟栈    def is_empty(self):        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return len(self.stack) == 0    def push(self, num):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.stack.append(num)    def pop(self):        &quot;&quot;&quot;弹栈操作&quot;&quot;&quot;        return self.stack.pop()    def peek(self):        &quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;        return self.stack[-1]    def size(self):        &quot;&quot;&quot;返回栈的大小&quot;&quot;&quot;        return len(self.stack)\n\n方式二：基于固定数组实现class Stack2:    &quot;&quot;&quot;    基于固定数组实现的栈    适用于已知同时在栈里元素个数上限的场景    常数时间性能更好，空间可以复用    &quot;&quot;&quot;    def __init__(self, n):        &quot;&quot;&quot;        初始化栈        参数: n - 同时在栈里的元素个数上限        &quot;&quot;&quot;        self.stack = [0] * n  # 固定大小数组        self.size_ = 0  # 当前栈元素个数    def is_empty(self):        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return self.size_ == 0    def push(self, num):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.stack[self.size_] = num  # 在当前size位置插入        self.size_ += 1  # 元素个数+1    def pop(self):        &quot;&quot;&quot;弹栈操作&quot;&quot;&quot;        self.size_ -= 1  # 元素个数-1，先减后取值        return self.stack[self.size_]  # 返回弹出的元素    def peek(self):        &quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;        return self.stack[self.size_ - 1]    def size(self):        &quot;&quot;&quot;返回栈大小&quot;&quot;&quot;        return self.size_\n\n循环队列循环队列是队列的一种特殊实现，通过循环使用固定大小的数组来避免空间浪费。\nclass MyCircularQueue:    &quot;&quot;&quot;    循环队列实现    测试链接: https://leetcode.cn/problems/design-circular-queue/    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.queue = [0] * k  # 固定大小数组        self.l = 0  # 队首指针        self.r = 0  # 队尾指针        self.size = 0  # 当前元素个数        self.limit = k  # 容量上限    def enQueue(self, value):        &quot;&quot;&quot;        入队操作        返回: 成功返回True，队列满返回False        &quot;&quot;&quot;        if self.isFull():            return False  # 队列已满        else:            self.queue[self.r] = value  # 队尾插入元素            # 队尾指针循环移动            self.r = 0 if self.r == self.limit - 1 else self.r + 1            self.size += 1  # 元素个数+1            return True    def deQueue(self):        &quot;&quot;&quot;        出队操作        返回: 成功返回True，队列空返回False        &quot;&quot;&quot;        if self.isEmpty():            return False  # 队列为空        else:            # 队首指针循环移动            self.l = 0 if self.l == self.limit - 1 else self.l + 1            self.size -= 1  # 元素个数-1            return True    def Front(self):        &quot;&quot;&quot;返回队首元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.queue[self.l]    def Rear(self):        &quot;&quot;&quot;返回队尾元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            # 计算队尾指针的实际位置            last = self.limit - 1 if self.r == 0 else self.r - 1            return self.queue[last]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n\n014【入门】队列和栈入门题目-栈和队列相互实现用栈实现队列队列是先进先出（FIFO），而栈是后进先出（LIFO）。要用栈实现队列，需要使用两个栈来模拟队列的行为。\n算法思想使用两个栈：\n\n输入栈（in_stack）：负责接收新元素的push操作\n输出栈（out_stack）：负责输出元素的pop和peek操作\n\n关键规则\n倒数据条件：只有当输出栈为空时，才能从输入栈倒数据\n倒数据原则：如果要倒数据，必须将输入栈的数据全部倒完\n时间复杂度：虽然单次操作可能是O(n)，但均摊时间复杂度是O(1)\n\nclass MyQueue:    &quot;&quot;&quot;    用栈实现队列    测试链接: https://leetcode.cn/problems/implement-queue-using-stacks/    时间复杂度: 均摊O(1)    &quot;&quot;&quot;    def __init__(self):        self.in_stack = []     # 输入栈，负责push        self.out_stack = []    # 输出栈，负责pop/peek    def inToOut(self):        &quot;&quot;&quot;        倒数据操作：从输入栈将数据倒入输出栈        核心规则：        1) 输出栈空了，才能倒数据        2) 如果倒数据，输入栈必须倒完        &quot;&quot;&quot;        if not self.out_stack:                     # 只有输出栈为空才能倒            while self.in_stack:                   # 输入栈必须倒完                self.out_stack.append(self.in_stack.pop())    def push(self, x: int):        &quot;&quot;&quot;入队操作：新元素加入输入栈&quot;&quot;&quot;        self.in_stack.append(x)                    # 新元素压入输入栈        self.inToOut()                             # 检查是否需要倒数据    def pop(self) -&gt; int:        &quot;&quot;&quot;出队操作：从输出栈弹出元素&quot;&quot;&quot;        self.inToOut()                             # 确保输出栈有数据        return self.out_stack.pop()                # 弹出队首元素    def peek(self) -&gt; int:        &quot;&quot;&quot;查看队首元素：不移除，只查看&quot;&quot;&quot;        self.inToOut()                             # 确保输出栈有数据        return self.out_stack[-1]                  # 返回栈顶即队首    def empty(self) -&gt; bool:        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return not self.in_stack and not self.out_stack  # 两个栈都空才是空队列\n\n时间复杂度分析虽然inToOut()操作在最坏情况下需要O(n)时间，但通过均摊分析：\n\n每个元素最多被移动两次（输入栈→输出栈→出队列）\nn次操作的总时间复杂度为O(n)\n均摊时间复杂度为O(1)\n\n用队列实现栈栈是后进先出（LIFO），队列是先进先出（FIFO）。要用队列实现栈，需要在每次push操作后重新排列队列中的元素。\n算法思想使用一个双端队列（deque），在每次push新元素后，将队列中原有的元素依次移动到新元素后面，确保新元素总是在队首位置。\nfrom collections import dequeclass MyStack:    &quot;&quot;&quot;    用双端队列实现栈    测试链接: https://leetcode.cn/problems/implement-stack-using-queues/    &quot;&quot;&quot;    def __init__(self):        self.queue = deque()                       # 用deque实现队列    def push(self, x: int):        &quot;&quot;&quot;        压栈操作        时间复杂度: O(n)        核心思想: 新元素入队后，将前面所有元素重新排列到新元素后面        &quot;&quot;&quot;        n = len(self.queue)                        # 记录当前队列长度        self.queue.append(x)                       # 新元素加入队尾                # 将前面的n个元素依次移动到队尾        for _ in range(n):            self.queue.append(self.queue.popleft())    def pop(self) -&gt; int:        &quot;&quot;&quot;弹栈操作：弹出队首元素，即栈顶元素&quot;&quot;&quot;        return self.queue.popleft()    def top(self) -&gt; int:        &quot;&quot;&quot;查看栈顶元素：返回队首元素&quot;&quot;&quot;        return self.queue[0]    def empty(self) -&gt; bool:        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return not self.queue\n\n操作示例假设依次push元素1, 2, 3：\n初始状态: []push(1): [1]push(2): [2] -&gt; [2,1] (将1移动到2后面)push(3): [3,2,1] -&gt; [3,2,1] (将2,1依次移动到3后面)\n\n最终队列状态为[3,2,1]，队首元素3就是栈顶元素，符合LIFO特性。\n\n015【入门】栈的入门题目-最小栈最小栈问题最小栈要求实现一个栈，除了基本的栈操作外，还要能够在O(1)时间内获取栈中的最小元素。\n问题分析核心挑战是如何在保持基本栈操作O(1)时间复杂度的同时，追踪当前栈中的最小值。当栈顶元素（恰好是最小值）被弹出时，需要快速知道剩余元素中的最小值。\n解决方案：辅助栈法使用两个栈：\n\n数据栈（data）：存储实际数据\n最小值栈（min）：存储对应位置的最小值\n\n实现方法一：基于列表class MinStack1:    &quot;&quot;&quot;    最小栈实现方法一：使用Python列表    测试链接: https://leetcode.cn/problems/min-stack/    时间复杂度: 所有操作均为O(1)    &quot;&quot;&quot;    def __init__(self):        self.data = []  # 数据栈，存储实际元素        self.min = []   # 最小值栈，存储对应位置的最小值    def push(self, val):        &quot;&quot;&quot;        压栈操作        核心思想: 每次压栈时，同时在最小值栈中记录当前的最小值        &quot;&quot;&quot;        self.data.append(val)  # 将val压入数据栈                if not self.min or val &lt;= self.min[-1]:  # 如果最小栈为空或val是新的最小值            self.min.append(val)  # 将val压入最小栈        else:  # 否则val不是最小值            self.min.append(self.min[-1])  # 将当前最小值再次压入最小栈    def pop(self):        &quot;&quot;&quot;弹栈操作：同时弹出两个栈的栈顶元素&quot;&quot;&quot;        self.data.pop()  # 弹出数据栈栈顶        self.min.pop()   # 弹出最小栈栈顶    def top(self):        &quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;        return self.data[-1]  # 返回数据栈栈顶元素    def getMin(self):        &quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;        return self.min[-1]   # 返回最小栈栈顶元素\n\n工作原理示例假设依次压入元素：5, 2, 7, 1, 3\n\n\n\n操作\n数据栈\n最小栈\n说明\n\n\n\npush(5)\n[5]\n[5]\n5是第一个元素，也是最小值\n\n\npush(2)\n[5,2]\n[5,2]\n2比5小，成为新的最小值\n\n\npush(7)\n[5,2,7]\n[5,2,2]\n7比2大，最小值仍是2\n\n\npush(1)\n[5,2,7,1]\n[5,2,2,1]\n1比2小，成为新的最小值\n\n\npush(3)\n[5,2,7,1,3]\n[5,2,2,1,1]\n3比1大，最小值仍是1\n\n\n实现方法二：基于固定数组class MinStack2:    &quot;&quot;&quot;    最小栈实现方法二：使用固定大小数组    适用于已知最大容量的场景，常数时间性能更好    &quot;&quot;&quot;    def __init__(self):        # 根据leetcode测试数据实验得出的容量上限        # 如果测试数据增加导致溢出，需要调大此值        self.MAXN = 8001        self.data = [0] * self.MAXN  # 数据数组        self.min = [0] * self.MAXN   # 最小值数组        self.size = 0  # 当前栈大小    def push(self, val):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.data[self.size] = val  # 在size位置存储val                if self.size == 0 or val &lt;= self.min[self.size - 1]:  # 第一个元素或新的最小值            self.min[self.size] = val  # 存储val作为最小值        else:  # val不是最小值            self.min[self.size] = self.min[self.size - 1]  # 复制前一个最小值                self.size += 1  # 栈大小加1    def pop(self):        &quot;&quot;&quot;弹栈操作：只需将size减1，不需要实际删除数据&quot;&quot;&quot;        self.size -= 1    def top(self):        &quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;        return self.data[self.size - 1]    def getMin(self):        &quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;        return self.min[self.size - 1]\n\n复杂度分析时间复杂度\npush操作：O(1) - 只需要常数次比较和赋值\npop操作：O(1) - 只需要移动指针或减少计数\ntop操作：O(1) - 直接访问数组元素\ngetMin操作：O(1) - 直接访问最小值栈顶\n\n空间复杂度\n总空间复杂度：O(n) - 需要两个栈存储数据\n额外空间：O(n) - 最小值栈的空间开销\n\n优化思考虽然辅助栈法简单易懂，但存在空间冗余。可以考虑以下优化：\n\n稀疏存储：最小值栈只在最小值更新时才压入新值\n差值存储：存储与最小值的差值而非绝对值\n链表实现：在节点中直接存储当前最小值\n\n\n数据结构选择指南性能对比\n\n\n实现方式\n时间复杂度\n空间复杂度\n常数因子\n适用场景\n\n\n\nPython内置容器\nO(1)均摊\nO(n)\n较大\n快速原型，不追求极致性能\n\n\n固定数组\nO(1)\nO(n)\n较小\n已知容量上限，追求性能\n\n\n双栈&#x2F;双队列\nO(1)均摊\nO(n)\n中等\n功能转换，教学示例\n\n\n016【入门】双端队列-双链表和固定数组实现双端队列的基本概念双端队列（Deque，Double-ended Queue）是一种特殊的线性数据结构，允许在队列的两端进行插入和删除操作。与普通队列只能在一端插入、另一端删除不同，双端队列提供了更大的灵活性。\n双端队列的基本操作\ninsertFront: 在队首插入元素\ninsertLast: 在队尾插入元素  \ndeleteFront: 删除队首元素\ndeleteLast: 删除队尾元素\ngetFront: 获取队首元素\ngetRear: 获取队尾元素\nisEmpty: 判断队列是否为空\nisFull: 判断队列是否已满\n\n循环双端队列的实现循环双端队列是双端队列的一种特殊实现，使用固定大小的数组并通过循环索引来管理队列的边界。\n实现方式一：基于Python列表class MyCircularDeque1:    &quot;&quot;&quot;    基于Python列表实现的循环双端队列    内部使用动态数组，操作简单但常数时间较慢    测试链接: https://leetcode.cn/problems/design-circular-deque/    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环双端队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.deque = []  # 用列表模拟双端队列        self.size = 0    # 当前队列大小        self.limit = k   # 队列容量    def insertFront(self, value):        &quot;&quot;&quot;        在队首插入元素        时间复杂度: O(n) - 需要移动所有现有元素        &quot;&quot;&quot;        if self.isFull():            return False        else:            self.deque.insert(0, value)  # 在索引0位置插入，其他元素后移            self.size += 1            return True    def insertLast(self, value):        &quot;&quot;&quot;        在队尾插入元素        时间复杂度: O(1)均摊        &quot;&quot;&quot;        if self.isFull():            return False        else:            self.deque.append(value)  # 直接添加到列表末尾            self.size += 1            return True    def deleteFront(self):        &quot;&quot;&quot;        删除队首元素        时间复杂度: O(n) - 需要移动所有剩余元素        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            self.size -= 1            self.deque.pop(0)  # 删除索引0的元素，其他元素前移            return True    def deleteLast(self):        &quot;&quot;&quot;        删除队尾元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            self.size -= 1            self.deque.pop()  # 删除列表末尾元素            return True    def getFront(self):        &quot;&quot;&quot;获取队首元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[0]    def getRear(self):        &quot;&quot;&quot;获取队尾元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[-1]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n实现方式二：基于固定数组class MyCircularDeque2:    &quot;&quot;&quot;    基于固定数组实现的循环双端队列    使用循环索引管理队列边界，常数时间性能更好    适用于已知容量上限的场景    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环双端队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.deque = [0] * k  # 固定长度数组        self.l = 0            # 队首指针        self.r = 0            # 队尾指针        self.size = 0         # 当前队列大小        self.limit = k        # 队列容量    def insertFront(self, value):        &quot;&quot;&quot;        在队首插入元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isFull():            return False        else:            if self.isEmpty():                # 空队列情况，队首和队尾指针都指向同一位置                self.l = self.r = 0                self.deque[0] = value            else:                # 队首指针向前移动（循环）                self.l = self.l - 1 if self.l != 0 else self.limit - 1                self.deque[self.l] = value            self.size += 1            return True    def insertLast(self, value):        &quot;&quot;&quot;        在队尾插入元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isFull():            return False        else:            if self.isEmpty():                # 空队列情况                self.l = self.r = 0                self.deque[0] = value            else:                # 队尾指针向后移动（循环）                self.r = 0 if self.r == self.limit - 1 else self.r + 1                self.deque[self.r] = value            self.size += 1            return True    def deleteFront(self):        &quot;&quot;&quot;        删除队首元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            if self.size == 1:                # 删除后队列变空，可选择重置指针                pass  # 这里不重置l和r，因为逻辑上没有影响            # 队首指针向后移动（循环）            self.l = 0 if self.l == self.limit - 1 else self.l + 1            self.size -= 1            return True    def deleteLast(self):        &quot;&quot;&quot;        删除队尾元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            if self.size == 1:                # 删除后队列变空                pass  # 不重置指针            # 队尾指针向前移动（循环）            self.r = self.limit - 1 if self.r == 0 else self.r - 1            self.size -= 1            return True    def getFront(self):        &quot;&quot;&quot;获取队首元素&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[self.l]    def getRear(self):        &quot;&quot;&quot;获取队尾元素&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[self.r]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n循环索引的关键理解指针移动规律在固定数组实现中，关键是理解循环索引的移动：\n# 向后移动（队尾插入，队首删除）next_index = 0 if current_index == limit - 1 else current_index + 1# 向前移动（队首插入，队尾删除）  prev_index = limit - 1 if current_index == 0 else current_index - 1\n\n边界情况处理\n空队列插入：第一个元素插入时，队首和队尾指针都指向同一位置\n单元素删除：删除唯一元素后队列变空，但指针位置不需要重置\n满队列检测：通过size变量而非指针位置来判断队列是否已满\n\n性能分析时间复杂度对比\n\n\n操作\n列表实现\n数组实现\n说明\n\n\n\ninsertFront\nO(n)\nO(1)\n列表需要移动所有元素\n\n\ninsertLast\nO(1)均摊\nO(1)\n列表可能需要扩容\n\n\ndeleteFront\nO(n)\nO(1)\n列表需要移动所有元素\n\n\ndeleteLast\nO(1)\nO(1)\n两种实现都是常数时间\n\n\ngetFront&#x2F;getRear\nO(1)\nO(1)\n直接索引访问\n\n\n空间复杂度\n列表实现：O(k)，但可能因为动态扩容导致额外开销\n数组实现：O(k)，固定空间，无额外开销\n\n应用场景双端队列的典型应用\n滑动窗口问题：需要在窗口两端进行操作\n回文检测：从两端向中间检查字符\n撤销&#x2F;重做功能：需要在两端添加和删除操作记录\n广度优先搜索变种：某些图算法需要双向扩展\n\n与其他数据结构的对比\n\n\n数据结构\n队首操作\n队尾操作\n适用场景\n\n\n\n普通队列\n删除O(1)\n插入O(1)\nFIFO场景\n\n\n栈\n插入&#x2F;删除O(1)\n无操作\nLIFO场景\n\n\n双端队列\n插入&#x2F;删除O(1)\n插入&#x2F;删除O(1)\n需要两端操作\n\n\n动态数组\n插入O(n)，删除O(n)\n插入O(1)均摊，删除O(1)\n随机访问\n\n\n双端队列提供了比普通队列和栈更大的灵活性，在需要两端操作的算法中具有重要作用。固定数组的循环实现虽然代码复杂度稍高，但提供了最优的时间和空间性能。刷题中优先选择固定数组实现，性能更好，实际工程中如果容量不确定，可以考虑列表实现或者动态扩容的数组；此外，固定数据能使得内存使用更可控。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","队列","栈","节点遍历","列表","数组"]},{"title":"数据结构与算法自学笔记（2）- 链表相关","url":"/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了class009 -&gt; class012，涵盖了链表的基础概念、反转操作、合并算法、链表运算以及分割技巧等内容。\n\n009【入门】单双链表及其反转链表的基本概念链表是一种线性数据结构，其中元素存储在节点中，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不必连续存储。\n单链表节点定义class ListNode:    &quot;&quot;&quot;    单链表节点类    &quot;&quot;&quot;    def __init__(self, val=0, next=None):        self.val = val                    # 节点存储的数据值        self.next = next                  # 指向下一个节点的指针\n\n双链表节点定义class DoubleListNode:    &quot;&quot;&quot;    双链表节点类    每个节点有两个指针：指向前驱和后继    &quot;&quot;&quot;    def __init__(self, value):        self.value = value                # 节点存储的数据值        self.last = None                  # 指向前一个节点的指针        self.next = None                  # 指向下一个节点的指针\n\n单链表反转算法反转单链表测试链接 : https://leetcode.cn/problems/reverse-linked-list/\n迭代方法实现单链表反转是链表操作中的经典问题，核心思想是改变节点间的指针方向。\nclass ListReverseOperations:    @staticmethod    def reverse_linked_list(head):        &quot;&quot;&quot;        反转单链表 - 迭代实现        时间复杂度: O(n), 空间复杂度: O(1)                参数: head - 链表头节点        返回: 反转后链表的头节点        &quot;&quot;&quot;        pre = None                        # 前驱节点指针，初始为None        next_node = None                  # 临时保存下一个节点                while head is not None:           # 遍历整个链表            next_node = head.next         # 保存下一个节点，防止链表断裂            head.next = pre               # 当前节点指向前驱（反转指针）            pre = head                    # 前驱指针前进到当前节点            head = next_node              # 头指针前进到下一个节点                return pre                        # pre此时指向原链表的尾节点，即新链表的头节点\n\n反转过程图解\n具体在上面的实现中，是利用next向后移动 利用pre改变方指针向\n原链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL第1步: pre=NULL, head=1, next=2      NULL &lt;- 1    2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL             pre  head第2步: pre=1, head=2, next=3        NULL &lt;- 1 &lt;- 2    3 -&gt; 4 -&gt; 5 -&gt; NULL                  pre  head第3步: pre=2, head=3, next=4      NULL &lt;- 1 &lt;- 2 &lt;- 3    4 -&gt; 5 -&gt; NULL                        pre  head最终: NULL &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5                                  pre\n\n递归方法实现@staticmethoddef reverse_linked_list_recursive(head):    &quot;&quot;&quot;    反转单链表 - 递归实现    时间复杂度: O(n), 空间复杂度: O(n) - 递归栈空间        参数: head - 链表头节点    返回: 反转后链表的头节点    &quot;&quot;&quot;    # 基础情况：空链表或单节点链表    if head is None or head.next is None:        return head        # 递归反转剩余部分    new_head = ListReverseOperations.reverse_linked_list_recursive(head.next)        # 反转当前节点与下一个节点的连接    head.next.next = head             # 下一个节点指回当前节点    head.next = None                  # 当前节点的next置空        return new_head                   # 返回新的头节点\n\n双链表反转算法双链表的反转需要同时处理前驱和后继两个指针，相比单链表更加复杂。\n@staticmethoddef reverse_double_list(head):    &quot;&quot;&quot;    反转双链表    时间复杂度: O(n), 空间复杂度: O(1)        参数: head - 双链表头节点    返回: 反转后双链表的头节点    &quot;&quot;&quot;    pre = None                        # 前驱节点指针    next_node = None                  # 临时保存下一个节点        while head is not None:           # 遍历整个双链表        next_node = head.next         # 保存下一个节点                # 交换当前节点的前驱和后继指针        head.next = pre               # next指向前驱        head.last = next_node         # last指向后继                pre = head                    # 前驱指针前进        head = next_node              # 头指针前进        return pre                        # 返回新的头节点\n\n双链表反转的关键点\n指针交换：每个节点的next和last指针需要互换方向\n边界处理：正确处理链表两端的NULL指针\n遍历顺序：确保在修改指针前保存必要的信息\n\n\n010【入门】合并两个有序链表测试链接 : https://leetcode.cn/problems/merge-two-sorted-lists/\n问题描述给定两个已排序的链表，将它们合并成一个新的有序链表。新链表应该通过拼接给定的两个链表的所有节点组成。\n算法思想采用双指针技术，比较两个链表当前节点的值，选择较小的节点添加到结果链表中，然后移动对应的指针。\n实现方案class Solution:    @staticmethod    def merge_two_lists(head1, head2):        &quot;&quot;&quot;        合并两个有序链表        时间复杂度: O(m + n), 空间复杂度: O(1)                参数: head1, head2 - 两个有序链表的头节点        返回: 合并后有序链表的头节点        &quot;&quot;&quot;        # 边界情况处理：其中一个链表为空        if head1 is None or head2 is None:            return head2 if head1 is None else head1                # 确定合并后链表的头节点        if head1.val &lt;= head2.val:            head = head1                  # head1的值更小，作为头节点            cur1 = head1.next             # cur1指向head1的下一个节点            cur2 = head2                  # cur2指向head2的当前节点        else:            head = head2                  # head2的值更小，作为头节点            cur1 = head1                  # cur1指向head1的当前节点            cur2 = head2.next             # cur2指向head2的下一个节点                pre = head                        # pre用于构建结果链表                # 双指针遍历两个链表        while cur1 is not None and cur2 is not None:            if cur1.val &lt;= cur2.val:     # cur1的值更小或相等                pre.next = cur1           # 将cur1连接到结果链表                cur1 = cur1.next          # cur1指针后移            else:                         # cur2的值更小                pre.next = cur2           # 将cur2连接到结果链表                cur2 = cur2.next          # cur2指针后移            pre = pre.next                # 结果链表指针后移                # 处理剩余节点：将未遍历完的链表直接连接到结果链表末尾        pre.next = cur1 if cur1 is not None else cur2                return head                       # 返回合并后链表的头节点\n\n算法优化版本@staticmethoddef merge_two_lists_optimized(head1, head2):    &quot;&quot;&quot;    合并两个有序链表 - 优化版本    使用虚拟头节点简化边界处理    &quot;&quot;&quot;    dummy = ListNode(0)               # 创建虚拟头节点    current = dummy                   # 当前指针指向虚拟头节点        # 双指针遍历两个链表    while head1 is not None and head2 is not None:        if head1.val &lt;= head2.val:            current.next = head1      # 连接较小节点            head1 = head1.next        # 移动head1指针        else:            current.next = head2      # 连接较小节点            head2 = head2.next        # 移动head2指针        current = current.next        # 移动结果链表指针        # 连接剩余节点    current.next = head1 if head1 is not None else head2        return dummy.next                 # 返回真正的头节点\n\n合并过程示例链表1: 1 -&gt; 2 -&gt; 4链表2: 1 -&gt; 3 -&gt; 4合并过程:step1: 比较1和1，选择链表1的1    结果: 1step2: 比较2和1，选择链表2的1    结果: 1 -&gt; 1  step3: 比较2和3，选择链表1的2    结果: 1 -&gt; 1 -&gt; 2step4: 比较4和3，选择链表2的3    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3step5: 比较4和4，选择链表1的4    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4step6: 连接剩余的4              结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n\n\n011【入门】两个链表相加测试链接：https://leetcode.cn/problems/add-two-numbers/\n问题描述给定两个非空链表来表示两个非负整数，数字最高位位于链表开始位置。它们的每个节点只存储一位数字，计算两个数的和并以相同形式返回一个表示和的链表。\n核心思想模拟手工加法运算，从链表尾部开始逐位相加，处理进位问题。\n算法实现class Solution:    @staticmethod    def add_two_numbers(h1, h2):        &quot;&quot;&quot;        两个链表数字相加        时间复杂度: O(max(m,n)), 空间复杂度: O(max(m,n))                参数: h1, h2 - 两个表示数字的链表头节点        返回: 表示和的链表头节点        &quot;&quot;&quot;        ans = None                        # 结果链表头节点        cur = None                        # 当前构建位置指针        carry = 0                         # 进位标志                # 遍历两个链表，直到都为空        while h1 is not None or h2 is not None:            # 获取当前位的数字，如果链表已结束则为0            val1 = h1.val if h1 is not None else 0            val2 = h2.val if h2 is not None else 0                        # 计算当前位的和（包括进位）            total = val1 + val2 + carry            carry = total // 10           # 计算新的进位            digit = total % 10            # 当前位的数字                        # 构建结果链表            if ans is None:               # 第一个节点                ans = ListNode(digit)                cur = ans            else:                         # 后续节点                cur.next = ListNode(digit)                cur = cur.next                        # 移动链表指针            h1 = h1.next if h1 is not None else None            h2 = h2.next if h2 is not None else None                # 处理最后的进位        if carry == 1:            cur.next = ListNode(1)                return ans                        # 返回结果链表头节点\n\n代码修正与优化优化了源代码最后的进位问题\n@staticmethoddef add_two_numbers_corrected(h1, h2):    &quot;&quot;&quot;    两个链表数字相加 - 优化版本，更加通用    &quot;&quot;&quot;    ans = None                        # 结果链表头节点    cur = None                        # 当前构建位置指针    carry = 0                         # 进位标志        while h1 is not None or h2 is not None:        # 安全获取节点值，避免空指针异常        val1 = h1.val if h1 is not None else 0        val2 = h2.val if h2 is not None else 0                # 计算当前位的和        total = val1 + val2 + carry        carry = total // 10           # 新进位        digit = total % 10            # 当前位数字                # 构建结果链表节点        new_node = ListNode(digit)        if ans is None:               # 初始化头节点            ans = cur = new_node        else:                         # 连接新节点            cur.next = new_node            cur = new_node                # 安全移动指针        h1 = h1.next if h1 is not None else None        h2 = h2.next if h2 is not None else None        # 处理最终进位    if carry &gt; 0:        cur.next = ListNode(carry)        return ans\n\n算法示例链表1: 2 -&gt; 4 -&gt; 3  (表示数字342)链表2: 5 -&gt; 6 -&gt; 4  (表示数字465)相加过程:位置0: 2 + 5 + 0(进位) = 7, 进位=0  结果: 7位置1: 4 + 6 + 0(进位) = 10, 进位=1  结果: 7 -&gt; 0位置2: 3 + 4 + 1(进位) = 8, 进位=0  结果: 7 -&gt; 0 -&gt; 8最终结果: 7 -&gt; 0 -&gt; 8 (表示数字807)验证: 342 + 465 = 807 ✓\n\n边界情况处理\n不同长度链表：短链表结束后，继续处理长链表的剩余位\n最高位进位：最后可能产生新的最高位\n空链表：输入验证，确保链表非空\n单位数：正确处理个位数相加的情况\n\n\n012【入门】划分链表测试链接 : https://leetcode.cn/problems/partition-list/\n问题描述给定一个链表和一个特定值x，对链表进行分隔，使得所有小于x的节点都在大于或等于x的节点之前。保持两个分区中每个节点的初始相对位置。\n算法思想使用双链表分离的思想：\n\n创建两个独立的链表：小于x的节点链表和大于等于x的节点链表\n遍历原链表，将节点分别添加到对应的链表中\n最后将两个链表连接起来\n\n实现方案class Solution:    @staticmethod    def partition(head, x):        &quot;&quot;&quot;        划分链表        时间复杂度: O(n), 空间复杂度: O(1)                参数: head - 链表头节点, x - 划分值        返回: 划分后链表的头节点        &quot;&quot;&quot;        # 初始化两个链表的头尾指针        left_head = None                  # 小于x的链表头指针        left_tail = None                  # 小于x的链表尾指针        right_head = None                 # 大于等于x的链表头指针        right_tail = None                 # 大于等于x的链表尾指针                next_node = None                  # 临时保存下一个节点                # 遍历原链表，分离节点        while head is not None:            next_node = head.next         # 保存下一个节点            head.next = None              # 断开当前节点的连接                        if head.val &lt; x:              # 当前节点值小于x                if left_head is None:    # 左链表为空                    left_head = head      # 设置左链表头节点                else:                     # 左链表非空                    left_tail.next = head # 连接到左链表尾部                left_tail = head          # 更新左链表尾指针            else:                         # 当前节点值大于等于x                if right_head is None:   # 右链表为空                    right_head = head     # 设置右链表头节点                else:                     # 右链表非空                    right_tail.next = head # 连接到右链表尾部                right_tail = head         # 更新右链表尾指针                        head = next_node              # 移动到下一个节点                # 连接两个链表        if left_head is None:            # 如果左链表为空            return right_head             # 直接返回右链表        else:                            # 左链表非空            left_tail.next = right_head   # 连接左右链表            return left_head              # 返回左链表头节点\n\n代码修正与完善优化了原代码在遍历阶段的指针指代可能不清晰的问题，修改了if else后的指定\nclass Solution:    @staticmethod    def partition_corrected(head, x):        &quot;&quot;&quot;        划分链表 - 修正版本        修复了原代码的语法错误和逻辑问题        &quot;&quot;&quot;        # 初始化四个指针        left_head = left_tail = None      # 小于x的链表头尾指针        right_head = right_tail = None    # 大于等于x的链表头尾指针                # 遍历原链表        while head is not None:            next_node = head.next         # 保存下一个节点            head.next = None              # 断开当前节点                        if head.val &lt; x:              # 节点值小于x                if left_head is None:    # 第一个小于x的节点                    left_head = left_tail = head                else:                     # 后续小于x的节点                    left_tail.next = head                    left_tail = head            else:                         # 节点值大于等于x                if right_head is None:   # 第一个大于等于x的节点                    right_head = right_tail = head                else:                     # 后续大于等于x的节点                    right_tail.next = head                    right_tail = head                        head = next_node              # 移动到下一个节点                # 合并两个链表        if left_head is None:            # 只有大于等于x的节点            return right_head                left_tail.next = right_head       # 连接两个链表        return left_head                  # 返回结果链表头节点\n\n优化版本：使用虚拟头节点@staticmethoddef partition_optimized(head, x):    &quot;&quot;&quot;    划分链表 - 优化版本    使用虚拟头节点简化代码逻辑，简化了边界处理    &quot;&quot;&quot;    # 创建虚拟头节点    left_dummy = ListNode(0)          # 小于x链表的虚拟头节点    right_dummy = ListNode(0)         # 大于等于x链表的虚拟头节点        left = left_dummy                 # 小于x链表的当前指针    right = right_dummy               # 大于等于x链表的当前指针        # 遍历原链表，分配节点    while head is not None:        if head.val &lt; x:            left.next = head          # 连接到左链表            left = left.next          # 移动左指针        else:            right.next = head         # 连接到右链表            right = right.next        # 移动右指针        head = head.next              # 移动原链表指针        # 断开右链表的尾部连接，防止环    right.next = None        # 连接两个链表    left.next = right_dummy.next        return left_dummy.next            # 返回真正的头节点\n\n算法示例原链表: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2划分值: x = 3分离过程:节点1 &lt; 3: 左链表 = 1节点4 &gt;= 3: 右链表 = 4  节点3 &gt;= 3: 右链表 = 4 -&gt; 3节点2 &lt; 3: 左链表 = 1 -&gt; 2节点5 &gt;= 3: 右链表 = 4 -&gt; 3 -&gt; 5节点2 &lt; 3: 左链表 = 1 -&gt; 2 -&gt; 2最终结果: 1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5\n\n算法特点\n稳定性：保持原有的相对顺序\n原地操作：只调整指针，不创建新节点\n时间效率：单次遍历，O(n)时间复杂度\n空间效率：只使用常数额外空间\n\n应用场景\n链表排序的预处理：快速排序的分区操作\n数据分类：按条件将数据分为两组\n链表重组：根据特定规则重新排列链表节点\n\n\n链表操作技巧拓展核心技巧与模式1. 双指针技术def two_pointer_pattern(head):    &quot;&quot;&quot;    双指针模式：快慢指针、左右指针等    常用于链表中点查找、环检测、倒数第k个节点等    &quot;&quot;&quot;    slow = fast = head                    # 快慢指针初始化    while fast and fast.next:        slow = slow.next                  # 慢指针每次移动1步        fast = fast.next.next             # 快指针每次移动2步    return slow                           # 返回中点或其他目标位置\n\n2. 虚拟头节点def dummy_head_pattern(head):    &quot;&quot;&quot;    虚拟头节点模式：简化头节点的特殊处理    特别适用于可能删除头节点或构建新链表的场景    &quot;&quot;&quot;    dummy = ListNode(0)                   # 创建虚拟头节点    dummy.next = head                     # 连接原链表        # 在这里进行各种操作    # ...        return dummy.next                     # 返回真正的头节点\n\n3. 递归模式def recursive_pattern(head):    &quot;&quot;&quot;    递归模式：将复杂问题分解为子问题    适用于链表反转、删除节点、合并等操作    &quot;&quot;&quot;    # 基础情况    if head is None or head.next is None:        return head        # 递归处理子问题    result = recursive_pattern(head.next)        # 处理当前层    # ...        return result\n\n4. 节点分离与重组def separate_and_merge_pattern(head):    &quot;&quot;&quot;    分离重组模式：将链表按条件分离后重新组合    适用于链表划分、奇偶分离、按值分组等    &quot;&quot;&quot;    # 创建多个子链表的头尾指针    list1_head = list1_tail = None    list2_head = list2_tail = None        while head:        next_node = head.next        head.next = None                  # 断开连接                if condition(head):               # 根据条件分配            # 添加到list1            if list1_head is None:                list1_head = list1_tail = head            else:                list1_tail.next = head                list1_tail = head        else:            # 添加到list2            if list2_head is None:                list2_head = list2_tail = head            else:                list2_tail.next = head                list2_tail = head                head = next_node        # 重新组合链表    if list1_tail:        list1_tail.next = list2_head    return list1_head if list1_head else list2_head\n\n常见错误与注意事项1. 空指针处理# 错误示例def wrong_example(head):    return head.next.val                  # 可能导致空指针异常# 正确示例  def correct_example(head):    if head and head.next:                # 先检查再访问        return head.next.val    return None\n\n2. 内存泄漏防止def prevent_memory_leak(head):    &quot;&quot;&quot;    防止内存泄漏：及时断开不需要的连接    &quot;&quot;&quot;    while head:        next_node = head.next        head.next = None                  # 断开连接，防止环        head = next_node\n\n3. 边界情况处理def handle_edge_cases(head):    &quot;&quot;&quot;    处理边界情况：空链表、单节点链表等    &quot;&quot;&quot;    # 空链表    if head is None:        return None        # 单节点链表    if head.next is None:        return head        # 正常处理逻辑    # ...\n\n性能分析与优化时间复杂度分析\n单次遍历操作：O(n) - 反转、合并、查找等\n嵌套遍历操作：O(n²) - 某些复杂的链表操作\n递归操作：O(n) - 但需要考虑递归栈空间\n\n空间复杂度优化\n原地操作：优先使用指针操作而非创建新节点\n迭代替代递归：在可能的情况下避免递归栈开销\n临时变量最小化：只保存必要的指针变量\n\n实际性能考虑def performance_optimized_merge(h1, h2):    &quot;&quot;&quot;    性能优化的链表合并    减少条件判断和指针操作    &quot;&quot;&quot;    dummy = ListNode(0)    tail = dummy        while h1 and h2:        if h1.val &lt;= h2.val:            tail.next, h1 = h1, h1.next        else:            tail.next, h2 = h2, h2.next        tail = tail.next        # 直接连接剩余部分，无需循环    tail.next = h1 or h2    return dummy.next\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","节点遍历","链表","指针操作"]},{"title":"数据结构与算法自学笔记（4）- 二叉树相关","url":"/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了二叉树的基础概念、三种遍历方式的递归实现和非递归实现，涵盖了先序、中序、后序遍历的原理与代码实现，包括了class017 -&gt; class018的内容\n017【入门】二叉树及其三种序的递归实现二叉树的基本概念二叉树是一种重要的树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树是许多高级数据结构和算法的基础。\n二叉树节点定义class TreeNode:    def __init__(self, v):        self.val = v         # 节点的值        self.left = None     # 左子节点        self.right = None    # 右子节点\n\n递归序的概念递归序是理解二叉树遍历的关键概念。对于任意二叉树节点，递归过程会经过该节点三次：\ndef f(head):    if head is None:        return    # 第1次到达该节点 - 刚进入该节点    f(head.left)   # 递归处理左子树    # 第2次到达该节点 - 左子树处理完毕    f(head.right)  # 递归处理右子树    # 第3次到达该节点 - 右子树处理完毕\n\n根据在这三个时机中选择处理节点的时机不同，就形成了三种不同的遍历方式。\n二叉树的三种递归遍历先序遍历（Pre-order Traversal）先序遍历的顺序是：根节点 → 左子树 → 右子树\n@staticmethoddef preOrder(head):    &quot;&quot;&quot;    先序遍历：在第1次到达节点时处理    应用场景：复制二叉树、表达式树求值、目录树打印    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/    &quot;&quot;&quot;    if head is None:        return    print(head.val, end=&quot; &quot;)  # 先处理当前节点    BinaryTreeTraversalRecursion.preOrder(head.left)   # 再遍历左子树    BinaryTreeTraversalRecursion.preOrder(head.right)  # 最后遍历右子树\n\n中序遍历（In-order Traversal）中序遍历的顺序是：左子树 → 根节点 → 右子树\n@staticmethoddef inOrder(head):    &quot;&quot;&quot;    中序遍历：在第2次到达节点时处理    应用场景：二叉搜索树排序（得到有序序列）、表达式树转中缀表达式    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/    &quot;&quot;&quot;    if head is None:        return    BinaryTreeTraversalRecursion.inOrder(head.left)   # 先遍历左子树    print(head.val, end=&quot; &quot;)  # 再处理当前节点    BinaryTreeTraversalRecursion.inOrder(head.right)  # 最后遍历右子树\n\n后序遍历（Post-order Traversal）后序遍历的顺序是：左子树 → 右子树 → 根节点\n@staticmethoddef posOrder(head):    &quot;&quot;&quot;    后序遍历：在第3次到达节点时处理    应用场景：计算目录大小、删除二叉树、表达式树计算    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if head is None:        return    BinaryTreeTraversalRecursion.posOrder(head.left)   # 先遍历左子树    BinaryTreeTraversalRecursion.posOrder(head.right)  # 再遍历右子树    print(head.val, end=&quot; &quot;)  # 最后处理当前节点\n\n递归遍历的示例执行以下面的二叉树为例：\n    1   / \\  2   3 / \\ / \\4  5 6  7\n\n执行结果对比\n先序遍历结果：1 2 4 5 3 6 7\n中序遍历结果：4 2 5 1 6 3 7  \n后序遍历结果：4 5 2 6 7 3 1\n\n递归调用过程分析以先序遍历为例，递归调用的过程：\n\n访问节点1，打印1\n递归进入左子树（节点2）\n访问节点2，打印2\n递归进入左子树（节点4）\n访问节点4，打印4\n左右子树为空，返回\n\n\n递归进入右子树（节点5）\n访问节点5，打印5\n左右子树为空，返回\n\n\n\n\n递归进入右子树（节点3）\n类似过程…\n\n\n\n复杂度分析时间复杂度所有递归遍历算法的时间复杂度都是 O(n)，其中n是二叉树的节点数。每个节点都会被访问恰好一次。\n空间复杂度额外空间复杂度：O(h)，其中h是树的高度。\n\n最好情况（完全平衡的二叉树）：h &#x3D; ⌊log₂n⌋，空间复杂度为O(log n)\n最坏情况（完全不平衡的树，退化为链表）：h &#x3D; n，空间复杂度为O(n)\n平均情况：对于随机二叉树，h &#x3D; O(log n)\n\n空间消耗主要来自递归调用栈，栈的最大深度等于树的高度。\n三种遍历方式的应用场景先序遍历的典型应用\n复制二叉树：先创建根节点，再递归复制左右子树\n表达式树求值：先处理操作符，再处理操作数\n目录树打印：先打印目录名，再打印子目录内容\n序列化二叉树：将树结构转换为字符串格式\n\n# 复制二叉树示例def copyTree(root):    if root is None:        return None    # 先创建新节点（先序特点）    newNode = TreeNode(root.val)    newNode.left = copyTree(root.left)    # 递归复制左子树    newNode.right = copyTree(root.right)  # 递归复制右子树    return newNode\n\n中序遍历的典型应用\n二叉搜索树排序：中序遍历BST得到有序序列\n表达式树转中缀表达式：按照运算符优先级添加括号\n验证二叉搜索树：检查中序遍历结果是否为递增序列\n\n# 验证二叉搜索树示例def isValidBST(root):    def inorder(node, values):        if node is None:            return        inorder(node.left, values)        values.append(node.val)  # 中序收集值        inorder(node.right, values)        values = []    inorder(root, values)    # 检查是否严格递增    return all(values[i] &lt; values[i+1] for i in range(len(values)-1))\n\n后序遍历的典型应用\n计算目录大小：先计算子目录大小，再计算当前目录\n删除二叉树：先删除子节点，再删除父节点\n表达式树计算：先计算子表达式，再计算根表达式\n计算树的高度：先计算子树高度，再计算当前树高度\n\n# 计算二叉树高度示例def maxDepth(root):    if root is None:        return 0    # 先计算左右子树高度（后序特点）    leftHeight = maxDepth(root.left)    rightHeight = maxDepth(root.right)    # 再计算当前树高度    return max(leftHeight, rightHeight) + 1\n\n遍历方式选择指南\n\n\n需求场景\n推荐遍历方式\n理由\n\n\n\n复制&#x2F;构建树结构\n先序遍历\n需要先创建根节点\n\n\n获取有序数据\n中序遍历\nBST的中序遍历有序\n\n\n释放&#x2F;计算资源\n后序遍历\n需要先处理子节点\n\n\n树的序列化\n先序遍历\n便于重建树结构\n\n\n表达式求值\n后序遍历\n需要先计算子表达式\n\n\n递归实现的优缺点优点\n代码简洁：逻辑清晰，易于理解和实现\n自然表达：完美匹配树的递归定义\n易于扩展：容易添加额外的处理逻辑\n\n缺点\n栈溢出风险：深度递归可能导致栈溢出\n性能开销：函数调用的开销相对较大\n难以控制：无法方便地暂停或恢复遍历过程\n\n在实际应用中，对于一般规模的二叉树，递归实现是首选方案。当树的深度可能很大时，需要考虑使用非递归实现来避免栈溢出问题。\n\n018【入门】二叉树遍历的非递归实现和复杂度分析非递归实现的必要性递归实现虽然简洁易懂，但在处理大型树时可能导致栈溢出。非递归实现使用显式栈来模拟递归过程，提供了更好的控制性和避免栈溢出的优势。\n核心思想用显式的栈数据结构来模拟系统递归调用栈的行为，手动管理遍历过程中的状态信息。\n先序遍历的非递归实现实现原理先序遍历要求”根-左-右”的访问顺序。使用栈时，由于栈是LIFO（后进先出）结构，需要先压入右子节点，再压入左子节点，这样弹栈时就是先处理左子树。\n@staticmethoddef preOrder(head):    &quot;&quot;&quot;    先序遍历非递归实现    核心思路：使用一个栈。每次先访问节点本身，再依次压入右、左子节点（注意顺序，先右后左），这样弹栈时总是优先处理左子树，实现“中-左-右”顺序    时间复杂度：O(n)，每个节点进栈出栈各一次    空间复杂度：O(h)，h为树的高度    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []        stack.append(head)        while stack:            head = stack.pop()        # 弹出栈顶节点            print(head.val, end=&quot; &quot;)  # 立即打印（先序特点）            # 关键：先压右子节点，再压左子节点            # 这样弹栈时就是先处理左子树，再处理右子树            if head.right is not None:                stack.append(head.right)            if head.left is not None:                stack.append(head.left)        print()\n\n执行过程示例以树 1(2(4,5),3(6,7)) 为例：\n\n\n\n步骤\n栈状态\n弹出节点\n打印\n压入节点\n\n\n\n初始\n[1]\n-\n-\n-\n\n\n1\n[3,2]\n1\n1\n3,2\n\n\n2\n[3,5,4]\n2\n2\n5,4\n\n\n3\n[3,5]\n4\n4\n-\n\n\n4\n[3]\n5\n5\n-\n\n\n5\n[7,6]\n3\n3\n7,6\n\n\n6\n[7]\n6\n6\n-\n\n\n7\n[]\n7\n7\n-\n\n\n输出结果：1 2 4 5 3 6 7\n中序遍历的非递归实现实现原理中序遍历要求”左-根-右”的访问顺序。需要先沿着左子树走到底，将路径上的所有节点压栈，然后开始弹栈处理节点，并转向右子树。\n@staticmethoddef inOrder(head):    &quot;&quot;&quot;    中序遍历非递归实现    核心思路：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []        while stack or head is not None:            if head is not None:                # 当前节点不为空，压栈并继续向左                stack.append(head)                head = head.left            else:                # 当前节点为空，说明左子树遍历完毕                head = stack.pop()        # 弹出栈顶节点                print(head.val, end=&quot; &quot;)  # 打印节点值（中序特点）                head = head.right         # 转向右子树        print()\n\n算法状态分析中序遍历的非递归实现有两种状态：\n\n下降状态：head != None，沿左子树向下走并压栈\n上升状态：head == None，弹栈处理节点并转向右子树\n\n\n执行过程示例以树 1(2(4,5),3(6,7)) 为例：\n\n\n\n步骤\nhead\n栈状态\n操作\n打印\n\n\n\n初始\n1\n[]\n-\n-\n\n\n1\n2\n[1]\n压栈1，左移\n-\n\n\n2\n4\n[1,2]\n压栈2，左移\n-\n\n\n3\nNone\n[1,2,4]\n压栈4，左移\n-\n\n\n4\n4\n[1,2]\n弹栈4\n4\n\n\n5\nNone\n[1,2]\n4右移(None)\n-\n\n\n6\n2\n[1]\n弹栈2\n2\n\n\n7\n5\n[1]\n2右移到5\n-\n\n\n8\nNone\n[1,5]\n压栈5，左移\n-\n\n\n…\n…\n…\n…\n…\n\n\n输出结果：4 2 5 1 6 3 7\n后序遍历的非递归实现后序遍历是最复杂的，因为需要确保在访问根节点之前，左右子树都已经被完全访问。提供两种实现方法：\n方法一：使用两个栈@staticmethoddef posOrderTwoStacks(head):    &quot;&quot;&quot;    后序遍历非递归实现 - 双栈法    核心思路：第一个栈实现&quot;中-右-左&quot;遍历，结果压入第二个栈    最后弹出第二个栈得到&quot;左-右-中&quot;的后序遍历结果    即：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []      # 主栈：用于遍历        collect = []    # 收集栈：用于收集结果        stack.append(head)                while stack:            head = stack.pop()            collect.append(head)      # 收集节点到第二个栈            # 注意：这里先压左子节点，再压右子节点            # 这样遍历顺序就是&quot;中-右-左&quot;            if head.left is not None:                stack.append(head.left)            if head.right is not None:                stack.append(head.right)                # 反向弹出收集栈，得到&quot;左-右-中&quot;顺序        while collect:            print(collect.pop().val, end=&quot; &quot;)        print()\n\n双栈法原理解析\n第一阶段：用第一个栈实现”中-右-左”遍历，类似先序遍历但左右子节点入栈顺序相反\n第二阶段：将第一阶段的结果压入第二个栈\n第三阶段：弹出第二个栈，得到”左-右-中”的后序遍历结果\n\n关键洞察：”中-右-左”的逆序正好是”左-右-中”\n方法二：使用一个栈@staticmethoddef posOrderOneStack(h):    &quot;&quot;&quot;    后序遍历非递归实现 - 单栈法    核心思路：通过记录最近访问的节点，确保每个节点在其左右子树都被访问后才访问自己，从而严格实现“左-右-中”的后序遍历。    每个节点最多入栈两次，效率更高    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if h is not None:        stack = []        stack.append(h)        # h的含义：最近一次处理（打印）的节点                while stack:            cur = stack[-1]  # 查看栈顶元素但不弹出                        # 情况1：有左子树且左子树未被处理过            if cur.left is not None and h != cur.left and h != cur.right:                stack.append(cur.left)            # 情况2：有右子树且右子树未被处理过            elif cur.right is not None and h != cur.right:                stack.append(cur.right)            # 情况3：左右子树都没有或都已处理完毕            else:                print(cur.val, end=&quot; &quot;)                h = stack.pop()  # 更新h为刚刚处理的节点        print()\n\n单栈法状态管理核心变量h的含义变化：\n\n初始时：h指向根节点（但实际表示”还没有处理过任何节点”）\n处理过程中：h始终指向最近一次处理（打印）的节点\n判断逻辑：通过比较当前节点的子节点与h的关系，判断子树是否已被处理\n\n三种处理情况：\n\n有左子树且未处理：cur.left != None and h != cur.left and h != cur.right\n有右子树且未处理：cur.right != None and h != cur.right\n可以处理当前节点：左右子树都不存在或都已处理完毕\n\n复杂度分析对比时间复杂度所有非递归遍历算法的时间复杂度都是 O(n)：\n\n先序和中序：每个节点进栈出栈各一次\n后序双栈法：每个节点进栈出栈总共两次（每个栈一次）\n后序单栈法：每个节点最多进栈两次，出栈一次\n\n空间复杂度额外空间复杂度对比：\n\n\n\n实现方法\n空间复杂度\n说明\n\n\n\n先序非递归\nO(h)\n一个栈，最大深度为树高\n\n\n中序非递归\nO(h)\n一个栈，最大深度为树高\n\n\n后序双栈法\nO(n)\n收集栈最坏情况存储所有节点\n\n\n后序单栈法\nO(h)\n一个栈，最大深度为树高\n\n\n递归实现\nO(h)\n系统调用栈，深度为树高\n\n\n其中h为树的高度：\n\n最好情况：h &#x3D; O(log n)（平衡树）\n最坏情况：h &#x3D; O(n)（退化为链表）\n\n实现方法选择建议性能对比\n\n\n方法\n时间复杂度\n空间复杂度\n实现难度\n推荐场景\n\n\n\n先序非递归\nO(n)\nO(h)\n简单\n通用推荐\n\n\n中序非递归\nO(n)\nO(h)\n中等\nBST相关问题\n\n\n后序双栈法\nO(n)\nO(n)\n简单\n理解后序遍历逻辑\n\n\n后序单栈法\nO(n)\nO(h)\n困难\n空间要求严格的场景\n\n\n选择建议\n实际应用：根据具体需求选择，一般情况下递归实现更简洁\n性能要求高：选择非递归实现，避免函数调用开销\n内存受限：后序遍历优选单栈法，其他遍历方式空间复杂度相当\n\n非递归实现的优势\n避免栈溢出：可以处理任意深度的树\n更好控制：可以方便地暂停、恢复遍历过程\n性能优化：减少函数调用开销\n状态保存：便于在遍历过程中保存额外信息\n\n非递归实现虽然代码复杂度较高，但在处理大规模数据或有特殊要求的场景中具有重要意义。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","节点遍历","二叉树","递归","迭代"]},{"title":"数据结构与算法自学笔记（5）- 算法笔试中处理输入和输出","url":"/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%20%20/","content":"引言参照左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series是class019的内容，本笔记重点介绍Python在算法竞赛和笔试中的高效输入输出处理技巧，包含子矩阵最大累加和问题的完整实现，以及与Java的性能对比分析。\n019【必备】算法笔试中处理输入和输出概述在算法竞赛和大厂笔试中，输入输出的处理效率往往是程序性能的关键瓶颈。Python虽然在执行速度上不如C++和Java，但通过合理的IO优化技巧，同样可以在大多数场景下取得良好的性能表现。\nPython vs Java IO性能对比\n\n\n特性\nPython\nJava\n\n\n\n默认IO\ninput()、print() 较慢\nScanner、System.out 较慢\n\n\n高效IO\nsys.stdin.read()、批量输出\nBufferedReader、PrintWriter\n\n\n内存管理\n自动垃圾回收，相对简单\n需要考虑静态空间分配\n\n\n大整数\n原生支持任意精度\n需要BigInteger类\n\n\n编程复杂度\n语法简洁，容易上手\n类型安全，但代码较长\n\n\nPython编程风格选择填函数风格（OJ平台推荐）适用于LeetCode、牛客网等在线判题平台，平台会自动处理输入输出。\nclass Solution:    def sumOfSubMatrix(self, mat, n):        &quot;&quot;&quot;        只需实现核心算法逻辑        平台自动调用并验证结果        &quot;&quot;&quot;        return self.maxSumSubmatrix(mat, n, n)        def maxSumSubmatrix(self, mat, rows, cols):        max_sum = float(&#x27;-inf&#x27;)        for i in range(rows):            arr = [0] * cols  # 辅助数组            for j in range(i, rows):                for k in range(cols):                    arr[k] += mat[j][k]                max_sum = max(max_sum, self.maxSumSubarray(arr))        return max_sum        def maxSumSubarray(self, arr):        max_sum = float(&#x27;-inf&#x27;)        cur = 0        for num in arr:            cur += num            max_sum = max(max_sum, cur)            cur = max(cur, 0)  # 负数时重置为0        return max_sum\n\nACM风格（竞赛笔试推荐）适用于ACM竞赛、大厂笔试等需要自己处理输入输出的场景。\nimport sysdef main():    &quot;&quot;&quot;    完整的输入输出处理    需要自己解析数据格式    &quot;&quot;&quot;    lines = sys.stdin.read().split()    ptr = 0    output = []        while ptr &lt; len(lines):        n = int(lines[ptr])        ptr += 1        m = int(lines[ptr])        ptr += 1                # 构建矩阵        mat = []        for i in range(n):            row = []            for j in range(m):                row.append(int(lines[ptr]))                ptr += 1            mat.append(row)                # 计算结果        result = maxSumSubmatrix(mat, n, m)        output.append(str(result))        # 批量输出    print(&#x27;\\n&#x27;.join(output))if __name__ == &#x27;__main__&#x27;:    main()\n\n高效输入输出技巧输入优化策略推荐：一次性读取大数据import sys# 最高效：适用于已知数据量的场景lines = sys.stdin.read().split()ptr = 0# 逐个解析数据while ptr &lt; len(lines):    n = int(lines[ptr])    ptr += 1    # 处理数据...\n\n优点：\n\nIO次数最少，效率最高\n相当于Java的BufferedReader一次性读取\n适合大数据量场景\n\n可选：按行读取# 适用：需要按行处理不同格式数据for line in sys.stdin:    parts = line.strip().split()    total = sum(int(num) for num in parts)    print(total)\n\n适用场景：\n\n每行数据格式不同\n无法提前确定数据量\n相当于Java的逐行readLine()\n\n不推荐：频繁调用input()# 效率低：类似Java的Scannern = int(input())  # 大数据时很慢for i in range(n):    x = int(input())  # 每次都要系统调用\n\n输出优化策略推荐：批量输出# 收集所有结果，最后一次性输出output = []for i in range(n):    result = solve(data[i])    output.append(str(result))print(&#x27;\\n&#x27;.join(output))  # 一次性输出\n\n不推荐：频繁print()# 每次print都会刷新缓冲区，效率低for i in range(n):    print(solve(data[i]))  # 大数据时很慢\n\n内存优化：静态空间vs动态空间推荐：静态空间分配# 全局预分配，避免频繁内存分配MAXN = 201MAXM = 201mat = [[0] * MAXM for _ in range(MAXN)]  # 静态矩阵arr = [0] * MAXM  # 静态辅助数组def solve():    global n, m    # 复用已分配的空间    for i in range(n):        for j in range(m):            mat[i][j] = read_next_int()        # 使用前先清空    for i in range(m):        arr[i] = 0\n\n不推荐：频繁动态分配def solve():    # 每次都重新分配内存    mat = []  # 动态创建    for i in range(n):        row = []  # 每行都新建        for j in range(m):            row.append(read_next_int())        mat.append(row)\n\n子矩阵最大累加和问题详解问题描述与算法思路问题：给定包含正数、负数、零的矩阵，求累加和最大的子矩阵。\n核心思想：将二维问题转化为一维最大子数组和问题\n\n枚举子矩阵的上下边界（第i行到第j行）\n将每列在这个范围内的元素累加，得到一维数组\n对一维数组使用Kadane算法求最大子数组和\n\n完整实现（填函数风格）class Code01_FillFunction:    def sumOfSubMatrix(self, mat, n):        &quot;&quot;&quot;主方法，求n×n矩阵的最大子矩阵和&quot;&quot;&quot;        return self.maxSumSubmatrix(mat, n, n)    @staticmethod    def maxSumSubmatrix(mat, n, m):        &quot;&quot;&quot;求子矩阵的最大累加和&quot;&quot;&quot;        max_sum = float(&#x27;-inf&#x27;)                # 枚举上边界        for i in range(n):            arr = [0] * m  # 辅助数组，每次重置                        # 枚举下边界（从i到n-1）            for j in range(i, n):                # 将第j行累加到辅助数组                for k in range(m):                    arr[k] += mat[j][k]                                # 求当前辅助数组的最大子数组和                max_sum = max(max_sum, Code01_FillFunction.maxSumSubarray(arr, m))                return max_sum    @staticmethod    def maxSumSubarray(arr, m):        &quot;&quot;&quot;Kadane算法求最大子数组和&quot;&quot;&quot;        max_sum = float(&#x27;-inf&#x27;)        cur = 0                for i in range(m):            cur += arr[i]            max_sum = max(max_sum, cur)            cur = 0 if cur &lt; 0 else cur  # 负数时重置                return max_sum\n\n算法复杂度：\n\n时间复杂度：O(n² × m)\n空间复杂度：O(m)\n\nACM风格实现（静态空间优化）import sys# 静态空间分配，避免频繁内存分配MAXN = 201MAXM = 201mat = [[0] * MAXM for _ in range(MAXN)]arr = [0] * MAXMn = m = 0def main():    global n, m    tokens = sys.stdin.read().split()    idx = 0    output = []        while idx &lt; len(tokens):        n = int(tokens[idx])        idx += 1        m = int(tokens[idx])        idx += 1                # 读取矩阵数据到静态空间        for i in range(n):            for j in range(m):                mat[i][j] = int(tokens[idx])                idx += 1                # 计算结果并收集输出        output.append(str(maxSumSubmatrix()))        # 批量输出所有结果    print(&#x27;\\n&#x27;.join(output))def maxSumSubmatrix():    &quot;&quot;&quot;使用静态空间的子矩阵最大和算法&quot;&quot;&quot;    max_sum = float(&#x27;-inf&#x27;)        for i in range(n):        # 清空辅助数组（复用静态空间）        for x in range(m):            arr[x] = 0                    for j in range(i, n):            # 累加第j行到辅助数组            for k in range(m):                arr[k] += mat[j][k]            max_sum = max(max_sum, maxSumSubarray())        return max_sumdef maxSumSubarray():    &quot;&quot;&quot;一维最大子数组和&quot;&quot;&quot;    max_sum = float(&#x27;-inf&#x27;)    cur = 0        for i in range(m):        cur += arr[i]        max_sum = max(max_sum, cur)        cur = 0 if cur &lt; 0 else cur        return max_sumif __name__ == &#x27;__main__&#x27;:    main()\n\n执行过程示例以矩阵为例：\n[[-90, 48, 78], [ 64,-40, 64],  [-81, -7, 66]]\n\n枚举过程：\n\ni&#x3D;0, j&#x3D;0（第0行）：arr&#x3D;[-90, 48, 78] → 最大子数组和&#x3D;126\ni&#x3D;0, j&#x3D;1（第0-1行）：arr&#x3D;[-26, 8, 142] → 最大子数组和&#x3D;150  \ni&#x3D;0, j&#x3D;2（第0-2行）：arr&#x3D;[-107, 1, 208] → 最大子数组和&#x3D;209\ni&#x3D;1, j&#x3D;1（第1行）：arr&#x3D;[64, -40, 64] → 最大子数组和&#x3D;88\ni&#x3D;1, j&#x3D;2（第1-2行）：arr&#x3D;[-17, -47, 130] → 最大子数组和&#x3D;130\ni&#x3D;2, j&#x3D;2（第2行）：arr&#x3D;[-81, -7, 66] → 最大子数组和&#x3D;66\n\n最终结果：209（来自第0-2行，第2-2列的子矩阵）\nPython高级IO优化FastReader快读类FastReader 是一个极致追求输入速度的工具，适用于数据量极大的算法竞赛场景。\n主要作用\n\n极速读取输入，尤其是大量数字（如百万级数据）。\n通过**一次性读取大块数据（8KB）**到内存，减少系统I&#x2F;O调用次数。\n按字节处理并手动解析数字，比标准 input() 或 sys.stdin.readline() 更快。\n\n工作原理\n\n缓冲区：用 self.buffer 存储从输入流一次性读取的大块数据。\n按字节解析：用 readByte 方法逐字节读取，跳过非数字字符，自己实现整数解析（包括负数）。\n高效：只处理数字和符号，省略 split、strip 等高层方法，极致优化输入。\n\n典型用法适合极端大数据输入、对时间卡得很紧的OJ平台。\nimport sysclass FastReader:    def __init__(self, file=sys.stdin):        self.file = file        self.buffer = &quot;&quot;        self.idx = 0    def _read(self):        &quot;&quot;&quot;一次性读取8KB数据到缓冲区&quot;&quot;&quot;        self.buffer = self.file.read(8192)        self.idx = 0    def readByte(self):        &quot;&quot;&quot;读取下一个字节&quot;&quot;&quot;        if self.idx &gt;= len(self.buffer):            self._read()            if self.buffer == &quot;&quot;:                return -1        byte = self.buffer[self.idx]        self.idx += 1        return ord(byte)    def readInt(self):        &quot;&quot;&quot;快速读取整数&quot;&quot;&quot;        num = 0        minus = False        b = self.readByte()                # 跳过非数字字符        while b != -1 and (b &lt; ord(&#x27;0&#x27;) or b &gt; ord(&#x27;9&#x27;)) and b != ord(&#x27;-&#x27;):            b = self.readByte()                    if b == ord(&#x27;-&#x27;):            minus = True            b = self.readByte()                    # 读取数字        while b != -1 and (ord(&#x27;0&#x27;) &lt;= b &lt;= ord(&#x27;9&#x27;)):            num = num * 10 + (b - ord(&#x27;0&#x27;))            b = self.readByte()                    return -num if minus else num    def readLong(self):        &quot;&quot;&quot;读取长整数（Python中与int相同）&quot;&quot;&quot;        return self.readInt()\n\nFastWriter快写类FastWriter 是一个高效输出工具，适用于需要频繁输出、输出量大的场合。\n主要作用\n\n减少输出次数：把所有输出内容先缓存在内存里，最后统一输出，减少系统调用。\n链式调用和兼容Java风格，用起来很方便。\n\n工作原理\n\n缓冲区：所有待输出内容先存入 self.buffer 列表。\n批量输出：调用 flush() 时，一次性将所有内容写入输出流。\n兼容性：支持 write（写字符串）、writeln&#x2F;println（写一行），用法灵活。\n\n典型用法\n适合数据量大、频繁输出的算法题&#x2F;竞赛场景，防止 print() 太慢导致超时。\nimport sysclass FastWriter:    def __init__(self, file=sys.stdout):        self.file = file        self.buffer = []    def write(self, s):        &quot;&quot;&quot;写入字符串到缓冲区&quot;&quot;&quot;        self.buffer.append(str(s))        return self  # 支持链式调用    def writeln(self, s=&quot;&quot;):        &quot;&quot;&quot;写入一行&quot;&quot;&quot;        self.buffer.append(str(s) + &quot;\\n&quot;)        return self    def println(self, s=&quot;&quot;):        &quot;&quot;&quot;兼容Java习惯的方法名&quot;&quot;&quot;        return self.writeln(s)    def flush(self):        &quot;&quot;&quot;刷新缓冲区，实际写入文件&quot;&quot;&quot;        if self.buffer:            self.file.write(&quot;&quot;.join(self.buffer))            self.file.flush()            self.buffer = []    def close(self):        &quot;&quot;&quot;关闭写入器&quot;&quot;&quot;        self.flush()        if self.file != sys.stdout:            self.file.close()\n\nKattio类（Python版）Kattio 类是一个高效的输入输出（I&#x2F;O）工具类，最初流行于 Java 的竞赛编程圈。它的 Python 版本（如你上面给出的代码）主要是用来简化和加快处理标准输入输出，尤其适合数据量较大、输入格式“特殊”或需要频繁读取单个数据的场景，比如各类算法竞赛、OJ（Online Judge）平台等。\n主要作用\n\n高效读取输入：普通的 input() 在数据量大时会变慢，Kattio 通过缓冲和一次性读取一行数据，提升了读取效率。\n简化输入格式处理：常见的输入格式如多行多列、混合类型（int、float、str）都能方便读取，不用每次都写 split、map 一大堆。\n输出简便：带有封装的 println 方法，输出不再需要手动 print(…, file&#x3D;…)。\n\n工作原理\n\n维护一个缓冲区（self.buffer），每次读取一整行并分割成单词。\n提供 next() 方法按顺序读取下一个字符串，nextInt() 读取下一个整数，nextDouble() 读取下一个浮点数等。\n适配输入和输出流（默认为标准输入输出，但也可以重定向到文件），并提供 close 方法在需要时关闭流。\n\n参考Java版Kattio的Python实现，处理特殊输入格式：\nimport sysfrom typing import Optionalclass Kattio:    &quot;&quot;&quot;    高效IO类，适用于特殊格式输入    效率略低于FastReader，但兼容性更好    &quot;&quot;&quot;    def __init__(self, input_stream=sys.stdin, output_stream=sys.stdout):        self.input = input_stream        self.output = output_stream        self.buffer = []        self.idx = 0    def _fill_buffer(self):        &quot;&quot;&quot;填充缓冲区&quot;&quot;&quot;        line = self.input.readline()        if line == &#x27;&#x27;:            return        self.buffer = line.strip().split()        self.idx = 0    def next(self) -&gt; Optional[str]:        &quot;&quot;&quot;读取下一个字符串&quot;&quot;&quot;        while self.idx &gt;= len(self.buffer):            self._fill_buffer()            if not self.buffer:                return None        result = self.buffer[self.idx]        self.idx += 1        return result    def nextInt(self) -&gt; int:        &quot;&quot;&quot;读取下一个整数&quot;&quot;&quot;        return int(self.next())    def nextLong(self) -&gt; int:        &quot;&quot;&quot;读取下一个长整数&quot;&quot;&quot;        return int(self.next())    def nextDouble(self) -&gt; float:        &quot;&quot;&quot;读取下一个浮点数&quot;&quot;&quot;        return float(self.next())    def println(self, s):        &quot;&quot;&quot;输出一行&quot;&quot;&quot;        print(s, file=self.output)    def close(self):        &quot;&quot;&quot;关闭IO流&quot;&quot;&quot;        if self.input != sys.stdin:            self.input.close()        if self.output != sys.stdout:            self.output.close()\n\nPython常用数据结构快速参考基础容器操作from collections import deque, defaultdictimport bisect# 列表（动态数组）arr = [1, 2, 3]arr.append(4)              # O(1) 尾部添加arr.insert(0, 0)           # O(n) 头部插入arr.pop()                  # O(1) 尾部删除arr.pop(0)                 # O(n) 头部删除print(arr[1])              # O(1) 随机访问# 双端队列（可当栈或队列）dq = deque()dq.append(1)               # 队尾入队dq.appendleft(2)           # 队首入队dq.pop()                   # 队尾出队dq.popleft()               # 队首出队# 集合操作s1 = &#123;1, 2, 3&#125;s2 = &#123;2, 3, 4&#125;print(s1 | s2)             # 并集print(s1 &amp; s2)             # 交集print(s1 - s2)             # 差集# 字典操作d = defaultdict(int)       # 默认值为0d[&quot;key&quot;] += 1              # 自动初始化并自增\n\n排序与查找# 排序arr = [3, 1, 4, 1, 5]arr.sort()                           # 原地升序排序arr.sort(reverse=True)               # 原地降序排序sorted_arr = sorted(arr)             # 返回新的排序数组custom_sorted = sorted(arr, key=lambda x: -x)  # 自定义排序# 二分查找arr = [1, 2, 4, 7, 9]  # 必须有序idx = bisect.bisect_left(arr, 4)     # 查找插入位置idx = bisect.bisect_right(arr, 4)    # 查找插入位置（右侧）\n\n大整数与高精度# Python原生支持任意精度整数big_num = 10**100                    # 10的100次方result = big_num * big_num           # 自动处理大整数运算# 高精度除法import decimaldecimal.getcontext().prec = 50       # 设置精度a = decimal.Decimal(&#x27;1&#x27;) / decimal.Decimal(&#x27;3&#x27;)\n\n实战技巧与注意事项性能优化技巧# 1. 避免在循环中重复计算# 错误写法for i in range(n):    for j in range(len(arr)):  # 每次都计算len(arr)        pass# 正确写法  arr_len = len(arr)for i in range(n):    for j in range(arr_len):        pass# 2. 使用局部变量访问全局数据# 错误写法def process():    for i in range(n):        result += global_data[i]  # 每次都查找全局变量# 正确写法def process():    local_data = global_data  # 本地化全局变量    for i in range(n):        result += local_data[i]# 3. 字符串拼接优化# 错误写法s = &quot;&quot;for i in range(n):    s += str(i)  # 每次都创建新字符串# 正确写法parts = []for i in range(n):    parts.append(str(i))s = &quot;&quot;.join(parts)\n\n常见陷阱与解决方案# 1. 递归深度限制import syssys.setrecursionlimit(10000)  # 设置递归深度限制# 2. 浮点数精度问题import mathdef is_equal(a, b, eps=1e-9):    return abs(a - b) &lt; eps# 3. 列表初始化陷阱# 错误：所有行共享同一个列表matrix = [[0] * m] * n# 正确：每行都是独立的列表matrix = [[0] * m for _ in range(n)]# 4. 字典默认值from collections import defaultdict# 使用defaultdict避免KeyErrorcount = defaultdict(int)count[key] += 1  # 自动初始化为0\n\n调试技巧# 条件编译式调试DEBUG = Falsedef debug_print(*args):    if DEBUG:        print(&quot;DEBUG:&quot;, *args)# 输入输出重定向（本地测试）import sysif DEBUG:    sys.stdin = open(&#x27;input.txt&#x27;, &#x27;r&#x27;)    sys.stdout = open(&#x27;output.txt&#x27;, &#x27;w&#x27;)# 计时器import timestart_time = time.time()# ... 算法代码 ...print(f&quot;执行时间: &#123;time.time() - start_time:.3f&#125;秒&quot;)\n\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","输入输出(IO)","高效编程","子矩阵问题"]},{"title":"25 Spring - 模式识别笔记(3)","url":"/2025/06/16/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲前三个part，符号源于课程讲义，整理了关于K-means 聚类及其变分表达、熵正则与空间正则的相关笔记。用markdown在网页上做笔记还是太费劲了，回归latex！\nPDF file","categories":["Notes","Course"],"tags":["模式识别","熵正则","空间正则","K-Means聚类","变分法"]},{"title":"25 Spring - 模式识别笔记(1)","url":"/2025/03/07/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/","content":"引言Word2Vec Embedding 技术Word2Vec 是一种用于将单词映射到向量空间的技术，通过训练语料库来学习单词的语义关系。核心思想是将单词转换为一个高维向量，使得语义相近的单词在向量空间中距离较近。\nWord2Vec 过程\n输入文本（例如：”我”、”是”、”中国”、”人民”）\n嵌入层（Embedding）：将单词转换为向量表示\n训练：使用 Skip-gram 或 CBOW 模型进行训练\n输出向量：得到语义空间中的词向量表示\n\n在黑板上的示例中，展示了单词如何通过 Word2Vec 进行向量化，并且最终映射到一个 n 维向量空间中。\n\nK-Means 聚类算法K-Means 是一种常见的无监督学习算法，主要用于数据聚类。其基本思想是：\n\n给定样本集合 $S$，包含样本 $S_1, S_2, \\dots, S_k$。\n设定 $k$ 个聚类中心 $C_1, C_2, \\dots, C_k$。\n将样本 $f$ 分配给最近的聚类中心 $C_k$。\n\n数学定义定义样本 $f$ 归属于最接近的簇：\n$$U_k^* &#x3D;\\begin{cases}1, &amp; f \\in S_k \\0, &amp; \\text{otherwise}\\end{cases}$$\n其中，样本 $f$ 的归属取决于其与聚类中心 $C_k$ 的欧式距离：\n$$| f - C_k |^2$$\n因此，每个样本都会归属于离它最近的簇。\nK-Means 迭代步骤\n随机初始化 $k$ 个聚类中心 $C_1, C_2, \\dots, C_k$。\n计算每个样本到聚类中心的距离，并将其分配到最近的簇。\n更新聚类中心，使其成为簇中所有样本的平均值。\n重复步骤 2 和 3，直到聚类中心不再发生变化或达到迭代次数上限。\n\n\n总结\nWord2Vec 将单词映射到向量空间，使语义相似的单词在向量空间中更接近。  \nK-Means 通过反复迭代，将数据点划分到不同的簇中进行聚类分析。\n\n这两者结合在自然语言处理 (NLP) 中可用于 文本分类、聚类分析 等任务。例如，先用 Word2Vec 将文本转换为向量，然后使用 K-Means 进行文本聚类。\nkmeans算法的定义独热编码（One-Hot Encoding）在 K-Means 聚类算法中，我们使用独热编码（One-Hot Encoding）来表示样本所属的类别：\n\n若样本 $f$ 属于第 $k$ 个簇，则其独热编码表示为\n$$\\mathbf{U}^* &#x3D; (0, 0, \\dots, 1, \\dots, 0)$$\n其中只有第 $k$ 维的值为 1，其余维度为 0。\n\n例如：\n\n若 $f \\in S_1$：$$\\mathbf{U}^* &#x3D; (1, 0, 0, \\dots, 0)$$\n若 $f \\in S_k$：$$\\mathbf{U}^* &#x3D; (0, 0, \\dots, 1, \\dots, 0)$$\n\n\n\n\nK-Means 目标函数在 K-Means 算法中，我们的目标是最小化样本点到其分配的聚类中心的距离平方和：\n$$\\mathbf{U}^* &#x3D; \\arg\\min_{\\mathbf{U} \\in \\mathcal{U}} \\sum_{k&#x3D;1}^{K}U_k (f - C_k)^2$$\n其中：\n\n$\\mathcal{U}$ 是所有可能的独热编码集合：\n\n  \n  $$\\mathcal{U} = \\left\\{ \\mathbf{u} = (U_1, U_2, \\dots, U_K) \\,\\middle|\\, \\sum_{k=1}^{K} U_k = 1, \\quad 0 \\leq U_k \\leq 1 \\right\\}$$\n\n  表示每个样本点只能属于一个簇。\n\n定理及其证明定理（Thm）对于任意样本 $f$ 和聚类中心 $C_1, C_2, \\dots, C_K$，定义：\n\n$$\nU_k^* =\n\\begin{cases} \n1, & k = \\arg\\min\\limits_{R=1,2,\\dots,K} (f - C_R)^2 \\\\\n0, & \\text{else}\n\\end{cases}\n$$\n\n\n即，样本 $f$ 应该被分配到使得 $(f - C_k)^2$（最小值唯一） 最小的簇 $C_k$。\n证明（Proof）\n定义\n$$m &#x3D; \\min_{k \\in {1,2,\\dots,K}} {(f - C_k)^2}$$\n由于 $U_k$ 是独热编码，所有可能的 $U_k$ 满足\n$$\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$$\n\n目标函数展开：\n$$\\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \\geq\\ \\sum_{k&#x3D;1}^{K} U_k \\cdot m$$\n由于 $\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1,$ 代入可得：\n$$\\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \\geq m$$\n\n取 $U_k^*$ 使得 $k$ 取最小距离的索引，则：\n$$\\sum_{k&#x3D;1}^{K} U_k^* (f - C_k)^2 &#x3D; m.$$\n这说明只有当 $U_k^$ 取最优独热编码时，目标函数才能取到最小值 $m$ ，从而证明了 $U_k^$ 具有唯一最优解。\n\n\n\n结论\n独热编码 用于表示样本所属的类别，每个样本只能属于一个簇。  \n目标函数 通过最小化样本到其最近聚类中心的距离平方和，确定最优分类。  \n定理证明 说明了最佳分配方案是将样本分配到使得 $(f - C_k)^2$ 最小的簇。\n\n这一定理是 K-Means 算法的核心之一，保证了算法在每一步迭代中都能使目标函数收敛到一个局部最优解。\n–\n连续情况下的 K-Means 聚类定义在离散情况下，我们用有限个样本点 $f$ 进行聚类，而在连续情况下，需要对整个定义域 $\\Omega$ 进行考虑。\n目标函数扩展到连续情况\n设函数 $f: \\Omega \\to \\mathbb{R}$，其中 $\\Omega$ 是定义域，$f(x)$ 是定义在 $\\Omega$ 上的连续函数。  \n\n目标是在整个 $\\Omega$ 上最小化聚类误差：\n$$\\min_{\\mathbf{U}(x) \\in \\mathcal{U}} \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} U_k(x) (f(x) - C_k)^2$$\n其中：\n\n$C_1, C_2, \\dots, C_K$ 为 $K$ 个聚类中心。  \n$U_k(x)$ 表示位置 $x$ 归属于第 $k$ 个聚类中心的程度。\n\n\n\n\n约束条件为了保证每个点 $x$ 仅归属于一个聚类簇，引入约束：\n\n$$\n\\mathcal{U} = \\left\\{ \\mathbf{U}(x) = (U_1(x), U_2(x), \\dots, U_K(x)) \\,\\middle|\\, \\sum_{k=1}^{K} U_k(x) = 1, \\quad 0 \\leq U_k(x) \\leq 1, \\quad \\forall x \\in \\Omega \\right\\}\n$$\n\n\n\n这意味着：\n\n每个 $x$ 只能属于一个簇（即某个 $U_k(x)$ 取 1，其余取 0）。\n$U_k(x)$ 的取值范围在 $[0,1]$ 之间。\n\n\n直观解释从黑板上的示意图可以看出：\n\n$x \\in \\Omega$ 表示数据点在连续空间中的分布。\n$f(x)$ 代表数据点的特征值。\n目标是将这些数据点划分到不同的簇 $C_1, C_2, \\dots, C_K$ 中，使得同一簇中的点具有较小的方差。\n\n\n结论\n在连续情况下，K-Means 的目标函数和约束条件从离散样本点扩展到了整个定义域 $\\Omega$。  \n目标仍然是最小化数据点到聚类中心的平方误差。  \n约束条件确保每个点 $x$ 只能归属于一个簇。  \n这种扩展形式在实际应用中可用于处理连续空间中的数据，如图像分割或概率密度估计。\n\n\nK-Means 迭代优化过程K-Means 算法的目标是最小化聚类误差 $E(\\mathbf{U}, \\mathbf{C})$，即样本点到其聚类中心的平方误差和。它采用 迭代优化 的方式，在每次迭代中交替更新 簇分配 和 聚类中心，直到收敛。\n定义\n聚类中心向量：\n$$\\mathbf{C} &#x3D; (C_1, C_2, \\dots, C_K)^T.$$\n\nK-Means 的优化目标：\n$$\\min_{\\mathbf{U} \\in \\mathcal{U}, \\mathbf{C}} E(\\mathbf{U}, \\mathbf{C}).$$\n\n\nStep 1：更新簇分配 $\\mathbf{U}$$$\\mathbf{U}^{t+1} &#x3D; \\arg\\min_{\\mathbf{U} \\in \\mathcal{U}} E(\\mathbf{U}, \\mathbf{C}^t).$$\n其中，$U_k^{t+1}(x)$ 按照最近邻准则更新：\n\n$$\nU_k^{t+1}(x) =\n\\begin{cases}\n1, & k = \\arg\\min\\limits_{\\,k' \\in \\{1,2,\\dots,K\\}} \\bigl(f(x) - C_{k'}^t\\bigr)^2 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n\n\n即，将样本 $x$ 归到当前最近的聚类中心 $C_k^t$。\nStep 2：更新聚类中心 $\\mathbf{C}$$$\\mathbf{C}^{t+1} &#x3D; \\arg\\min_{\\mathbf{C}} E(\\mathbf{U}^{t+1}, \\mathbf{C}).$$\n聚类中心的更新公式：\n$$C_k &#x3D; \\frac{\\sum\\limits_{x \\in \\Omega} U_k^{t+1}(x) , f(x)}{|\\Omega_k|},$$\n其中：\n\n$\\Omega_k$ 是当前属于第 $k$ 个簇的所有样本点集合。\n上式表示：新的聚类中心是该簇内所有样本的加权平均值。\n也可以把$\\Omega_k$替换成$\\sum_{x \\in \\Omega} U_k^{t+1} (x) :&#x3D; \\Omega^{t+1}_{k}$\n\n总结\nStep 1：更新簇分配，使得每个点归属于与其最近的聚类中心。  \nStep 2：更新聚类中心，使其为簇内所有点的均值。  \n这两步交替进行，直到聚类中心不再变化，算法收敛。\n\n\n目标函数关于聚类中心的推导以下演示 Step 2（更新聚类中心）中，如何对目标函数关于聚类中心 $C_k$ 求导并得到更新公式。为简化，只对离散情形展示，连续情形可将求和替换为积分，思路相同。\n目标函数拆分K-Means 的目标函数（离散情形）：\n$$E(\\mathbf{U}, \\mathbf{C})&#x3D; \\sum_{k&#x3D;1}^{K} \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n我们先单独关注属于簇 $k$ 的部分：\n$$E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n在更新 $C_k$ 时，$U_k(x)$ 固定，只需对 $C_k$ 进行最优化。\n对 $C_k$ 求偏导令\n$$E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n对 $C_k$ 求导并令其为 0：\n$$\\frac{\\partial}{\\partial C_k} E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} 2 U_k(x)  \\bigl(C_k - f(x)\\bigr).$$\n令其为 0，可得：\n$$\\sum_{x \\in \\Omega} U_k(x)\\bigl(C_k - f(x)\\bigr) &#x3D; 0$$\n解方程，得到更新公式整理可得：\n$$C_k \\sum_{x \\in \\Omega} U_k(x)&#x3D; \\sum_{x \\in \\Omega} U_k(x)f(x)$$\n若分母不为 0（该簇有样本），则\n$$C_k &#x3D; \\frac{\\sum\\limits_{x \\in \\Omega} U_k(x) f(x)}{\\sum\\limits_{x \\in \\Omega} U_k(x)}$$\n这就是 K-Means 中聚类中心的更新公式。在常见的离散数据立场下，上式意味着“该簇内所有样本特征的加权平均值”，权值由 $U_k(x)$ 决定。若 $U_k(x)$ 只取 0 或 1（硬划分），则退化为简单的算术平均。\n\n注：\n\n在连续情况下，将“求和”换为对 $\\Omega$ 的积分即可：\n$$C_k &#x3D; \\frac{\\int_{\\Omega} U_k(x)f(x)\\mathrm{d}x}{\\int_{\\Omega} U_k(x)\\mathrm{d}x}$$\n\n当 $U_k(x)$ 只取 0 或 1，即标准 K-Means，公式变为簇内样本的算术平均。\n\n\n\n\nK-Means 能量单调下降（不增）性以下笔记基于课堂板书，展示 K-Means 迭代过程中目标函数（也称“能量”或“误差”）如何在每一步都单调下降（或不增），从而收敛到局部最优解。\n引理 &#x2F; 定理描述\n定理：由 K-Means 算法产生的迭代序列 $(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)})$ 满足\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr),$$\n即每次迭代更新后，目标函数 $E(\\cdot)$ 不会增大，从而保证了算法的单调收敛性。\n\n目标函数回顾离散情形下的 K-Means 目标函数：\n$$E\\bigl(\\mathbf{u}, \\mathbf{c}\\bigr)&#x3D; \\sum_{k&#x3D;1}^{K} \\sum_{x \\in \\Omega}U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n迭代过程（两步更新）\nStep 1：更新 $\\mathbf{u}^{(t+1)}$固定 $\\mathbf{c}^{(t)}$，令\n$$\\mathbf{u}^{(t+1)}&#x3D; \\arg\\min_{\\mathbf{u} \\in \\mathcal{U}}  E\\bigl(\\mathbf{u}, \\mathbf{c}^{(t)}\\bigr)$$\n由于独热编码的性质，每个样本 $x$ 归于距离最近的中心 $C_k^{(t)}$。这样得到\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr)$$\n\nStep 2：更新 $\\mathbf{c}^{(t+1)}$固定 $\\mathbf{u}^{(t+1)}$，令\n$$\\mathbf{c}^{(t+1)}&#x3D; \\arg\\min_{\\mathbf{c}}  E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}\\bigr).$$\n对每个 $C_k$ 求导并令其为 0，得到聚类中心是该簇内样本的加权平均。于是\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t)}\\bigr)$$\n\n\n能量严格下降的证明思路上两步结合，可得：\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr)$$\n这说明每一轮迭代后，目标函数都会朝着不增的方向变化，从而收敛到某个局部最优或鞍点。\n结论\nK-Means 通过交替最小化簇分配 $\\mathbf{u}$ 和聚类中心 $\\mathbf{c}$，使目标函数在每次迭代中不增。  \n因此，算法单调地收敛到一个局部最优解（或鞍点）。\n\n这便是 K-Means 能量单调下降 的主要证明思路，也是该算法能保证在有限步内收敛的关键原因。\n","categories":["Notes","Course"],"tags":["机器学习","模式识别","K-Means聚类"]},{"title":"25 Spring - 模式识别笔记(4)","url":"/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲第四个和第五个part，符号源于课程讲义，整理了关于混合模型分类（GMM），EM算法及其变分表示以及MM算法的相关笔记。\nPDF file","categories":["Notes","Course"],"tags":["模式识别","变分法","GMM算法","MM算法"]},{"title":"25 Spring - 模式识别笔记(2)","url":"/2025/05/10/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/","content":"模式识别笔记汇总本次笔记主要关于K-Means 及其变分问题、熵不等式、Softmax&#x2F;Softmin 函数、数值稳定化、以及泛函与方向导数等内容。\n\nK-Means 基本原理与能量函数K-Means 能量函数的定义K-Means 算法的能量函数（目标函数）定义如下：\n$$E(\\vec{U}, \\vec{C})&#x3D; \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} \\bigl(f(x) - C_k\\bigr)^2  U_k(x)$$\n其中：\n\n$ f(x) $ 表示数据点 $ x $ 的特征值；\n$ C_k $ 表示第 $ k $ 个聚类中心；\n$ U_k(x) $ 为归属矩阵的元素，表示数据点 $ x $ 是否属于第 $ k $ 个簇（在硬分类中，取值为 0 或 1）。\n\n然后定义\n$$\\langle \\overrightarrow{O}, \\overrightarrow{u} \\rangle &#x3D; \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} O_k(x) \\cdot u_k(x)$$\n其中误差函数为：\n$$O_k(x) &#x3D; \\bigl(f(x) - C_k\\bigr)^2$$\n该能量函数也可用内积的形式表示：\n$$E(\\vec{U}, \\vec{C}) &#x3D; \\langle \\vec{O}, \\vec{U} \\rangle$$\n其中 $\\vec{O}$ 为一个误差向量。\n\nK-Means 算法的迭代更新规则K-Means 算法通过两步交替迭代来最小化能量函数 $E(\\vec{U}, \\vec{C})$：\n\n更新归属矩阵 $\\vec{U}^{t+1}$：\n$$\\vec{U}^{t+1} &#x3D; \\arg \\min_{\\vec{U}}  E(\\vec{U}, \\vec{C}^t)$$\n具体到每个样本点 $x$ 的更新规则为：\n  \n   $$\n   U_k^{t+1}(x)= \n   \\begin{cases}\n   1, & \\text{if} k = \\arg \\min_{k \\in \\{1, \\dots, K\\}} (f(x) - C_k^t)^2 \\\\\n   0, & \\text{otherwise}\n   \\end{cases}\n   $$\n     \n\n即将每个数据点分配给距离其最近的簇中心。\n\n更新聚类中心 $\\vec{C}^{t+1}$：\n$$\\vec{C}^{t+1} &#x3D; \\arg \\min_{\\vec{C}}  E\\bigl(\\vec{U}^{t+1}, \\vec{C}\\bigr)$$\n即对每个簇的样本求均值，作为新的聚类中心。\n\n\n\n误差函数与误差向量定义误差函数：\n$$O_k(x) &#x3D; \\bigl(f(x) - C_k\\bigr)^2$$\n令\n$$\\vec{O}(x) &#x3D; \\bigl(O_1(x), O_2(x), \\dots, O_K(x)\\bigr)^\\mathsf{T},$$\n则 $\\vec{O}$ 是一个向量值函数，映射\n$$\\vec{O}: \\Omega \\subseteq \\mathbb{R}^2 \\to \\mathbb{R}^K.$$\n\n备注\nK-Means 采用硬聚类方式，每个数据点只能属于一个簇，$U_k(x) \\in {0,1}$。\n优化目标：在每次迭代中，先更新 $\\vec{U}$，再更新 $\\vec{C}$，直至收敛。\n计算复杂度：主要与数据点数 $N$ 和簇数 $K$ 有关，通常为 $O(NKT)$（$T$ 为迭代次数）。\n\n\nK-Means 的变分问题与熵的性质K-Means 变分问题我们希望最小化下述能量函数：\n$$\\min_{\\vec{U}, \\vec{C}} E(\\vec{U}, \\vec{C})$$\n其中 $\\vec{U}$ 为归属矩阵，$\\vec{C}$ 为聚类中心。\n除硬划分之外，还可使用许多优化或正则化技巧，例如引入软分类思想（softmax &#x2F; softmin）的方法。\n\n熵的性质在分析 K-Means 变分问题时，引入熵的一条不等式，用于约束归属矩阵的对数项：\n$$-\\ln K\\le \\langle \\vec{U}, \\ln \\vec{U} \\rangle\\le 0$$\n其中：\n\n$U_k$ 表示数据点对第 $k$ 个簇的归属概率（软分类时可在 $[0,1]$ 之间）；\n$\\langle \\vec{U}, \\ln \\vec{U}\\rangle &#x3D; \\sum_{k&#x3D;1}^{K} U_k \\ln U_k$ 是熵相关的项。\n\n该不等式可以用 Jensen 不等式等方法证明。等号成立的两种情况为：\n\n左边等号：所有 $U_k &#x3D; \\frac{1}{K}$，即均匀分布；\n右边等号：某一个 $U_k&#x3D;1$，其它为 0，即完全硬分类。\n\n\n变分方法的直观解释\n最优化角度：寻找最优的 $\\vec{U}, \\vec{C}$ 使得数据点与簇中心的总体误差最小；\n信息论角度：考虑信息熵约束，避免过度偏向某一簇，从而获得更合理的簇划分。\n\n\n备注\n熵的约束：对归属矩阵 $ \\vec{U} $ 提供了额外的正则约束。\n与 EM（期望最大化）算法中的软聚类思想存在对应关系。\n\n\n熵不等式的证明这里给出熵不等式：\n$$-\\ln K\\leq \\langle \\vec{U}, \\ln \\vec{U} \\rangle\\leq 0$$\n的推导思路详述如下：\n证明 $f(u)&#x3D;-\\ln u$ 是凸函数：函数 $f(u) &#x3D; -\\ln u$ 的一阶导数和二阶导数分别为：\n$$f’(u) &#x3D; -\\frac{1}{u},\\quadf’’(u) &#x3D; \\frac{1}{u^2} &gt; 0 \\quad (u&gt;0)$$\n由于 $f’’(u) &gt; 0$，可知 $f(u)$ 是凸函数。\n计算极限 $\\lim\\limits_{u\\to0^+} u \\ln u$：令 $g(u) &#x3D; -u \\ln u$，求其极限：\n$$\\lim_{u\\to0^+} u \\ln u &#x3D; \\lim_{u\\to0^+} \\frac{\\ln u}{1&#x2F;u}$$\n利用洛必达法则，分子求导得$1&#x2F;u$，分母求导得 $-1&#x2F;u^2$，因此：\n$$\\lim_{u\\to0^+} \\frac{\\ln u}{1&#x2F;u} &#x3D; \\lim_{u\\to0^+} \\frac{1&#x2F;u}{-1&#x2F;u^2} &#x3D; \\lim_{u\\to0^+} -u &#x3D; 0$$\n所以：\n$$\\lim_{u\\to0^+} u \\ln u &#x3D; 0.$$\n这表明当 $u \\to 0$ 时，$u \\ln u$ 趋于 0。\n用 Jensen 不等式推导熵不等式：由于 $f(x)&#x3D;-\\ln x$ 是凸函数，因此对于满足 $\\sum_{k&#x3D;1}^{K} \\alpha_k &#x3D; 1$ 且 $ 0 \\leq \\alpha_k \\leq 1$ 的权重  $\\alpha_{k} $ ，有：\n$$\\left( \\sum_{k&#x3D;1}^{K} \\alpha_k x_k \\right) \\leq \\sum_{k&#x3D;1}^{K} \\alpha_k f(x_k)$$\n取 $\\alpha_k &#x3D; U_k$，$x_k &#x3D; \\frac{1}{U_k}$，则：\n$$-ln \\left( \\sum_{k&#x3D;1}^{K} U_k \\cdot \\frac{1}{U_k} \\right) \\leq \\sum_{k&#x3D;1}^{K} U_k (-\\ln \\frac{1}{U_k})$$\n由于 $\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$，所以：\n$$-ln K \\leq \\sum_{k&#x3D;1}^{K} U_k \\ln U_k \\leq 0$$\n即\n$$ln K \\geq -\\langle \\vec{U}, \\ln \\vec{U} \\rangle$$\n等号成立的条件：\n左边等号成立条件：当所有 $U_k$ 相等，即 $U_k &#x3D; 1&#x2F;K$ 时，左侧等号成立。\n右边等号成立条件：当仅有一个 $U_k&#x3D;1$，其余 $U_k&#x3D;0$ 时，右侧等号成立。\n\n熵不等式在 K-Means 变分问题中的作用：该不等式用于限制聚类的过度集中，即防止所有数据点都归属于同一簇。同时，它也鼓励一定程度的分散度，使簇划分更加均匀，从而优化聚类效果。\n\nK-Means 的变分问题扩展在传统 K-Means 的能量函数 $E(\\vec{U}, \\vec{C})$ 基础上，引入一项基于熵的正则化：\n$$\\min_{\\vec{u}\\in U}\\Bigl[E(\\vec{u}, \\vec{C})+\\varepsilon \\langle \\vec{u}, \\ln \\vec{u}\\rangle\\Bigr]$$\n其中 $\\varepsilon &gt; 0$ 为权衡系数（正则化参数）。当 $\\varepsilon \\to 0$ 时，该模型接近传统 K-Means 硬分类；当 $\\varepsilon$ 较大时，模型更倾向于软聚类。\n更新过程：\n\n$\\vec{u}^{t+1} &#x3D; \\arg \\min_{\\vec{u}} \\bigl[E(\\vec{u}, \\vec{C}^t) - \\varepsilon H(\\vec{u})\\bigr]$ (变成了严格凸)\n$\\vec{C}^{t+1} &#x3D; \\arg \\min_{\\vec{C}} \\bigl[E(\\vec{u}^{t+1}, \\vec{C})\\bigr]$  （与传统 K-Means 相同）\n\n这里的熵项\n$$H(\\vec{u})&#x3D; - \\sum_{k&#x3D;1}^{K} \\sum_{x\\in \\Omega} u_k(x)\\ln u_k(x)$$\n作为“软化”或正则化手段，避免完全的 0-1 硬分类。\n偏导数计算熵项 $H(\\vec{u})$ 可重写为\n$$ -H(\\vec{u}) &#x3D; \\langle \\vec{u}, \\ln \\vec{u} \\rangle.$$\n对于目标函数 $E(\\vec{u}, \\vec{C}) - \\varepsilon H(\\vec{u})$，计算其关于 $u_k$ 的偏导数：\n\n设 $E(\\vec{u}, \\vec{C})$ 关于 $u_k$ 的偏导数为：\n$$\\frac{\\delta E}{\\delta u_k} &#x3D; O_k$$\n\n对于熵项：\n$$\\frac{\\delta (-H)}{\\delta u_k} &#x3D; \\ln u_k + 1$$\n\n结合上述结果，求解极值条件：\n$$O_k - \\varepsilon (\\ln u_k + 1) &#x3D; 0$$\n\n化简得：\n$$u_k &#x3D; \\exp\\left(-\\frac{O_k}{\\varepsilon} - 1\\right)$$\n\n\n这表明更新 $u_k$ 时，其值受 $\\varepsilon$ 控制，较大的 $\\varepsilon$ 使得 $u_k$ 更加平滑，有助于软聚类。\n\n拉格朗日函数与 Softmax 分析拉格朗日函数定义拉格朗日函数：\n$$\\mathcal{L}(\\vec{u}, \\lambda)&#x3D; E(\\vec{u}, \\vec{c})-\\varepsilon H(\\vec{u})+\\sum_{x \\in \\Omega} \\lambda(x)\\Bigl(\\sum_{k&#x3D;1}^{K} u_k(x)-1\\Bigr)$$\n其中：\n\n$H(\\vec{u})$ 是熵项；\n$\\lambda(x)$ 为拉格朗日乘子，用于保证 $\\sum_{k&#x3D;1}^{K} u_k(x)&#x3D;1$。\n\n软分类 (Softmin &#x2F; Softmax) 的推导对 $\\mathcal{L}(\\vec{u}, \\lambda)$ 关于 $u_k$ 取偏导为 0，可得到：\n$$\\ln u_k(x)&#x3D; -\\frac{O_k(x) +\\lambda(x)}{\\varepsilon}$$\n其中 $O_k$ 是某类损失（例如 $(f(x)-C_k)^2$ ）或能量。\n结合约束 $\\sum_{k&#x3D;1}^K u_k(x)&#x3D;1$，可得Softmin形式：\n$$u_k^{t+1}(x)&#x3D; \\frac{\\exp\\Bigl(\\dfrac{-O_k(x)}{\\varepsilon}\\Bigr)}{\\sum_{j&#x3D;1}^{K} \\exp\\Bigl(\\dfrac{-O_j(x)}{\\varepsilon}\\Bigr)}$$\n也可写成softmax形式：\n  \n$$\n\\text{Softmax}_{\\varepsilon}(-\\vec{O}) =\n\\left[\\text{Softmin}_{\\varepsilon}(\\vec{O})\\right]_k\n$$\n  \n\n\n极限问题与分母拆分k-means 硬分类更新公式当不考虑熵正则化时，k-means 的硬分类可写为：\n$$u_k^{t+1}(x) &#x3D;\\begin{cases}    1, &amp; \\text{if } k &#x3D; \\arg \\min_{k \\in {1, \\dots, K}} O_k, \\    0, &amp; \\text{otherwise}.\\end{cases}$$\nSoftmin 的极限考虑\n\n$$\n\\lim_{\\varepsilon \\to 0^+}\n\\frac{\\exp\\bigl(-O_k(x)/\\varepsilon\\bigr)}{\\sum_{j=1}^K \\exp\\bigl(-O_j(x)/\\varepsilon\\bigr)}\n=\\lim_{\\varepsilon \\to 0^+}\\frac{\\exp\\bigl(-O_k(x)+m(x)/\\varepsilon\\bigr)}{\\sum_{j\\in M} \\exp\\bigl(-O_j(x)+m(x)/\\varepsilon\\bigr)+\\sum_{j\\notin M} \\exp\\bigl(-O_j(x)+m(x)/\\varepsilon\\bigr)}\n$$\n\n\n令 $m = \\min \\bigl\\{ O_1(x), O_2(x), \\dots, O_K(x) \\bigr\\}, \\quad M = \\arg\\min_{k \\in \\bigl\\{ 1, \\dots, K \\bigr\\}} O_k(x)$。当 $\\varepsilon \\to 0^+$，对于属于最优集 $M$ 的索引 $k$，$\\exp(-O_k&#x2F;\\varepsilon)$ 主导；而不是最优集的 $\\exp(-O_k&#x2F;\\varepsilon)$ 迅速衰减为 0。因此极限结果为：\n\n$$\n\\lim_{\\varepsilon \\to 0^+}\n\\text{Softmin}_{\\varepsilon}(\\vec{O})\n=\n\\begin{cases}\n1, & \\text{if } k \\in M \\\\\n0, & \\text{if } k \\notin M\n\\end{cases}\n\\quad \\text{where } M = \\left\\{ k \\mid O_k = \\min_j O_j \\right\\}\n$$\n\n\n这与 k-means 硬分类（一次只属于距离最近的簇）相一致。称   $\\min_{\\vec{u}\\in U，\\vec{C}}\\Bigl[E(\\vec{u}, \\vec{C})-\\varepsilon H(u)\\Bigr]$   为softmin&#x2F;softmax的分类的变分优化问题k-means 的光滑化与 Softmax 溢出问题k-means 的光滑化通过在 k-means 能量函数中加入熵项并令 $\\varepsilon&gt;0$，可以将硬分类变为软分类，使其输出变得连续可导。\n\n当 $\\varepsilon \\to 0$，Softmin 退化为 k-means 硬分类；\n当 $\\varepsilon$ 较大时，软分类更加显著。\n\nSoftmax 的数值溢出问题Softmax 标准形式：\n  \n$$\n\\text{Softmax}\\bigl(\\vec{O}\\bigr)_k\n=\n\\frac{e^{O_k}}{\\sum_{j=1}^K e^{O_j}}.\n$$\n  \n\n若 $O_k$ 值过大，$e^{O_k}$ 可能数值溢出。\n解决方案：数值稳定化取   $\\displaystyle M = \\max\\{O_1, O_2, \\dots, O_K\\}$  ，将所有项减去 $M$：\n  \n$$\n\\text{Softmax}(\\vec{O})_k\n=\n\\frac{e^{O_k - M}}{\\sum_{j=1}^K e^{O_j - M}}\n$$\n\n\n这样可防止溢出，保持结果不变。\n\n泛函分析与方向导数泛函与方向导数基本概念在更高层次，令\n  \n$$\nJ: \\mathcal{F} \\to \\mathbb{R}\n$$\n  \n\n是作用于函数空间 $\\mathcal{F}$ 的一个泛函（functional）。对于 $u(x)$ 的变化，可以定义方向导数：\n  \n$$\n\\lim_{h \\to 0}\n\\frac{J\\bigl(x + hv\\bigr) - J(x)}{h}\n=\n\\left.\n\\frac{d}{dh} \nJ\\bigl(x + hv\\bigr)\n\\right|_{h=0}\n$$\n  \n\n方向导数与梯度存在对应关系：若把 $\\nabla J&#x3D;(\\tfrac{\\delta J}{\\delta x_1}，\\tfrac{\\delta J}{\\delta x_2} \\cdot \\cdot \\cdot \\tfrac{\\delta J}{\\delta x_n})$ 类比于有限维中的梯度，则方向导数可理解为梯度在 $v$ 方向的投影。\n\n方向导数与梯度的关系对 $J(U_k)$ 做微分：\n  \n$$\n\\langle \\tfrac{\\delta J}{\\delta U_k},  V_k \\rangle\n=\n\\left.\n\\tfrac{d}{dh}\nJ\\bigl(U_k + hV_k\\bigr)\n\\right|_{h=0}.\n$$\n  \n\n例如，若\n  \n$$\nJ(U_k)\n=\n\\sum_{x\\in \\Omega}\nO_k(x)\\ln U_k(x),\n$$\n  \n\n则\n  \n$$\nJ(U_k + hV_k)\n=\n\\sum_{x\\in \\Omega}\nO_k(x)\\ln\\bigl(U_k(x) + hV_k(x)\\bigr)\n$$\n  \n\n对其在 $h&#x3D;0$ 处求导，可得到对应的偏导，从而确定梯度形式。\n\n九、总结与要点\nK-Means 算法\n\n能量函数：数据点到簇中心的平方误差和；\n经典迭代：硬分类与均值更新交替进行。\n\n\nK-Means 的变分扩展\n\n通过引入熵（软分类），可得到 Softmin &#x2F; Softmax 形式；\n当正则系数 $\\varepsilon \\to 0$ 时，又可退化到原始硬划分结果。\n\n\n熵不等式与数值稳定\n\n熵提供了在聚类中的分布约束；\nSoftmax 需用数值移位避免溢出。\n\n\n泛函与方向导数\n\n在更高阶场景中，可将 K-Means 问题放到泛函分析框架下；\n方向导数、梯度概念可帮助理解对函数空间的优化。\n\n\n\n","categories":["Notes","Course"],"tags":["模式识别","K-Means聚类","变分法","熵不等式"]},{"title":"25 Spring - 模式识别笔记(5)","url":"/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲最后一个part，符号源于课程讲义，整理了关于MLP及其网络训练、反向传播算法的相关笔记。\nPDF file","categories":["Notes","Course"],"tags":["模式识别","神经网络","MLP","反向传播算法"]}]