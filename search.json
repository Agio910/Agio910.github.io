[{"title":"24 Spring - 概率论课程判断题留档","url":"/2025/07/30/24%E7%A7%8B-%E6%A6%82%E7%8E%87%E8%AE%BA%E5%88%A4%E6%96%AD%E9%A2%98%E7%95%99%E6%A1%A3/","content":"  longlongago之前的概率论判断题作业，记录一下\nPDF file","categories":["Coursework"],"tags":["概率论","样本空间","随机变量","数字特征"]},{"title":"25 Fall - 哲学导论课程论文","url":"/2025/02/13/25%E7%A7%8B-%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BA%E6%96%87%E7%95%99%E6%A1%A3/","content":"  第一次有课程拿100分，留档记录一下课程论文，内容主要和确定性理论比较相关，以及对极端怀疑论的反驳。\nPDF file","categories":["Coursework"],"tags":["philosophy","确定性理论","维特根斯坦","怀疑论"]},{"title":"Longitudinal associations between family conflict and depression among family members：Evidence from CFPS, 2016-2020.","url":"/2025/02/25/Longitudinal%20associations%20between%20family%20conflict,%20intergenerational%20transmission,%20and%20adolescents%E2%80%99%20depressive%20symptoms%20evidence%20from%20China%20Family%20Panel%20studies/","content":"  I am honored to be the co-first author of this paper, and my main for data processing, data analysis, visualization, and paper writing.  Based on the 2016-2020 China Family Tracking Survey (CFPS) data, the study analyzed 1,772 adolescents and their parents over a four-year period, and for the first time systematically revealed the bidirectional mechanism of family conflict and adolescent depressive symptoms and the intergenerational transmission pathway. The study found that: （1） family conflict significantly exacerbates adolescent depression, and adolescent depression will in turn aggravate family conflict, forming a vicious cycle; （2） mothers’ depression has a particularly prominent impact on adolescent mental health, and adolescent depression may further trigger fathers’ depression; （3） mothers’ education level is an important protective factor against adolescent depression, and mothers with high levels of education can significantly reduce the risk of their children’s depression. risk. These findings provide key scientific support for the development of family-centered mental health intervention strategies, which are important for breaking the intergenerational transmission of depression and improving family functioning.\nPDF file","categories":["Publication"],"tags":["mental health","structural equation modeling","longitudinal study"]},{"title":"The Applications of Large Language Models in Mental Health Scoping Review.","url":"/2025/05/10/The%20Applications%20of%20Large%20Language%20Models%20in%20Mental%20Health%20Scoping%20Review/","content":"  I am honored to be the co-first author of this paper, and my main contrbution are data extraction and visualization.  Based on the 2019-2024 scoping review of 95 peer-reviewed articles, this study mapped the landscape of large language models (LLMs) applications in mental health across three key domains. The analysis revealed that LLMs are predominantly utilized for screening and detection of mental disorders (71%), with particular emphasis on depression detection (35%) and suicide risk prediction (13%). Additionally, LLMs demonstrate significant potential in supporting clinical treatments (33%) and facilitating mental health counseling and education (12%). Comparative assessments indicate that LLMs exhibit superior capabilities in information processing and natural language response generation relative to traditional non-transformer models and human performance in specific contexts. The research identified distinct advantages among different LLM architectures for various mental health applications, highlighting their promising role in addressing critical challenges in global mental healthcare, including detection efficiency, treatment effectiveness, privacy protection, and access to specialized care. These findings provide essential scientific evidence for the development and implementation of LLM-enhanced mental health interventions, which may significantly improve early detection rates and expand access to mental healthcare resources.\nPDF file","categories":["Publication"],"tags":["mental health","large language models","application","comparison"]},{"title":"Academic Paper learning & Translation Records","url":"/2025/08/04/Academic%20Paper%20learning%20&%20Translation%20Records/","content":"引言本文档用于记录自己读过的学术论文和亲自翻译的论文内容。每篇论文包含简要说明和个人理解，部分论文附有飞书文档或doi链接\n\n翻译论文记录P´olya’s Random Walk Theorem当时是为了随机过程的pre，然后翻译并推了一遍polya随机游走定理，记录一下。\n原文标题：P´olya’s Random Walk Theorem作者：Jonathan Novak出处：The American Mathematical Monthly, 2014•Taylor &amp; Francisdoi号：点此查看全文飞书链接：点此查看翻译版\nMDS&#x2F;TSNE&#x2F;UMAPlonglongago之前把生物信息里比较常用的三种降维算法都学和推了一遍，分别是MDS（multidimensional scaling）多维尺度分析、t-SNE（t-distributed Stochastic Neighbor Embedding）和UMAP（Uniform Manifold Approximation and Projection），记录一下翻译版。\n飞书链接：点此查看整合的笔记\nMDSMultidimensional scaling，简称MDS，中文翻译成多维尺度分析。其原理是利用成对样本间的相似性，去构建合适的低维空间，使得样本在此空间的距离和在高维空间中的样本间的相似性尽可能的保持一致。我们可以用这种方式来可视化数据分布，PCA是MDS中特殊的一种。\n感觉有点像层次分析法，比较早用于心理学&amp;社会科学上的一些相似性分析。以下公式为简单的优化思想，理论上可以从欧式距离推广到各种距离如曼哈顿、马氏等等。\n原始文献有点太古老了，所以看的是csdn上的专栏：https://blog.csdn.net/u010705209/article/details/53518772?utm_source=itdadao&amp;utm_medium=referral\n\nKruskal, J. B. (1964). “Multidimensional Scaling by Optimizing Goodness of Fit to a Nonmetric Hypothesis.” Psychometrika, 29(1), 1-27.\nShepard, R. N. (1962). “The Analysis of Proximities: Multidimensional Scaling with an Unknown Distance Function.” Psychometrika, 27(2), 125-140.\n\nTSNEt-sne感觉是比较fashion的概率方法，很有意思。找了一篇论文https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf\n原文标题：Visualizing Data using t-SNE作者：Laurens van der Maaten， Geoffrey Hinton出处：Journal of Machine Learning Research 9 (2008) 2579-2605doi号：点此查看全文\nUMAPUMAP没有看太懂，主要是我没学过拓扑，但是其中模糊数学的部分很有意思，这篇论文刚刚发预印本的时候模糊数学还挺火的，现在不行了。\n原文标题：Uniform manifold approximation and projection作者：John Healy， Leland McInnes出处：Nature Reviews Methods Primers volume 4, Article number: 82 (2024)doi号：点此查看全文\n注意力机制相关包括注意力机制到transformer的自注意力及其后续的变体，还有ESM3几何注意力机制、rfdiffusion的IGSO3等等。\n注意力机制的发展longlongago之前学深度学习补的：\n飞书链接：点此查看整合的笔记\n几何注意力机制ESM3有用到，ESM3模型处理蛋白质结构信息的两种主要方法：几何注意力（Geometric Attention）和结构标记（Structure Tokens）。\n飞书链接：点此查看整合的笔记\nIGSO3当时看rfdiffusion被吓坏了，这个证明真的很吓人\n飞书链接：点此查看整合的笔记\n倾向性得分在观察性研究中因果效应分析的核心作用文理学院统计系汇报的pre，看完了之后连统计学都不想学了，数学和统计完全是两个学科啊！感觉自己喜欢的是统计计算而不是数理统计和传统的统计inference，润了润了润去计算了\n原文标题：The central role of the propensity score in observational studies for causal effect作者：PAUL R. ROSENBAUM, DONALD B. RUBIN出处：Biometrilca (1083), 70, 1, pp. 41-55doi号：点此查看全文飞书链接：点此查看翻译版\n","categories":["Review","Translation"],"tags":["Paper Reading","Translation","Academic","Learning"]},{"title":"吴恩达机器学习课程资料归档","url":"/2025/08/03/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E4%BB%B6%E7%95%99%E6%A1%A3/","content":"大概是24年暑假期间一周速通学完了吴恩达的机器学习，真真真是深入浅出，言简意赅， 记录一下吴恩达机器学习课程相关的PDF资料、讲义、笔记等，方便日后复习与查阅。\n课程链接吴恩达机器学习（B站全套）\n课堂上的PDF笔记\n\n网盘整体的文件通过网盘分享的文件：A最新版 吴恩达机器学习Deeplearning.ai链接: https://pan.baidu.com/s/1RGHnExutISizVeFNNR4OnQ?pwd=ue7m 提取码: ue7m \n","categories":["Review","Online course"],"tags":["机器学习","吴恩达","Review","监督学习","无监督学习"]},{"title":"数据结构与算法自学笔记（11）- 位图&位运算实现加减乘除","url":"/2025/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89-%20%E4%BD%8D%E5%9B%BE&%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记包括了位图数据结构的原理、实现和应用，以及如何用位运算实现加减乘除（完全不依赖任何算术运算符）。涵盖了class032 and class033的内容\n032【必备】位图前置知识在学习位图之前，需要掌握以下基础知识：\n\n二进制和位运算操作\n对数器的使用方法\n\nPython特别提醒：在实现位运算题目时需要特别注意溢出和符号扩展问题，通常需要手动处理：\n# Python中处理溢出的常见方法result = (n &lt;&lt; shift_amount) &amp; 0xFFFFFFFF\n\n位图的核心概念什么是位图位图（Bitset）是一种极其节省空间的数据结构，用于存储大量布尔值。相比传统哈希表，位图具有显著的空间优势：\n\n哈希表：每存储一个数字需要32个bit的空间\n位图：每存储一个数字只需要1个bit的空间\n\n位图的基本原理位图本质上是用bit组成的数组来存放值，使用bit的状态（1和0）来表示元素的存在性：\n\nbit位为1：表示该数字存在于集合中\nbit位为0：表示该数字不存在于集合中\n\n基本思想：\n用一个很长的二进制位数组，每一位（bit）对应一个整数的&quot;有无&quot;状态第0位代表数字0，第1位代表数字1，第2位代表数字2，依此类推\n\n位图的适用场景优势：\n\n极大节省空间（1个数字仅占1个bit）\n查询和修改操作都是O(1)时间复杂度\n支持高效的批量操作\n\n限制：\n\n必须是连续范围的整数\n范围不能过大（适合0到几百万，不适合到几十亿）\n只能表示元素的存在性，不能存储额外信息\n\n适用场景：\n\n判断大量整数是否存在\n统计范围内数字的出现情况\n实现简单的集合操作\n\n位图的实现\n类设计接口class Bitset:    def __init__(self, n):          # 初始化位图，支持0~n-1所有数字    def add(self, num):             # 把num加入到位图    def remove(self, num):          # 把num从位图中删除    def reverse(self, num):         # 翻转num的状态（存在则删除，不存在则添加）    def contains(self, num):        # 查询num是否在位图中\n\n完整实现代码class Bitset:    def __init__(self, n):        &quot;&quot;&quot;        初始化位图，支持0~n-1范围内的数字        n个数字需要 (n + 31) // 32 个32位整数来存储        &quot;&quot;&quot;        # 计算需要多少个32位整数        # 使用 (n + 31) // 32 实现向上取整        # 例如：32个数字需要1个整数，33个数字需要2个整数        self.set = [0] * ((n + 31) // 32)        def add(self, num):        &quot;&quot;&quot;        将num添加到位图中（将对应位设置为1）        &quot;&quot;&quot;        # num // 32：确定数字在第几个32位整数中        # num % 32：确定在该32位整数中的第几位        # 1 &lt;&lt; (num % 32)：创建掩码，将1左移到对应位置        # |=：按位或赋值，将对应位设置为1        self.set[num // 32] |= 1 &lt;&lt; (num % 32)        def remove(self, num):        &quot;&quot;&quot;        将num从位图中删除（将对应位设置为0）        &quot;&quot;&quot;        # ~(1 &lt;&lt; (num % 32))：创建掩码并取反，除了目标位其他位都是1        # &amp;=：按位与赋值，将对应位清除为0        self.set[num // 32] &amp;= ~(1 &lt;&lt; (num % 32))        def reverse(self, num):        &quot;&quot;&quot;        翻转num在位图中的状态        如果存在则删除，如果不存在则添加        &quot;&quot;&quot;        # ^=：按位异或赋值        # 如果位是0，异或1后变成1        # 如果位是1，异或1后变成0        self.set[num // 32] ^= 1 &lt;&lt; (num % 32)        def contains(self, num):        &quot;&quot;&quot;        判断num是否存在于位图中        &quot;&quot;&quot;        # &gt;&gt; (num % 32)：将目标位移动到最低位        # &amp; 1：提取最低位的值        # == 1：判断是否为1        return ((self.set[num // 32] &gt;&gt; (num % 32)) &amp; 1) == 1\n\n关键实现细节1. 空间分配策略# 向上取整的巧妙实现# 对于n个数字，需要的32位整数个数array_size = (n + 31) // 32# 原理：# - 如果n=32，则(32+31)//32 = 63//32 = 1（正好1个整数）# - 如果n=33，则(33+31)//32 = 64//32 = 2（需要2个整数）\n\n2. 位置计算def get_position(num):    &quot;&quot;&quot;计算数字num在位图中的位置&quot;&quot;&quot;    array_index = num // 32    # 在第几个32位整数中    bit_index = num % 32       # 在该整数的第几位    return array_index, bit_index\n\n3. 位运算技巧总结\n\n\n操作\n位运算实现\n说明\n\n\n\n设置位为1\nx |= (1 &lt;&lt; i)\n按位或运算\n\n\n清除位为0\nx &amp;= ~(1 &lt;&lt; i)\n按位与运算（掩码取反）\n\n\n翻转位\nx ^= (1 &lt;&lt; i)\n按位异或运算\n\n\n检查位\n(x &gt;&gt; i) &amp; 1\n右移后提取最低位\n\n\n对数器测试测试设计思路使用Python内置的set作为参照标准，对位图的所有操作进行验证：\ndef test_bitset():    &quot;&quot;&quot;使用对数器验证位图实现的正确性&quot;&quot;&quot;    n = 1000          # 位图大小    testTimes = 10000 # 测试次数        print(&quot;测试开始&quot;)    bitSet = Bitset(n)      # 被测试的位图结构    hashSet = set()         # 参照标准（Python内置set）        print(&quot;调用阶段开始&quot;)    for _ in range(testTimes):        decide = random.random()                    # 随机决定操作类型        number = int(random.random() * n)          # 随机生成0~n-1的数字                if decide &lt; 0.333:                         # 33%概率执行add操作            bitSet.add(number)            hashSet.add(number)        elif decide &lt; 0.666:                       # 33%概率执行remove操作            bitSet.remove(number)            hashSet.discard(number)                # 使用discard避免KeyError        else:                                      # 34%概率执行reverse操作            bitSet.reverse(number)            if number in hashSet:                hashSet.remove(number)            else:                hashSet.add(number)        print(&quot;调用阶段结束&quot;)    print(&quot;验证阶段开始&quot;)        # 验证所有数字的存在性是否一致    for i in range(n):        if bitSet.contains(i) != (i in hashSet):            print(&quot;出错了!&quot;)            return False        print(&quot;验证阶段结束&quot;)    print(&quot;测试结束&quot;)    return True\n\n测试覆盖的场景\n随机操作序列：大量随机的增删改查操作\n边界条件：0和n-1等边界值\n重复操作：对同一个数字的重复操作\n状态一致性：每次操作后验证状态的一致性\n\n性能分析时间复杂度\n\n\n操作\n时间复杂度\n说明\n\n\n\n初始化\nO(n&#x2F;32)\n需要初始化数组\n\n\nadd\nO(1)\n常数时间位运算\n\n\nremove\nO(1)\n常数时间位运算\n\n\nreverse\nO(1)\n常数时间位运算\n\n\ncontains\nO(1)\n常数时间位运算\n\n\n空间复杂度\n位图空间：O(n&#x2F;32) &#x3D; O(n)\n相比哈希表：空间节省约32倍\n\n实际空间对比# 存储1000万个数字的空间对比numbers = 10_000_000# 哈希表（假设每个数字32位）hash_space = numbers * 32  # 320,000,000 bits# 位图bitset_space = numbers * 1  # 10,000,000 bits# 空间节省比例space_saving = hash_space / bitset_space  # 32倍\n\n应用场景与扩展典型应用场景\n大数据去重：判断海量数据中的重复元素\n布隆过滤器基础：位图是布隆过滤器的核心组件\n状态压缩：在动态规划中压缩状态空间\n集合运算：高效实现并集、交集、差集运算\n\n位图的集合运算def bitset_union(bitset1, bitset2):    &quot;&quot;&quot;位图并集运算&quot;&quot;&quot;    result = Bitset(max(len(bitset1.set), len(bitset2.set)) * 32)    for i in range(min(len(bitset1.set), len(bitset2.set))):        result.set[i] = bitset1.set[i] | bitset2.set[i]    return resultdef bitset_intersection(bitset1, bitset2):    &quot;&quot;&quot;位图交集运算&quot;&quot;&quot;    result = Bitset(max(len(bitset1.set), len(bitset2.set)) * 32)    for i in range(min(len(bitset1.set), len(bitset2.set))):        result.set[i] = bitset1.set[i] &amp; bitset2.set[i]    return result\n\n实际应用示例def find_missing_numbers(arr, n):    &quot;&quot;&quot;找出0到n-1范围内缺失的所有数字&quot;&quot;&quot;    bitset = Bitset(n)        # 标记存在的数字    for num in arr:        if 0 &lt;= num &lt; n:            bitset.add(num)        # 找出缺失的数字    missing = []    for i in range(n):        if not bitset.contains(i):            missing.append(i)        return missing# 示例使用arr = [0, 1, 3, 6, 7, 9]n = 10missing = find_missing_numbers(arr, n)print(f&quot;缺失的数字: &#123;missing&#125;&quot;)  # 输出: [2, 4, 5, 8]\n\n总结位图是一种非常实用的数据结构，特别适合处理大量整数的存在性判断问题。它的核心优势在于：\n\n极致的空间效率：相比传统数据结构节省32倍空间\n优秀的时间性能：所有基本操作都是O(1)时间复杂度\n简单的实现逻辑：基于基础位运算，易于理解和实现\n\n在大数据处理、系统设计等场景中，位图都是一个非常有价值的工具。\n033【必备】位运算实现加减乘除核心思想位运算实现四则运算的核心在于模拟计算机底层的运算逻辑：\n\n加法：基于异或（无进位相加）和与运算（进位处理）\n减法：通过加法和取反实现\n乘法：基于移位和加法的重复运算\n除法：基于减法和移位的优化算法\n\nPython中的特殊处理在实现过程中，需要特别注意Python与Java的差异：\n# Java中的整数范围限制MIN = -2**31      # -2147483648MAX = 2**31 - 1   # 2147483647# Python中需要手动处理32位整数溢出result &amp;= 0xFFFFFFFF  # 保持32位if result &gt; 0x7FFFFFFF:    result = ~(result ^ 0xFFFFFFFF)  # 转换为有符号整数\n\n1. 加法实现（核心基础）算法原理加法的位运算实现基于两个关键概念：\n\n无进位相加：使用异或运算（XOR）\n进位信息：使用与运算（AND）后左移\n\n@staticmethoddef add(a, b):    &quot;&quot;&quot;位运算实现加法&quot;&quot;&quot;    #单次相加的结果为：无进位相加的结果+进位信息    ans = a    while b != 0: # 当b为0时，说明没有进位了，加法结束        # 单次进位只能把当前位的进位信息加到下一高位，但新一位的进位可能和更高位产生新的进位冲突，需要继续处理。        # 只有所有进位都为0，结果才是完整无误的。        # ans : a和b无进位相加的结果        ans = a ^ b        # b : a和b相加时的进位信息        b = (a &amp; b) &lt;&lt; 1        # Python中int无限大，为了模拟int32，需要对超出部分进行处理        # 下面两行确保ans和b都保持32位        ans &amp;= 0xFFFFFFFF        b &amp;= 0xFFFFFFFF        a = ans    # 处理负数转为补码    return ans if ans &lt;= 0x7FFFFFFF else ~(ans ^ 0xFFFFFFFF)  #结果超过最大值时，需要将无符号32位结果转换为有符号，当加法结果超过0x7FFFFFFF时，实际上表示的是负数，需要转换为对应的有符号表示    #将ans与全1进行异或，相当于按位取反，~(...)：再次取反，相当于恢复原值\n\n执行过程示例以 5 + 3 为例：\n第1轮：a=5(101), b=3(011)  无进位：5^3 = 101^011 = 110 = 6  进位：(5&amp;3)&lt;&lt;1 = (001)&lt;&lt;1 = 010 = 2  第2轮：a=6(110), b=2(010)    无进位：6^2 = 110^010 = 100 = 4  进位：(6&amp;2)&lt;&lt;1 = (010)&lt;&lt;1 = 100 = 4  第3轮：a=4(100), b=4(100)  无进位：4^4 = 100^100 = 000 = 0  进位：(4&amp;4)&lt;&lt;1 = (100)&lt;&lt;1 = 1000 = 8  第4轮：a=0(000), b=8(1000)  无进位：0^8 = 1000 = 8  进位：(0&amp;8)&lt;&lt;1 = 0  结果：8\n\n2. 取反运算@staticmethoddef neg(n):    &quot;&quot;&quot;取相反数：~n + 1&quot;&quot;&quot;    return BitOperationAddMinusMultiplyDivide.add(~n, 1)\n\n原理解释基于补码的性质：一个数的相反数等于该数按位取反后加1。\n\n正数：直接按位取反加1\n负数：同样规则，利用补码特性\n\n3. 减法实现@staticmethoddef minus(a, b):    &quot;&quot;&quot;减法就是加上-b&quot;&quot;&quot;    return BitOperationAddMinusMultiplyDivide.add(a, BitOperationAddMinusMultiplyDivide.neg(b))\n\n减法的实现非常简洁：a - b = a + (-b)\n4. 乘法实现（龟速乘）算法原理基于二进制乘法的原理，将乘法转换为多次加法和移位运算：\n@staticmethoddef multiply(a, b):    &quot;&quot;&quot;位运算实现乘法&quot;&quot;&quot;    # 把乘法拆成若干次加法，用位运算（移位）和加法实现，不直接用乘号，适合大数和防溢出场合。    # 二进制的乘法也是像十进制一样，从右到左，一位一位的乘，然后错位相加    ans = 0    # 为了模拟int32，确保a, b, ans都在32位内    a &amp;= 0xFFFFFFFF    b &amp;= 0xFFFFFFFF    while b != 0: #说明乘数没有耗尽，继续乘        if (b &amp; 1) != 0: #说明当前位是1，需要加到结果上            # 考察b当前最右的状态！            ans = BitOperationAddMinusMultiplyDivide.add(ans, a)            ans &amp;= 0xFFFFFFFF  # 保持32位        a = (a &lt;&lt; 1) &amp; 0xFFFFFFFF  # 左移并保持32位        # Java中的 &gt;&gt;&gt; 表示无符号右移，Python没有，需特殊处理        if b &gt;= 0:            b &gt;&gt;= 1        else:            #在Java中，&gt;&gt;&gt; 是无符号右移操作，无论原数是正数还是负数，右移时都在高位补0。但在Python中，&gt;&gt; 是有符号右移，对于负数会补1            #内存中：b + 0x100000000和b的位模式完全相同，这时候又该告诉python该改变语义理解了            b = (b + 0x100000000) &gt;&gt; 1 #0x100000000等于2^32        b &amp;= 0xFFFFFFFF  # 保持32位    # 处理负数转为补码    return ans if ans &lt;= 0x7FFFFFFF else ~(ans ^ 0xFFFFFFFF) # 0xFFFFFFFF是全1，保证结果是32位，    # 如果结果超过0x7FFFFFFF，说明发生了溢出    # 使用~(ans ^ 0xFFFFFFFF)将结果&quot;包装&quot;到32位范围内    # 这样就能得到正确的有符号32位整数结果\n\n执行过程示例以 5 × 3 为例：\n3的二进制：011第1轮：b=011, b&amp;1=1, ans += 5×2^0 = 5第2轮：b=001, b&amp;1=1, ans += 5×2^1 = 5+10 = 15第3轮：b=000, 结束结果：15\n\n应用场景这种”龟速乘”在以下场景特别有用：\n\n大数乘法防溢出\n模运算：(a × b) % m\n快速幂运算的基础\n\n5. 除法实现（最复杂）核心挑战除法是四则运算中最复杂的，需要处理多种边界情况：\n\n除数为0的情况\n整数最小值的特殊处理\n溢出预防\n符号处理\n\n主要函数结构@staticmethoddef divide(a, b):    &quot;&quot;&quot;主除法函数，处理各种边界情况&quot;&quot;&quot;    # 处理 a 和 b 都为最小值的情况    if a == BitOperationAddMinusMultiplyDivide.MIN and b == BitOperationAddMinusMultiplyDivide.MIN:        # a和b都是整数最小        return 1    # 处理 a 和 b 都不是最小值的情况    if a != BitOperationAddMinusMultiplyDivide.MIN and b != BitOperationAddMinusMultiplyDivide.MIN:        # a和b都不是整数最小，那么正常去除        return BitOperationAddMinusMultiplyDivide.div(a, b)    # 处理 b 为最小值的情况    if b == BitOperationAddMinusMultiplyDivide.MIN:         # a不是整数最小，b是整数最小，整数最小值是负数，而且整数最小值无法转成相反数        return 0    # 处理 a 为最小值，b 为 -1 的情况（防止溢出）    # 第1个if不成立：a 和 b 不都是最小值；第2个if不成立：a 和 b 不都不是最小值；第3个if不成立：b 不是最小值，则排除完b，a就是最小值    if b == BitOperationAddMinusMultiplyDivide.neg(1):        # a是整数最小，b是-1，返回整数最大，因为题目里明确这么说了        return BitOperationAddMinusMultiplyDivide.MAX    # a是整数最小，b不是整数最小，b也不是-1    a = BitOperationAddMinusMultiplyDivide.add(a, b if b &gt; 0 else BitOperationAddMinusMultiplyDivide.neg(b)) #让 a 不再是最小值，这样就可以安全地调用 div 函数了，如果 b &gt; 0：a = a + b；如果 b &lt; 0：a = a + (-b)    ans = BitOperationAddMinusMultiplyDivide.div(a, b) # 现在 a 不再是最小值，可以安全地调用 div 函数    offset = BitOperationAddMinusMultiplyDivide.neg(1) if b &gt; 0 else 1 # 如果 b &gt; 0，则 offset = -1；如果 b &lt; 0，则 offset = 1    return BitOperationAddMinusMultiplyDivide.add(ans, offset) # 最后把 offset 加回去\n\n核心除法算法@staticmethoddef div(a, b): #向下取整，但是不返回余数    &quot;&quot;&quot;核心除法实现，要求a和b都不是整数最小值&quot;&quot;&quot;    x = BitOperationAddMinusMultiplyDivide.neg(a) if a &lt; 0 else a  # 取绝对值    y = BitOperationAddMinusMultiplyDivide.neg(b) if b &lt; 0 else b  # 取绝对值    ans = 0    i = 30    while i &gt;= 0:        # (x &gt;&gt; i) &gt;= y 时，说明y &lt;&lt; i 还能减掉        if (x &gt;&gt; i) &gt;= y: #判断x右移i位后是否大于等于y，若大于则记录1            ans |= (1 &lt;&lt; i)  # 记录这个位            x = BitOperationAddMinusMultiplyDivide.minus(x, y &lt;&lt; i)  # x 减去 y &lt;&lt; i，即y*2^i        i = BitOperationAddMinusMultiplyDivide.minus(i, 1)  # 相当于 i--    # 最后根据正负判断符号    return BitOperationAddMinusMultiplyDivide.neg(ans) if (a &lt; 0) ^ (b &lt; 0) else ans #当两个数的符号不同时，结果取负；当符号相同时，结果保持正。\n\n算法原理解析除法算法本质上是二分查找的变种：\n\n从高位到低位：尝试每一位是否能为1\n位移优化：y &lt;&lt; i 相当于 y × 2^i\n贪心策略：能减就减，记录对应的位\n\n执行过程示例以 10 ÷ 3 为例：\nx=10, y=3i=30: (10&gt;&gt;30)=0 &lt; 3, 跳过...i=2: (10&gt;&gt;2)=2 &lt; 3, 跳过  i=1: (10&gt;&gt;1)=5 &gt;= 3, ans|=(1&lt;&lt;1), x=10-6=4i=0: (4&gt;&gt;0)=4 &gt;= 3, ans|=(1&lt;&lt;0), x=4-3=1结果：ans = 11(二进制) = 3(十进制)\n\n边界情况处理整数最小值的特殊性MIN = -2**31  # -2147483648MAX = 2**31 - 1  # 2147483647\n\n整数最小值的特殊性在于它没有对应的正数，因为：\n\n最小值的绝对值是 2^31\n最大正整数只有 2^31 - 1\n\n处理策略\n预处理：将最小值调整为非最小值\n后处理：补偿调整造成的误差\n特殊返回：MIN ÷ (-1) 返回 MAX\n\n完整实现的使用示例# 创建类实例calc = BitOperationAddMinusMultiplyDivide()# 测试各种运算print(calc.add(15, 27))        # 42print(calc.minus(50, 18))      # 32  print(calc.multiply(6, 7))     # 42print(calc.divide(84, 2))      # 42# 测试边界情况print(calc.divide(-2**31, -1)) # 2**31-1 (MAX)print(calc.divide(10, 3))      # 3print(calc.divide(-10, 3))     # -3\n\n时间复杂度分析\n\n\n运算\n时间复杂度\n空间复杂度\n说明\n\n\n\n加法\nO(1)\nO(1)\n最多32次循环\n\n\n减法\nO(1)\nO(1)\n调用加法和取反\n\n\n乘法\nO(1)\nO(1)\n最多32次循环\n\n\n除法\nO(1)\nO(1)\n固定31次循环\n\n\n虽然有循环，但循环次数是固定的（最多32次），所以时间复杂度为常数。\n实际应用场景\n\n底层系统编程在某些嵌入式系统或底层驱动中，可能需要在没有算术运算单元的情况下实现运算。\n\n\n\n大数运算在实现大整数库时，这些技巧是基础构建块。\n\n\n\n密码学应用在某些密码学算法中，需要避免使用标准库的运算函数。\n\n\n\n算法竞赛某些特殊题目可能限制算术运算的使用。\n\n\n\n教学演示帮助理解计算机底层运算原理。\n\n\n\n总结与思考位运算实现四则运算展示了计算机底层运算的本质。虽然在实际开发中很少直接使用，但理解这些原理对于：\n\n加深对计算机原理的理解\n提升位运算技巧  \n应对特殊场景需求\n算法思维的训练\n\n都具有重要意义。特别是除法的实现，体现了二分思想和贪心策略的完美结合，是位运算技巧的集大成者。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","位运算","对数器","贪心算法"]},{"title":"数据结构与算法自学笔记（13）- 数据结构设计高频题","url":"/2025/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记是class035的内容，总结了数据结构设计类题目的高频考点，包含7道经典数据结构设计题目的详细解析。这些题目主要基于哈希表的O(1)操作时间复杂度特性。\n前置知识在学习数据结构设计高频题之前，需要掌握以下基础知识：\n\n动态数组和扩容分析（007讲）\n链表入门内容（009~012讲）\n堆结构（025讲）\n哈希表、有序表、比较器的使用（026讲）\n\n重要说明本节以数据结构设计高频题为主，并不涉及太难的数据结构设计题目，很多题的原理都是基于哈希表的O(1)时间复杂度。数据结构设计的更难题目，需要学习更多数据结构之后才能解决，如前缀树、并查集、线段树等。\n035【必备】数据结构设计高频题题目一：setAll功能的哈希表问题描述哈希表常见的三个操作是put、get和containsKey，而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是把所有记录value都设成统一的值。请设计并实现这种有setAll功能的哈希表，并且put、get、containsKey和setAll四个操作的时间复杂度都为O(1)。\n测试链接：https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967\n核心思想采用”懒更新”(Lazy Update)策略，setAll操作只记录一个全局值和当前时间戳，并不实际修改数据。当get一个键时，通过比较该键自身的时间戳和全局setAll的时间戳，来实时决定返回它自己的值还是全局的值。\n\n算法实现class SetAllHashMap:    def __init__(self):        # 核心数据结构，存储键和它对应的值与时间戳        # 格式为: &#123; key: [value, time] &#125;        self.map = &#123;&#125;        # setAll操作设定的统一值        self.set_all_value = 0        # setAll操作发生的时间戳        self.set_all_time = -1        # 全局时间戳，用于记录每次操作的顺序        self.cnt = 0    def put(self, k, v):        # 核心思想：为每个put操作记录一个独立的时间戳        if k in self.map:            # 如果键已存在，更新其值和时间戳            value = self.map[k]            value[0] = v            value[1] = self.cnt            self.cnt += 1        else:            # 如果键不存在，创建新的条目            self.map[k] = [v, self.cnt]            self.cnt += 1    def set_all(self, v):        # 核心思想：只记录setAll的值和时间戳，不实际遍历map        # 这是一个懒更新策略，只有在get的时候才根据时间戳判断        self.set_all_value = v        self.set_all_time = self.cnt        self.cnt += 1    def get(self, k):        # 核心思想：比较单个key的更新时间和全局setAll的更新时间        if k not in self.map:            return -1                value = self.map[k]        # 如果这个key的最后更新时间晚于setAll的时间，说明它的值是有效的        if value[1] &gt; self.set_all_time:            return value[0]        # 否则，它的值已经被setAll覆盖了，应返回setAll的值        else:            return self.set_all_value\n\n高效读写\ndef main():    # 创建一个SetAllHashMap对象，模拟带有setAll操作的哈希表，模拟牛客网的输入输出处理    solution = SetAllHashMap()    # 读取所有输入行（提高输入效率）    lines = sys.stdin.readlines()    i = 0    while i &lt; len(lines): # 遍历所有行        line = lines[i].strip()        if not line:            # 跳过空行            i += 1            continue        # 读取本组操作数n        n = int(line)        # 每个测试用例开始前重置数据结构        solution.__init__()        # 连续读取n行操作        for j in range(n):            i += 1            # 解析当前操作的所有参数，map是把字符串转换成列表，int指明了列表的元素类型            parts = list(map(int, lines[i].strip().split()))            op = parts[0]            if op == 1:                # op=1，put操作，后面有两个参数a, b                a, b = parts[1], parts[2]                solution.put(a, b)            elif op == 2:                # op=2，get操作，后面一个参数a                a = parts[1]                print(solution.get(a))            else:                # op=3，setAll操作，后面一个参数a                a = parts[1]                solution.set_all(a)        # 处理完一组数据，i+1进入下一组或结束        i += 1if __name__ == &quot;__main__&quot;:    # 在提交时，类名需要改为 Main    main()\n\n算法分析\n时间复杂度：所有操作都是O(1)\n空间复杂度：O(N)，N为键的数量\n核心技巧：时间戳比较 + 懒更新策略\n\n题目二：实现LRU结构问题描述实现 LRUCache 类：\n\nLRUCache(int capacity) 以正整数作为容量capacity初始化LRU缓存\nint get(int key) 如果关键字key存在于缓存中，则返回关键字的值，否则返回-1\nvoid put(int key, int value) 如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字\n\n函数get和put必须以O(1)的平均时间复杂度运行。\n测试链接：https://leetcode.cn/problems/lru-cache/\n核心思想结合了哈希表和双向链表：哈希表提供了对任意键的O(1)快速访问，而双向链表则负责维护数据的访问顺序，使其能在O(1)时间内将最新访问的节点移到队尾，并在容量满时淘汰队首的最久未使用节点。\n\n算法实现class LRUCache:    # 内部类，定义双向链表节点    class DoubleNode:        def __init__(self, key=0, val=0):            self.key = key            self.val = val            self.last = None            self.next = None    # 内部类，实现双向链表，用于维护节点的访问顺序    class DoubleList:        def __init__(self):            # 哨兵节点，简化边界条件处理            self.head = self.DoubleNode() #头节点            self.tail = self.DoubleNode() #尾节点            self.head.next = self.tail #头节点的下一个节点是尾节点            self.tail.last = self.head #尾节点的上一个节点是头节点        # 将一个节点添加到链表尾部（表示最近使用）        def add_node_to_tail(self, node):            node.next = self.tail # 将新节点添加到尾节点的前一个位置            node.last = self.tail.last # 将新节点的上一个节点设置为尾节点的前一个节点            self.tail.last.next = node # 将尾节点的前一个节点的下一个节点设置为新节点            self.tail.last = node # 将尾节点的前一个节点设置为新节点            # 这样设置是为了把尾节点和前一个节点的两条指针变成四条指针        # 将指定节点移动到链表尾部        def move_node_to_tail(self, node):            # 先将节点从原位置断开            node.last.next = node.next            node.next.last = node.last            # 再将节点添加到尾部            self.add_node_to_tail(node)        # 移除链表头部节点（最久未使用的节点）并返回        def remove_head(self):            # 如果链表为空（只有哨兵节点），则无法移除            if self.head.next == self.tail:                return None            node_to_remove = self.head.next            # 从链表中移除            node_to_remove.last.next = node_to_remove.next            node_to_remove.next.last = node_to_remove.last            return node_to_remove    def __init__(self, capacity: int):        # 核心思想：使用哈希表实现O(1)查找，使用双向链表实现O(1)的节点移动（更新访问顺序）        # 哈希表，存储 key -&gt; DoubleNode 的映射        self.key_node_map = &#123;&#125;        # 双向链表实例，维护节点的LRU顺序        self.node_list = self.DoubleList()        # 缓存的容量        self.capacity = capacity    def get(self, key: int) -&gt; int:        # 如果key存在        if key in self.key_node_map:            # 获取节点            node = self.key_node_map[key]            # 将该节点移动到链表尾部，表示最近被访问            self.node_list.move_node_to_tail(node)            return node.val        # 如果key不存在，返回-1        return -1    def put(self, key: int, value: int) -&gt; None:        # 如果key已存在        if key in self.key_node_map:            # 更新节点的值            node = self.key_node_map[key]            node.val = value            # 将该节点移动到链表尾部            self.node_list.move_node_to_tail(node)        else:            # 如果缓存已满            if len(self.key_node_map) == self.capacity:                # 移除链表头部的最久未使用节点，之后会再把新节点添加到尾部                removed_node = self.node_list.remove_head()                # 从哈希表中删除对应的key                del self.key_node_map[removed_node.key]                        # 创建新节点            new_node = self.DoubleNode(key, value)            # 存入哈希表            self.key_node_map[key] = new_node            # 将新节点添加到链表尾部            self.node_list.add_node_to_tail(new_node)\n\n算法分析\n时间复杂度：get和put操作都是O(1)\n空间复杂度：O(capacity)\n核心技巧：哈希表 + 双向链表\n\n题目三：插入、删除和获取随机元素O(1)时间的结构问题描述设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构：\n\ninsert(val)：当元素val不存在时，向集合中插入该项\nremove(val)：元素val存在时，从集合中移除该项\ngetRandom()：随机返回现有集合中的一项\n\n测试链接：https://leetcode.cn/problems/insert-delete-getrandom-o1/\n核心思想结合了动态数组与哈希表，数组负责存储元素以实现O(1)的随机获取，哈希表则存储”值到数组索引”的映射以实现O(1)的查找。其remove操作的精髓在于：将待删除元素与数组的最后一个元素交换，然后直接删除数组末尾。\n\n算法实现import randomclass RandomizedSet:    def __init__(self):        # 核心思想：        # 1. 使用哈希表（字典）存储 值 -&gt; 索引 的映射，实现O(1)的查找。        # 2. 使用动态数组（列表）存储值，实现O(1)的随机访问。        self.map = &#123;&#125;          self.arr = []    def insert(self, val: int) -&gt; bool:        # 如果值已存在，直接返回False        if val in self.map:            return False        # 将值添加到数组末尾        self.arr.append(val)        # 在哈希表中记录新值及其索引,map[val]返回val在数组中的索引        self.map[val] = len(self.arr) - 1        return True    def remove(self, val: int) -&gt; bool:        # 如果值不存在，直接返回False        if val not in self.map:            return False                # 核心步骤：为了实现O(1)删除，将被删除元素与数组末尾元素交换，然后删除末尾元素。        # 获取待删除元素的索引        val_index = self.map[val]        # 获取数组末尾的元素        end_value = self.arr[-1]                # 将末尾元素放到待删除元素的位置        self.arr[val_index] = end_value        # 更新哈希表中末尾元素的索引，只更新索引不更新值        self.map[end_value] = val_index                # 从哈希表中删除目标值        del self.map[val]        # 从数组中删除末尾元素，两者同步更新        self.arr.pop()                return True    def getRandom(self) -&gt; int:        # 利用数组的特性，随机选择一个索引并返回对应的值        return random.choice(self.arr)\n\n算法分析\n时间复杂度：所有操作都是O(1)\n空间复杂度：O(N)\n核心技巧：数组末尾交换删除\n\n题目四：插入、删除和获取随机元素O(1)时间且允许重复数字的结构问题描述设计一个支持在平均时间复杂度O(1)下，执行以下操作的数据结构，且允许有重复数字：\n\ninsert(val)：向集合中插入元素val\nremove(val)：从集合中移除元素val的一个实例\ngetRandom()：随机返回现有集合中的一项\n\n测试链接：https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/\n核心思想与不允许重复的版本类似，但哈希表需要存储一个值所有出现位置的索引集合。\n算法实现import randomfrom collections import defaultdictclass RandomizedCollection:    def __init__(self):        # 核心思想：与不允许重复的版本类似，但哈希表需要存储一个值所有出现位置的索引集合。        # 注意：字典中每个key指向的是不同的集合(set)，而不是同一个数组        # 字典：存储 值 -&gt; 索引集合 的映射        self.map = defaultdict(set)        # 列表：存储所有值        self.arr = []    def insert(self, val: int) -&gt; bool:        # 判断是否是第一次插入该值        is_new = val not in self.map        # 将值添加到数组末尾        self.arr.append(val)        # 在哈希表中记录新值的索引        self.map[val].add(len(self.arr) - 1)        return is_new    def remove(self, val: int) -&gt; bool:        # 如果值不存在，无法删除        if val not in self.map:            return False        # 核心步骤：同样是与末尾元素交换以实现O(1)删除        # 获取待删除值的一个索引        val_index = self.map[val].pop()        # 获取末尾元素的值和索引        end_value = self.arr[-1]        end_index = len(self.arr) - 1        # 如果待删除的元素恰好是末尾元素，则不需要交换        if val_index != end_index:            # 用末尾元素覆盖待删除元素的位置            self.arr[val_index] = end_value            # 更新末尾元素在哈希表中的索引记录            self.map[end_value].remove(end_index)             self.map[end_value].add(val_index)            #这里的 map 是一个存储集合的集合，所以需要通过 map[key] 先获取到集合，然后对集合调用 remove() 和 add() 方法。这是 Python 中嵌套数据结构的常见操作模式。        # 从数组中移除末尾元素        self.arr.pop()                # 如果移除后，某个值的索引集合为空，则从哈希表中彻底删除该值        if not self.map[val]:            del self.map[val]                    return True    def getRandom(self) -&gt; int:        # 随机获取一个元素        return random.choice(self.arr)\n\n算法分析\n时间复杂度：所有操作都是O(1)\n空间复杂度：O(N)\n核心技巧：索引集合管理\n\n题目五：快速获得数据流的中位数的结构问题描述中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。\n例如，[2,3,4]的中位数是3，[2,3]的中位数是(2 + 3) &#x2F; 2 &#x3D; 2.5\n设计一个支持以下两个操作的数据结构：\n\nvoid addNum(int num) - 从数据流中添加一个整数到数据结构中\ndouble findMedian() - 返回目前所有元素的中位数\n\n测试链接：https://leetcode.cn/problems/find-median-from-data-stream/\n核心思想使用两个堆来维护数据流，一个大顶堆和一个小顶堆。大顶堆存储数据流中较小的一半数字，小顶堆存储数据流中较大的一半数字。这样，中位数总是可以通过两个堆的堆顶元素快速得到。\n\n算法实现import heapqclass MedianFinder:    def __init__(self):        # 核心思想：使用两个堆来维护数据流，一个大顶堆和一个小顶堆。        # 大顶堆 (max_heap) 存储数据流中较小的一半数字。        # 小顶堆 (min_heap) 存储数据流中较大的一半数字。        # 这样，中位数总是可以通过两个堆的堆顶元素快速得到。                # Python的heapq是小顶堆，为了实现大顶堆，我们存入元素的相反数。        self.max_heap = []        self.min_heap = []    def addNum(self, num: int) -&gt; None:        # 步骤1: 决定将新元素添加到哪个堆。        # 如果大顶堆为空，或者新元素小于等于大顶堆的堆顶，则放入大顶堆。        # 否则，放入小顶堆。        if not self.max_heap or -self.max_heap[0] &gt;= num:            heapq.heappush(self.max_heap, -num)        else:            heapq.heappush(self.min_heap, num)                # 步骤2: 平衡两个堆的大小，确保它们的size之差不超过1。        self._balance()    def findMedian(self) -&gt; float:        # 根据两个堆的大小来计算中位数。        # 如果大小相等（总元素为偶数），中位数是两个堆顶的平均值。        if len(self.max_heap) == len(self.min_heap):            # 注意从大顶堆取值时要取反，恢复其原始值。            return (-self.max_heap[0] + self.min_heap[0]) / 2.0        # 如果大小不等（总元素为奇数），中位数就是那个size更大的堆的堆顶。        else:            return -self.max_heap[0] if len(self.max_heap) &gt; len(self.min_heap) else self.min_heap[0]    # 私有辅助方法，用于平衡两个堆    def _balance(self) -&gt; None:        # 当两个堆的大小差距为2时，需要从元素多的堆移动一个到元素少的堆。        if abs(len(self.max_heap) - len(self.min_heap)) == 2:            if len(self.max_heap) &gt; len(self.min_heap):                heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))            else:                heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))\n\n算法分析\n时间复杂度：addNum为O(logN)，findMedian为O(1)\n空间复杂度：O(N)\n核心技巧：双堆平衡\n\n题目六：最大频率栈问题描述设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。\n实现 FreqStack 类：\n\nFreqStack() 构造一个空的堆栈\nvoid push(int val) 将一个整数val压入栈顶\nint pop() 删除并返回堆栈中出现频率最高的元素\n\n测试链接：https://leetcode.cn/problems/maximum-frequency-stack/\n核心思想使用一个哈希表记录每个值出现的频率，使用另一个哈希表将频率映射到一个栈，这个栈存储了所有出现该频率的数字。使用一个变量实时追踪当前的最大频率。\n\n算法实现from collections import defaultdictclass FreqStack:    def __init__(self): #这个初始化的是hashmap        # 核心思想:        # 1. 使用一个哈希表 (value_times) 记录每个值出现的频率。        # 2. 使用另一个哈希表 (cnt_values) 将频率映射到一个栈（列表），这个栈存储了所有出现该频率的数字。        # 3. 使用一个变量 (top_times) 实时追踪当前的最大频率。        # pop操作总是从最大频率对应的栈中弹出元素，这保证了既是最高频也是最“新”的。        # 出现的最大次数        self.top_times = 0        # 每层节点 (每个频率有哪些数)        # defaultdict(list) 会在key不存在时自动创建一个空列表        self.cnt_values = defaultdict(list)         # 每一个数出现了几次        # defaultdict(int) 会在key不存在时自动创建一个0        self.value_times = defaultdict(int)         #实际上，cnt_values和value_times是两个哈希表，一个存储频率，一个存储频率对应的数    def push(self, val: int) -&gt; None:        # 步骤1: 更新该值的频率        self.value_times[val] += 1        current_freq = self.value_times[val]                # 步骤2: 将该值压入其新频率对应的栈中        self.cnt_values[current_freq].append(val)                # 步骤3: 更新全局最大频率        self.top_times = max(self.top_times, current_freq)    def pop(self) -&gt; int:        # 步骤1: 从最大频率对应的栈中弹出最近压入的元素        ans = self.cnt_values[self.top_times].pop()                # 步骤2: 如果弹出后，该频率的栈为空了，说明最大频率需要降低        if not self.cnt_values[self.top_times]:            self.top_times -= 1                # 步骤3: 更新被弹出元素自身的频率记录        self.value_times[ans] -= 1                return ans\n\n算法分析\n时间复杂度：push和pop操作都是O(1)\n空间复杂度：O(N)\n核心技巧：频率分层存储\n\n题目七：全O(1)的数据结构问题描述请你实现一个数据结构支持以下操作：\n\nInc(key) - 插入一个新的值为1的key，或者使一个存在的key增加一，保证key不为空字符串\nDec(key) - 如果这个key的值是1，那么把他从数据结构中移除掉。否则使一个存在的key值减一。如果这个key不存在，这个函数不做任何事情。key保证不为空字符串\nGetMaxKey() - 返回key中值最大的任意一个。如果没有元素存在，返回一个空字符串””\nGetMinKey() - 返回key中值最小的任意一个。如果没有元素存在，返回一个空字符串””\n\n挑战：以O(1)的时间复杂度实现所有操作。\n测试链接：https://leetcode.cn/problems/all-oone-data-structure/\n核心思想使用一个双向链表来组织桶(Bucket)，链表按桶的计数值(cnt)升序排列。每个桶包含一个集合，存储所有计数值等于该桶cnt的key。使用一个哈希表来存储key -&gt; Bucket的映射，实现O(1)的key定位。\n\n算法实现class AllOne:    # 内部类，定义双向链表的节点，也叫“桶”    # 每个桶存储具有相同计数值的所有key    class Bucket:        def __init__(self, cnt):            self.cnt = cnt            self.keys = set()            self.last = None            self.next = None    def __init__(self):        # 核心思想:        # 1. 使用一个双向链表来组织桶(Bucket)，链表按桶的计数值(cnt)升序排列。        # 2. 每个桶(Bucket)包含一个集合(set)，存储所有计数值等于该桶cnt的key。        # 3. 使用一个哈希表(map)来存储 key -&gt; Bucket 的映射，实现O(1)的key定位。        # inc/dec操作本质上是将key从一个桶移动到相邻的下一个/上一个桶。                # 创建头尾哨兵节点，简化边界处理        self.head = self.Bucket(0)        self.tail = self.Bucket(float(&#x27;inf&#x27;))        # 将头节点的下一个指针指向尾节点，尾节点的上一个指针指向头节点，这样操作后，双向链表形成了一个初始的空结构：head &lt;-&gt; tail        self.head.next = self.tail        self.tail.last = self.head        # 存储 key 到其所在 Bucket 的映射        self.map = &#123;&#125;    # 辅助函数：在指定位置(prev_bucket)后插入一个新桶(new_bucket)    def _insert_after(self, prev_bucket, new_bucket):        new_bucket.next = prev_bucket.next        new_bucket.last = prev_bucket        prev_bucket.next.last = new_bucket        prev_bucket.next = new_bucket    # 辅助函数：从链表中移除一个桶，让前后的指针跳过当前桶    def _remove_bucket(self, bucket):        bucket.last.next = bucket.next        bucket.next.last = bucket.last    def inc(self, key: str) -&gt; None:        # 核心步骤：将key从当前桶移动到cnt+1的桶        if key not in self.map:            # case 1: 新key，计数值为1            # 找到或创建cnt=1的桶            target_bucket = self.head.next #定位到第一个桶            if target_bucket.cnt != 1:                target_bucket = self.Bucket(1)                self._insert_after(self.head, target_bucket)            # 将key加入桶和map            target_bucket.keys.add(key)            self.map[key] = target_bucket        else:            # case 2: key已存在            current_bucket = self.map[key] #map是双向的            new_cnt = current_bucket.cnt + 1                        # 找到或创建cnt=new_cnt的桶            target_bucket = current_bucket.next            if target_bucket.cnt != new_cnt:                target_bucket = self.Bucket(new_cnt)                self._insert_after(current_bucket, target_bucket)            # 移动key            target_bucket.keys.add(key)            self.map[key] = target_bucket            current_bucket.keys.remove(key)                        # 如果原桶变空，则移除            if not current_bucket.keys:                self._remove_bucket(current_bucket)    def dec(self, key: str) -&gt; None:        if key not in self.map:            return                # 核心步骤：将key从当前桶移动到cnt-1的桶        current_bucket = self.map[key]        current_bucket.keys.remove(key)        if current_bucket.cnt &gt; 1:            new_cnt = current_bucket.cnt - 1            # 找到或创建cnt=new_cnt的桶            target_bucket = current_bucket.last            if target_bucket.cnt != new_cnt:                target_bucket = self.Bucket(new_cnt)                self._insert_after(current_bucket.last, target_bucket)            # 移动key            target_bucket.keys.add(key)            self.map[key] = target_bucket        else:            # 如果cnt为1，dec后直接从map中移除            del self.map[key]                # 如果原桶变空，则移除        if not current_bucket.keys:            self._remove_bucket(current_bucket)    def getMaxKey(self) -&gt; str:        # 最大计数值的桶在tail哨兵节点的前面        if self.tail.last == self.head:            return &quot;&quot;        # 从桶的集合中任意取一个key即可        return next(iter(self.tail.last.keys))         # self.tail.last - 获取尾哨兵节点的前一个节点，也就是链表中最后一个实际的桶        # .keys - 这个桶中存储的键的集合（set）        # iter(...) - 将集合转换为迭代器        # next(...) - 从迭代器中获取第一个元    def getMinKey(self) -&gt; str:        # 最小计数值的桶在head哨兵节点的后面        if self.head.next == self.tail:            return &quot;&quot;        # 从桶的集合中任意取一个key即可        return next(iter(self.head.next.keys))\n\n算法分析\n时间复杂度：所有操作都是O(1)\n空间复杂度：O(N)\n核心技巧：双向链表 + 桶分组\n\n数据结构设计核心技巧总结1. 哈希表的O(1)特性大部分设计题都基于哈希表的O(1)查找、插入、删除特性：\n# 基本哈希表操作hash_map = &#123;&#125;hash_map[key] = value  # O(1) 插入val = hash_map[key]    # O(1) 查找del hash_map[key]      # O(1) 删除\n\n2. 时间戳技巧用于实现懒更新策略：\n# 时间戳比较if operation_time &gt; global_time:    return local_valueelse:    return global_value\n\n3. 双向链表维护顺序适用于需要频繁移动元素位置的场景：\n# 双向链表节点移动def move_to_tail(node):    # 断开原连接    node.prev.next = node.next    node.next.prev = node.prev    # 插入到尾部    node.next = tail    node.prev = tail.prev    tail.prev.next = node    tail.prev = node\n\n4. 数组末尾交换删除实现O(1)删除的经典技巧：\n# 将待删除元素与末尾元素交换arr[del_index] = arr[-1]map[arr[-1]] = del_index  # 更新索引映射arr.pop()  # 删除末尾元素\n\n5. 双堆维护极值适用于动态维护中位数或其他统计量：\n# 维护两个堆的平衡if abs(len(max_heap) - len(min_heap)) &gt; 1:    # 从大的堆移动元素到小的堆    balance_heaps()\n\n复杂度分析总结\n\n\n题目\n时间复杂度\n空间复杂度\n核心数据结构\n\n\n\nsetAll哈希表\nO(1)\nO(N)\n哈希表+时间戳\n\n\nLRU缓存\nO(1)\nO(capacity)\n哈希表+双向链表\n\n\n随机数据结构\nO(1)\nO(N)\n哈希表+动态数组\n\n\n随机数据结构(重复)\nO(1)\nO(N)\n哈希表+集合+数组\n\n\n中位数查找\nO(logN)&#x2F;O(1)\nO(N)\n双堆\n\n\n最大频率栈\nO(1)\nO(N)\n哈希表+栈数组\n\n\n全O(1)数据结构\nO(1)\nO(N)\n哈希表+双向链表+桶\n\n\n学习建议\n理解O(1)的本质：大多数设计题的核心是利用哈希表的O(1)特性\n\n掌握组合数据结构：\n\n哈希表 + 双向链表（LRU）\n哈希表 + 动态数组（随机访问）\n双堆（维护极值）\n时间戳（懒更新）\n\n\n注意边界条件：\n\n空数据结构\n容量限制\n重复元素处理\n\n\n理解权衡取舍：\n\n时间复杂度 vs 空间复杂度\n实现复杂度 vs 运行效率\n\n\n多练习组合技巧：数据结构设计题往往需要组合多种基础数据结构\n\n\n数据结构设计题考察的是对基础数据结构的深入理解和灵活运用能力。通过掌握这些经典模式和技巧，可以应对大多数设计类问题。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","哈希表","LRU","堆","双向链表"]},{"title":"数据结构与算法自学笔记（12）- 链表高频题目和必备技巧","url":"/2025/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记总结了链表类题目的高频考点和必备技巧，包含6道经典链表题目的详细解析。链表题目主要考察的是编程能力而非算法设计，是class034的内容。\n前置知识在学习链表高频题目之前，需要掌握以下基础知识：\n\n链表入门内容（009~012讲）\n归并排序（021讲）\n哈希表的使用（026讲）\n排序算法的稳定性（029讲）\n\n链表定义# 定义链表节点类class ListNode:    def __init__(self, val=0, next=None):        self.val = val  # 节点存储的值        self.next = next  # 指向下一个节点的指针\n\n\n034【必备】链表高频题目和必备技巧链表题目解题要点核心注意事项\n空间复杂度的选择：\n\n如果笔试中空间要求不严格，直接使用容器来解决链表问题\n如果笔试中空间要求严格、或者在面试中面试官强调空间的优化，需要使用额外空间复杂度O(1)的方法\n\n\n最常用的技巧：快慢指针\n\n考察重点：链表类题目往往都是很简单的算法问题，核心考察点并不是算法设计，而是coding能力\n\n练习建议：既然练的就是coding，那么不要采取空间上讨巧的方式来练习（容器方法），这些题难就难在要用有限几个变量来解决\n\n\n题目一：返回两个无环链表相交的第一个节点问题描述给定两个单链表的头节点，判断两个链表是否相交，如果相交返回第一个交点，否则返回None。\n测试链接：https://leetcode.cn/problems/intersection-of-two-linked-lists/\n\n解题思路容器解法（空间复杂度O(N)）：\n\n遍历链表1，将每个节点加入哈希表\n遍历链表2，检查每个节点是否在哈希表中\n如果找到第一个在哈希表中的节点，即为第一个交点\n\n最优解法（空间复杂度O(1)）：核心思想是先判断两条链表是否相交，再找交点。\n判断相交的关键：两条链表如果相交，最后一个节点一定是同一个节点（因为链表每个节点只有一个next指针）。\n算法步骤# 返回两个无环链表相交的第一个节点def getIntersectionNode(self, h1: ListNode, h2: ListNode) -&gt; ListNode:    if not h1 or not h2:  # 任一链表为空，不可能相交        return None    a = h1  # a指针遍历链表1    b = h2  # b指针遍历链表2    diff = 0  # 记录两个链表的长度差        # 遍历链表1，计算其长度    while a.next:        a = a.next  # a指针后移        diff += 1  # 长度差加1    # 遍历链表2，计算其长度    while b.next:        b = b.next  # b指针后移        diff -= 1  # 长度差减1        if a != b:  # 最后一个节点不同，说明不相交        return None            # 根据长度差的正负，确定哪个是长链表，哪个是短链表    # a指向长链表的头，b指向短链表的头    if diff &gt;= 0:        a = h1  # a指向长链表        b = h2  # b指向短链表    else:        a = h2        b = h1            diff = abs(diff)    while diff != 0:        a = a.next        diff -= 1            # 同时移动直到相遇    while a != b:        a = a.next        b = b.next            return a  # 返回交点\n\n算法分析\n时间复杂度：O(M + N)，M和N分别是两个链表的长度\n空间复杂度：O(1)\n核心技巧：长度差计算 + 双指针\n\n题目二：每k个节点一组翻转链表问题描述给定一个链表，每k个节点一组进行翻转，如果最后剩余节点不够k个，则保持原样。\n测试链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/\n解题思路容器解法：把所有节点都放到数组里，然后每k个节点一组进行翻转，但空间复杂度为O(N)。\n最优解法：使用有限变量完成分组翻转。\n\n\n\n算法步骤# 按k个一组翻转链表def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:    start = head  # start指向当前组的开始节点    end = self.teamEnd(start, k)  # 找到第一组的结束节点        if end is None:  # 如果第一组的长度不足k，直接返回原链表头节点        return head        # 第一组很特殊因为牵扯到换头的问题    # 翻转后，第一组的末尾节点end会成为整个链表的新头节点    head = end    self.reverse(start, end)  # 翻转第一组节点        # 翻转之后start变成了上一组的结尾节点    lastTeamEnd = start  # lastTeamEnd记录上一组翻转后的尾节点        # 循环处理剩余的链表    while lastTeamEnd.next is not None:        start = lastTeamEnd.next  # 下一组的开始节点        end = self.teamEnd(start, k)  # 找到下一组的结束节点                if end is None:  # 如果剩余部分的长度不足k，直接返回头节点，不进行翻转            return head                self.reverse(start, end)  # 翻转当前组        lastTeamEnd.next = end  # 将上一组的尾节点与当前组翻转后的头节点(即原来的end)连接起来        lastTeamEnd = start  # 更新lastTeamEnd为当前组翻转后的尾节点(即原来的start)            return head  # 返回新的头节点# 当前组的开始节点是s，往下数k个找到当前组的结束节点返回def teamEnd(self, s: ListNode, k: int) -&gt; ListNode:    &quot;&quot;&quot;找到从s开始第k个节点&quot;&quot;&quot;    # 从s开始，向后移动k-1次    while k - 1 != 0 and s is not None:        s = s.next  # s指针后移        k -= 1  # 计数器减1    return s  # 返回第k个节点，如果不足k个则返回None# s -&gt; a -&gt; b -&gt; c -&gt; e -&gt; 下一组的开始节点# 上面的链表通过如下的reverse方法调整成 : e -&gt; c -&gt; b -&gt; a -&gt; s -&gt; 下一组的开始节点# 翻转从s到e的这一段链表def reverse(self, s: ListNode, e: ListNode):    &quot;&quot;&quot;翻转从s到e的链表段&quot;&quot;&quot;    e = e.next  # e是当前组的结尾，e.next指向下一组的开头    pre = None  # pre是前一个节点，初值为None    cur = s  # cur是当前节点，初值为s    next_node = None  # next是下一个节点        # 遍历当前组，直到cur到达下一组的开头    while cur != e:        next_node = cur.next  # 保存当前节点的下一个节点        cur.next = pre  # 将当前节点的next指针指向前一个节点        pre = cur  # pre, cur向后移动        cur = next_node        s.next = e  # 翻转后，原来的头节点s变成了尾节点，它的next应该指向下一组的开头\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(1)\n核心技巧：分组处理 + 局部翻转\n\n题目三：复制带随机指针的链表问题描述复制一个带random指针的链表，random可以指向链表中的任意节点或者null。\n测试链接：https://leetcode.cn/problems/copy-list-with-random-pointer/\n解题思路容器解法：使用哈希表记录原节点和新节点的对应关系，空间复杂度O(N)。\n最优解法：在原链表上直接操作，分三步完成复制。\n\n算法步骤def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;:    if head is None:  # 如果头节点为空，直接返回None        return None        cur = head  # cur指针用于遍历原链表    next_node = None  # next指针用于暂存下一个节点        # 1 -&gt; 2 -&gt; 3 -&gt; ...变成 : 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27; -&gt; ...    # 第一步：复制每个节点并将其插入到原节点之后    while cur is not None:        next_node = cur.next  # 保存原节点的下一个节点        cur.next = self.Node(cur.val)  # 创建新节点，值为原节点的值        cur.next.next = next_node  # 将新节点的next指向原节点的下一个节点        cur = next_node  # 移动cur到下一个原节点        cur = head  # cur指针重置回头节点，准备设置新节点的random指针    copy = None  # copy指针用于指向复制的节点        # 第二步：为新节点设置random指针    while cur is not None:        next_node = cur.next.next  # 保存下一个原节点的位置        copy = cur.next  # 获取当前节点的复制节点        # 设置复制节点的random指针        # 如果原节点的random不为空，则其复制节点的random指向原节点random的下一个节点(即random指向节点的复制品)        copy.random = cur.random.next if cur.random is not None else None        cur = next_node  # 移动cur到下一个原节点            ans = head.next  # ans是新链表的头节点，即原头节点的下一个节点    cur = head  # cur指针重置回头节点，准备分离新旧链表        # 第三步：分离原链表和新链表    while cur is not None:        next_node = cur.next.next  # 保存下一个原节点的位置        copy = cur.next  # 获取当前节点的复制节点        cur.next = next_node  # 恢复原链表的next指针        # 设置复制节点的next指针        # 如果下一个原节点不为空，则复制节点的next指向下一个原节点的复制节点        copy.next = next_node.next if next_node is not None else None        cur = next_node  # 移动cur到下一个原节点            return ans  # 返回新链表的头节点\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(1)\n核心技巧：节点插入 + 关系复制 + 链表分离\n\n题目四：判断链表是否是回文结构问题描述判断链表是否是回文结构，一个链表节点视为一个字符。\n测试链接：https://leetcode.cn/problems/palindrome-linked-list/\n解题思路容器解法：使用栈存储所有节点，然后比较压栈过程和弹栈过程的数字是不是一致的，空间复杂度O(N)。\n最优解法：使用快慢指针找中点，翻转后半部分，然后比较。\n算法步骤# 提交如下的方法def isPalindrome(self, head: ListNode) -&gt; bool:    if head is None or head.next is None:  # 空链表或只有一个节点的链表是回文结构        return True        slow = head  # slow指针每次走一步，fast指针每次走两步    fast = head        # 找中点，当fast到达链表末尾时，slow正好在中间位置    while fast.next is not None and fast.next.next is not None:        slow = slow.next  # slow指针后移一步        fast = fast.next.next  # fast指针后移两步            # 现在中点就是slow，从中点开始往后的节点逆序    pre = slow  # pre是反转后的链表的头节点，初始是slow    cur = pre.next  # cur是当前要处理的节点，初始是slow的下一个    next_node = None  # next_node用于保存cur的下一个节点    pre.next = None  # 断开前半部分和后半部分的连接        # 循环反转后半部分链表    while cur is not None:        next_node = cur.next  # 保存下一个节点        cur.next = pre  # 当前节点的next指向前一个节点(pre)        pre = cur  # pre和cur指针后移        cur = next_node            # 上面的过程已经把链表调整成从左右两侧往中间指    # head -&gt; ... -&gt; slow &lt;- ... &lt;- pre    ans = True  # ans默认为True，即假设是回文    left = head  # left指针从头开始    right = pre  # right指针从后半部分的头（即反转前的尾）开始        # left往右、right往左，每一步比对值是否一样，如果某一步不一样答案就是false    while left is not None and right is not None:        if left.val != right.val:  # 如果左右两边的值不相等            ans = False  # 那么不是回文            break  # 退出循环        left = left.next  # 移动指针        right = right.next            # 本着不坑的原则，把链表调整回原来的样子再返回判断结果    # 再次反转后半部分，恢复原链表结构    cur = pre.next  # cur是当前要处理的节点，初始是pre的下一个    pre.next = None  # 断开连接    next_node = None  # next_node用于保存cur的下一个节点        # 循环将后半部分链表反转回来    while cur is not None:        next_node = cur.next  # 保存下一个节点        cur.next = pre  # 当前节点的next指向前一个节点(pre)        pre = cur  # pre和cur指针后移        cur = next_node            return ans  # 返回最终的判断结果\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(1)\n核心技巧：快慢指针找中点 + 链表翻转\n\n题目五：返回链表的第一个入环节点问题描述判断链表是否有环，如果有环，返回入环节点，否则返回None。\n测试链接：https://leetcode.cn/problems/linked-list-cycle-ii/\n解题思路容器解法：用哈希表记录每个节点，如果某个节点再次出现，则该节点就是入环节点。\n最优解法：使用快慢指针，分两阶段找环。\n\n数学原理设链表头到入环点距离为a，入环点到相遇点距离为b，相遇点到入环点距离为c。\n当快慢指针相遇时：\n\n慢指针走过距离：a + b\n快指针走过距离：a + b + c + b &#x3D; a + 2b + c\n\n由于快指针速度是慢指针的2倍：2(a + b) &#x3D; a + 2b + c解得：a &#x3D; c\n算法步骤def detectCycle(self, head: ListNode) -&gt; ListNode:    if head is None or head.next is None or head.next.next is None:        return None            slow = head.next  # 慢指针slow每次走一步    fast = head.next.next  # 快指针fast每次走两步        # 第一阶段：快慢指针相遇    while slow != fast:        if fast.next is None or fast.next.next is None:  # 如果快指针或其下一个节点为空，说明没有环            return None        slow = slow.next  # 慢指针走一步        fast = fast.next.next  # 快指针走两步            # 第二阶段：快指针回到头部，同步移动    fast = head  # 当快慢指针相遇后，将快指针重置到链表头    # 此时，慢指针和快指针同时以每次一步的速度前进    while slow != fast:        slow = slow.next  # 慢指针后移        fast = fast.next  # 快指针后移            return slow  # 相遇点即为入环点\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(1)\n核心技巧：快慢指针 + 数学推导\n\n题目六：链表排序问题描述在链表上排序，要求时间复杂度O(n*logn)，额外空间复杂度O(1)，还要求排序有稳定性。\n测试链接：https://leetcode.cn/problems/sort-list/\n解题思路链表由于有指针存在可以做到这个指标，但是数组排序不行。使用自底向上的归并排序，采用非递归方法避免O(logn)的递归空间。\n算法步骤def findEnd(self, s: ListNode, k: int) -&gt; ListNode:    &quot;&quot;&quot;从s开始找第k个节点&quot;&quot;&quot;    while s and s.next and k - 1 &gt; 0:        s = s.next        k -= 1    return s# l1...r1 -&gt; null : 有序的左部分 (在Python实现中r1,r2参数是不必要的)# l2...r2 -&gt; null : 有序的右部分# 整体merge在一起，保证有序# 并且返回整体的头和尾def merge(self, l1: ListNode, l2: ListNode) -&gt; (ListNode, ListNode):    &quot;&quot;&quot;合并两个有序链表，返回头和尾&quot;&quot;&quot;    dummy = self.ListNode(0)  # dummy是哨兵节点，方便处理    pre = dummy  # pre指针用于构建新链表        # 当两个链表都不为空时    while l1 and l2:        # 比较两个链表节点的值        if l1.val &lt;= l2.val:            pre.next = l1  # 将较小的节点连接到新链表            l1 = l1.next  # 移动l1指针        else:            pre.next = l2  # 将较小的节点连接到新链表            l2 = l2.next  # 移动l2指针        pre = pre.next  # 移动pre指针        # 如果l1还有剩余，直接连接    if l1:        pre.next = l1    elif l2:  # 如果l2还有剩余，直接连接        pre.next = l2            # 找到合并后链表的尾部    while pre.next:        pre = pre.next            return dummy.next, pre  # 返回新链表的头和尾def sortList(self, head: ListNode) -&gt; ListNode:    &quot;&quot;&quot;正式排序&quot;&quot;&quot;    if not head:  # 如果链表为空，直接返回        return None        n = 0  # n用于存储链表长度    cur = head  # cur用于遍历链表    # 计算链表长度    while cur:        n += 1        cur = cur.next            # l1...r1 每组的左部分    # l2...r2 每组的右部分    # next_group_head 下一组的开头    # last_team_end 上一组的结尾        step = 1  # step是每次合并的子链表长度，从1开始，每次翻倍    while step &lt; n:        # 每一轮归并开始时，重新从头开始，dummy是一个哨兵节点，方便处理头节点        dummy = self.ListNode(0, head)        last_team_end = dummy  # last_team_end指向上一次合并后的尾部        cur = dummy.next  # cur指向当前处理的链表的头部                while cur:                   l1 = cur  # l1是第一部分的头            r1 = self.findEnd(l1, step)  # r1是第一部分的尾            l2 = r1.next if r1 else None  # l2是第二部分的头            if not l2:  # 如果没有第二部分，就结束这一轮的合并                last_team_end.next = l1                break            r2 = self.findEnd(l2, step)  # r2是第二部分的尾                        next_group_head = r2.next if r2 else None  # next_group_head是下一组的头                        # 断开链表，准备合并            r1.next = None            r2.next = None                        merged_head, merged_end = self.merge(l1, l2)  # 合并l1和l2两个有序链表                        last_team_end.next = merged_head  # 将合并后的链表接在上一组的后面            last_team_end = merged_end  # 更新last_team_end为当前合并后的尾部                        cur = next_group_head  # cur指向下一组的开头                head = dummy.next  # 更新整个链表的头        step &lt;&lt;= 1  # 步长翻倍            return head\n\n算法分析\n时间复杂度：O(N*logN)\n空间复杂度：O(1)\n稳定性：是\n核心技巧：自底向上归并 + 非递归实现\n\n链表问题核心技巧总结1. 快慢指针技巧快慢指针是链表问题中最重要的技巧：\n# 找链表中点slow = fast = headwhile fast and fast.next:    slow = slow.next    fast = fast.next.next# slow指向中点# 判断链表是否有环slow = fast = headwhile fast and fast.next:    slow = slow.next    fast = fast.next.next    if slow == fast:        return True  # 有环return False\n\n2. 虚拟头节点技巧当需要修改头节点时，使用虚拟头节点简化操作：\ndummy = ListNode(0)dummy.next = head# 对dummy.next进行操作return dummy.next\n\n3. 双指针技巧用于处理需要同时操作两个位置的问题：\n# 删除倒数第n个节点dummy = ListNode(0, head)first = second = dummyfor _ in range(n + 1):    first = first.nextwhile first:    first = first.next    second = second.nextsecond.next = second.next.next\n\n4. 链表翻转技巧翻转是链表的基础操作：\ndef reverse(head):    pre = None    cur = head    while cur:        next_node = cur.next        cur.next = pre        pre = cur        cur = next_node    return pre\n\n复杂度分析总结\n\n\n题目\n时间复杂度\n空间复杂度\n核心技巧\n\n\n\n链表相交\nO(M+N)\nO(1)\n长度差+双指针\n\n\nK组翻转\nO(N)\nO(1)\n分组+局部翻转\n\n\n复制随机链表\nO(N)\nO(1)\n节点插入+分离\n\n\n回文判断\nO(N)\nO(1)\n快慢指针+翻转\n\n\n环检测\nO(N)\nO(1)\n快慢指针+数学\n\n\n链表排序\nO(N*logN)\nO(1)\n自底向上归并\n\n\n学习建议\n重视编程能力：链表题目主要考察coding能力，要多练习用有限变量解决问题\n\n掌握核心技巧：\n\n快慢指针（最重要）\n虚拟头节点\n双指针\n链表翻转\n\n\n避免容器方法：在练习时尽量使用O(1)空间的方法，提升编程能力\n\n注意边界条件：\n\n空链表\n单节点链表\n链表长度不足的情况\n\n\n保持链表结构：某些题目要求恢复原链表结构，要特别注意\n\n\n链表问题虽然算法相对简单，但对编程能力要求较高。通过大量练习和对核心技巧的熟练掌握，可以有效提升解题能力。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","链表","快慢指针","归并排序"]},{"title":"数据结构与算法自学笔记（15）- 常见经典递归过程解析","url":"/2025/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89-%20%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记是 038【必备】常见经典递归过程解析 的内容，总结了7道经典递归题目，涵盖了递归的核心思想和技巧，包括带路径的递归、不带路径的递归、回溯算法等重要概念。\n前置知识在学习本节内容之前，建议先熟悉以下章节：\n\n讲解017、020、021、023、036、037（这些章节都分析过递归）\n\n重要概念递归与回溯的关系\n任何递归都是DFS且非常灵活\n回溯这个术语并不重要，它只是递归过程中的恢复现场操作\n带路径的递归 vs 不带路径的递归：大部分DP和状态压缩DP可以认为是路径简化了结构\n\n\n038【必备】常见经典递归过程解析题目一：返回字符串全部子序列（去重）问题描述返回字符串全部子序列，子序列要求去重。\n测试链接：https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a\n核心思想使用递归的方式，对于字符串中的每一个字符，我们都有两种选择：\n\n将该字符包含在当前子序列中\n不将该字符包含在当前子序列中\n\n通过递归遍历所有这些选择，就能得到所有可能的子序列。\n\n算法实现方法一：使用列表作为路径class Solution:    def generatePermutation1(self, s: str) -&gt; List[str]:        &quot;&quot;&quot;        主函数，初始化并调用递归函数 f1        &quot;&quot;&quot;        # 使用集合 set 来自动处理重复的子序列        result_set = set()        # path 使用列表来模拟 Java 的 StringBuilder，方便添加和删除字符        path = []        self._f1(s, 0, path, result_set)        return sorted(list(result_set))    def _f1(self, s: str, i: int, path: List[str], result_set: Set[str]):        &quot;&quot;&quot;        递归函数，用于生成所有子序列        s[i...]，之前决定的路径path，set收集结果时去重        &quot;&quot;&quot;        # base case: 当索引 i 到达字符串末尾时，所有字符都已考虑完毕        if i == len(s):            result_set.add(&quot;&quot;.join(path))        else:            # 决策1: 选择当前字符 s[i]            path.append(s[i])  # 加到路径中去            self._f1(s, i + 1, path, result_set)                        # 回溯：撤销选择，为下一种决策做准备            path.pop()  # 从路径中移除，删掉最后一个字符                        # 决策2: 不选择当前字符 s[i]            self._f1(s, i + 1, path, result_set)\n\n方法二：使用固定长度列表和size指针class Solution:    def generatePermutation2(self, s: str) -&gt; List[str]:        &quot;&quot;&quot;        主函数，初始化并调用递归函数 f2        &quot;&quot;&quot;        result_set = set()        # 预先分配一个与原字符串等长的列表作为路径容器        path = [&#x27;&#x27;] * len(s)        self._f2(s, 0, path, 0, result_set)        return sorted(list(result_set))    def _f2(self, s: str, i: int, path: List[str], size: int, result_set: Set[str]):        &quot;&quot;&quot;        与f1思想相同，但使用不同的方式来维护路径        这方法不用回溯，因为path是固定长度的列表，size指针来表示有效字符长度        &quot;&quot;&quot;        if i == len(s):            # path[:size] 表示路径中的有效部分            result_set.add(&quot;&quot;.join(path[:size]))            # path[:size]: 取列表/序列 path 的前 size 个元素（左闭右开，不会越界，超过长度就取到末尾）            # &quot;&quot;.join(...): 用空字符串作为分隔符，把可迭代对象里的“字符串元素”拼接成一个整体字符串            # result_set.add(...): 将结果添加到集合中，自动去重        else:            # 决策1: 选择当前字符 s[i]，将其放入 path 的 size 位置            path[size] = s[i]            self._f2(s, i + 1, path, size + 1, result_set) #size+1表明有效字符长度+1，指针后移                        # 决策2: 不选择当前字符 s[i]，直接进入下一层递归            self._f2(s, i + 1, path, size, result_set)\n\n算法分析\n时间复杂度：O(2^n × n)，子序列个数2^n，平均长度O(n)级别\n空间复杂度：O(2^n × n)\n核心技巧：递归选择 + set去重\n\n\n题目二：返回数组的所有组合（去重）问题描述给你一个整数数组 nums，其中可能包含重复元素，请你返回该数组所有可能的组合。答案不能包含重复的组合。\n测试链接：https://leetcode.cn/problems/subsets-ii/\n核心思想与生成子序列（排列）不同，这里通过一次性决策一组相同数字的方式来避免重复。\n\n先对数组排序。\n在递归到位置 i 时，首先找到下一个与 nums[i] 不同的数的位置 j。 这表示从 i 到 j-1 都是相同的数。\n决策1：这组相同的数一个都不要。直接从 j 位置继续递归。\n决策2：依次决策要1个、2个…直到 j-i 个相同的数。 每做一次选择，就将数加入路径，然后从 j 位置继续递归。\n\n\n算法实现class Solution:    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:        &quot;&quot;&quot;        主函数，初始化并调用递归函数        &quot;&quot;&quot;        ans = []        # 排序是关键，它使得相同的元素相邻，便于后续去重处理        nums.sort()        path = [0] * len(nums)        self._f(nums, 0, path, 0, ans)        return ans    def _f(self, nums: List[int], i: int, path: List[int], size: int, ans: List[List[int]]):        &quot;&quot;&quot;        递归函数，生成不重复的组合        &quot;&quot;&quot;        # base case: 当 i 到达数组末尾时，形成一个组合        if i == len(nums):            ans.append(path[:size])        else:            # 找到下一个不同于 nums[i] 的元素的位置 j            j = i + 1            while j &lt; len(nums) and nums[j] == nums[i]:                j += 1                        # 决策1: 当前数 nums[i] 一个都不要            self._f(nums, j, path, size, ans)                        # 决策2: 依次尝试要 1 个、2 个... k 个 nums[i]            # 从这一段相同数字里，依次选择 1 个、2 个、…、(j-i) 个放入路径，然后递归从 j 开始，即处理下一组数去            for k in range(i, j):                path[size] = nums[k]                size += 1                # 每次选择后，都从下一个不同的数 j 开始继续递归                self._f(nums, j, path, size, ans)\n\n区别：set去重 vs 剪枝去重\n剪枝去重：当有相同的元素时，不进入递归，直接跳过，避免重复计算。（本题有用到这方面的考虑）\nset去重：当有相同的元素时，会进入递归，但最终结果会去重。（但是题目1没有）\n\n算法分析\n时间复杂度：O(2^n × n)，所有不重复组合数量≤2^n\n空间复杂度：O(2^n × n)\n核心技巧：排序 + 剪枝去重\n\n\n题目三：返回没有重复值数组的全部排列问题描述没有重复项数字的全排列。\n测试链接：https://leetcode.cn/problems/permutations/\n核心思想使用交换模型：\n\n递归函数 _f(nums, i) 的任务是确定数组中第 i 个位置应该放哪个数。\n我们可以从 i 到 len(nums)-1 的范围内选择一个数，将它与 nums[i] 交换， 这样就确定了第 i 位。\n然后递归调用 _f(nums, i+1) 去确定第 i+1 位。\n当 i 到达数组末尾时，一个完整的排列就形成了。\n递归返回后，必须将之前交换的元素换回来（回溯），以确保不影响其他分支的决策。\n\n\n算法实现class Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        &quot;&quot;&quot;        主函数，初始化并调用递归函数        &quot;&quot;&quot;        ans = []        self._f(nums, 0, ans)  # 复用了原数组做路径        return ans    def _f(self, nums: List[int], i: int, ans: List[List[int]]):        &quot;&quot;&quot;        递归函数，生成全排列        核心思想 (交换模型)        &quot;&quot;&quot;        # base case: 当 i 到达数组长度时，一个完整的排列就形成了        if i == len(nums):            ans.append(nums[:])  # 将当前排列的副本加入结果列表        else:            # 尝试将 i 到 len(nums)-1 的每个数放到 i 位置上            for j in range(i, len(nums)):                # 将 nums[j] 换到当前要确定的 i 位置                self._swap(nums, i, j)                # 递归去确定下一个位置 i+1                self._f(nums, i + 1, ans)                # 回溯：将数组恢复原样，以便 for 循环下一次迭代能正确执行                self._swap(nums, i, j)    def _swap(self, nums: List[int], i: int, j: int):        nums[i], nums[j] = nums[j], nums[i]\n\n算法分析\n时间复杂度：O(n! × n)\n空间复杂度：O(n!)\n核心技巧：交换模型 + 回溯\n\n\n题目四：返回可能有重复值数组的全部排列（去重）问题描述有重复项数组的去重全排列。\n测试链接：https://leetcode.cn/problems/permutations-ii/\n核心思想核心思想 (在交换模型基础上增加剪枝逻辑)：与生成无重复数字的全排列思路基本一致，但增加了一个去重机制。\n\n在确定第 i 个位置的数时，我们遍历 j from i to len-1。\n为了防止产生重复排列，我们规定：在第 i 个位置，一个数只能被放一次。 例如，对于 [1, 2, 2]，在确定第0位时，我们尝试放第一个 2， 就不应该再尝试放第二个 2，因为这两种情况后续会产生完全相同的排列。\n使用一个集合 seen (或 set) 来记录在当前位置 i 已经尝试过的数字。 如果 nums[j] 已经被放过，就跳过。\n\n算法实现class Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        &quot;&quot;&quot;        主函数，初始化并调用递归函数        &quot;&quot;&quot;        ans = []        self._f(nums, 0, ans)        return ans    def _f(self, nums: List[int], i: int, ans: List[List[int]]):        &quot;&quot;&quot;        递归函数，生成不重复的全排列        在交换模型基础上增加剪枝逻辑        &quot;&quot;&quot;        if i == len(nums):            ans.append(nums[:])        else:            # seen 集合用于记录在当前 i 位置上已经尝试过的数字            seen: Set[int] = set()            for j in range(i, len(nums)):                # nums[j]没有来到过i位置，才会去尝试                if nums[j] not in seen:                    # 记录下来，表示 nums[j] 这个值已经在 i 位置上用过了                    seen.add(nums[j])                    # 交换，将 nums[j] 放到 i 位置                    self._swap(nums, i, j)                    # 递归处理下一个位置                    self._f(nums, i + 1, ans)                    # 回溯，恢复数组                    self._swap(nums, i, j)                        def _swap(self, nums: List[int], i: int, j: int):        nums[i], nums[j] = nums[j], nums[i]\n\n算法分析\n时间复杂度：O(n! × n)\n空间复杂度：O(n!)\n核心技巧：交换模型 + 集合去重\n\n\n题目五：用递归逆序一个栈问题描述用递归函数逆序栈，不能使用任何额外的数据结构。\n核心思想需要两个递归函数：\n\nbottom_out：移除并返回栈底元素，同时保持其他元素顺序不变\nreverse：利用bottom_out函数来逆序整个栈\n\n\n算法实现class Solution:    def reverse(self, stack: List[int]):        &quot;&quot;&quot;        主递归函数，用于逆序整个栈。        核心思想：        1. 假设有一个函数 `_bottom_out` 可以移除并返回栈底元素。        2. `reverse` 函数首先调用 `_bottom_out` 得到栈底元素 `num`。        3. 然后，递归调用 `reverse` 来逆序剩下的 n-1 个元素的栈。        4. 最后，将之前取出的栈底元素 `num` 压入已逆序的栈中，此时它就成了新的栈顶。        &quot;&quot;&quot;        if not stack:            return                # 递归地移除并获取栈底元素        num = self._bottom_out(stack)        # 递归地逆序剩余的栈        self.reverse(stack)        # 将取出的栈底元素压入栈顶        stack.append(num)    def _bottom_out(self, stack: List[int]) -&gt; int:        &quot;&quot;&quot;        辅助递归函数，移除并返回栈底元素，同时保持其他元素顺序不变。        核心思想：        1. 弹出栈顶元素 `ans`。        2. 如果栈空了，说明 `ans` 就是我们想要的栈底元素，返回它。        3. 如果栈不空，递归调用 `_bottom_out` 获取剩下部分的栈底元素 `last`。        4. 在递归返回的过程中，将之前弹出的 `ans` 重新压栈，以恢复栈的状态。        5. 将从递归深处得到的 `last` 一路返回上去。        &quot;&quot;&quot;        ans = stack.pop()        if not stack:            return ans  # 如果栈空了，说明ans就是栈底元素        else:            last = self._bottom_out(stack)  # 递归获取剩下部分的栈底元素            stack.append(ans)  # 在递归返回过程中，将之前弹出的ans重新压栈            return last  # 将从递归深处得到的last一路返回上去\n\n执行过程示例原栈: [1, 2, 3, 4, 5] (5在栈顶)第1次reverse调用:  bottom_out取出栈底1，栈变为[2, 3, 4, 5]  递归reverse([2, 3, 4, 5])  返回后将1压入栈顶第2次reverse调用:  bottom_out取出栈底2，栈变为[3, 4, 5]  递归reverse([3, 4, 5])  返回后将2压入栈顶...以此类推最终结果: [1, 2, 3, 4, 5] (1在栈顶)\n\n算法分析\n时间复杂度：O(n²)\n空间复杂度：O(n) (递归栈空间)\n核心技巧：双递归函数配合\n\n\n题目六：用递归排序一个栈问题描述用递归函数排序栈，只能使用栈提供的push、pop、isEmpty三个方法，以及递归函数。要求排完序后，从栈顶到栈底从小到大。\n除此之外不能使用任何的容器，数组也不行。就是排序过程中只能用：(1) 栈提供的push、pop、isEmpty三个方法，(2) 递归函数，并且返回值最多为单个整数\n核心思想这是一个类似选择排序的递归实现。\n\n整个排序过程分为 deep 轮，deep 是当前未排序部分的栈深度。\n在每一轮中，目标是找出这 deep 个元素中的最大值（可能不止一个），并将它们“沉”到这 deep 个元素的最底部。\n_max() 函数：递归地在 deep 层中找到最大值。\n_times() 函数：递归地在 deep 层中统计这个最大值出现了几次 k。\n_down() 函数：递归地将这 k 个最大值移动到 deep 层的底部，同时保持其他 deep-k 个元素的相对顺序。\n完成一轮后，未排序的深度减少 k (deep -= k)，然后对剩下的 deep 个元素重复此过程。\n\n\n算法实现class Solution:    def sort_stack(self, stack: List[int]):        deep = self._deep(stack)        while deep &gt; 0:            # 找到当前 deep 范围内的最大值            maximum = self._max(stack, deep)            # 统计最大值出现的次数            k = self._times(stack, deep, maximum)            # 将这 k 个最大值沉底            self._down(stack, deep, maximum, k)            # 待排序的深度减少 k            deep -= k    def _deep(self, stack: List[int]) -&gt; int:        &quot;&quot;&quot;返回栈的深度，不改变栈的数据状况&quot;&quot;&quot;        if not stack:            return 0        num = stack.pop()        deep = self._deep(stack) + 1        stack.append(num)  # 恢复现场        return deep    def _max(self, stack: List[int], deep: int) -&gt; int:        &quot;&quot;&quot;从栈当前的顶部开始，往下数deep层，返回这deep层里的最大值&quot;&quot;&quot;        if deep == 0:            return -float(&#x27;inf&#x27;)  # 返回一个极小值作为基准        num = stack.pop()        rest_max = self._max(stack, deep - 1)        current_max = max(num, rest_max)        stack.append(num)  # 恢复现场        return current_max    def _times(self, stack: List[int], deep: int, maximum: int) -&gt; int:        &quot;&quot;&quot;返回maximum在deep层中出现的次数，不改变栈的数据状况&quot;&quot;&quot;        if deep == 0:            return 0        num = stack.pop()        rest_times = self._times(stack, deep - 1, maximum)        times = rest_times + (1 if num == maximum else 0)        stack.append(num)  # 恢复现场        return times    def _down(self, stack: List[int], deep: int, maximum: int, k: int):        &quot;&quot;&quot;将k个最大值沉到deep层的底部，剩下的数据状况不变&quot;&quot;&quot;        if deep == 0:            # 递归到底部时，先把k个最大值压入栈            for _ in range(k):                stack.append(maximum)        else:            num = stack.pop()            self._down(stack, deep - 1, maximum, k)            # 在递归返回时，只把非最大值的元素压回去            if num != maximum:                stack.append(num)\n\n算法分析\n时间复杂度：O(n²)\n空间复杂度：O(n) (递归栈空间)\n核心技巧：多递归函数配合 + 选择排序思想\n\n\n题目七：打印n层汉诺塔问题的最优移动轨迹问题描述打印n层汉诺塔问题的最优移动轨迹。\n核心思想这是一个经典的递归分治问题。要将 i 个盘子从 A 移动到 C：\n\n先将 i-1 个盘子从 A 移动到 B (辅助柱)。\n再将第 i 个盘子 (最大的那个) 从 A 移动到 C。\n最后将 i-1 个盘子从 B 移动到 C。这个过程完美地将一个大问题分解为两个规模更小的相同问题和一个简单的单步操作。\n\n\n算法实现class TowerOfHanoi:    def hanoi(self, n: int):        &quot;&quot;&quot;        汉诺塔问题主函数入口        &quot;&quot;&quot;        if n &gt; 0:            self._f(n, &quot;左&quot;, &quot;右&quot;, &quot;中&quot;)    def _f(self, i: int, start: str, end: str, other: str):        &quot;&quot;&quot;        递归函数，解决将 i 个圆盘从 start 移动到 end 的问题        &quot;&quot;&quot;        # base case：如果只有一个圆盘，直接移动        if i == 1:            print(f&quot;移动圆盘 1 从 &#123;start&#125; 到 &#123;end&#125;&quot;)        else:            # 步骤1: 将 i-1 个圆盘从 start 移动到 other            self._f(i - 1, start, other, end)            # 步骤2: 移动第 i 个圆盘从 start 到 end            print(f&quot;移动圆盘 &#123;i&#125; 从 &#123;start&#125; 到 &#123;end&#125;&quot;)            # 步骤3: 将 i-1 个圆盘从 other 移动到 end            self._f(i - 1, other, end, start)\n\n执行过程示例（n&#x3D;3）解决 3 层汉诺塔问题的步骤：移动圆盘 1 从 左 到 右移动圆盘 2 从 左 到 中移动圆盘 1 从 右 到 中移动圆盘 3 从 左 到 右移动圆盘 1 从 中 到 左移动圆盘 2 从 中 到 右移动圆盘 1 从 左 到 右\n\n算法分析\n时间复杂度：O(2^n)\n空间复杂度：O(n) (递归栈空间)\n核心技巧：递归分治\n\n\n递归技巧总结1. 递归模板def recursive_function(parameters):    # base case: 递归终止条件    if base_condition:        return base_result        # 递归调用：分解问题    result = recursive_function(modified_parameters)        # 处理当前层的逻辑    current_result = process(result)        return current_result\n\n2. 回溯模板def backtrack(path, choices):    # base case    if satisfied:        result.append(path[:])  # 收集结果        return        for choice in choices:        # 做选择        path.append(choice)        backtrack(path, remaining_choices)        # 撤销选择        path.pop()\n\n3. 常见递归模式选择模式# 对每个元素有选择：要 or 不要def choose(i, path):    if i == len(arr):        process(path)        return        # 要当前元素    path.append(arr[i])    choose(i + 1, path)    path.pop()        # 不要当前元素    choose(i + 1, path)\n\n交换模式# 全排列问题def permute(arr, i):    if i == len(arr):        process(arr)        return        for j in range(i, len(arr)):        swap(arr, i, j)        permute(arr, i + 1)        swap(arr, i, j)  # 回溯\n\n复杂度分析总结\n\n\n题目\n时间复杂度\n空间复杂度\n核心技巧\n\n\n\n字符串子序列\nO(2^n × n)\nO(2^n × n)\n选择模式 + set去重\n\n\n数组组合\nO(2^n × n)\nO(2^n × n)\n排序 + 剪枝去重\n\n\n无重复全排列\nO(n! × n)\nO(n!)\n交换模式 + 回溯\n\n\n有重复全排列\nO(n! × n)\nO(n!)\n交换模式 + 集合去重\n\n\n递归逆序栈\nO(n²)\nO(n)\n双递归函数\n\n\n递归排序栈\nO(n²)\nO(n)\n多递归函数\n\n\n汉诺塔\nO(2^n)\nO(n)\n递归分治\n\n\n学习建议\n理解递归本质：递归就是函数调用自己，关键在于找到递归关系和base case\n\n掌握常见模式：\n\n选择模式（子集、组合问题）\n交换模式（排列问题）\n分治模式（汉诺塔、归并排序等）\n\n\n注意回溯时机：\n\n何时需要回溯（恢复现场）\n何时不需要回溯（使用额外空间）\n\n\n优化技巧：\n\n剪枝去重 vs set去重\n空间复用（固定长度数组 + size指针）\n预处理（排序、哈希表等）\n\n\n递归栈深度：注意递归深度，避免栈溢出\n\n实践建议：\n\n多画递归树理解执行过程\n从简单案例开始推导\n注意边界条件的处理\n\n\n\n递归是解决很多复杂问题的有力工具，掌握好递归的思想和常见模式，可以大大提升解决问题的能力。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","递归","回溯","DFS"]},{"title":"数据结构与算法自学笔记（10）- 异或运算和位运算的骚操作","url":"/2025/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89-%20%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了异或运算和位运算的高效技巧与应用，包括了class030 -&gt; class031的内容\n030【必备】异或运算的骚操作异或运算的核心性质前置知识异或运算是计算机科学中一种重要的位运算，符号为^。在Python中实现位运算题目时需要特别注意溢出和符号扩展问题，通常需要手动处理：\n# Python中处理溢出的常见方法result = (n &lt;&lt; shift_amount) &amp; 0xFFFFFFFF\n\n异或运算的四大核心性质1. 异或运算就是无进位相加这是理解异或运算最重要的性质，其他所有性质都可以由此推导得出。\n示例：5 ^ 35: 1013: 011   ---   110  (结果为6)\n\n\n2. 异或运算满足交换律和结合律同一批数字，不管异或顺序如何，最终结果都相同：\n\na ^ b &#x3D; b ^ a（交换律）\n(a ^ b) ^ c &#x3D; a ^ (b ^ c)（结合律）\n\n3. 特殊值性质# 任何数与0异或等于自己0 ^ n = n# 任何数与自己异或等于0n ^ n = 0\n\n4. 整体异或和性质如果整体异或和为x，其中某部分异或和为y，那么剩余部分的异或和为x ^ y。\n这个性质在很多题目中都有应用，特别是区间异或和相关的问题。\n有趣的数学问题让我们从一个有趣的概率问题开始：\n问题：袋子里有a个白球，b个黑球。每次取2个球：\n\n取出2个白球或2个黑球 → 放回1个白球\n取出1白1黑 → 放回1个黑球\n\n最终袋子里剩1个球，问这个球是黑球的概率？\n答案：\n\n如果黑球数量为偶数，最终是黑球的概率为0%\n如果黑球数量为奇数，最终是黑球的概率为100%\n完全与白球数量无关！\n\n\n这个结果与异或运算的性质有关：黑球数量的奇偶性在整个过程中保持不变。\n经典应用题目题目1：用异或运算交换两数的值def swap(arr, i, j):    # 注意：当i==j时会出错，实际开发中不推荐使用    if i != j:  # 添加安全检查        arr[i] = arr[i] ^ arr[j]  # 第一步        arr[j] = arr[i] ^ arr[j]  # 第二步：arr[j]变成原arr[i]        arr[i] = arr[i] ^ arr[j]  # 第三步：arr[i]变成原arr[j]# 更简洁的变量交换def swap_variables():    a, b = -2323, 10    a = a ^ b  # a现在是原a^原b    b = a ^ b  # b现在是原a^原b^原b = 原a    a = a ^ b  # a现在是原a^原b^原a = 原b    return a, b# 示例用法if __name__ == &quot;__main__&quot;:    a = -2323  # 定义a    b = 10     # 定义b  因为a^b=b^a ，这么操作的前提是a和b都有自己的内存空间    a = a ^ b  # 第一步，a和b异或后的结果给a    b = a ^ b  # 第二步，a和b再次异或的结果赋给b，b&#x27;=(a^b)^b    a = a ^ b  # 第三步，a和b再次异或的结果赋给a,a&#x27;&#x27;=a^b^((a^b)^b)=a^b^a^b^b=a^b^a，根据交换律，a^b^a=a^a^b=b    print(a)   # 输出此时的a    print(b)   # 输出此时的b    arr = [3, 5]          # 定义一个数组    swap(arr, 0, 1)       # 交换arr[0]和arr[1]    print(arr[0])         # 输出交换后的arr[0],输出3    print(arr[1])         # 输出交换后的arr[1],输出5    swap(arr, 0, 0)       # 交换同一个元素（java会出错，需谨慎，但是python不会） Python的整数对象是不可变的，每次赋值都会创建新的整数对象。更重要的是，Python的异或运算对于相同值的结果是 0，这是数学上正确的，内存模型不同：Java：直接操作内存中的值Python：操作的是对象的引用，整数是不可变对象    print(arr[0])         # 输出arr[0]，输出3    print(arr[1])         # 输出arr[1]，输出5\n\n原理分析：\n\n第一步：a = a ^ b，a存储了原始a和b的异或结果\n第二步：b = a ^ b ，则 b&#39;=(a^b)^b\n第三步：a = a ^ b ，则 a&#39;&#39;=a^b^((a^b)^b)=a^b^a^b^b=a^b^a，根据交换律，a^b^a=a^a^b=b\n\n题目2：不用判断语句返回两数最大值# 测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76def flip(n):    &quot;&quot;&quot;翻转0和1&quot;&quot;&quot;    return n ^ 1  # 0变1，1变0def sign(n):    &quot;&quot;&quot;非负数返回1，负数返回0&quot;&quot;&quot;    return flip((n &gt;&gt; 31) &amp; 1)    #因为负数符号位为1，正数符号位为0，所以负数右移31位后符号位为1，正数右移31位后符号位为0    # 右移后得到的值，可能不是严格的0或1，尤其在Python里，负数右移得到的是全1（二进制全是1，对应十进制-1）。    # 所以为了保证只取最低1位（也就是现在的符号位），要 &amp; 1。    # 如果结果是0，0 &amp; 1 = 0。    # 如果结果是-1，-1 &amp; 1 = 1（因为-1的二进制补码是全1)def getMax1(a, b):    # 有溢出风险的实现，若c溢出了的话会出错    c = a - b                    # 计算差值    returnA = sign(c)            # 差值非负则返回a    returnB = flip(returnA)      # 差值负则返回b    return a * returnA + b * returnB  # 保证互斥就行def getMax2(a, b):    # 没有溢出风险的实现，增加了一个判断a、b符号的逻辑    c = a - b                    # 差值    sa = sign(a)                 # a的符号，非负返回1，负数返回0    sb = sign(b)                 # b的符号    sc = sign(c)                 # 差值的符号    diffAB = sa ^ sb             # 判断a和b的符号是否一样，如果符号不同，则为1；符号一样，则为0    sameAB = flip(diffAB)        # 符号相同，则为1    returnA = diffAB * sa + sameAB * sc  # 决定返回哪个，diffAB和sameAB只有一个能为1，a和b的符号不同，且a非负，则返回1；a和b的符号相同，且c非负，则返回1，整合起来就是判断a    returnB = flip(returnA)                # 另一个    return a * returnA + b * returnB       # 返回最大值#示例用法if __name__ == &quot;__main__&quot;:    a = -2**31                # Integer.MIN_VALUE    b = 2**31 - 1             # Integer.MAX_VALUE    # getMax1方法会错误，因为溢出    print(getMax1(a, b))      # 可能错误    # getMax2方法永远正确    print(getMax2(a, b))      # 永远正确\n\n核心思想：\n\n通过位运算判断数字符号\n用乘法实现条件选择，避免if语句\n处理溢出情况，确保算法的鲁棒性\n\n题目3：找到缺失的数字题目：给定包含n个不同数字的数组，数字范围为[0,n]，找出缺失的那个数字。\n# 测试链接 : https://leetcode.cn/problems/missing-number/def missingNumber(nums):    # eorAll用于异或0~n，0到10之间的数字缺了一个    # eorHas用于异或数组内所有数    eorAll = 0                  # 初始化eorAll    eorHas = 0                  # 初始化eorHas    for i in range(len(nums)):  # 遍历数组        eorAll ^= i             # 累计异或0~n-1，把下标0-n-1全都异或起来        eorHas ^= nums[i]       # 累计异或数组元素，    eorAll ^= len(nums)         # 最后再异或n    return eorAll ^ eorHas      # 缺失的数即为两者异或结果，这是由于交换律，所有出现两次的数字会相互抵消，最后只剩下缺失的数字# 示例用法# print(missingNumber([3,0,1]))  # 输出2\n\n原理：\n\n完整序列：0,1,2,…,n\n给定数组：缺少一个数字\n两者异或后，相同数字抵消，剩下的就是缺失数字\n\n题目4：找到出现奇数次的数字题目：数组中只有一种数出现奇数次，其他数都出现偶数次，找到这个数。\n# 测试链接 : https://leetcode.cn/problems/single-number/def singleNumber(nums):    eor = 0                     # 初始化eor    for num in nums:            # 遍历数组        eor ^= num              # 累计异或    return eor                  # 返回结果，原理同code03# 示例用法# print(singleNumber([2,2,1]))  # 输出1\n\n\n题目5：找到两个出现奇数次的数字题目：数组中有2种数出现奇数次，其他数都出现偶数次，返回这2种数。\n# https://leetcode.cn/problems/single-number-iii/def singleNumber(nums):    eor1 = 0    for num in nums:        # nums中有2种数a、b出现了奇数次，其他的数都出现了偶数次        eor1 ^= num                        # 累计异或所有数，得到a^b    # eor1 : a ^ b    # Brian Kernighan算法    # 提取出二进制里最右侧的1    rightOne = eor1 &amp; -eor1                # &amp;是与运算，返回1和1相与为1，0和0相与为0，1和0相与为0；    # n 的二进制表示中，最右边的 1 之前可能有若干个 0。    # -n 的二进制表示会反转所有位，然后加1，相当于把最右边的 1 及其右边的 0 都翻转了。    # 这样，n &amp; -n 只会留下最右边的 1，其余位都变成0。    # 因为~n= n的取反+1，所以能够提取最右侧的1，所以就拿这个最右侧的1来分组    eor2 = 0    # 此外因为a^b不尽相同，则从左到右，a和b的二进制状态中，必然有一位不同（能找到一个位置上是1，假设是第k位），则可以利用这个不同进行分组    # 分成两组，一组是第k位为0的数，另一组是第k位为1的数，而q，b一定分别落在不同的组里    # 所以额外引入一个变量eor2来得到a或者b    for num in nums:        if (num &amp; rightOne) == 0:          # 分组，最后返回，            eor2 ^= num                    # 分组后累加异或，对分到“那一位为0”这一组的数进行异或。    # 这组里除了 a 或 b 以外，其他数都成对出现（偶数次），异或后消掉了，只剩下一个（假设是 a）。    return [eor2, eor1 ^ eor2]             # 返回那两个数# 示例用法# print(singleNumber([1,2,1,3,2,5]))  # 输出[3,5]（顺序无关）\n\n关键技巧：\n\nn &amp; -n：提取最右侧的1\n用这个位进行分组，将a和b分到不同组\n每组内除了a或b，其他数都成对出现\n\nBrian Kernighan算法原理：\n假设 eor1 = 6 (二进制: 110)-eor1 = -6 (二进制: ...11111010)  // 补码表示eor1 &amp; -eor1 = 110 &amp; ...11111010 = 010 = 2\n\n题目6：通用的k次方法题目：数组中只有1种数出现次数少于m次，其他数都出现m次，找到这个数。\n# 测试链接 : https://leetcode.cn/problems/single-number-ii/# 注意 : 测试题目只是通用方法的一个特例，课上讲了更通用的情况def singleNumber(nums):    return find(nums, 3)  # 调用更通用的方法，m=3# 更通用的方法# 已知数组中只有1种数出现次数少于m次，其他数都出现了m次# 返回出现次数小于m次的那种数def find(arr, m):    # 统计每个位有多少个1，如果一个位置的1的个数不是m的整数倍，说明该位属于出现次数小于m次的数    # cnts[0] : 0位上有多少个1    # cnts[i] : i位上有多少个1    # cnts[31] : 31位上有多少个1    cnts = [0] * 32    for num in arr:        for i in range(32):            cnts[i] += (num &gt;&gt; i) &amp; 1   # 统计每个位有多少个1    ans = 0    for i in range(32):        if cnts[i] % m != 0:            # 如果不是m的整数倍，说明该位属于少于m次的数            ans |= 1 &lt;&lt; i               # 把该位设置为1，|= 是“按位或赋值”运算符，相当于 ans = ans | (1 &lt;&lt; i)    # 处理负数    if (ans &amp; (1 &lt;&lt; 31)) != 0:          # 如果最高位是1，说明是负数        # 检查ans的第31位（最高位）是否为1。在32位整数里，第31位是符号位，1表示负数（补码）        ans -= 1 &lt;&lt; 32                  # 当检测到ans的第31位（最高位）为1时，把它转化为Python中的负数表示        #在32位二进制补码表示中，负数的真实值等于它的二进制表示减去2^32，而Python的int没有溢出，补码负数要手动转换    return ans# 示例用法# print(singleNumber([2,2,3,2]))  # 输出3\n\n算法思路：\n\n统计每一位上1的个数\n如果某位上1的个数不是m的整数倍，说明目标数字在该位为1\n重新构造答案\n\n时间复杂度分析\n\n\n操作\n时间复杂度\n空间复杂度\n说明度\n\n\n\n交换两数\nO(1)\nO(1)\n常数时间操作\n\n\n找最大值\nO(1)\nO(1)\n位运算替代条件判断\n\n\n找缺失数字\nO(n)\nO(1)\n遍历数组一次\n\n\n找一个奇数次数字\nO(n)\nO(1)\n异或运算线性时间\n\n\n找两个奇数次数字\nO(n)\nO(1)\n两次遍历，分组处理\n\n\n通用k次方法\nO(n)\nO(1)\n虽然有32层循环但32是常数\n\n\n核心技巧总结1. 位运算技巧# 提取最右侧的1rightOne = n &amp; -n# 判断数字符号sign = (n &gt;&gt; 31) &amp; 1# 翻转0和1flip = n ^ 1# 设置某位为1ans |= 1 &lt;&lt; i\n\n2. 异或运算应用模式\n消除配对：相同数字异或为0，利用这个性质找到不配对的数字\n分组策略：根据某一位的不同将数组分成两组\n位统计：统计每一位上1的个数，重构答案\n\n3. Python特有注意事项# 处理负数if (ans &amp; (1 &lt;&lt; 31)) != 0:    ans -= 1 &lt;&lt; 32# 处理溢出result = (n &lt;&lt; shift_amount) &amp; 0xFFFFFFFF\n\n异或运算虽然看起来简单，但在算法设计中有着广泛而巧妙的应用。掌握这些核心性质和应用模式，能够帮助我们解决很多看似困难的问题。特别是在处理数组中的配对、查找问题时，异或运算往往能提供O(1)空间复杂度的优雅解法。\n031【必备】位运算的骚操作前言位运算有很多奇技淫巧，位运算的速度非常快，仅次于赋值操作，常数时间极好！属于是大佬骚解，左神讲解，苯人copy就对了。\n特别提醒：Python实现位运算的题目需要特别注意，需要自己去手动处理溢出和符号扩展等问题。\n# Python中处理溢出的常见方法result = (n &lt;&lt; shift_amount) &amp; 0xFFFFFFFF\n\n核心算法：Brian Kernighan算法Brian Kernighan算法是位运算中的经典算法，用于提取二进制数中最右侧的1。\n算法原理# 提取最右侧的1rightOne = n &amp; -n\n\n工作原理：\n\nn的二进制表示中，最右边的1右边可能有若干个0\n-n是n的补码表示（所有位取反后加1），所以可以进位到最右边的1，这个1左边的和n 的左边也都是完全相反的\nn &amp; -n只会保留最右边的1，其余位都变成0\n\n示例演示：\n假设 n = 12 (二进制: 1100)-n = -12 (二进制: ...11110100)  // 补码表示n &amp; -n = 1100 &amp; ...11110100 = 0100 = 4\n\n这个算法在很多高级位运算技巧中都有应用，是理解后续算法的基础。\n经典应用题目题目1：判断一个整数是不是2的幂问题描述：给定一个整数n，判断它是否为2的幂次方。\n# 测试链接: https://leetcode.cn/problems/power-of-two/def isPowerOfTwo(n):    # n &gt; 0 确保正数    # n &amp; -n 提取最右侧的1，如果n是2的幂，只会有一个1    # n == (n &amp; -n) 则说明n只有一个1    return n &gt; 0 and n == (n &amp; -n)# 示例用法print(isPowerOfTwo(4))   # True (4 = 2^2)print(isPowerOfTwo(6))   # False (6的二进制是110，有两个1)print(isPowerOfTwo(16))  # True (16 = 2^4)\n\n算法原理：\n\n2的幂的特点：二进制表示中只有一个1\n例如：1(1), 2(10), 4(100), 8(1000), 16(10000)\n利用Brian Kernighan算法提取最右侧的1\n如果提取的结果等于原数，说明只有一个1\n\n时间复杂度：O(1)空间复杂度：O(1)\n题目2：判断一个整数是不是3的幂问题描述：给定一个整数n，判断它是否为3的幂次方。\n# 测试链接: https://leetcode.cn/problems/power-of-three/def isPowerOfThree(n):    # 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子    # 1162261467是int型范围内，最大的3的幂，它是3的19次方    # 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么    # 1162261467 % n == 0    # 反之如果1162261467 % n != 0 说明n一定含有其他因子    return n &gt; 0 and 1162261467 % n == 0# 示例用法print(isPowerOfThree(27))  # True (27 = 3^3)print(isPowerOfThree(45))  # False (45 = 3^2 * 5)print(isPowerOfThree(81))  # True (81 = 3^4)\n\n算法原理：\n\n利用数论知识：如果n是3的幂，那么n只含有质数因子3\n1162261467 &#x3D; 3^19，是32位整数范围内最大的3的幂\n如果n也只含有质数因子3，那么1162261467一定能被n整除\n这种方法引入了额外的先验知识，是一种巧妙的数学技巧\n\n关键洞察：\n\n3^19 &#x3D; 1162261467 (32位int范围内最大的3的幂)\n如果n是3的幂，则n只有质数因子3\n因此最大的3的幂能被所有较小的3的幂整除\n\n时间复杂度：O(1)空间复杂度：O(1)\n题目3：返回大于等于n的最小的2的幂问题描述：给定一个非负整数n，返回大于等于n的最小的2的幂次方。\ndef near2power(n):    if n &lt;= 0:        return 1  # 非正数直接返回1    n -= 1        # 先减1，保证等于2的幂时不变，这样处理可以保证：如果 n 本身就是 2 的幂，返回的还是 n 本身。    # 例如 n = 8，n-1 = 7 (0111)，后面填充后再加1，结果还是 8    n |= n &gt;&gt; 1   #这个是或逻辑，右移1位再取或可以保证用1填充右边    n |= n &gt;&gt; 2      n |= n &gt;&gt; 4       n |= n &gt;&gt; 8       n |= n &gt;&gt; 16  # 这一坨代码的作用是把左边第一个1开始，往右的1都变成1    n += 1        # 再加1得到最小2的幂    # Python没有int溢出，可以直接返回    if n &gt; 0x7fffffff:        return -0x80000000  # 超过int范围，返回整数最小值    return n# 示例用法print(near2power(100))  # 128 (2^7)print(near2power(16))   # 16 (本身就是2的幂)print(near2power(33))   # 64 (2^6)\n\n算法原理详解：\n让我们以n = 100为例，详细演示算法过程：\nStep 1：n = 100，先减1得到n = 99\n99 的二进制：01100011\n\nStep 2：逐步填充最高位右边的所有位\nn = 99        : 01100011n &gt;&gt; 1        : 00110001n |= n &gt;&gt; 1   : 01110011  (把最高位向右扩展1位)n &gt;&gt; 2        : 00011100n |= n &gt;&gt; 2   : 01111111  (继续向右扩展2位)n &gt;&gt; 4        : 00000111n |= n &gt;&gt; 4   : 01111111  (继续向右扩展4位)... (8位和16位移动不会改变结果，因为数字较小)\n\nStep 3：n + 1 = 01111111 + 1 = 10000000 = 128\n核心思想：\n\n先减1：确保如果n本身是2的幂，结果仍然是n\n逐步填充：将最高位1右边的所有位都填充为1\n加1：得到下一个2的幂\n\n为什么先减1？\n\n如果n&#x3D;16(10000)，我们希望结果是16而不是32\n减1后：15(01111)\n填充后：15(01111)\n加1后：16(10000) ✓\n\n位运算技巧解析：\n# 通过连续的右移和或运算，将最高位的1向右&quot;传播&quot;n |= n &gt;&gt; 1   # 传播1位n |= n &gt;&gt; 2   # 传播2位  n |= n &gt;&gt; 4   # 传播4位n |= n &gt;&gt; 8   # 传播8位n |= n &gt;&gt; 16  # 传播16位（覆盖32位整数的所有位）\n\n时间复杂度：O(1) - 固定数量的位运算空间复杂度：O(1) - 只使用常数额外空间\n题目4：区间[left, right]内所有数字按位与的结果问题描述：给定两个整数left和right，返回区间[left, right]内所有数字按位与的结果。\n# 测试链接: https://leetcode.cn/problems/bitwise-and-of-numbers-range/def rangeBitwiseAnd(left, right):    while left &lt; right:        right -= right &amp; -right  # 每次消掉right最右边的1    return right #当 left == right 时，区间内只有1个数，直接返回即可；若left&gt;right, 也照样返回right# 示例用法print(rangeBitwiseAnd(5, 7))   # 输出4\n\n算法原理：\n按位与的关键特性：\n\n如果区间[left, right]内某一位在这段区间内经历了从0到1的变化，那么最终结果这一位一定为0\n只有left和right的公共前缀部分才可能保留为1\n\n消去变化的位：\n\nright &amp; -right取出right的最右侧的1（最低位的1）\n每次把right的最右边的1消掉，right变小，靠近left\n只要left &lt; right，说明区间还有变化，继续消掉最低位的1\n\n详细示例分析：\n区间[5, 7]的按位与：5: 1016: 110  7: 111-----结果: 100 = 4分析过程：- 最低位：5(1), 6(0), 7(1) → 有0有1 → 结果为0- 第2位：5(0), 6(1), 7(1) → 有0有1 → 结果为0  - 第3位：5(1), 6(1), 7(1) → 全为1 → 结果为1\n\n算法执行过程：\nleft=5(101), right=7(111)第1次：right &amp; -right = 111 &amp; 001 = 001       right = 111 - 001 = 110       left=5, right=6，继续第2次：right &amp; -right = 110 &amp; 010 = 010         right = 110 - 010 = 100       left=5, right=4，left &gt; right，结束返回right=4\n\n时间复杂度：O(log n) - 最多执行log(right)次循环空间复杂度：O(1)\n看题目5和题目6前的提醒\n\n题目5和题目6代码看着跟脑子有大病一样，承认很强但似乎有点太嘚瑟了，是这样吗？\n不是的，条件判断相比于赋值、位运算、算术运算是稍慢的，所以其实有现实意义\n但是不需要追求在练算法过程中尽量少写条件判断，\n那样会带来很多不必要的困扰，还是要写尽量直白、尤其是自己能理解的代码最好\n大牛的实现欣赏完理解就好，下次当模版直接用\n还是那句话：属于是大佬骚解，左神讲解，苯人copy就对了\n\n题目5：反转二进制位（超自然版）问题描述：将一个32位无符号整数的二进制位完全反转。\n# 测试链接: https://leetcode.cn/problems/reverse-bits/def reverseBits(n):    # 逆序二进制的状态，分治思想：1v1 → 2v2 → 4v4 → 8v8 → 16v16    n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1)   # 交换奇偶位    n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2)   # 交换每两位    n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4)   # 交换每四位    n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8)   # 交换每八位    n = (n &gt;&gt; 16) | ((n &amp; 0xffff) &lt;&lt; 16)                    # 交换高低16位    return n &amp; 0xffffffff  # 保证结果32位# 示例用法print(reverseBits(43261596))  # 输出964176192\n\n算法原理深度解析：\n这是著名的位分组逆序法（Bitwise reversal by mask），采用分治思想：\n第1步：交换奇偶位\n# 0xaaaaaaaa = 10101010...10101010 (偶数位为1)# 0x55555555 = 01010101...01010101 (奇数位为1)例如：n = 11010110奇数位(从右数第1,3,5,7位): 1_1_1_1_ = 1111偶数位(从右数第2,4,6,8位): _1_0_0_0 = 1000交换后：01101101\n\n第2步：交换每两位\n# 0xcccccccc = 11001100...11001100 (每两位的高位)# 0x33333333 = 00110011...00110011 (每两位的低位)例如：n = 01101101分组：01|10|11|01交换：10|01|11|10 = 10011110\n\n第3步-5步：类似地交换4位、8位、16位\n完整示例演示：\n原数：11010110 (从左到右)目标：01101011 (反转后)Step1(交换奇偶位)：01101101Step2(交换每2位)：  10011110  Step3(交换每4位)：  11101001Step4(交换每8位)：  01101011 ✓\n\n为什么效率极高？\n\n没有任何条件判断和循环\n全部是位操作：按位与、或、移位\n5次操作完成32位反转，而传统方法需要32次循环\n\n时间复杂度：O(1) - 固定5次位运算空间复杂度：O(1)\n题目6：统计二进制中1的个数（超自然版）问题描述：计算两个整数的汉明距离（二进制位不同的位置数目）。\n# 测试链接: https://leetcode.cn/problems/hamming-distance/def hammingDistance(x, y):    return cntOnes(x ^ y)  # 先异或，统计不同位数def cntOnes(n):    # 分组统计法：每次合并相邻组的1的个数    n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555)     # 每两位一组    n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333)     # 每四位一组      n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f)     # 每八位一组    n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff)     # 每十六位一组    n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff)    # 全部加起来    return n# 示例用法print(hammingDistance(1, 4))  # 输出2 (1:001, 4:100, 异或:101, 有2个1)print(cntOnes(13))           # 输出3 (13:1101, 有3个1)\n\n算法原理深度解析：\n这是分组统计法，核心思想是逐步合并局部的1的个数：\n详细示例（n &#x3D; 13 &#x3D; 1101）：\n初始状态：\nn = 1101 (二进制)\n\n第1步：每两位统计1的个数\n# 0x55555555 = 01010101...01010101n &amp; 0x55555555     = 1101 &amp; 0101 = 0101  # 保留奇数位(n &gt;&gt; 1) &amp; 0x55555555 = 0110 &amp; 0101 = 0100  # 保留偶数位(右移后)相加：0101 + 0100 = 1001\n此时n的每2位表示该2位内1的个数：\n\n10（二进制）&#x3D; 2（十进制）：前2位有2个1\n01（二进制）&#x3D; 1（十进制）：后2位有1个1\n\n第2步：每四位统计1的个数\n# 0x33333333 = 00110011...00110011  n &amp; 0x33333333     = 1001 &amp; 0011 = 0001(n &gt;&gt; 2) &amp; 0x33333333 = 0010 &amp; 0011 = 0010相加：0001 + 0010 = 0011\n此时n&#x3D;0011，表示整个4位中有3个1。\n后续步骤类似，最终得到总的1的个数，更高位依此类推，每一步后，n的每2^k位表示这2^k位内1的总个数，最终全加到最低位\n状态变化图解：\n原始：  1101 (每位表示原始位值)Step1： 1001 (每2位表示该2位内1的个数)  Step2： 0011 (每4位表示该4位内1的个数)Step3： 0011 (8位内1的个数，但只有4位所以不变)...最终：  3 (总共3个1)\n\n为什么叫”分组统计”？\n\n不是独立统计每组，而是累加合并\n每步都使用上一步的统计结果\n最终所有1的个数聚合到最低位\n\n核心技巧总结：\n\n利用掩码分离不同位置的位\n用加法累积局部统计结果  \n分治思想：部分→整体\n\n时间复杂度：O(1) - 固定5次位运算空间复杂度：O(1)\n算法性能对比与应用场景性能对比表\n\n\n算法\n时间复杂度\n空间复杂度\n核心技巧\n适用场景\n\n\n\n判断2的幂\nO(1)\nO(1)\nBrian Kernighan算法\n内存分配、哈希表大小\n\n\n判断3的幂\nO(1)\nO(1)\n数论+预计算\n数学问题、特殊判断\n\n\n最小2的幂\nO(1)\nO(1)\n位填充技术\n内存对齐、缓存优化\n\n\n区间按位与\nO(log n)\nO(1)\n公共前缀\n区间查询、数据结构\n\n\n反转二进制\nO(1)\nO(1)\n分治+掩码\n图像处理、编码转换\n\n\n统计1的个数\nO(1)\nO(1)\n分组统计\n数据压缩、校验算法\n\n\n实际应用场景1. 系统编程中的应用\n# 内存对齐检查def isAligned(address, alignment):    return isPowerOfTwo(alignment) and (address &amp; (alignment - 1)) == 0# 快速向上对齐到2的幂def alignUp(size, alignment):    return (size + alignment - 1) &amp; ~(alignment - 1)\n\n2. 数据结构优化\n# 哈希表大小优化class HashTable:    def __init__(self, initial_size):        self.size = near2power(initial_size)  # 确保是2的幂        self.table = [None] * self.size        def hash(self, key):        return hash(key) &amp; (self.size - 1)  # 快速取模\n\n3. 图像处理应用\n# 图像位操作def mirrorImage(pixel_data):    return [reverseBits(pixel) for pixel in pixel_data]# 图像特征提取def hammingDistance(img1, img2):    return sum(cntOnes(p1 ^ p2) for p1, p2 in zip(img1, img2))\n\n核心技巧模板总结1. Brian Kernighan系列# 基础：提取最右侧的1rightOne = n &amp; -n# 应用1：判断2的幂isPowerOfTwo = n &gt; 0 and n == (n &amp; -n)# 应用2：清除最右侧的1  n = n &amp; (n - 1)# 应用3：计算1的个数（朴素版）def countOnes(n):    count = 0    while n:        n = n &amp; (n - 1)  # 每次清除最右侧的1        count += 1    return count\n\n2. 位填充技术模板# 标准位填充（用于找下一个2的幂）def fillBits(n):    n |= n &gt;&gt; 1    n |= n &gt;&gt; 2    n |= n &gt;&gt; 4      n |= n &gt;&gt; 8    n |= n &gt;&gt; 16    return ndef nextPowerOfTwo(n):    if n &lt;= 1: return 1    return fillBits(n - 1) + 1\n\n3. 分治+掩码模板# 反转二进制位模板def reverseBits(n, bits=32):    if bits == 32:        n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1)        n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2)        n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4)        n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8)        n = (n &gt;&gt; 16) | ((n &amp; 0xffff) &lt;&lt; 16)    return n# 分组统计模板  def countOnes(n):    n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555)    n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333)    n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f)    n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff)    n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff)    return n\n\n4. Python位运算注意事项# 符号处理def handleSign(n):    if (n &amp; (1 &lt;&lt; 31)) != 0:  # 检查符号位        n -= 1 &lt;&lt; 32          # 转换为Python负数    return n# 溢出检查def checkOverflow(n):    return -0x80000000 &lt;= n &lt;= 0x7fffffff# 掩码应用def mask32bit(n):    return n &amp; 0xffffffff\n\n扩展思考1. 为什么位运算如此高效？\nCPU层面：位运算是最接近硬件的操作，执行速度极快\n并行性：现代CPU可以并行处理多个位\n无条件判断：避免了分支预测失误的性能损失\n\n2. 什么时候不应该使用这些技巧？\n代码可读性：团队协作时，清晰比技巧更重要\n过度优化：在非性能关键路径上使用可能得不偿失\n平台差异：某些技巧在不同架构上表现可能不同\n\n3. 如何掌握位运算？\n理解原理：每个技巧背后的数学&#x2F;逻辑基础\n动手实践：在纸上画出二进制变化过程\n模板化：将常用技巧整理成模板\n适度应用：在合适的场景使用，不要炫技\n\n位运算虽然看起来神秘，但其本质是对二进制数据的高效操作。掌握了这些核心技巧后，不仅能解决特定的算法问题，更能在系统编程、性能优化等场景中发挥重要作用。关键是要在”技巧性”和”可读性”之间找到平衡，让代码既高效又易维护。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","位运算","Brian Kernighan算法","算法技巧"]},{"title":"数据结构与算法自学笔记（1）- 二进制&位运算&排序算法&二分搜索","url":"/2025/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%20%E4%BA%8C%E8%BF%9B%E5%88%B6&%E4%BD%8D%E8%BF%90%E7%AE%97&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了class002 -&gt; class 007的内容，涵盖了社会实验模拟、位运算、基础排序算法、算法验证方法、二分搜索以及复杂度分析等核心内容。\n原代码是java版，我改成了python\n\n002【入门】从社会实验到入门提醒基尼系数的理论基础基尼系数是经济学中衡量收入分配不平等程度的重要指标，其数学定义为：\n$$G &#x3D; \\frac{\\sum_{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{n}|x_i - x_j|}{2n\\sum_{i&#x3D;1}^{n}x_i}$$\n其中 $x_i$ 表示第 $i$ 个个体的财富值，$n$ 为总人数。\n基尼系数的经济学意义\nG &#x3D; 0：完全平等，所有人财富相同\nG &#x3D; 1：完全不平等，一人拥有全部财富  \nG &#x3D; 0.4-0.5：国际公认的贫富差距警戒线\nG &gt; 0.5：社会可能面临动荡风险\n\n财富分配模拟实验通过计算机模拟研究在完全随机的财富转移过程中，社会财富分配的自然演化规律。\nimport numpy as npimport randomdef calculate_gini(wealth):    &quot;&quot;&quot;    计算基尼系数的函数    参数: wealth - 财富分布列表    返回: 基尼系数值    &quot;&quot;&quot;    n = len(wealth)                        # 获取人数    sum_of_wealth = sum(wealth)            # 计算总财富    sum_of_absolute_differences = 0        # 初始化财富差异总和        # 计算所有个体间财富差异的绝对值之和    for i in range(n):        for j in range(n):            sum_of_absolute_differences += abs(wealth[i] - wealth[j])        # 根据基尼系数公式计算并返回结果    return sum_of_absolute_differences / (2 * n * sum_of_wealth)def experiment(n, t):    &quot;&quot;&quot;    财富分配模拟实验    参数: n - 人数, t - 模拟轮数    &quot;&quot;&quot;    wealth = [100] * n                     # 初始化每人财富为100        for _ in range(t):                     # 进行t轮模拟        has_money = [w &gt; 0 for w in wealth]  # 判断每个人是否有钱可转        transfers = []                     # 记录本轮转账列表                for j in range(n):                 # 遍历每个人            if has_money[j]:               # 如果该人有钱                other = j                  # 初始化接收者为自己                while other == j:          # 确保接收者不是自己                    other = random.randint(0, n - 1)  # 随机选择其他人                transfers.append((j, other))          # 记录转账关系                # 统一执行所有转账，避免执行顺序影响结果        for giver, receiver in transfers:            wealth[giver] -= 1             # 转出者财富减1            wealth[receiver] += 1          # 接收者财富加1        wealth.sort()                          # 按财富排序便于观察分布        # 输出结果分析    print(&quot;财富分布(从贫穷到富有):&quot;)    for idx, w in enumerate(wealth):        print(int(w), end=&#x27; &#x27;)        if idx % 10 == 9:                  # 每10个数换行            print()    print()    print(&quot;社会基尼系数:&quot;, calculate_gini(wealth))\n\n实验意义与启示\n随机性中的必然性：即使在完全公平的随机转移规则下，财富差距仍会自然产生\n马太效应：财富分配存在自然的分化趋势\n社会政策启示：需要主动的调节机制来维护社会公平\n\n\n003【入门】二进制和位运算计算机数值表示系统正数的二进制表示正数采用标准的二进制表示法，最高位为符号位（0表示正数）。\n负数的补码表示负数采用补码（Two’s Complement）表示：\n\n原码按位取反\n结果加1\n\n$$\\text{负数补码} &#x3D; \\sim(\\text{原码}) + 1$$\ndef print_binary(num):    &quot;&quot;&quot;    打印32位二进制表示    参数: num - 要打印的整数    &quot;&quot;&quot;    s = &#x27;&#x27;                                 # 初始化二进制字符串    for i in range(31, -1, -1):           # 从最高位到最低位遍历        # 通过位与运算判断第i位是否为1        s += &#x27;1&#x27; if (num &amp; (1 &lt;&lt; i)) != 0 else &#x27;0&#x27;    print(s)                              # 输出32位二进制表示# 演示正负数的二进制表示if __name__ == &quot;__main__&quot;:    a = 78                                # 正数示例    print(f&quot;正数&#123;a&#125;的二进制表示:&quot;)    print_binary(a)        b = -6                                # 负数示例      print(f&quot;负数&#123;b&#125;的二进制表示:&quot;)    print_binary(b)        # 验证补码计算    print(f&quot;~&#123;a&#125; + 1 = &#123;~a + 1&#125;&quot;)        # 计算a的相反数    print_binary(~a + 1)\n\n核心位运算操作基本位运算符详解def bitwise_operations_demo():    &quot;&quot;&quot;位运算操作演示&quot;&quot;&quot;    &#x27;&#x27;&#x27;0b 是Python中表示二进制数字的前缀。&#x27;&#x27;&#x27;    g = 0b0001010                         # 二进制字面量：10    h = 0b0001100                         # 二进制字面量：12        print(&quot;操作数g:&quot;, bin(g))    print(&quot;操作数h:&quot;, bin(h))        # 按位或运算：有1则1    print(&quot;g | h  =&quot;, bin(g | h))         # 0b1110 = 14        # 按位与运算：全1则1      print(&quot;g &amp; h  =&quot;, bin(g &amp; h))         # 0b1000 = 8        # 按位异或运算：不同则1    print(&quot;g ^ h  =&quot;, bin(g ^ h))         # 0b0110 = 6def shift_operations_demo():    &quot;&quot;&quot;移位运算演示&quot;&quot;&quot;    i = 0b0011010                         # 二进制：26    print(f&quot;原数: &#123;i&#125;, 二进制: &#123;bin(i)&#125;&quot;)        # 左移运算：相当于乘以2的幂次    print(f&quot;&#123;i&#125; &lt;&lt; 1 = &#123;i &lt;&lt; 1&#125;&quot;)        # 26 * 2 = 52    print(f&quot;&#123;i&#125; &lt;&lt; 2 = &#123;i &lt;&lt; 2&#125;&quot;)        # 26 * 4 = 104      print(f&quot;&#123;i&#125; &lt;&lt; 3 = &#123;i &lt;&lt; 3&#125;&quot;)        # 26 * 8 = 208        # 右移运算：相当于除以2的幂次（向下取整）    k = 10    print(f&quot;&#123;k&#125; &gt;&gt; 1 = &#123;k &gt;&gt; 1&#125;&quot;)        # 10 / 2 = 5    print(f&quot;&#123;k&#125; &gt;&gt; 2 = &#123;k &gt;&gt; 2&#125;&quot;)        # 10 / 4 = 2    print(f&quot;&#123;k&#125; &gt;&gt; 3 = &#123;k &gt;&gt; 3&#125;&quot;)        # 10 / 8 = 1\n\n逻辑运算与位运算的重要区别def return_true():    print(&quot;执行了return_true函数&quot;)    return Truedef return_false():    print(&quot;执行了return_false函数&quot;)     return Falsedef logical_vs_bitwise():    &quot;&quot;&quot;演示逻辑运算与位运算的区别&quot;&quot;&quot;    print(&quot;=== 位运算测试 ===&quot;)    # 位运算：两个函数都会被调用    test1 = return_true() | return_false()    print(f&quot;位运算结果: &#123;test1&#125;&quot;)        print(&quot;=== 逻辑运算测试 ===&quot;)     # 逻辑运算：存在短路求值，第二个函数可能不被调用    test2 = return_true() or return_false()    print(f&quot;逻辑运算结果: &#123;test2&#125;&quot;)\n\n位运算的实际应用\n快速乘除法：左移代替乘法，右移代替除法\n奇偶性判断：num &amp; 1 == 0 判断偶数。这是因为：num &amp; 1 只保留 num 的二进制最低位，其余全部变成0。\n集合操作：用位掩码表示集合的并、交、差运算\n状态压缩：在动态规划中压缩状态空间\n\n\n004【入门】选择、冒泡、插入排序理解python中的class：什么是“实例化类”？\n类（class）：可以理解为一个“模具”或者“模板”，描述一类对象应该有哪些属性和行为。\n实例（instance）：就是根据这个“模具”制造出来的一个具体的“物品”。\n实例化：把类变成实例（对象）的过程，叫做实例化。\n\n选择排序（Selection Sort）算法思想每次从未排序部分选择最小（或最大）元素，将其放置到已排序部分的末尾。\n时间复杂度分析\n比较次数：$\\sum_{i&#x3D;0}^{n-2}(n-1-i) &#x3D; \\frac{n(n-1)}{2} &#x3D; O(n^2)$\n交换次数：$O(n)$\n总体复杂度：$O(n^2)$\n\nclass SortingAlgorithms:        @staticmethod    def swap(arr, i, j):        &quot;&quot;&quot;        交换数组中两个位置的元素        参数: arr - 数组, i,j - 要交换的索引        &quot;&quot;&quot;        arr[i], arr[j] = arr[j], arr[i]  # Python的元组赋值交换        @staticmethod    def selection_sort(arr):        &quot;&quot;&quot;        选择排序实现        时间复杂度: O(n²), 空间复杂度: O(1)        不稳定排序        &quot;&quot;&quot;        if arr is None or len(arr) &lt; 2:   # 边界条件检查            return                # 外层循环控制已排序部分的边界        for i in range(len(arr) - 1):            min_index = i                  # 假设当前位置为最小值                        # 内层循环在未排序部分寻找真正的最小值            for j in range(i + 1, len(arr)):                if arr[j] &lt; arr[min_index]:  # 找到更小的元素                    min_index = j           # 更新最小值索引                        # 将找到的最小值与当前位置交换            SortingAlgorithms.swap(arr, i, min_index)\n\n冒泡排序（Bubble Sort）算法思想重复遍历数组，比较相邻元素并在必要时交换，使得大元素逐渐”冒泡”到数组末尾。\n@staticmethoddef bubble_sort(arr):    &quot;&quot;&quot;    冒泡排序实现    时间复杂度: O(n²), 空间复杂度: O(1)      稳定排序    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:   # 边界条件检查        return        # 外层循环控制未排序部分的右边界    for end in range(len(arr) - 1, 0, -1):        # 内层循环进行相邻元素比较和交换        for i in range(end):            if arr[i] &gt; arr[i + 1]:    # 如果前面元素大于后面元素                SortingAlgorithms.swap(arr, i, i + 1)  # 交换位置                # 经过一轮后，最大元素&quot;冒泡&quot;到末尾\n\n冒泡排序的优化@staticmethod  def bubble_sort_optimized(arr):    &quot;&quot;&quot;    优化版冒泡排序：添加提前终止条件    如果某轮遍历中没有发生交换，说明数组已有序    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return            for end in range(len(arr) - 1, 0, -1):        swapped = False               # 标记本轮是否发生交换        for i in range(end):            if arr[i] &gt; arr[i + 1]:                SortingAlgorithms.swap(arr, i, i + 1)                swapped = True        # 发生了交换                if not swapped:               # 如果本轮没有交换            break                     # 数组已有序，提前结束\n\n插入排序（Insertion Sort）算法思想将数组分为已排序和未排序两部分，依次将未排序元素插入到已排序部分的正确位置。\n@staticmethoddef insertion_sort(arr):    &quot;&quot;&quot;    插入排序实现    时间复杂度: 最坏O(n²), 最好O(n), 平均O(n²)    空间复杂度: O(1)    稳定排序，对小规模或近似有序数据效率高    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:   # 边界条件检查        return        # 从第二个元素开始，逐个插入到已排序部分    for i in range(1, len(arr)):        # 从当前位置向前比较，寻找插入位置        for j in range(i - 1, -1, -1):            if arr[j] &gt; arr[j + 1]:    # 如果前面元素大于后面元素                SortingAlgorithms.swap(arr, j, j + 1)  # 交换位置            else:                break                  # 找到正确位置，提前结束内层循环\n\n插入排序的另一种实现@staticmethoddef insertion_sort_v2(arr):    &quot;&quot;&quot;    插入排序的另一种实现：先保存要插入的元素，然后移动其他元素    减少交换次数，提高效率    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return            for i in range(1, len(arr)):        key = arr[i]                  # 保存要插入的元素        j = i - 1                     # 从已排序部分的末尾开始                # 向右移动大于key的元素        while j &gt;= 0 and arr[j] &gt; key:            arr[j + 1] = arr[j]       # 元素后移            j -= 1                arr[j + 1] = key              # 插入key到正确位置\n\n排序算法性能对比\n\n\n算法\n时间复杂度(最好)\n时间复杂度(平均)\n时间复杂度(最坏)\n空间复杂度\n稳定性\n\n\n\n选择排序\n$O(n^2)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n不稳定\n\n\n冒泡排序\n$O(n)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n稳定\n\n\n插入排序\n$O(n)$\n$O(n^2)$\n$O(n^2)$\n$O(1)$\n稳定\n\n\n\n005【入门】对数器-验证的重要手段对数器的理论基础对数器（Logarithmic Validator）是一种系统性验证算法正确性的重要工具，通过大量随机测试用例来检验算法实现的可靠性。\n对数器设计的六个核心原则\n确定待测算法a：需要验证正确性的高效算法\n实现简单算法b：复杂度可能不优但逻辑简单、容易验证正确的算法  \n构建随机样本生成器：能够产生各种边界情况的测试数据\n对比验证：在相同输入下比较两种算法的输出结果\n错误定位：当发现不一致时，人工分析并修正错误\n大规模验证：通过大量测试建立对算法正确性的信心\n\n对数器实现框架（以上节课的三种排序方法为例）import randomclass AlgorithmValidator:    &quot;&quot;&quot;算法验证器类&quot;&quot;&quot;        @staticmethod    def random_array(n, v):        &quot;&quot;&quot;        生成随机数组        参数: n - 数组长度, v - 元素值域[1,v]        返回: 长度为n的随机数组        &quot;&quot;&quot;        # 使用列表推导式生成随机数组        return [random.randint(1, v) for _ in range(n)]        @staticmethod    def copy_array(arr):        &quot;&quot;&quot;        数组深拷贝        参数: arr - 原数组        返回: 原数组的副本        &quot;&quot;&quot;        return arr[:]                     # 切片操作创建新列表        @staticmethod      def arrays_equal(arr1, arr2):        &quot;&quot;&quot;        比较两个数组是否相等        参数: arr1, arr2 - 待比较的数组        返回: 布尔值表示是否相等        &quot;&quot;&quot;        if len(arr1) != len(arr2):        # 长度不等直接返回False            return False                # 逐元素比较        for a, b in zip(arr1, arr2):            if a != b:                return False        return True        @staticmethod    def comprehensive_sort_test():        &quot;&quot;&quot;        排序算法综合测试        使用对数器方法验证多种排序算法的正确性        &quot;&quot;&quot;        # 测试参数配置        N = 200                          # 数组最大长度        V = 1000                         # 元素最大值        test_times = 50000               # 测试次数                print(&quot;算法验证开始...&quot;)                for test_round in range(test_times):            # 生成随机测试用例            n = random.randint(0, N - 1)  # 随机数组长度            arr = AlgorithmValidator.random_array(n, V)                        # 创建多个数组副本用于不同算法测试            arr_selection = AlgorithmValidator.copy_array(arr)            arr_bubble = AlgorithmValidator.copy_array(arr)              arr_insertion = AlgorithmValidator.copy_array(arr)            arr_builtin = AlgorithmValidator.copy_array(arr)                        # 应用不同排序算法            SortingAlgorithms.selection_sort(arr_selection)            SortingAlgorithms.bubble_sort(arr_bubble)            SortingAlgorithms.insertion_sort(arr_insertion)            arr_builtin.sort()            # Python内置排序作为标准答案                        # 结果一致性验证            if not (AlgorithmValidator.arrays_equal(arr_selection, arr_builtin) and                    AlgorithmValidator.arrays_equal(arr_bubble, arr_builtin) and                      AlgorithmValidator.arrays_equal(arr_insertion, arr_builtin)):                                # 发现错误时输出详细信息                print(&quot;发现算法错误!&quot;)                print(f&quot;测试轮次: &#123;test_round + 1&#125;&quot;)                print(f&quot;原始数组: &#123;arr&#125;&quot;)                print(f&quot;选择排序: &#123;arr_selection&#125;&quot;)                print(f&quot;冒泡排序: &#123;arr_bubble&#125;&quot;)                print(f&quot;插入排序: &#123;arr_insertion&#125;&quot;)                print(f&quot;内置排序: &#123;arr_builtin&#125;&quot;)                return False                            # 每完成1000次测试输出进度            if (test_round + 1) % 1000 == 0:                print(f&quot;已完成 &#123;test_round + 1&#125; 次测试...&quot;)                print(&quot;所有测试通过！算法实现正确。&quot;)        return True\n\n对数器方法的优势\n自动化验证：减少人工测试的工作量和错误率\n覆盖边界情况：随机生成能够触及各种极端情况\n置信度建立：大量测试通过后可以高度确信算法正确性\n错误定位：一旦发现问题能够提供具体的错误样例\n\n\n006【入门】二分搜索二分搜索的数学基础二分搜索基于分治思想，每次将搜索空间减半，时间复杂度为 $O(\\log n)$。\n设数组长度为 $n$，经过 $k$ 次二分后搜索空间大小为 $\\frac{n}{2^k}$，当搜索空间减小到1时：\n$$\\frac{n}{2^k} &#x3D; 1 \\Rightarrow k &#x3D; \\log_2 n$$\n基础二分搜索问题：判断有序数组中是否存在目标值def binary_search_exist(arr, target):    &quot;&quot;&quot;    在有序数组中查找目标值是否存在    参数: arr - 有序数组, target - 目标值    返回: True/False 表示是否存在    时间复杂度: O(log n), 空间复杂度: O(1)    &quot;&quot;&quot;    if arr is None or len(arr) == 0:      # 边界条件：空数组        return False        left, right = 0, len(arr) - 1         # 初始化搜索边界[left, right]        while left &lt;= right:                  # 搜索空间非空时继续        # 防止整数溢出的中点计算方法        mid = left + (right - left) // 2   # 等价于 (left + right) // 2                if arr[mid] == target:            # 找到目标值            return True        elif arr[mid] &gt; target:           # 目标值在左半部分            right = mid - 1               # 收缩右边界        else:                             # 目标值在右半部分              left = mid + 1                # 收缩左边界        return False                          # 搜索完毕未找到\n\n暴力验证方法def linear_search_exist(arr, target):    &quot;&quot;&quot;    线性搜索验证方法    用于对数器验证二分搜索的正确性    &quot;&quot;&quot;    for element in arr:                   # 遍历数组每个元素        if element == target:             # 找到目标值            return True    return False                          # 未找到目标值\n\n二分搜索的边界查找变种查找左边界：&gt;&#x3D;target的最左位置def binary_search_left_bound(arr, target):    &quot;&quot;&quot;    在有序数组中查找 &gt;= target 的最左位置    参数: arr - 有序数组, target - 目标值    返回: 满足条件的最左索引，不存在返回-1    &quot;&quot;&quot;    if arr is None or len(arr) == 0:        return -1        left, right = 0, len(arr) - 1    ans = -1                              # 记录答案，初始化为-1表示未找到        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] &gt;= target:            # 当前元素满足条件            ans = mid                     # 更新答案            right = mid - 1               # 继续在左半部分寻找更左的位置        else:                             # 当前元素小于target            left = mid + 1                # 在右半部分继续搜索        return ansdef linear_search_left_bound(arr, target):    &quot;&quot;&quot;线性搜索验证：查找&gt;=target的最左位置&quot;&quot;&quot;    for i in range(len(arr)):             # 从左到右遍历        if arr[i] &gt;= target:              # 找到第一个满足条件的位置            return i    return -1                             # 未找到\n\n查找右边界：&lt;&#x3D;target的最右位置def binary_search_right_bound(arr, target):    &quot;&quot;&quot;    在有序数组中查找 &lt;= target 的最右位置    参数: arr - 有序数组, target - 目标值      返回: 满足条件的最右索引，不存在返回-1    &quot;&quot;&quot;    if arr is None or len(arr) == 0:        return -1        left, right = 0, len(arr) - 1    ans = -1                              # 记录答案        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid] &lt;= target:            # 当前元素满足条件            ans = mid                     # 更新答案            left = mid + 1                # 继续在右半部分寻找更右的位置        else:                             # 当前元素大于target            right = mid - 1               # 在左半部分继续搜索        return ansdef linear_search_right_bound(arr, target):    &quot;&quot;&quot;线性搜索验证：查找&lt;=target的最右位置&quot;&quot;&quot;    for i in range(len(arr) - 1, -1, -1): # 从右到左遍历        if arr[i] &lt;= target:              # 找到第一个满足条件的位置            return i    return -1                             # 未找到\n\n峰值元素查找问题定义在数组中找到任意一个峰值元素（比左右邻居都大的元素），假设边界外的元素为负无穷。\ndef find_peak_element(arr):    &quot;&quot;&quot;    查找数组中的峰值元素    参数: arr - 整数数组（相邻元素不相等）    返回: 任意峰值元素的索引    时间复杂度: O(log n)    &quot;&quot;&quot;    n = len(arr)        # 边界情况处理    if n == 1:                            # 单元素数组        return 0    if arr[0] &gt; arr[1]:                   # 第一个元素是峰值        return 0      if arr[n-1] &gt; arr[n-2]:              # 最后一个元素是峰值        return n - 1        # 在 [1, n-2] 范围内二分搜索    left, right = 1, n - 2        while left &lt;= right:        mid = left + (right - left) // 2                if arr[mid-1] &gt; arr[mid]:         # 左邻居更大，峰值在左半部分            right = mid - 1        elif arr[mid] &lt; arr[mid+1]:       # 右邻居更大，峰值在右半部分              left = mid + 1        else:                             # arr[mid-1] &lt; arr[mid] &gt; arr[mid+1]            return mid                    # 找到峰值        return -1                             # 理论上不会到达这里\n\n峰值查找的正确性证明定理：在满足相邻元素不相等的数组中，上述算法一定能找到峰值。\n证明：\n\n边界已处理端点峰值。\n二分查找时，每次都能缩小到含有峰值的半区。\n因为每次都“爬坡”，必然最终会达到一个峰值。\n相邻元素不等消除了平台的歧义。\n因此，算法在O(log n)时间内一定能找到一个峰值。\n\n二分搜索验证框架def test_binary_search_algorithms():    &quot;&quot;&quot;二分搜索算法综合测试&quot;&quot;&quot;    N = 100                               # 数组最大长度    V = 1000                              # 元素值域    test_times = 500000                   # 测试次数        print(&quot;二分搜索算法测试开始...&quot;)        for _ in range(test_times):        # 生成随机有序数组        n = random.randint(0, N - 1)        arr = [random.randint(1, V) for _ in range(n)]        arr.sort()                        # 确保数组有序                target = random.randint(0, V - 1) # 随机目标值                # 验证基础二分搜索        if binary_search_exist(arr, target) != linear_search_exist(arr, target):            print(&quot;基础二分搜索错误!&quot;)            return False                # 验证左边界查找            if binary_search_left_bound(arr, target) != linear_search_left_bound(arr, target):            print(&quot;左边界查找错误!&quot;)            return False                    # 验证右边界查找        if binary_search_right_bound(arr, target) != linear_search_right_bound(arr, target):            print(&quot;右边界查找错误!&quot;)            return False        print(&quot;所有二分搜索测试通过!&quot;)    return True\n\n\n007【入门】时间复杂度和空间复杂度时间复杂度的数学基础渐近记号系统设 $f(n)$ 和 $g(n)$ 为定义在正整数集上的函数：\n\n大O记号 $O(g(n))$：$f(n) &#x3D; O(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \\geq n_0$ 有 $f(n) \\leq c \\cdot g(n)$\n大Ω记号 $\\Omega(g(n))$：$f(n) &#x3D; \\Omega(g(n))$ 当且仅当存在正常数 $c$ 和 $n_0$，使得对所有 $n \\geq n_0$ 有 $f(n) \\geq c \\cdot g(n)$  \n大Θ记号 $\\Theta(g(n))$：$f(n) &#x3D; \\Theta(g(n))$ 当且仅当 $f(n) &#x3D; O(g(n))$ 且 $f(n) &#x3D; \\Omega(g(n))$\n\n其实和泛函的函数的范数有点像，也就是这个映射算是有界的那种感觉。\n常见复杂度级别$$O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$$\n复杂嵌套循环分析等差数列型循环def quadratic_complexity_demo(N):    &quot;&quot;&quot;    演示O(n²)时间复杂度    等差数列求和：1 + 2 + ... + n = n(n+1)/2 = O(n²)    &quot;&quot;&quot;    operations = 0                        # 记录操作次数        for i in range(1, N + 1):            # 外层循环：i从1到N        for j in range(i, N + 1):        # 内层循环：j从i到N            operations += 1               # 模拟一次基本操作            # 当i=1时，内层执行N次            # 当i=2时，内层执行N-1次              # ...            # 当i=N时，内层执行1次            # 总计：N + (N-1) + ... + 1 = N(N+1)/2        print(f&quot;N=&#123;N&#125;, 总操作次数=&#123;operations&#125;, 理论值=&#123;N*(N+1)//2&#125;&quot;)    return operations\n\n调和级数型循环def n_log_n_complexity_demo(N):    &quot;&quot;&quot;    演示O(n log n)时间复杂度      调和级数：1 + 1/2 + 1/3 + ... + 1/n ≈ ln(n) = O(log n)    &quot;&quot;&quot;    operations = 0                        # 记录操作次数        for i in range(1, N + 1):            # 外层循环：i从1到N        j = i                             # 内层循环起始值        while j &lt;= N:                     # 按i的倍数递增            operations += 1               # 模拟一次基本操作            j += i                        # j = i, 2i, 3i, ...            # 当i=1时，内层执行N次（N/1）            # 当i=2时，内层执行N/2次            # 当i=3时，内层执行N/3次            # ...            # 总计：N(1 + 1/2 + 1/3 + ... + 1/N) = N·H_N ≈ N log N        print(f&quot;N=&#123;N&#125;, 总操作次数=&#123;operations&#125;&quot;)    return operations\n\n复杂度实验验证import timedef complexity_benchmark():    &quot;&quot;&quot;    通过实际运行时间验证复杂度分析    &quot;&quot;&quot;    test_sizes = [1000, 2000, 4000, 8000]   # 测试规模        print(&quot;=== 复杂度实验验证 ===&quot;)    print(&quot;规模\\tO(n²)时间\\tO(n log n)时间\\t比率&quot;)        for N in test_sizes:        # 测试O(n²)算法        start_time = time.time()        quadratic_complexity_demo(N)        quadratic_time = time.time() - start_time                # 测试O(n log n)算法          start_time = time.time()        n_log_n_complexity_demo(N)        n_log_n_time = time.time() - start_time                ratio = quadratic_time / n_log_n_time if n_log_n_time &gt; 0 else float(&#x27;inf&#x27;)        print(f&quot;&#123;N&#125;\\t&#123;quadratic_time:.4f&#125;s\\t&#123;n_log_n_time:.4f&#125;s\\t&#123;ratio:.2f&#125;&quot;)\n\n单循环冒泡排序的复杂度分析def single_loop_bubble_sort(arr):    &quot;&quot;&quot;    使用单个循环实现冒泡排序    虽然只有一个while循环，但时间复杂度仍然是O(n²)    &quot;&quot;&quot;    if arr is None or len(arr) &lt; 2:        return        n = len(arr)    end = n - 1                           # 未排序部分的右边界    i = 0                                 # 当前比较位置        while end &gt; 0:                        # 外层逻辑：控制轮次        if arr[i] &gt; arr[i + 1]:          # 相邻元素比较            arr[i], arr[i + 1] = arr[i + 1], arr[i]  # 交换                if i &lt; end - 1:                   # 当前轮次未结束            i += 1                        # 移动到下一个比较位置        else:                             # 当前轮次结束            end -= 1                      # 缩小未排序范围            i = 0                         # 重置比较位置            # 虽然是单循环，但逻辑上等价于双层嵌套            # 时间复杂度仍为O(n²)\n\n空间复杂度分析动态数组的均摊复杂度分析def dynamic_array_analysis():    &quot;&quot;&quot;    动态数组扩容的均摊复杂度分析    &quot;&quot;&quot;    arr = []                              # 初始空数组    operations = []                       # 记录每次操作的代价        for i in range(16):                   # 插入16个元素        old_capacity = len(arr)           # 当前容量        arr.append(i)                     # 插入元素                # 模拟扩容过程        if len(arr) &gt; old_capacity:       # 发生了扩容            # Python的list实际扩容策略比较复杂，这里简化为2倍扩容            cost = old_capacity            # 扩容代价：复制所有旧元素        else:            cost = 1                      # 普通插入代价                operations.append(cost)        print(f&quot;插入元素&#123;i&#125;, 当前大小=&#123;len(arr)&#125;, 本次代价=&#123;cost&#125;&quot;)        total_cost = sum(operations)    average_cost = total_cost / len(operations)    print(f&quot;总代价=&#123;total_cost&#125;, 平均代价=&#123;average_cost:.2f&#125;&quot;)        # 数学分析：    # 扩容发生在容量为1,2,4,8,...时    # 总扩容代价：0 + 1 + 2 + 4 + 8 + ... &lt; 2n    # 总插入代价：n      # 均摊代价：(2n + n) / n = 3 = O(1)\n\n递归算法的空间复杂度def recursive_space_analysis(n):    &quot;&quot;&quot;    递归算法空间复杂度分析    计算阶乘的递归实现    &quot;&quot;&quot;    if n &lt;= 1:                           # 基础情况        return 1        # 每次递归调用占用O(1)空间    # 最大递归深度为n，所以空间复杂度为O(n)    return n * recursive_space_analysis(n - 1)def iterative_space_analysis(n):    &quot;&quot;&quot;    迭代版本的阶乘计算    空间复杂度为O(1)    &quot;&quot;&quot;    result = 1                           # 只使用常数额外空间    for i in range(1, n + 1):        result *= i    return result\n\n复杂度分析的实用技巧主定理（Master Theorem）对于递归关系 $T(n) &#x3D; aT(\\frac{n}{b}) + f(n)$，其中 $a \\geq 1, b &gt; 1$：\n\n如果 $f(n) &#x3D; O(n^{\\log_b a - \\epsilon})$，则 $T(n) &#x3D; \\Theta(n^{\\log_b a})$\n如果 $f(n) &#x3D; \\Theta(n^{\\log_b a})$，则 $T(n) &#x3D; \\Theta(n^{\\log_b a} \\log n)$  \n如果 $f(n) &#x3D; \\Omega(n^{\\log_b a + \\epsilon})$，则 $T(n) &#x3D; \\Theta(f(n))$\n\n均摊分析方法\n聚合分析：分析一系列操作的总代价\n核算法：为每种操作分配均摊代价\n势能法：定义势能函数分析代价分布\n\n实际性能考虑因素def practical_performance_factors():    &quot;&quot;&quot;    影响实际性能的因素    &quot;&quot;&quot;    print(&quot;影响算法实际性能的因素：&quot;)    print(&quot;1. 常数因子：O(n)算法的常数可能很大&quot;)    print(&quot;2. 数据规模：小规模时简单算法可能更快&quot;)      print(&quot;3. 内存访问模式：缓存友好的算法性能更好&quot;)    print(&quot;4. 分支预测：减少条件分支可提高性能&quot;)    print(&quot;5. 编译器优化：现代编译器能显著优化代码&quot;)    print(&quot;6. 硬件特性：利用SIMD等特性可大幅提速&quot;)\n\n\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","对数器","算法","二分搜索","排序算法","时间复杂度"]},{"title":"数据结构与算法自学笔记（16）- 嵌套类问题的递归解题套路","url":"/2025/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89-%20%E5%B5%8C%E5%A5%97%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记是讲解039的内容，总结了嵌套类问题的递归解题套路。这类问题的共同特点是存在嵌套结构（如括号嵌套），需要用递归来处理。\n前置知识在学习嵌套类问题之前，需要掌握以下基础知识：\n\n讲解017、020、021、023、036、037、038\n这些章节都分析过递归，尤其是讲解038，不熟悉的同学可以先熟悉一下\n\n\n039【必备】嵌套类问题的递归解题套路核心解题思路基本套路模板嵌套类问题的解题套路可以概括为：\n\n定义全局变量 where：记录当前解析到的位置\n递归函数 f(i)：从位置i开始解析，遇到字符串终止或嵌套条件终止就返回\n返回值机制：f(i)负责这一段的结果，返回前更新全局变量where\n位置传递：让上级函数通过where知道解析到了什么位置，进而继续\n\n执行细节\n如果f(i)遇到嵌套条件开始，就调用下级递归去处理嵌套\n下级会负责嵌套部分的计算结果\nf(i)下级处理完成后，可以根据下级更新的全局变量where，知道该从什么位置继续解析\n\n\n题目一：含有嵌套的表达式求值问题描述请写一个整数计算器，支持加减乘三种运算和括号。\n\n数据范围：0 &lt; |s| &lt; 100，保证计算结果始终在整型范围内\n要求：空间复杂度 O(n)，时间复杂度 O(n)\n\n测试链接：\n\nLeetCode：https://leetcode.cn/problems/basic-calculator-iii/\n牛客网：https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4\n\n核心思想使用递归处理括号嵌套，同时用两个列表分别存储数字和操作符。通过push辅助函数处理运算优先级：\n\n乘除法优先级高：遇到时立即计算，并更新数字列表的最后一个数\n加减法优先级低：先将数字和操作符存入列表\n遇到左括号(：递归调用自身 _f 来计算括号内的值，把它当作一个整体的数字\n遇到右括号 ) 或字符串末尾：结束当前层级的计算,并对 numbers 和 ops 列表中的加减法进行最终求和\n\n\n算法实现class Solution:    def calculate(self, s: str) -&gt; int:        &quot;&quot;&quot;        主函数，初始化共享索引并启动递归        &quot;&quot;&quot;        self.where = 0        return self._f(list(s), 0)    # s[i....]开始计算，遇到字符串终止 或者 遇到)停止    # 返回 : 自己负责的这一段，计算的结果    # 返回之间，更新全局变量where，为了上游函数知道从哪继续！    def _f(self, s: List[str], i: int) -&gt; int:        &quot;&quot;&quot;        递归函数，处理一个括号内的或整个表达式的求值        &quot;&quot;&quot;        cur = 0        numbers = []        ops = []                while i &lt; len(s) and s[i] != &#x27;)&#x27;: # 未终止且未遇到右括号            if s[i].isdigit(): # 是数字                cur = cur * 10 + int(s[i])                i += 1            elif s[i] != &#x27;(&#x27;: # 不是左括号                # 遇到了运算符 + - * /                self._push(numbers, ops, cur, s[i])                i += 1                cur = 0            else: # 是左括号                # i (.....)                # 遇到了左括号！                # 递归调用 f，计算括号内的结果                cur = self._f(s, i + 1)                # 递归返回后，where 指向了 &#x27;)&#x27; 的位置，i 需要跳到 &#x27;)&#x27; 之后                i = self.where + 1                # 如果碰到了右括号，将最后一个数字（或括号运算结果）加入列表，并更新全局索引        self._push(numbers, ops, cur, &#x27;+&#x27;) # 末尾添加一个 &#x27;+&#x27; 不影响最终计算        # 更新全局索引，让上级函数知道从哪继续        self.where = i        return self._compute(numbers, ops)    def _push(self, numbers: List[int], ops: List[str], cur: int, op: str):        &quot;&quot;&quot;辅助函数，处理数字和操作符的入栈逻辑，并处理乘除法&quot;&quot;&quot;        if not numbers or ops[-1] == &#x27;+&#x27; or ops[-1] == &#x27;-&#x27;:            # 如果是第一个数，或者前一个运算符是+或-，直接入栈            numbers.append(cur)            ops.append(op)        else:            # 如果前一个运算符是*或/，立即计算            top_number = numbers[-1]            top_op = ops[-1]            if top_op == &#x27;*&#x27;:                numbers[-1] = top_number * cur            else: # top_op == &#x27;/&#x27;                # Python 的 // 是向下取整，题目要求向零取整                numbers[-1] = int(top_number / cur)            ops[-1] = op # 更新操作符            # 具体例子               # 原始：3 * 4 + 5            #     处理到 * 4 时：            #     - numbers: [3, 4] → [12] (3*4=12)            #     - ops: [&#x27;*&#x27;] → [&#x27;+&#x27;] (更新操作符)              # 这样下一个数字 5 就能正确地与 12 进行加法运算    def _compute(self, numbers: List[int], ops: List[str]) -&gt; int:        &quot;&quot;&quot;辅助函数，计算只有加减法的最终结果&quot;&quot;&quot;        ans = numbers[0]        for i in range(1, len(numbers)):            ans += numbers[i] if ops[i - 1] == &#x27;+&#x27; else -numbers[i]        return ans\n\n算法分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n核心技巧：递归处理嵌套 + 分离处理优先级\n\n\n题目二：含有嵌套的字符串解码问题描述给定一个经过编码的字符串，返回它解码后的字符串。编码规则为：k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。\n示例：输入：s = &quot;3[a2[c]]&quot;，输出：&quot;accaccacc&quot;\n测试链接：https://leetcode.cn/problems/decode-string/\n核心思想递归解码嵌套字符串。有嵌套就一定有数字：\n\n遇到字母：直接拼接到当前层级的结果 path 中\n遇到数字：累加成一个完整的数字 cnt，这代表后续 [] 内字符串的重复次数\n遇到左括号[：说明进入了一个新的嵌套层级。此时，递归调用 _f 来解码 [] 内的子问题。递归返回后，将得到的子字符串重复 cnt 次，拼接到 path 中。\n遇到右括号 ] 或字符串末尾：当前层级解码结束，返回 path。\n\n\n算法实现class Solution:    def decodeString(self, s: str) -&gt; str:        &quot;&quot;&quot;        主函数，初始化共享索引并启动递归        &quot;&quot;&quot;        self.where = 0        return self._f(list(s), 0)    # s[i....]开始计算，遇到字符串终止 或者 遇到 ] 停止    # 返回 : 自己负责的这一段字符串的结果    # 返回之间，更新全局变量where，为了上游函数知道从哪继续！    def _f(self, s: list, i: int) -&gt; str:        &quot;&quot;&quot;        递归函数，解码一个层级的字符串        &quot;&quot;&quot;        path = []        cnt = 0        while i &lt; len(s) and s[i] != &#x27;]&#x27;:            if &#x27;a&#x27; &lt;= s[i] &lt;= &#x27;z&#x27; or &#x27;A&#x27; &lt;= s[i] &lt;= &#x27;Z&#x27;:  # 比较范围                path.append(s[i])                i += 1            elif s[i].isdigit():                cnt = cnt * 10 + int(s[i])                i += 1            else:                # 遇到 [                 # 递归调用 f 来解码括号内的内容                inner_str = self._f(s, i + 1)                # 将解码后的子串重复 cnt 次                path.append(cnt * inner_str)                # 更新 i 到 &#x27;]&#x27; 之后的位置                i = self.where + 1                # 重置 cnt                cnt = 0                # 更新全局索引，以便上层函数知道从哪里继续        self.where = i        return &quot;&quot;.join(path)\n\n算法分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n核心技巧：递归处理嵌套 + 字符串重复\n\n\n题目三：含有嵌套的分子式求原子数量问题描述给你一个字符串化学式 formula，返回每种原子的数量。\n\n原子总是以一个大写字母开始，接着跟随0个或任意个小写字母\n如果数量大于1，原子后会跟着数字表示原子的数量\n如果数量等于1则不会跟数字\n\n测试链接：https://leetcode.cn/problems/number-of-atoms/\n核心思想递归解析嵌套分子式，返回原子计数字典\n具体流程如下：\n\n循环解析当前层级，直到遇到 ‘)’ 或字符串末尾。\n解析过程中维护三个状态：name (当前原子名), pre (括号内解析结果的字典), cnt (倍数)。\n当遇到下一个大写字母或左括号 ( 时，说明前一个“单元”（原子或括号）已经解析完毕，  调用 _fill 函数将其信息合并到当前层级的总结果 ans 字典中。\n遇到 (，递归调用 _f 获取括号内的原子构成，存入 pre 字典。\n遇到大写字母，开始一个新的原子名 name。\n遇到小写字母，追加到 name。\n遇到数字，累加成倍数 cnt。\n\n\n算法实现from collections import defaultdictclass Solution:    def countOfAtoms(self, formula: str) -&gt; str:        &quot;&quot;&quot;        主函数，初始化共享索引并启动递归，最后格式化输出        &quot;&quot;&quot;        self.where = 0        # 调用递归函数获取原子计数的字典        atom_map = self._f(list(formula), 0)                # 构建最终的输出字符串        ans = []        # 按原子名称的字母顺序排序，返回有序表        for key in sorted(atom_map.keys()):            ans.append(key) # 先添加原子名称再添加数量            cnt = atom_map[key]            if cnt &gt; 1:                ans.append(str(cnt))        return &quot;&quot;.join(ans)    def _f(self, s: list, i: int) -&gt; dict:        &quot;&quot;&quot;        递归函数，解析一个层级的分子式，返回一个字典        &quot;&quot;&quot;        ans = defaultdict(int)  # 创建默认字典        name = []  # 存储当前原子名称        pre = None  # 历史记录        cnt = 0                while i &lt; len(s) and s[i] != &#x27;)&#x27;:            if &#x27;A&#x27; &lt;= s[i] &lt;= &#x27;Z&#x27; or s[i] == &#x27;(&#x27;:                # 遇到新单元，先把之前收集的信息处理掉                self._fill(ans, name, pre, cnt)                # 重置状态                name.clear()  # 清空列表中的所有元素                pre = None                cnt = 0  # 重置倍数                                if &#x27;A&#x27; &lt;= s[i] &lt;= &#x27;Z&#x27;:                    name.append(s[i])                    i += 1  # 移动到下一个字符                else:  # 遇到 (                    # 递归处理括号内的表达式                    pre = self._f(s, i + 1)                    i = self.where + 1            elif &#x27;a&#x27; &lt;= s[i] &lt;= &#x27;z&#x27;:                name.append(s[i])                i += 1            else:  # 遇到数字                cnt = cnt * 10 + int(s[i])                i += 1                # 循环结束，处理最后一个单元        self._fill(ans, name, pre, cnt)        # 更新全局索引        self.where = i        return ans    def _fill(self, ans: dict, name: list, pre: dict, cnt: int):        &quot;&quot;&quot;辅助函数，将一个解析完的单元（原子或括号）合并到总结果中&quot;&quot;&quot;        if name or pre:            # 如果没有数字，倍数默认为1            cnt = 1 if cnt == 0 else cnt            if name:                # 如果是原子，直接累加数量                key = &quot;&quot;.join(name)                ans[key] += cnt            else:  # 如果是括号内的字典 pre                # 遍历字典，将其中每个原子的数量乘以倍数 cnt，再累加                for key, val in pre.items():                    ans[key] += val * cnt\n\n算法分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n核心技巧：递归处理嵌套 + 字典合并\n\n\n核心套路总结1. 递归函数设计模板class Solution:    def solve(self, s: str):        &quot;&quot;&quot;主函数，初始化全局变量&quot;&quot;&quot;        self.where = 0        return self._f(list(s), 0)        def _f(self, s: list, i: int):        &quot;&quot;&quot;递归函数核心模板&quot;&quot;&quot;        # 初始化当前层级的状态变量        result = []  # 或其他适当的数据结构                while i &lt; len(s) and s[i] != 终止条件:            if 普通字符处理:                # 直接处理                i += 1            elif 嵌套开始标志:                # 递归调用处理嵌套                nested_result = self._f(s, i + 1)                # 处理递归结果                result.append(nested_result)                # 更新位置                i = self.where + 1            else:                # 其他情况处理                i += 1                # 更新全局位置        self.where = i        return result\n\n2. 全局变量where的作用# where的三个关键作用：# 1. 记录当前递归函数解析到的位置# 2. 让上级函数知道下级函数处理到哪里了# 3. 实现递归层级之间的位置传递\n\n3. 嵌套处理的通用策略# 遇到嵌套开始标志时：if s[i] == &#x27;(&#x27; or s[i] == &#x27;[&#x27;:  # 根据具体问题调整    # 1. 递归调用处理嵌套内容    nested_result = self._f(s, i + 1)        # 2. 处理递归返回的结果    process_nested_result(nested_result)        # 3. 更新当前位置到嵌套结束后    i = self.where + 1\n\n复杂度分析总结\n\n\n题目\n时间复杂度\n空间复杂度\n核心数据结构\n\n\n\n表达式求值\nO(n)\nO(n)\n列表 + 递归栈\n\n\n字符串解码\nO(n)\nO(n)\n字符串 + 递归栈\n\n\n分子式解析\nO(n)\nO(n)\n字典 + 递归栈\n\n\n学习建议1. 理解递归本质\n递归是处理嵌套结构的自然选择\n每一层递归负责处理一个层级的内容\n通过全局变量实现层级间的信息传递\n\n2. 掌握状态管理\n明确每层递归需要维护哪些状态\n合理设计辅助函数处理复杂逻辑\n注意状态的重置和更新时机\n\n3. 练习边界处理\n递归终止条件的设计\n嵌套边界的正确处理\n特殊情况的考虑（空字符串、单字符等）\n\n4. 优化技巧\n使用合适的数据结构（列表、字典、栈等）\n避免重复计算和冗余操作\n考虑空间复杂度的优化\n\n5. 调试方法\n画出递归调用的层级关系图\n追踪全局变量where的变化\n验证每层递归的输入输出\n\n通过掌握这个通用的嵌套类问题解题套路，可以有效解决包含括号、方括号等嵌套结构的各类算法问题。关键在于理解递归的层级关系和全局变量的作用机制。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","递归","嵌套结构"]},{"title":"数据结构与算法自学笔记（14）- 二叉树高频题目","url":"/2025/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记是class036→037的内容，总结了二叉树相关的9+7&#x3D;16道高频算法题目。class36涵盖了二叉树的遍历、序列化、构造、验证等核心操作，但不包含树型动态规划的内容。class037算是036的补充，讲了二叉树相关的另外7道高频算法题目，包含了最近公共祖先（LCA）问题、路径搜索、平衡性验证、搜索二叉树相关操作。\n前置知识在学习二叉树高频题目之前，需要掌握以下基础知识：\n\n队列用数组实现（讲解013）\n二叉树入门内容（讲解017~018）\n\n重要说明\n本期和下期视频会讲解二叉树高频题目，但不含树型dp的题目\n树型dp问题会放在【必备】课程的动态规划大章节部分讲述\n树型dp中的换根dp问题会放在【扩展】课程的动态规划大章节部分讲述\nAVL树的实现、树的左旋右旋等内容也会在【扩展】课程里讲述\n问题1又叫LCA问题，非常重要！Tarjan算法解决LCA的批量查询、树链剖分算法解决LCA的在线查询会在【扩展】课程讲述\n数组的打家劫舍问题变形很多，会在【必备】课程的动态规划大章节部分讲述\n再次强调树型dp的整体讲解，会在【必备】课程的动态规划大章节部分讲述\n\n\n036【必备】二叉树高频题目-上-不含树型dp初始化的二叉树类class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right\n\n题目一：二叉树的层序遍历问题描述给你二叉树的根节点 root，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）\n测试链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/\n核心思想使用广度优先搜索（BFS）进行层序遍历，有两种实现方式：\n\n普通BFS：使用队列存储节点，用哈希表记录每个节点的层级\n优化BFS：按层处理，每次处理完整一层的所有节点\n\n\n算法实现方法一：普通BFSfrom collections import dequefrom typing import List, Optional# 提交时把方法名改为levelOrder，此方法为普通bfs（宽度/广度优先搜索，叫宽度搜索的原因是层的最大节点数为宽度），此题不推荐def levelOrder1(self, root: Optional[TreeNode]) -&gt; List[List[int]]:    # 核心思想：标准的广度优先搜索（BFS）。    # 使用一个队列存储待访问节点，同时用一个哈希表（字典）来记录每个节点所在的层级。    ans = []    if root:#根节点有东西        # Python的deque是一个高效的双端队列，非常适合用于BFS        queue = deque([root])        # 字典用于存储 node -&gt; level 的映射        levels = &#123;root: 0&#125;        while queue:# 队列不空的时候从队列中取出一个节点            cur = queue.popleft()            level = levels[cur]                            # 如果当前层级是第一次遇到，就在ans中创建一个新列表            if len(ans) == level: #ans 列表的长度总是等于当前已经处理过的层级数量，包括第0层，说明当前节点的层级 level 正好等于已经创建的层级数量，味着这个层级还没有被处理过，需要创建新的列表                ans.append([])                           # 将当前节点的值加入对应层级的列表            ans[level].append(cur.val)                          # 将子节点加入队列，并记录它们的层级            if cur.left:                queue.append(cur.left)                levels[cur.left] = level + 1            if cur.right:                queue.append(cur.right)                levels[cur.right] = level + 1    return ans    # 核心思想：标准的广度优先搜索（BFS），使用一个队列存储待访问节点，    # 同时用一个哈希表（字典）来记录每个节点所在的层级。\n\n方法二：优化BFS（推荐）def levelOrder2(self, root: Optional[TreeNode]) -&gt; List[List[int]]:    # 核心思想：优化的广度优先搜索（BFS），按层处理。    # 外层while循环控制层级，内层for循环精确地处理当前层的所有节点。    # 这样就无需额外的哈希表来存储节点的层级信息。    ans = []    if root:        queue = deque([root])        while queue: # 当队列不为空，说明还有节点待处理            size = len(queue) # 当前层的节点数量            level_list = []            for _ in range(size): # 精确处理当前层的所有节点                cur = queue.popleft()                level_list.append(cur.val)                if cur.left: # 将下一层节点入队                    queue.append(cur.left)                 if cur.right:                    queue.append(cur.right) # append是加在右边的            ans.append(level_list)    return ans\n\n执行过程示例以树结构 1-&gt;2,3; 2-&gt;4,5; 3-&gt;6 为例：\n初始状态：queue = [1], ans = []处理第0层：  size = 1, level_list = []  取出节点1，level_list = [1]  将节点2,3入队，queue = [2, 3]  ans = [[1]]处理第1层：  size = 2, level_list = []  取出节点2，level_list = [2]，将4,5入队  取出节点3，level_list = [2, 3]，将6入队  queue = [4, 5, 6]  ans = [[1], [2, 3]]处理第2层：  size = 3, level_list = []  依次取出4,5,6，level_list = [4, 5, 6]  ans = [[1], [2, 3], [4, 5, 6]]\n\n\n算法分析\n时间复杂度：O(N)，N为节点数\n空间复杂度：O(N)\n核心技巧：按层BFS遍历\n\n\n题目二：二叉树的锯齿形层序遍历问题描述给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）\n测试链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\n核心思想在按层BFS的基础上，增加一个布尔标记 reverse。每一层遍历结束后，根据 reverse 的值决定是否要将当前层收集到的节点值列表进行反转。\n算法实现# 提交以下的方法# 用每次处理一层的优化bfs就非常容易实现def zigzagLevelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:    # 核心思想：在按层BFS的基础上，增加一个布尔标记 `reverse`。    # 每一层遍历结束后，根据 `reverse` 的值决定是否要将当前层收集到的节点值列表进行反转。    # 然后切换 `reverse` 的状态，供下一层使用。    ans = []    if root:        queue = deque([root])        # false 代表从左往右        # true 代表从右往左        reverse = False        while queue:            size = len(queue)            level_list = []                        # 步骤1: 像常规的按层BFS一样，先收集当前层的所有节点值            for _ in range(size):                cur = queue.popleft()                level_list.append(cur.val)                if cur.left:                    queue.append(cur.left)                if cur.right:                    queue.append(cur.right)                        # 步骤2: 根据reverse标记决定是否反转当前层的列表            if reverse:                level_list.reverse()                        # 步骤3: 将处理好的层列表加入结果，并切换reverse标记            ans.append(level_list)            reverse = not reverse    return ans\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n核心技巧：层序遍历 + 交替反转\n\n\n题目三：二叉树的最大特殊宽度问题描述给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树的宽度与满二叉树相同，但不一定是满的。\n测试链接：https://leetcode.cn/problems/maximum-width-of-binary-tree/\n核心思想给每个节点进行编号，就像在一个完全二叉树中一样。根节点编号为1，其左子节点为 2i，右子节点为 2i + 1。每一层的宽度就等于该层最右边节点的编号减去最左边节点的编号，再加1。\n算法实现def widthOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:    # 核心思想：给每个节点进行编号，就像在一个完全二叉树中一样。    # 根节点编号为1，其左子节点为 2*i，右子节点为 2*i + 1。    # 每一层的宽度就等于该层最右边节点的编号减去最左边节点的编号，再加1。    # 我们使用按层BFS来遍历，同时在队列中存储 (节点, 编号) 对。    if not root:        return 0    ans = 1    # 队列中存储 (节点, 节点编号) 的元组    queue = deque([(root, 1)])        while queue:        size = len(queue)        # 记录当前层的起始编号        start_id = queue[0][1]                # 遍历当前层的所有节点        for i in range(size):            node, node_id = queue.popleft()                        # 在遍历到当前层最后一个节点时，计算宽度，这个是额外的步骤            if i == size - 1:                ans = max(ans, node_id - start_id + 1)            # 将子节点及其新编号加入队列            if node.left:                queue.append((node.left, node_id * 2))            if node.right:                queue.append((node.right, node_id * 2 + 1))    return ans\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n核心技巧：完全二叉树编号规则\n\n\n题目四：求二叉树的最大深度、最小深度问题描述\n求二叉树的最大深度\n求二叉树的最小深度\n\n测试链接：\n\n最大深度：https://leetcode.cn/problems/maximum-depth-of-binary-tree/\n最小深度：https://leetcode.cn/problems/minimum-depth-of-binary-tree/\n\n核心思想最大深度核心思想：递归。一棵树的最大深度等于其左、右子树最大深度中的较大者，再加1（根节点本身）。空树的深度为0，这是递归的基准情况，一定要到叶节点底部。\n最小深度递归，但需要特殊处理。最小深度是从根节点到最近的”叶子节点”的路径长度。如果一个节点只有一个子树，那么我们必须沿着这个非空的子树继续寻找叶子节点。\n\n算法实现最大深度def maxDepth(self, root: Optional[TreeNode]) -&gt; int:    if not root:        return 0    return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\n最小深度def minDepth(self, root: Optional[TreeNode]) -&gt; int:    if not root:        # 当前的树是空树        return 0            left_depth = self.minDepth(root.left)    right_depth = self.minDepth(root.right)    # case 1: 如果左子树或右子树为空，我们不能取它为最小值（因为那条路没有叶子）。    # 此时必须走另一条非空的路。`left_depth + right_depth + 1` 巧妙地处理了    # (左=0, 右=N) -&gt; N+1 和 (左=N, 右=0) -&gt; N+1 的情况。    if left_depth == 0 or right_depth == 0:        return left_depth + right_depth + 1        # case 2: 如果左右子树都不为空，那么最小深度就是两者中的较小值加1。    return min(left_depth, right_depth) + 1\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(H)，H为树的高度\n核心技巧：递归分治\n\n\n题目五：二叉树先序序列化和反序列化问题描述设计一个算法来序列化和反序列化二叉树。将树转换为字符串（序列化），再将字符串转换为树（反序列化）。\n测试链接：https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/\n\n核心思想序列化使用先序遍历（根-左-右）将树递归地转换成字符串。空节点用特殊字符’#’表示，节点之间用’,’分隔。\n反序列化利用先序遍历的顺序，递归地重建树。字符串按’,’分割成列表，然后用一个迭代器顺序消费这些值来构建节点。\n重要说明二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，但是无法通过中序遍历的方式实现序列化和反序列化，因为不同的两棵树可能得到同样的中序序列。\n算法实现# 中序遍历的反面例子，比如如下两棵树#         __2#        /#       1#       和#       1__#          \\#           2# 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125;# 提交这个类class Codec:    def serialize(self, root):        # 核心思想：使用先序遍历（根-左-右）将树递归地转换成字符串。        # 空节点用特殊字符&#x27;#&#x27;表示，节点之间用&#x27;,&#x27;分隔。 #叫sharp        res = [] #res是结果列表result        self._f(root, res)        return &quot;,&quot;.join(res)    def _f(self, root, res): # 递归函数求先序遍历        if not root:            res.append(&quot;#&quot;)            return        res.append(str(root.val))        self._f(root.left, res)        self._f(root.right, res)    def deserialize(self, data):        # 核心思想：利用先序遍历的顺序，递归地重建树。        # 字符串按&#x27;,&#x27;分割成列表，然后用一个迭代器顺序消费这些值来构建节点。        if not data:            return None        vals = iter(data.split(&#x27;,&#x27;))        return self._g(vals)    def _g(self, vals): # 递归函数求反序列化        val = next(vals) # 迭代器，next是取下一个值，val是理论上是字符串，next能逐个取值        if val == &quot;#&quot;:            return None                # 先构建根节点，然后递归构建左子树，再递归构建右子树        head = Code05_PreorderSerializeAndDeserialize.TreeNode(int(val))        head.left = self._g(vals)        head.right = self._g(vals)        return head\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n核心技巧：先序遍历 + 迭代器\n\n\n题目六：二叉树按层序列化和反序列化问题描述使用层序遍历的方式实现二叉树的序列化和反序列化。\n测试链接：https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/\n核心思想序列化使用广度优先搜索（BFS）进行层序遍历。队列中的每个节点，都将其左右子节点（即使是None）的信息加入结果字符串。\n反序列化同样使用BFS和队列来重建树。先创建根节点并入队，然后依次出队父节点，并从字符串值列表中读出左右子节点的信息进行构建和连接。\n算法实现# 提交这个类，补点思想即：把所有空节点也序列化/反序列化出来，不遗漏任何节点位置。# 按层序列化class Codec:    def serialize(self, root):        # 核心思想：使用广度优先搜索（BFS）进行层序遍历。        # 队列中的每个节点，都将其左右子节点（即使是None）的信息加入结果字符串。        if not root:            return &quot;&quot;  # 空树直接返回空字符串        res = []        queue = deque([root])        while queue:            cur = queue.popleft()            if cur:                res.append(str(cur.val))  # 记录当前节点值                queue.append(cur.left)    # 即使是None也加入队列，补点思想                queue.append(cur.right)   # 即使是None也加入队列，补点思想            else:                res.append(&quot;#&quot;)  # 用&#x27;#&#x27;表示空节点，补点思想        return &quot;,&quot;.join(res)  # 用逗号连接成字符串    def deserialize(self, data):        # 核心思想：同样使用BFS和队列来重建树。        # 先创建根节点并入队，然后依次出队父节点，并从字符串值列表中读出左右子节点的信息进行构建和连接。        if not data:            return None  # 空字符串返回空树        nodes = data.split(&#x27;,&#x27;) # 字符串按逗号分割成列表        root = self.generate(nodes[0])  # 构建根节点        queue = deque([root])        index = 1  # 指向下一个要处理的节点值在nodes中的位置        while queue:            parent = queue.popleft() #这个循环是按层从顶到下遍历的，parent是父节点            if index &lt; len(nodes):                # 生成父节点的左孩子，补点思想                parent.left = self.generate(nodes[index])                index += 1            if index &lt; len(nodes):                # 生成父节点的右孩子，补点思想                parent.right = self.generate(nodes[index])                index += 1            # 只将非空子节点入队            if parent.left:                queue.append(parent.left)            if parent.right:                queue.append(parent.right)        return root    def generate(self, val):        if val == &quot;#&quot;:            return None  # 空点返回None，补点思想        return Code06_LevelorderSerializeAndDeserialize.TreeNode(int(val))  # 普通点返回节点对象\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n核心技巧：层序遍历 + 补点思想\n\n\n题目七：利用先序与中序遍历序列构造二叉树问题描述根据一棵树的前序遍历与中序遍历构造二叉树。要求没有重复元素。\n测试链接：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\n\n核心思想递归分治。先序遍历的第一个元素是当前子树的根。在中序遍历中找到这个根，其左边的所有元素构成左子树，右边的所有元素构成右子树。根据左子树的元素数量，可以确定先序遍历中左右子树的范围，从而递归构建。\n算法实现# 提交如下的方法def buildTree(self, pre: List[int], tin: List[int]) -&gt; Optional[TreeNode]:    if not pre or not tin or len(pre) != len(tin):        return None    # 为了快速查找根节点在中序遍历中的位置，预处理成哈希表    in_map = &#123;val: i for i, val in enumerate(tin)&#125;    return self._f(pre, 0, len(pre) - 1, tin, 0, len(tin) - 1, in_map) #初始化方法def _f(self, pre, l1, r1, tin, l2, r2, in_map):    if l1 &gt; r1:        return None    head = self.TreeNode(pre[l1])    if l1 == r1: # 如果l1和r1相等，说明只有一个节点，直接返回head        return head        # k是根节点在中序遍历中的位置    k = in_map[pre[l1]]    # 左子树的节点数量    left_size = k - l2        # 递归构建左子树和右子树    # pre : l1(........)[.......r1] -&gt; l1是根, (l1+1...l1+left_size)是左子树, (...)是右子树    # in  : (l2......)k[........r2] -&gt; k是根, (l2...k-1)是左子树, [...]是右子树    head.left = self._f(pre, l1 + 1, l1 + left_size, tin, l2, k - 1, in_map)    head.right = self._f(pre, l1 + left_size + 1, r1, tin, k + 1, r2, in_map)    return head\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n核心技巧：递归分治 + 哈希表优化\n\n\n题目八：验证完全二叉树问题描述给定一个二叉树，确定它是否是一个完全二叉树。在一棵完全二叉树中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都要靠左。\n测试链接：https://leetcode.cn/problems/check-completeness-of-a-binary-tree/\n\n核心思想使用BFS进行层序遍历。一棵完全二叉树有两个特点：\n\n任何节点不能只有右孩子没有左孩子\n在层序遍历中，一旦遇到第一个孩子不双全的节点，之后遇到的所有节点都必须是叶子节点\n\n算法实现# 提交以下的方法，实际上是一个又一个节点的bfsdef isCompleteTree(self, h: Optional[TreeNode]) -&gt; bool:    if not h:        return True    queue = deque([h])    # 是否遇到过左右两个孩子不双全的节点    leaf_stage = False    while queue:        node = queue.popleft()        # case 1: 如果一个节点只有右孩子没有左孩子，必不是完全二叉树        # case 2: 如果已经遇到了不双全的节点(进入leaf_stage)，后面又出现了孩子节点，也不是完全二叉树        if (not node.left and node.right) or \\            (leaf_stage and (node.left or node.right)):            return False        if node.left:            queue.append(node.left)        if node.right:            queue.append(node.right)                # 一旦遇到孩子不双全的节点，就进入leaf_stage设为true，下一次循环中进行判断        if not node.left or not node.right:            leaf_stage = True    return True\n\n算法分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n核心技巧：BFS + 状态标记\n\n\n题目九：求完全二叉树的节点个数问题描述给出一个完全二叉树，求出该树的节点个数。要求时间复杂度低于O(N)。\n测试链接：https://leetcode.cn/problems/count-complete-tree-nodes/\n\n核心思想利用完全二叉树的性质进行优化。对于任意节点，其左子树和右子树中，至少有一个是满二叉树。通过比较左右子树的高度，可以判断出哪个是满二叉树，从而用公式 (2^h - 1) 快速计算其节点数，然后只需递归计算另一半子树。每次递归都会下降一层，所以递归深度最多是 O(logN)，每次调用 _mostLeft 的时间复杂度是 O(logN)，这使得时间复杂度从O(N)降低到O((logN)^2)。\n算法实现def countNodes(self, head: Optional[TreeNode]) -&gt; int:    if not head:        return 0    h = self._mostLeft(head, 1)  # 计算整棵树的高度    return self._f(head, 1, h)def _f(self, cur, level, h):    &quot;&quot;&quot;    cur: 当前来到的节点    level: 当前cur来到的节点在第几层    h: 整棵树的高度    返回: cur这棵子树上有多少节点    &quot;&quot;&quot;    if level == h: # base case: 遍历到了最底层        return 1        # 如果右子树的最左路径能到达整棵树的最后一层    if self._mostLeft(cur.right, level + 1) == h:        # 说明cur的左子树是满二叉树，其节点数可以直接计算        # 节点总数 = 左子树节点数(2^(h-level)-1) + 根节点(1) + 递归求右子树节点数        # 合并后就是 (1 &lt;&lt; (h - level)) + 递归求右子树        return (1 &lt;&lt; (h - level)) + self._f(cur.right, level + 1, h) #1 &lt;&lt; n 表示将数字1向左移动n位    else: #if else判断往左递归还是往右递归        # 否则，说明cur的右子树是比左子树少一层的满二叉树        # 节点总数 = 右子树节点数(2^(h-level-1)-1) + 根节点(1) + 递归求左子树节点数        # 合并后就是 (1 &lt;&lt; (h - level - 1)) + 递归求左子树        return (1 &lt;&lt; (h - level - 1)) + self._f(cur.left, level + 1, h)def _mostLeft(self, cur, level):    &quot;&quot;&quot;    当前节点是cur，并且它在level层    返回从cur开始不停往左，能扎到几层    &quot;&quot;&quot;    while cur:        level += 1        cur = cur.left    return level - 1    \n\n算法分析\n时间复杂度：O((logN)²)\n空间复杂度：O(logN)\n核心技巧：完全二叉树性质 + 满二叉树公式\n\n\n核心技巧总结1. BFS层序遍历# 标准BFS模板queue = deque([root])while queue:    size = len(queue)  # 当前层节点数    for _ in range(size):  # 处理当前层        node = queue.popleft()        # 处理当前节点        if node.left:            queue.append(node.left)        if node.right:            queue.append(node.right)\n\n2. 树的递归# 递归模板def traverse(root):    if not root:  # base case        return    # 处理当前节点    traverse(root.left)   # 递归左子树    traverse(root.right)  # 递归右子树\n\n3. 完全二叉树编号# 根节点编号为1# 左子节点编号为 2*i# 右子节点编号为 2*i + 1\n\n4. 序列化技巧# 先序序列化：根-左-右# 层序序列化：逐层BFS + 补点# 中序无法唯一确定树结构\n\n复杂度分析总结\n\n\n题目\n时间复杂度\n空间复杂度\n核心算法\n\n\n\n层序遍历\nO(N)\nO(N)\nBFS\n\n\n锯齿形遍历\nO(N)\nO(N)\nBFS + 反转\n\n\n最大宽度\nO(N)\nO(N)\nBFS + 编号\n\n\n最大&#x2F;最小深度\nO(N)\nO(H)\n递归\n\n\n先序序列化\nO(N)\nO(N)\n递归 + 迭代器\n\n\n层序序列化\nO(N)\nO(N)\nBFS + 补点\n\n\n构造二叉树\nO(N)\nO(N)\n递归 + 哈希表\n\n\n验证完全二叉树\nO(N)\nO(N)\nBFS + 状态\n\n\n完全二叉树节点数\nO((logN)²)\nO(logN)\n递归 + 性质\n\n\n学习建议\n掌握BFS和DFS：这是处理树问题的两大基本方法\n\n理解递归本质：树的递归结构使得很多问题都可以用递归解决\n\n灵活运用数据结构：\n\n队列（BFS）\n哈希表（快速查找）\n迭代器（序列化处理）\n\n\n注意边界条件：\n\n空树处理\n叶子节点判断\n层级边界\n\n\n理解树的性质：\n\n完全二叉树的特点\n满二叉树的节点公式\n不同遍历方式的特点\n\n\n练习组合技巧：很多树的问题需要组合多种基础算法\n\n\n通过掌握这些经典的二叉树算法，可以为后续学习更复杂的树型动态规划和高级树结构打下坚实的基础。\n037【必备】二叉树高频题目-下-不含树型dp初始化的二叉树类class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right\n\n题目一：普通二叉树上寻找两个节点的最近公共祖先问题描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n测试链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/\n\n核心思想采用递归的方式深度优先搜索：\n\n如果当前节点为空，或者等于p或q中的一个，那么它本身就是其子树中p或q的LCA\n否则，递归地在左子树和右子树中寻找p和q\n如果左右子树都返回了非空节点，说明p和q分别位于当前节点的两侧，当前节点就是LCA\n如果只有一个子树返回了非空节点，说明p和q都在那个子树中，返回那个非空节点即可\n如果左右子树都返回空，说明p和q都不在此子树中。\n\n算法实现class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        &quot;&quot;&quot;        寻找最近公共祖先的核心函数        采用递归的方式深度优先搜索        &quot;&quot;&quot;        # 遇到空，或者p，或者q，直接返回        # 这是递归的基准情况 (base case)        if not root or root == p or root == q: # 如果root不空的话，这样从下往上会一直传p或者q            return root        # 在左子树和右子树中递归查找 p 和 q        l = self.lowestCommonAncestor(root.left, p, q)        r = self.lowestCommonAncestor(root.right, p, q)        # 左树也搜到，右树也搜到，返回root        # 这意味着p和q分别在root的左右两侧，root是它们的LCA        if l and r:            return root                # 如果左右子树的搜索结果都为空，说明p,q不在此子树        if not l and not r:            return None                # l和r一个为空，一个不为空        # 返回不空的那个，这个非空节点要么是p或q本身，要么已经是p和q的LCA        return l if l else r\n\n算法分析\n时间复杂度：O(N)，最坏情况下需要遍历所有节点\n空间复杂度：O(H)，H为树的高度，递归栈的深度\n核心技巧：递归 + 分情况讨论\n\n\n题目二：搜索二叉树上寻找两个节点的最近公共祖先问题描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n测试链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/\n\n核心思想利用BST的特性，可以高效地进行迭代查找：\n\n从根节点开始遍历\n如果p和q的值都小于当前节点的值，说明LCA必定在左子树，往左走\n如果p和q的值都大于当前节点的值，说明LCA必定在右子树，往右走\n如果当前节点的值在p和q的值之间（或者等于其中一个），那么当前节点就是第一个”分叉点”，即为LCA\n\n算法实现class Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        &quot;&quot;&quot;        在二叉搜索树(BST)中寻找最近公共祖先        利用BST的特性，可以高效地进行迭代查找        &quot;&quot;&quot;        # 确定p和q节点值的范围        min_val = min(p.val, q.val)        max_val = max(p.val, q.val)        # 循环遍历，直到找到LCA        while root:            # 如果当前节点的值大于p和q的最大值，说明LCA在左子树            if root.val &gt; max_val:                root = root.left            # 如果当前节点的值小于p和q的最小值，说明LCA在右子树            elif root.val &lt; min_val:                root = root.right            # 否则，当前节点的值在[min_val, max_val]之间，它就是LCA            else:                return root                return None # 理论上在有效输入下不会到达这里\n\n算法分析\n时间复杂度：O(H)，H为树的高度\n空间复杂度：O(1)\n核心技巧：利用BST性质 + 迭代\n\n\n题目三：收集累加和等于aim的所有路径问题描述给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，返回所有从根节点到叶子节点路径总和等于给定目标和的路径。\n测试链接：https://leetcode.cn/problems/path-sum-ii/\n\n核心思想使用DFS + 回溯的方法：\n\n维护一个当前路径 path 和当前路径和 current_sum\n深入遍历树，每经过一个节点，就将其加入 path，并更新 current_sum\n当到达一个叶子节点时，检查 current_sum + cur.val是否等于目标值，如果是，将当前路径（包括叶子节点）的一个副本添加到最终结果 ans 中\n遍历完一个节点的所有子树后，需要回溯，即将该节点从 path 中移除，以便返回到父节点继续搜索其他分支\n\n算法实现from typing import List, Optionalclass Solution:    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; List[List[int]]:        &quot;&quot;&quot;        主函数，初始化结果列表和路径列表，并启动递归搜索        &quot;&quot;&quot;        ans = []        if root:            path = []            # 调用递归辅助函数 f            self.f(root, targetSum, 0, path, ans) # 一开始sum=0，ans也是空列表，path也是空列表        return ans    def f(self, cur: TreeNode, aim: int, current_sum: int, path: List[int], ans: List[List[int]]):        &quot;&quot;&quot;        递归辅助函数，用于深度优先搜索所有路径        &quot;&quot;&quot;          # 将当前节点值加入路径        path.append(cur.val)                 # 判断是否为叶节点        is_leaf = cur.left is None and cur.right is None                 if is_leaf:            # 叶节点            # 如果当前路径和加上叶节点的值等于目标值，则找到一个有效路径            if current_sum + cur.val == aim:                 # 将路径的副本添加到结果中                # 必须是副本(path[:])，否则后续的回溯操作会影响已存入的结果                ans.append(path[:])        else:            # 不是叶节点            # 递归探索左子树            if cur.left:                self.f(cur.left, aim, current_sum + cur.val, path, ans)            # 递归探索右子树            if cur.right:                self.f(cur.right, aim, current_sum + cur.val, path, ans)                # 回溯步骤：当一个节点的左右子树都探索完毕后，        # 将该节点从当前路径中移除，返回到其父节点的递归调用中。        path.pop() # 用 path.pop() 把刚才加入的那个节点移除，恢复到进入递归前的状态\n\n回溯不会死循环的原因\n控制流是”递归调用”不是”循环依赖”：每次调用只会递归左子树、右子树各最多一次\nfor&#x2F;if 的次数是固定的：子树递归只发生在固定的分支中，不会因为pop重复触发\npop 只是在撤销路径，不改变遍历指针：pop 修改的是 path 内容，用于恢复现场；并不改变 cur、cur.left、cur.right 的结构或递归栈帧。可以把它看作：DFS 到底（或到叶&#x2F;路尽）后，撤销上一步选择，然后走兄弟分支；兄弟分支走完，再撤销并上返……直到根。整个过程单调“回退”栈帧，不可能形成死循环。这个调用栈帧的所有工作（检查&#x2F;递归左右）都完成了，撤销现场后，自然结束返回到父调用。\n\n算法分析\n时间复杂度：O(N²)，最坏情况下每条路径都需要复制\n空间复杂度：O(H)，H为树的高度\n核心技巧：DFS + 回溯 + 路径复制\n\n\n题目四：验证平衡二叉树问题描述给定一个二叉树，判断它是否是高度平衡的二叉树。一个高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。\n测试链接：https://leetcode.cn/problems/balanced-binary-tree/\n\n核心思想使用后序遍历的思想：\n\n要判断当前节点是否平衡，需要先知道其左右子树的高度\n这天然地符合后序遍历的顺序（先左、再右、后根）\n递归地计算左子树和右子树的高度\n在计算完左右子树高度后，检查它们的高度差\n使用一个实例变量来记录是否已发现不平衡，一旦发现不平衡，就将此标志设为False，后续的递归调用可以提前终止。\n\n算法实现from typing import Optionalclass Solution:    def __init__(self):        # balance是实例变量，用于在递归调用中共享状态，所以能够实现全局变量的效果        # 每次判断开始时，在主函数中将其重置为true        self.balance = True    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:        &quot;&quot;&quot;        主函数，用于启动平衡性检查        &quot;&quot;&quot;        # 重置平衡标志        self.balance = True        # 调用递归函数计算高度并检查平衡性        self.height(root)        return self.balance    def height(self, cur: Optional[TreeNode]) -&gt; int:        &quot;&quot;&quot;        递归计算节点高度，并在此过程中检查平衡性        &quot;&quot;&quot;        # 核心思想（后序遍历）：        # 1. 要判断当前节点是否平衡，需要先知道其左右子树的高度。        # 2. 这天然地符合后序遍历的顺序（先左、再右、后根）。        # 3. 递归地计算左子树和右子树的高度。        # 4. 在计算完左右子树高度后，检查它们的高度差。如果差值大于1，说明树不平衡。        # 5. 使用一个全局或实例变量 `self.balance` 来记录是否已发现不平衡。        #    一旦发现不平衡，就将此标志设为False，后续的递归调用可以提前终止。        # 一旦发现不平衡，或者当前节点为空，返回0，后续计算已无意义或到达递归边界        if not self.balance or cur is None:            return 0                # 递归计算左子树的高度        lh = self.height(cur.left)        # 递归计算右子树的高度        rh = self.height(cur.right)                # 检查左右子树的高度差        if abs(lh - rh) &gt; 1:            # 如果高度差大于1，则标记为不平衡            self.balance = False                # 返回当前节点的高度，即左右子树中较高者的高度加1        # 叶子节点的高度为 1，因为它的左右子树高度都是 0，返回 max(0, 0) + 1 = 1        return max(lh, rh) + 1\n\n算法分析\n时间复杂度：O(N)，每个节点访问一次\n空间复杂度：O(H)，H为树的高度\n核心技巧：后序遍历 + 全局状态\n\n\n题目五：验证搜索二叉树问题描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n测试链接：https://leetcode.cn/problems/validate-binary-search-tree/\n\n核心思想有两种实现方法：\n方法一：中序遍历一个有效的BST，其中序遍历的结果必然是一个严格递增的序列。\n方法二：递归验证对任意一个节点，它必须满足：\n\n它的左子树是BST，且左子树所有节点的值都小于它自身的值\n它的右子树是BST，且右子树所有节点的值都大于它自身的值\n\n算法实现方法一：迭代实现的中序遍历def isValidBST1(self, head: Optional[TreeNode]) -&gt; bool:    &quot;&quot;&quot;    通过迭代方式进行中序遍历来验证BST。    核心思想：    一个有效的BST，其中序遍历的结果必然是一个严格递增的序列。    因此，我们可以在遍历过程中，持续比较当前节点的值和前一个节点的值。    如果发现当前节点值小于或等于前一个节点值，那么它就不是一个BST。    &quot;&quot;&quot;    if not head:        return True        stack = []    pre_node = None        # 使用cur指针和栈来模拟递归的中序遍历    cur = head    while stack or cur:        if cur:            # 一直向左，将路径上的节点入栈            stack.append(cur)            cur = cur.left        else:            # 左边到头了，从栈中弹出一个节点，这个就是中序遍历的当前节点            cur = stack.pop()                        # 检查中序遍历的有序性，pre_node是当前节点的前一个节点            if pre_node is not None and pre_node.val &gt;= cur.val:                return False                        # 更新前一个节点，然后转向右子树            pre_node = cur            cur = cur.right                return True\n\n方法二：递归实现def __init__(self):    # 实例变量，用于在递归调用中传递子树的最小值和最大值    self.min_val = float(&#x27;inf&#x27;)    self.max_val = float(&#x27;-inf&#x27;)def isValidBST2(self, head: Optional[TreeNode]) -&gt; bool:    &quot;&quot;&quot;    通过递归方式验证BST。    核心思想：    对任意一个节点，它必须满足：    1. 它的左子树是BST，且左子树所有节点的值都小于它自身的值。    2. 它的右子树是BST，且右子树所有节点的值都大于它自身的值。    这个过程可以通过后序遍历，在返回时收集子树的信息（是否为BST，最大值，最小值）来完成。    &quot;&quot;&quot;    # Base case是 head is None，即空树的情况，    if head is None:        # 基准情况：空树是有效的BST        # 初始化min和max，确保不影响上层计算        self.min_val = float(&#x27;inf&#x27;)        self.max_val = float(&#x27;-inf&#x27;)        return True    # 递归检查左子树是不是有效的BST    is_left_ok = self.isValidBST2(head.left)    l_min = self.min_val  # 保存左子树的最小值    l_max = self.max_val  # 保存左子树的最大值        # 递归检查右子树是不是有效的BST    is_right_ok = self.isValidBST2(head.right)    r_min = self.min_val    r_max = self.max_val        # 更新当前树的min和max值    self.min_val = min(l_min, r_min, head.val)    self.max_val = max(l_max, r_max, head.val)        # 综合判断当前节点是否满足BST的条件    # 1. 左右子树本身都是BST (is_left_ok and is_right_ok)    # 2. 左子树的最大值必须小于当前节点值 (l_max &lt; head.val)    # 3. 右子树的最小值必须大于当前节点值 (head.val &lt; r_min)    return is_left_ok and is_right_ok and l_max &lt; head.val and head.val &lt; r_min\n\n算法分析\n时间复杂度：O(N)，每个节点访问一次\n空间复杂度：O(H)，H为树的高度\n核心技巧：中序遍历有序性 &#x2F; 递归验证BST性质\n\n\n题目六：修剪搜索二叉树问题描述给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。\n测试链接：https://leetcode.cn/problems/trim-a-binary-search-tree/\n\n核心思想利用BST的性质进行递归：\n\n如果 cur.val &lt; low，那么 cur 和它的整个左子树都应该被删除，修剪后的树必定在右子树中\n如果 cur.val &gt; high，那么 cur 和它的整个右子树都应该被删除，修剪后的树必定在左子树中\n如果 low &lt;= cur.val &lt;= high，那么当前节点应该被保留，继续递归地修剪左右子树\n\n算法实现from typing import Optionalclass Solution:    def trimBST(self, cur: Optional[TreeNode], low: int, high: int) -&gt; Optional[TreeNode]:        &quot;&quot;&quot;        递归地修剪二叉搜索树。        核心思想：        利用BST的性质进行递归。对于当前节点 `cur`：        1. 如果 `cur.val &lt; low`，那么 `cur` 和它的整个左子树都应该被删除。           修剪后的树必定在 `cur` 的右子树中，因此我们返回对右子树的修剪结果。        2. 如果 `cur.val &gt; high`，那么 `cur` 和它的整个右子树都应该被删除。           修剪后的树必定在 `cur` 的左子树中，因此我们返回对左子树的修剪结果。        3. 如果 `low &lt;= cur.val &lt;= high`，那么 `cur` 节点应该被保留。           我们继续递归地修剪它的左子树和右子树，并将返回的结果作为 `cur` 新的左、右孩子。           最后返回 `cur` 本身。        &quot;&quot;&quot;        # base case是 cur is None，即空树的情况，返回None        if cur is None:            return None                # 当前节点值太小，应该在右子树中寻找有效部分        if cur.val &lt; low:            return self.trimBST(cur.right, low, high)                # 当前节点值太大，应该在左子树中寻找有效部分        if cur.val &gt; high:            return self.trimBST(cur.left, low, high)                # 当前节点在 [low, high] 范围内，保留该节点        # 然后递归地处理它的左子树和右子树        cur.left = self.trimBST(cur.left, low, high)        cur.right = self.trimBST(cur.right, low, high)                # 返回处理后的当前节点        return cur\n\n算法分析\n时间复杂度：O(N)，最坏情况下访问所有节点\n空间复杂度：O(H)，H为树的高度\n核心技巧：利用BST性质 + 递归修剪\n\n\n题目七：二叉树打家劫舍问题问题描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为”根”。除了”根”之外，每栋房子有且只有一个”父”房子与之相连。一番侦察之后，聪明的小偷意识到”这个地方的所有房屋的排列类似于一棵二叉树”。如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的前提下，小偷一晚能够盗取的最高金额。\n测试链接：https://leetcode.cn/problems/house-robber-iii/\n\n核心思想树形DP问题。对于任意一个节点，我们考虑两种情况：\n\n偷当前节点：那么它的左右孩子节点都不能偷\n不偷当前节点：那么它的左右孩子可以偷也可以不偷，取两者中的较大值\n\n通过后序遍历，我们可以先计算出左右子树的结果，再用来推导当前节点的结果。\n算法实现from typing import Optionalclass Solution:    def __init__(self):        # 实例变量，用于在递归中保存子问题的解        # yes: 表示在X子树中，偷头节点的情况下能获得的最大收益        # no: 表示在X子树中，不偷头节点的情况下能获得的最大收益        self.yes = 0        self.no = 0    def rob(self, root: Optional[TreeNode]) -&gt; int:        &quot;&quot;&quot;        主函数，启动递归计算        &quot;&quot;&quot;        self.f(root)        return max(self.yes, self.no)    def f(self, root: Optional[TreeNode]):        &quot;&quot;&quot;        递归函数，采用后序遍历计算以root为根的子树的打劫收益        核心思想 (树形DP):        对于任意一个节点 `root`，我们考虑两种情况：        1. 偷 `root` 节点：那么它的左右孩子节点都不能偷。           最大收益 = `root.val` + 左子树不偷的最大收益 + 右子树不偷的最大收益。        2. 不偷 `root` 节点：那么它的左右孩子可以偷也可以不偷，取两者中的较大值。           最大收益 = max(偷左孩子，不偷左孩子) + max(偷右孩子，不偷右孩子)。                通过后序遍历，我们可以先计算出左右子树的结果，再用来推导当前节点的结果。        &quot;&quot;&quot;        if root is None:            # 基准情况：空节点收益为0            self.yes = 0            self.no = 0            return        # 暂存当前节点的收益        current_yes = root.val        current_no = 0                # 先递归处理左子树，再处理右子树        self.f(root.left)        # 此时 self.yes 和 self.no 是左子树的结果                # 更新当前节点的收益：        # 如果偷当前节点，则不能偷左孩子，所以加上左子树不偷的收益 no        current_yes += self.no         # 如果不偷当前节点，则左孩子可偷可不偷，取最大值        current_no += max(self.yes, self.no)                # 递归处理右子树        self.f(root.right)        # 此时 self.yes 和 self.no 是右子树的结果                # 再次更新当前节点的收益：        # 加上右子树的贡献        current_yes += self.no        current_no += max(self.yes, self.no)                # 将最终计算出的当前节点的结果，存回实例变量，供上层调用使用        self.yes = current_yes        self.no = current_no\n\n算法分析\n时间复杂度：O(N)，每个节点访问一次\n空间复杂度：O(H)，H为树的高度\n核心技巧：树形DP + 后序遍历\n\n\n核心技巧总结1. LCA问题模板def lowestCommonAncestor(self, root, p, q):    if not root or root == p or root == q:        return root        left = self.lowestCommonAncestor(root.left, p, q)    right = self.lowestCommonAncestor(root.right, p, q)        if left and right:        return root    return left if left else right\n\n2. 路径搜索 + 回溯模板def dfs(node, path, target):    path.append(node.val)  # 选择        if is_leaf(node):        if meets_condition():            result.append(path[:])  # 记录答案    else:        dfs(node.left, path, target)   # 递归        dfs(node.right, path, target)  # 递归        path.pop()  # 撤销选择（回溯）\n\n3. BST性质利用# BST中序遍历是有序的# BST搜索可以利用大小关系剪枝# BST的LCA在分叉点\n\n4. 树形DP模板def tree_dp(node):    if not node:        return base_case        # 后序遍历：先处理子树    left_result = tree_dp(node.left)    right_result = tree_dp(node.right)        # 根据子树结果计算当前节点结果    current_result = combine(node.val, left_result, right_result)        return current_result\n\n复杂度分析总结\n\n\n题目\n时间复杂度\n空间复杂度\n核心算法\n\n\n\n普通二叉树LCA\nO(N)\nO(H)\n递归DFS\n\n\nBST的LCA\nO(H)\nO(1)\n利用BST性质\n\n\n路径和问题\nO(N²)\nO(H)\nDFS + 回溯\n\n\n验证平衡二叉树\nO(N)\nO(H)\n后序遍历\n\n\n验证BST\nO(N)\nO(H)\n中序遍历&#x2F;递归\n\n\n修剪BST\nO(N)\nO(H)\n递归修剪\n\n\n打家劫舍III\nO(N)\nO(H)\n树形DP\n\n\n学习建议\n掌握LCA问题：这是树算法中的经典问题，有多种解法和应用\n\n理解BST性质：\n\n中序遍历有序\n可以利用大小关系进行搜索优化\n左子树 &lt; 根 &lt; 右子树\n\n\n掌握回溯模板：\n\n做选择 → 递归 → 撤销选择\n注意保存结果时要使用副本\n\n\n理解树形DP：\n\n后序遍历获取子树信息\n根据子树状态计算当前状态\n状态定义要考虑所有可能情况\n\n\n注意边界条件：\n\n空节点处理\n叶子节点判断\n单节点情况\n\n\n练习状态管理：\n\n实例变量在递归中的使用\n多个状态的传递和更新\n\n\n\n通过掌握这些经典的二叉树问题，可以深入理解树的递归性质，为学习更高级的树算法和动态规划打下基础。这些问题模式在实际编程中经常出现，是算法面试的重点内容。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","递归","回溯","DFS","二叉树","BFS","LCA"]},{"title":"数据结构与算法自学笔记（2）- 链表相关","url":"/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了class009 -&gt; class012，涵盖了链表的基础概念、反转操作、合并算法、链表运算以及分割技巧等内容。\n\n009【入门】单双链表及其反转链表的基本概念链表是一种线性数据结构，其中元素存储在节点中，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不必连续存储。\n单链表节点定义class ListNode:    &quot;&quot;&quot;    单链表节点类    &quot;&quot;&quot;    def __init__(self, val=0, next=None):        self.val = val                    # 节点存储的数据值        self.next = next                  # 指向下一个节点的指针\n\n双链表节点定义class DoubleListNode:    &quot;&quot;&quot;    双链表节点类    每个节点有两个指针：指向前驱和后继    &quot;&quot;&quot;    def __init__(self, value):        self.value = value                # 节点存储的数据值        self.last = None                  # 指向前一个节点的指针        self.next = None                  # 指向下一个节点的指针\n\n单链表反转算法反转单链表测试链接 : https://leetcode.cn/problems/reverse-linked-list/\n迭代方法实现单链表反转是链表操作中的经典问题，核心思想是改变节点间的指针方向。\nclass ListReverseOperations:    @staticmethod    def reverse_linked_list(head):        &quot;&quot;&quot;        反转单链表 - 迭代实现        时间复杂度: O(n), 空间复杂度: O(1)                参数: head - 链表头节点        返回: 反转后链表的头节点        &quot;&quot;&quot;        pre = None                        # 前驱节点指针，初始为None        next_node = None                  # 临时保存下一个节点                while head is not None:           # 遍历整个链表            next_node = head.next         # 保存下一个节点，防止链表断裂            head.next = pre               # 当前节点指向前驱（反转指针）            pre = head                    # 前驱指针前进到当前节点            head = next_node              # 头指针前进到下一个节点                return pre                        # pre此时指向原链表的尾节点，即新链表的头节点\n\n反转过程图解\n具体在上面的实现中，是利用next向后移动 利用pre改变方指针向\n原链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL第1步: pre=NULL, head=1, next=2      NULL &lt;- 1    2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL             pre  head第2步: pre=1, head=2, next=3        NULL &lt;- 1 &lt;- 2    3 -&gt; 4 -&gt; 5 -&gt; NULL                  pre  head第3步: pre=2, head=3, next=4      NULL &lt;- 1 &lt;- 2 &lt;- 3    4 -&gt; 5 -&gt; NULL                        pre  head最终: NULL &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5                                  pre\n\n递归方法实现@staticmethoddef reverse_linked_list_recursive(head):    &quot;&quot;&quot;    反转单链表 - 递归实现    时间复杂度: O(n), 空间复杂度: O(n) - 递归栈空间        参数: head - 链表头节点    返回: 反转后链表的头节点    &quot;&quot;&quot;    # 基础情况：空链表或单节点链表    if head is None or head.next is None:        return head        # 递归反转剩余部分    new_head = ListReverseOperations.reverse_linked_list_recursive(head.next)        # 反转当前节点与下一个节点的连接    head.next.next = head             # 下一个节点指回当前节点    head.next = None                  # 当前节点的next置空        return new_head                   # 返回新的头节点\n\n双链表反转算法双链表的反转需要同时处理前驱和后继两个指针，相比单链表更加复杂。\n@staticmethoddef reverse_double_list(head):    &quot;&quot;&quot;    反转双链表    时间复杂度: O(n), 空间复杂度: O(1)        参数: head - 双链表头节点    返回: 反转后双链表的头节点    &quot;&quot;&quot;    pre = None                        # 前驱节点指针    next_node = None                  # 临时保存下一个节点        while head is not None:           # 遍历整个双链表        next_node = head.next         # 保存下一个节点                # 交换当前节点的前驱和后继指针        head.next = pre               # next指向前驱        head.last = next_node         # last指向后继                pre = head                    # 前驱指针前进        head = next_node              # 头指针前进        return pre                        # 返回新的头节点\n\n双链表反转的关键点\n指针交换：每个节点的next和last指针需要互换方向\n边界处理：正确处理链表两端的NULL指针\n遍历顺序：确保在修改指针前保存必要的信息\n\n\n010【入门】合并两个有序链表测试链接 : https://leetcode.cn/problems/merge-two-sorted-lists/\n问题描述给定两个已排序的链表，将它们合并成一个新的有序链表。新链表应该通过拼接给定的两个链表的所有节点组成。\n算法思想采用双指针技术，比较两个链表当前节点的值，选择较小的节点添加到结果链表中，然后移动对应的指针。\n实现方案class Solution:    @staticmethod    def merge_two_lists(head1, head2):        &quot;&quot;&quot;        合并两个有序链表        时间复杂度: O(m + n), 空间复杂度: O(1)                参数: head1, head2 - 两个有序链表的头节点        返回: 合并后有序链表的头节点        &quot;&quot;&quot;        # 边界情况处理：其中一个链表为空        if head1 is None or head2 is None:            return head2 if head1 is None else head1                # 确定合并后链表的头节点        if head1.val &lt;= head2.val:            head = head1                  # head1的值更小，作为头节点            cur1 = head1.next             # cur1指向head1的下一个节点            cur2 = head2                  # cur2指向head2的当前节点        else:            head = head2                  # head2的值更小，作为头节点            cur1 = head1                  # cur1指向head1的当前节点            cur2 = head2.next             # cur2指向head2的下一个节点                pre = head                        # pre用于构建结果链表                # 双指针遍历两个链表        while cur1 is not None and cur2 is not None:            if cur1.val &lt;= cur2.val:     # cur1的值更小或相等                pre.next = cur1           # 将cur1连接到结果链表                cur1 = cur1.next          # cur1指针后移            else:                         # cur2的值更小                pre.next = cur2           # 将cur2连接到结果链表                cur2 = cur2.next          # cur2指针后移            pre = pre.next                # 结果链表指针后移                # 处理剩余节点：将未遍历完的链表直接连接到结果链表末尾        pre.next = cur1 if cur1 is not None else cur2                return head                       # 返回合并后链表的头节点\n\n算法优化版本@staticmethoddef merge_two_lists_optimized(head1, head2):    &quot;&quot;&quot;    合并两个有序链表 - 优化版本    使用虚拟头节点简化边界处理    &quot;&quot;&quot;    dummy = ListNode(0)               # 创建虚拟头节点    current = dummy                   # 当前指针指向虚拟头节点        # 双指针遍历两个链表    while head1 is not None and head2 is not None:        if head1.val &lt;= head2.val:            current.next = head1      # 连接较小节点            head1 = head1.next        # 移动head1指针        else:            current.next = head2      # 连接较小节点            head2 = head2.next        # 移动head2指针        current = current.next        # 移动结果链表指针        # 连接剩余节点    current.next = head1 if head1 is not None else head2        return dummy.next                 # 返回真正的头节点\n\n合并过程示例链表1: 1 -&gt; 2 -&gt; 4链表2: 1 -&gt; 3 -&gt; 4合并过程:step1: 比较1和1，选择链表1的1    结果: 1step2: 比较2和1，选择链表2的1    结果: 1 -&gt; 1  step3: 比较2和3，选择链表1的2    结果: 1 -&gt; 1 -&gt; 2step4: 比较4和3，选择链表2的3    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3step5: 比较4和4，选择链表1的4    结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4step6: 连接剩余的4              结果: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n\n\n011【入门】两个链表相加测试链接：https://leetcode.cn/problems/add-two-numbers/\n问题描述给定两个非空链表来表示两个非负整数，数字最高位位于链表开始位置。它们的每个节点只存储一位数字，计算两个数的和并以相同形式返回一个表示和的链表。\n核心思想模拟手工加法运算，从链表尾部开始逐位相加，处理进位问题。\n算法实现class Solution:    @staticmethod    def add_two_numbers(h1, h2):        &quot;&quot;&quot;        两个链表数字相加        时间复杂度: O(max(m,n)), 空间复杂度: O(max(m,n))                参数: h1, h2 - 两个表示数字的链表头节点        返回: 表示和的链表头节点        &quot;&quot;&quot;        ans = None                        # 结果链表头节点        cur = None                        # 当前构建位置指针        carry = 0                         # 进位标志                # 遍历两个链表，直到都为空        while h1 is not None or h2 is not None:            # 获取当前位的数字，如果链表已结束则为0            val1 = h1.val if h1 is not None else 0            val2 = h2.val if h2 is not None else 0                        # 计算当前位的和（包括进位）            total = val1 + val2 + carry            carry = total // 10           # 计算新的进位            digit = total % 10            # 当前位的数字                        # 构建结果链表            if ans is None:               # 第一个节点                ans = ListNode(digit)                cur = ans            else:                         # 后续节点                cur.next = ListNode(digit)                cur = cur.next                        # 移动链表指针            h1 = h1.next if h1 is not None else None            h2 = h2.next if h2 is not None else None                # 处理最后的进位        if carry == 1:            cur.next = ListNode(1)                return ans                        # 返回结果链表头节点\n\n代码修正与优化优化了源代码最后的进位问题\n@staticmethoddef add_two_numbers_corrected(h1, h2):    &quot;&quot;&quot;    两个链表数字相加 - 优化版本，更加通用    &quot;&quot;&quot;    ans = None                        # 结果链表头节点    cur = None                        # 当前构建位置指针    carry = 0                         # 进位标志        while h1 is not None or h2 is not None:        # 安全获取节点值，避免空指针异常        val1 = h1.val if h1 is not None else 0        val2 = h2.val if h2 is not None else 0                # 计算当前位的和        total = val1 + val2 + carry        carry = total // 10           # 新进位        digit = total % 10            # 当前位数字                # 构建结果链表节点        new_node = ListNode(digit)        if ans is None:               # 初始化头节点            ans = cur = new_node        else:                         # 连接新节点            cur.next = new_node            cur = new_node                # 安全移动指针        h1 = h1.next if h1 is not None else None        h2 = h2.next if h2 is not None else None        # 处理最终进位    if carry &gt; 0:        cur.next = ListNode(carry)        return ans\n\n算法示例链表1: 2 -&gt; 4 -&gt; 3  (表示数字342)链表2: 5 -&gt; 6 -&gt; 4  (表示数字465)相加过程:位置0: 2 + 5 + 0(进位) = 7, 进位=0  结果: 7位置1: 4 + 6 + 0(进位) = 10, 进位=1  结果: 7 -&gt; 0位置2: 3 + 4 + 1(进位) = 8, 进位=0  结果: 7 -&gt; 0 -&gt; 8最终结果: 7 -&gt; 0 -&gt; 8 (表示数字807)验证: 342 + 465 = 807 ✓\n\n边界情况处理\n不同长度链表：短链表结束后，继续处理长链表的剩余位\n最高位进位：最后可能产生新的最高位\n空链表：输入验证，确保链表非空\n单位数：正确处理个位数相加的情况\n\n\n012【入门】划分链表测试链接 : https://leetcode.cn/problems/partition-list/\n问题描述给定一个链表和一个特定值x，对链表进行分隔，使得所有小于x的节点都在大于或等于x的节点之前。保持两个分区中每个节点的初始相对位置。\n算法思想使用双链表分离的思想：\n\n创建两个独立的链表：小于x的节点链表和大于等于x的节点链表\n遍历原链表，将节点分别添加到对应的链表中\n最后将两个链表连接起来\n\n实现方案class Solution:    @staticmethod    def partition(head, x):        &quot;&quot;&quot;        划分链表        时间复杂度: O(n), 空间复杂度: O(1)                参数: head - 链表头节点, x - 划分值        返回: 划分后链表的头节点        &quot;&quot;&quot;        # 初始化两个链表的头尾指针        left_head = None                  # 小于x的链表头指针        left_tail = None                  # 小于x的链表尾指针        right_head = None                 # 大于等于x的链表头指针        right_tail = None                 # 大于等于x的链表尾指针                next_node = None                  # 临时保存下一个节点                # 遍历原链表，分离节点        while head is not None:            next_node = head.next         # 保存下一个节点            head.next = None              # 断开当前节点的连接                        if head.val &lt; x:              # 当前节点值小于x                if left_head is None:    # 左链表为空                    left_head = head      # 设置左链表头节点                else:                     # 左链表非空                    left_tail.next = head # 连接到左链表尾部                left_tail = head          # 更新左链表尾指针            else:                         # 当前节点值大于等于x                if right_head is None:   # 右链表为空                    right_head = head     # 设置右链表头节点                else:                     # 右链表非空                    right_tail.next = head # 连接到右链表尾部                right_tail = head         # 更新右链表尾指针                        head = next_node              # 移动到下一个节点                # 连接两个链表        if left_head is None:            # 如果左链表为空            return right_head             # 直接返回右链表        else:                            # 左链表非空            left_tail.next = right_head   # 连接左右链表            return left_head              # 返回左链表头节点\n\n代码修正与完善优化了原代码在遍历阶段的指针指代可能不清晰的问题，修改了if else后的指定\nclass Solution:    @staticmethod    def partition_corrected(head, x):        &quot;&quot;&quot;        划分链表 - 修正版本        修复了原代码的语法错误和逻辑问题        &quot;&quot;&quot;        # 初始化四个指针        left_head = left_tail = None      # 小于x的链表头尾指针        right_head = right_tail = None    # 大于等于x的链表头尾指针                # 遍历原链表        while head is not None:            next_node = head.next         # 保存下一个节点            head.next = None              # 断开当前节点                        if head.val &lt; x:              # 节点值小于x                if left_head is None:    # 第一个小于x的节点                    left_head = left_tail = head                else:                     # 后续小于x的节点                    left_tail.next = head                    left_tail = head            else:                         # 节点值大于等于x                if right_head is None:   # 第一个大于等于x的节点                    right_head = right_tail = head                else:                     # 后续大于等于x的节点                    right_tail.next = head                    right_tail = head                        head = next_node              # 移动到下一个节点                # 合并两个链表        if left_head is None:            # 只有大于等于x的节点            return right_head                left_tail.next = right_head       # 连接两个链表        return left_head                  # 返回结果链表头节点\n\n优化版本：使用虚拟头节点@staticmethoddef partition_optimized(head, x):    &quot;&quot;&quot;    划分链表 - 优化版本    使用虚拟头节点简化代码逻辑，简化了边界处理    &quot;&quot;&quot;    # 创建虚拟头节点    left_dummy = ListNode(0)          # 小于x链表的虚拟头节点    right_dummy = ListNode(0)         # 大于等于x链表的虚拟头节点        left = left_dummy                 # 小于x链表的当前指针    right = right_dummy               # 大于等于x链表的当前指针        # 遍历原链表，分配节点    while head is not None:        if head.val &lt; x:            left.next = head          # 连接到左链表            left = left.next          # 移动左指针        else:            right.next = head         # 连接到右链表            right = right.next        # 移动右指针        head = head.next              # 移动原链表指针        # 断开右链表的尾部连接，防止环    right.next = None        # 连接两个链表    left.next = right_dummy.next        return left_dummy.next            # 返回真正的头节点\n\n算法示例原链表: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2划分值: x = 3分离过程:节点1 &lt; 3: 左链表 = 1节点4 &gt;= 3: 右链表 = 4  节点3 &gt;= 3: 右链表 = 4 -&gt; 3节点2 &lt; 3: 左链表 = 1 -&gt; 2节点5 &gt;= 3: 右链表 = 4 -&gt; 3 -&gt; 5节点2 &lt; 3: 左链表 = 1 -&gt; 2 -&gt; 2最终结果: 1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5\n\n算法特点\n稳定性：保持原有的相对顺序\n原地操作：只调整指针，不创建新节点\n时间效率：单次遍历，O(n)时间复杂度\n空间效率：只使用常数额外空间\n\n应用场景\n链表排序的预处理：快速排序的分区操作\n数据分类：按条件将数据分为两组\n链表重组：根据特定规则重新排列链表节点\n\n\n链表操作技巧拓展核心技巧与模式1. 双指针技术def two_pointer_pattern(head):    &quot;&quot;&quot;    双指针模式：快慢指针、左右指针等    常用于链表中点查找、环检测、倒数第k个节点等    &quot;&quot;&quot;    slow = fast = head                    # 快慢指针初始化    while fast and fast.next:        slow = slow.next                  # 慢指针每次移动1步        fast = fast.next.next             # 快指针每次移动2步    return slow                           # 返回中点或其他目标位置\n\n2. 虚拟头节点def dummy_head_pattern(head):    &quot;&quot;&quot;    虚拟头节点模式：简化头节点的特殊处理    特别适用于可能删除头节点或构建新链表的场景    &quot;&quot;&quot;    dummy = ListNode(0)                   # 创建虚拟头节点    dummy.next = head                     # 连接原链表        # 在这里进行各种操作    # ...        return dummy.next                     # 返回真正的头节点\n\n3. 递归模式def recursive_pattern(head):    &quot;&quot;&quot;    递归模式：将复杂问题分解为子问题    适用于链表反转、删除节点、合并等操作    &quot;&quot;&quot;    # 基础情况    if head is None or head.next is None:        return head        # 递归处理子问题    result = recursive_pattern(head.next)        # 处理当前层    # ...        return result\n\n4. 节点分离与重组def separate_and_merge_pattern(head):    &quot;&quot;&quot;    分离重组模式：将链表按条件分离后重新组合    适用于链表划分、奇偶分离、按值分组等    &quot;&quot;&quot;    # 创建多个子链表的头尾指针    list1_head = list1_tail = None    list2_head = list2_tail = None        while head:        next_node = head.next        head.next = None                  # 断开连接                if condition(head):               # 根据条件分配            # 添加到list1            if list1_head is None:                list1_head = list1_tail = head            else:                list1_tail.next = head                list1_tail = head        else:            # 添加到list2            if list2_head is None:                list2_head = list2_tail = head            else:                list2_tail.next = head                list2_tail = head                head = next_node        # 重新组合链表    if list1_tail:        list1_tail.next = list2_head    return list1_head if list1_head else list2_head\n\n常见错误与注意事项1. 空指针处理# 错误示例def wrong_example(head):    return head.next.val                  # 可能导致空指针异常# 正确示例  def correct_example(head):    if head and head.next:                # 先检查再访问        return head.next.val    return None\n\n2. 内存泄漏防止def prevent_memory_leak(head):    &quot;&quot;&quot;    防止内存泄漏：及时断开不需要的连接    &quot;&quot;&quot;    while head:        next_node = head.next        head.next = None                  # 断开连接，防止环        head = next_node\n\n3. 边界情况处理def handle_edge_cases(head):    &quot;&quot;&quot;    处理边界情况：空链表、单节点链表等    &quot;&quot;&quot;    # 空链表    if head is None:        return None        # 单节点链表    if head.next is None:        return head        # 正常处理逻辑    # ...\n\n性能分析与优化时间复杂度分析\n单次遍历操作：O(n) - 反转、合并、查找等\n嵌套遍历操作：O(n²) - 某些复杂的链表操作\n递归操作：O(n) - 但需要考虑递归栈空间\n\n空间复杂度优化\n原地操作：优先使用指针操作而非创建新节点\n迭代替代递归：在可能的情况下避免递归栈开销\n临时变量最小化：只保存必要的指针变量\n\n实际性能考虑def performance_optimized_merge(h1, h2):    &quot;&quot;&quot;    性能优化的链表合并    减少条件判断和指针操作    &quot;&quot;&quot;    dummy = ListNode(0)    tail = dummy        while h1 and h2:        if h1.val &lt;= h2.val:            tail.next, h1 = h1, h1.next        else:            tail.next, h2 = h2, h2.next        tail = tail.next        # 直接连接剩余部分，无需循环    tail.next = h1 or h2    return dummy.next\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","链表","指针操作","节点遍历"]},{"title":"数据结构与算法自学笔记（9）- 基数排序&排序算法总结","url":"/2025/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89-%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F&%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了基数排序的原理与实现，以及重要排序算法的性能总结与选择策略，包括了class028 -&gt; class029的内容\n028【必备】基数排序基数排序概述基数排序是一种非基于比较的排序算法，它通过对数字的每一位进行排序来实现整体排序。与其他基于比较的排序算法不同，基数排序对数据类型有特定要求。\n测试链接：https://www.luogu.com.cn/problem/P1177\n\n基于比较 vs 非基于比较的排序基于比较的排序：\n\n只需要定义好两个对象之间怎么比较即可\n对象的数据特征并不关心，很通用\n例如：快速排序、归并排序、堆排序等\n\n非基于比较的排序：\n\n和比较无关的排序，对于对象的数据特征有要求\n并不通用，但在特定条件下效率极高\n例如：计数排序、桶排序、基数排序\n\n从计数排序到基数排序计数排序计数排序是最简单的非比较排序算法：\n\n用一个数组或哈希表来记录每个数字出现的次数\n遍历数组统计，然后按顺序输出\n限制：数值范围比较大时就不实用了\n\n桶排序桶排序是计数排序的升级版：\n\n将数据分到有限数量的桶里，然后对每个桶再分别排序，最后合并\n计数排序可以看成每个桶只存储相同元素\n桶排序每个桶存储一定范围的元素\n需要确定两个信息：桶的数量和每个桶的区间范围\n\n\n基数排序基数排序进一步优化了桶的使用：\n\n按位进行排序，比如先按个位数字放进桶里再倒出，再按十位数字放进桶里再倒出\n这样就得到一个有序的序列\n\n基数排序的核心思想基数排序采用**LSD（Least Significant Digit）**策略，从最低位开始排序：\n\n从个位开始：按个位数字进行计数排序\n依次向高位：按十位、百位、千位…依次排序\n保持稳定性：每次排序都要保持之前排序的相对顺序\n\n关键点：\n\n前缀数量分区的技巧\n数字提取某一位的技巧\n时间复杂度O(n)，额外空间复杂度O(m)\n\n基数排序实现详解核心代码结构# 可以设置进制，不一定10进制BASE = 10  # 基数，当前设置为10进制MAXN = 100001  # 最大数据量arr = [0] * MAXN      # 存储待排序数组help_arr = [0] * MAXN # 辅助数组cnts = [0] * BASE     # 计数数组n = 0                 # 元素数量\n\n处理负数的技巧由于基数排序要求非负整数，需要特殊处理负数：\ndef sort():    # 找到数组中的最小值    min_val = arr[0]    for i in range(1, n):        min_val = min(min_val, arr[i])        max_val = 0    for i in range(n):        arr[i] -= min_val  # 全部减去最小值，转为非负数        max_val = max(max_val, arr[i])        # 根据最大值在BASE进制下的位数，决定基数排序做多少轮    radixSort(bits(max_val))        # 数组中所有数都减去了最小值，所以最后不要忘了还原    for i in range(n):        arr[i] += min_val\n\n\n计算位数def bits(number):    &quot;&quot;&quot;返回number在BASE进制下有几位&quot;&quot;&quot;    ans = 0    while number &gt; 0:        ans += 1        number //= BASE    return ans\n\n基数排序核心算法def radixSort(bits_):    &quot;&quot;&quot;    基数排序核心代码    arr内要保证没有负数    bits_是arr中最大值在BASE进制下有几位    &quot;&quot;&quot;    offset = 1  # 当前位权重        for _ in range(bits_):        # 每一轮针对某一位排序                # 1. 计数数组清零        for i in range(BASE):            cnts[i] = 0                # 2. 统计该位各数字出现次数        for i in range(n):            cnts[(arr[i] // offset) % BASE] += 1                # 3. 转换为前缀和（确定位置）        for i in range(1, BASE):            cnts[i] += cnts[i - 1]                # 4. 从后往前放入辅助数组（保证稳定性）        for i in range(n - 1, -1, -1):            idx = (arr[i] // offset) % BASE  # 该位的值            cnts[idx] -= 1            help_arr[cnts[idx]] = arr[i]                # 5. 拷回原数组        for i in range(n):            arr[i] = help_arr[i]                offset *= BASE  # 下一位\n\n算法详细步骤演示以数组 [170, 45, 75, 90, 2, 802, 24, 66] 为例：\n初始数组：[170, 45, 75, 90, 2, 802, 24, 66]\n第一轮（个位排序）Step 1 - 统计个位数字：\n个位: [0, 5, 5, 0, 2, 2, 4, 6]cnts: [2, 0, 2, 0, 1, 2, 1, 0, 0, 0]\n\nStep 2 - 计算前缀和：\ncnts: [2, 2, 4, 4, 5, 7, 8, 8, 8, 8]\n\nStep 3 - 从后往前放置：\n结果: [170, 90, 2, 802, 24, 45, 75, 66]\n\n第二轮（十位排序）Step 1 - 统计十位数字：\n十位: [7, 9, 0, 0, 2, 4, 7, 6]cnts: [2, 0, 1, 0, 1, 0, 1, 2, 0, 1]\n\nStep 2 - 计算前缀和并放置：\n结果: [2, 802, 24, 45, 66, 170, 75, 90]\n\n第三轮（百位排序）最终结果：[2, 24, 45, 66, 75, 90, 170, 802]\n稳定性保证基数排序的稳定性通过以下方式保证：\n\n从后往前处理：在放入辅助数组时从后往前遍历原数组\n前缀和技巧：使用前缀和确定每个元素在结果数组中的准确位置\n逐位处理：每一位的排序都保持前一位排序的相对顺序\n\n# 关键：从后往前，确保稳定性for i in range(n - 1, -1, -1):    idx = (arr[i] // offset) % BASE    cnts[idx] -= 1    help_arr[cnts[idx]] = arr[i]\n\n复杂度分析时间复杂度：O(n)\n\n设最大数有d位，需要进行d轮排序\n每轮排序需要O(n + k)时间，其中k是基数（通常k&#x3D;10）\n总时间复杂度：O(d × (n + k)) ≈ O(n)\n\n空间复杂度：O(m)\n\nm为基数大小，需要辅助空间做类似桶的作用\n包括辅助数组help_arr和计数数组cnts\n\n应用限制一般来讲，基数排序要求：\n\n样本是10进制的非负整数\n如果不是就需要转化（如代码中处理负数的方式）\n可以设置任何进制来进行排序\n\n局限性：\n\n一旦比较的对象不再是常规数字，改写代价显著增加\n不基于比较的排序并不通用\n\n029【必备】重要排序算法的总结排序算法稳定性稳定性定义排序算法的稳定性是指：同样大小的样本在排序之后不会改变原始的相对次序。\n重要性：\n\n稳定性对基础类型对象来说毫无意义\n稳定性对非基础类型对象有意义，可以保留之前的相对次序\n\n主要排序算法性能总结\n\n\n排序算法\n时间复杂度\n空间复杂度\n稳定性\n备注\n\n\n\nSelectionSort选择排序\nO(N²)\nO(1)\n❌\n因为是随机的交换\n\n\nBubbleSort冒泡排序\nO(N²)\nO(1)\n✅\n数学归纳法可以保证\n\n\nInsertionSort插入排序\nO(N²)\nO(1)\n✅\n相等会直接停，能够保证稳定性\n\n\nMergeSort归并排序\nO(N log N)\nO(N)\n✅\n左右两边的区域满足偏序性\n\n\nQuickSort快速排序\nO(N log N)\nO(log N)\n❌\n普通的是固定选择，随机的随机选择\n\n\nHeapSort堆排序\nO(N log N)\nO(1)\n❌\n建堆的过程根本不在乎稳不稳定\n\n\nCountSort计数排序\nO(N)\nO(M)\n✅\n入桶和出桶的过程是按次序的\n\n\nRadixSort基数排序\nO(N)\nO(M)\n✅\n同计数排序\n\n\n关键说明随机快速排序的复杂度：\n\n一定要按照概率上的期望指标来估计\n用最差的复杂度估计无意义\n随机快排的详细说明在之前的视频中已有详细解释\n\n重要结论：\n\n基于比较的排序，时间复杂度O(n log n)，空间复杂度低于O(n)，还具有稳定性的排序算法目前没有找到\n\nTimSort说明：\n\nTimSort也不行，虽然在实际应用中通常不需要这么多的额外空间\n但空间复杂度指标就是O(n)\n在算法面试、笔试、比赛中都很少用到\n\n希尔排序（ShellSort）：\n\n也不常用，就是加入步长调整的插入排序\n有兴趣的同学可以研究一下\n\n排序算法选择策略排序算法的选择完全取决于你在排序过程中在乎什么：\n1. 数据量非常小的情况推荐：插入排序\n\n可以做到非常迅速\n实现简单，常数项小\n很多高级排序算法在小数据量时会切换到插入排序\n\n2. 性能优异 + 实现简单 + 不在乎稳定性推荐：随机快速排序\n\n性能优异，期望时间复杂度O(n log n)\n实现简单且利于改进\n面对不同业务可以选择不同划分策略\n空间复杂度较小O(log n)\n\n3. 性能优异 + 需要稳定性 + 不在乎额外空间推荐：归并排序\n\n性能优异，稳定的O(n log n)时间复杂度\n具有稳定性\n适合外部排序（大数据量）\n空间复杂度O(n)\n\n4. 性能优异 + 额外空间要求O(1) + 不在乎稳定性推荐：堆排序\n\n性能优异，稳定的O(n log n)时间复杂度\n额外空间占用O(1)\n最坏情况下性能依然稳定\n不具有稳定性\n\n5. 特定数据特征 + 追求极致性能推荐：基数排序&#x2F;计数排序\n\n在特定条件下可以达到O(n)时间复杂度\n对数据类型有严格要求\n适用于整数排序且范围有限的场景\n\n实际应用建议编程竞赛&#x2F;面试\n快速排序：最常考查，需要熟练掌握\n归并排序：稳定性要求时的首选\n堆排序：空间复杂度有严格限制时\n\n工程实践\n小数组：插入排序\n大数组：快速排序（随机化）\n需要稳定性：归并排序\n内存敏感：堆排序\n特殊数据：计数排序&#x2F;基数排序\n\n语言内置排序大多数编程语言的内置排序算法都是混合算法：\n\nPython：Timsort（归并+插入的混合）\nJava：双轴快排（小数组时用插入排序）\nC++：通常是内省排序（快排+堆排序+插入排序的混合）\n\n总结理解各种排序算法的特点和适用场景比单纯记忆算法更重要。在实际应用中，需要根据具体需求（数据规模、稳定性要求、空间限制等）来选择合适的排序算法。基数排序作为非比较排序的代表，在特定场景下能够突破O(n log n)的理论下界，达到线性时间复杂度。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","排序算法","基数排序","计数排序","桶排序"]},{"title":"数据结构与算法自学笔记（3）- 队列和栈相关","url":"/2025/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-%20%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9B%B8%E5%85%B3/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了栈和队列的基础实现、相互转换以及最小栈等核心内容，涵盖了链表实现、数组实现、循环队列等多种实现方式,包括了class013 -&gt; class016的内容。\n\n013【入门】队列和栈-链表、数组实现队列的基本概念队列（Queue）是一种先进先出（FIFO, First In First Out）的线性数据结构。元素从队尾（rear）插入，从队首（front）删除。\n队列的基本操作\nenqueue&#x2F;offer: 入队，将元素添加到队尾\ndequeue&#x2F;poll: 出队，从队首移除元素\nfront&#x2F;peek: 查看队首元素，但不移除\nisEmpty: 判断队列是否为空\nsize: 获取队列中元素个数\n\n队列的实现方式方式一：基于双端队列（deque）实现Python内置的collections.deque提供了高效的双端操作，但常数时间较慢。\nfrom collections import dequeclass Queue1:    &quot;&quot;&quot;    基于Python内置deque实现的队列    内部使用双向链表，常数操作较慢但使用简单    &quot;&quot;&quot;    def __init__(self):        self.queue = deque()  # 内部存储使用deque（双端队列）    def is_empty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return not self.queue    def offer(self, num):        &quot;&quot;&quot;向队列中加入元素，加到队尾&quot;&quot;&quot;        self.queue.append(num)    def poll(self):        &quot;&quot;&quot;从队列头部弹出元素&quot;&quot;&quot;        return self.queue.popleft()    def peek(self):        &quot;&quot;&quot;返回队列头的元素但不弹出&quot;&quot;&quot;        return self.queue[0]    def size(self):        &quot;&quot;&quot;返回队列中元素个数&quot;&quot;&quot;        return len(self.queue)\n\n方式二：基于固定数组实现在已知操作次数上限的情况下，使用固定数组实现具有更好的常数时间性能。\nclass Queue2:    &quot;&quot;&quot;    基于固定数组实现的队列    适用于已知加入操作总次数上限的场景    常数时间性能更好，是实际刷题中最常用的方式    &quot;&quot;&quot;    def __init__(self, n):        &quot;&quot;&quot;        初始化队列        参数: n - 加入操作的总次数上限        &quot;&quot;&quot;        self.queue = [0] * n  # 固定大小数组        self.l = 0  # 队首指针        self.r = 0  # 队尾指针    def is_empty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.l == self.r    def offer(self, num):        &quot;&quot;&quot;入队操作&quot;&quot;&quot;        self.queue[self.r] = num  # 在队尾位置插入元素        self.r += 1  # 队尾指针后移    def poll(self):        &quot;&quot;&quot;出队操作&quot;&quot;&quot;        num = self.queue[self.l]  # 取队首元素        self.l += 1  # 队首指针后移        return num    def head(self):        &quot;&quot;&quot;返回队首元素&quot;&quot;&quot;        return self.queue[self.l]    def tail(self):        &quot;&quot;&quot;返回队尾元素&quot;&quot;&quot;        return self.queue[self.r - 1]    def size(self):        &quot;&quot;&quot;队列当前元素个数，区间[l, r)&quot;&quot;&quot;        return self.r - self.l\n\n栈的基本概念栈（Stack）是一种后进先出（LIFO, Last In First Out）的线性数据结构。元素只能从栈顶插入和删除。\n栈的基本操作\npush: 压栈，将元素添加到栈顶\npop: 弹栈，从栈顶移除元素\npeek&#x2F;top: 查看栈顶元素，但不移除\nisEmpty: 判断栈是否为空\nsize: 获取栈中元素个数\n\n栈的实现方式方式一：基于动态数组实现class Stack1:    &quot;&quot;&quot;    基于Python内置列表实现的栈    使用动态数组，常数时间不是最优但使用简单    &quot;&quot;&quot;    def __init__(self):        self.stack = []  # 用列表模拟栈    def is_empty(self):        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return len(self.stack) == 0    def push(self, num):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.stack.append(num)    def pop(self):        &quot;&quot;&quot;弹栈操作&quot;&quot;&quot;        return self.stack.pop()    def peek(self):        &quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;        return self.stack[-1]    def size(self):        &quot;&quot;&quot;返回栈的大小&quot;&quot;&quot;        return len(self.stack)\n\n方式二：基于固定数组实现class Stack2:    &quot;&quot;&quot;    基于固定数组实现的栈    适用于已知同时在栈里元素个数上限的场景    常数时间性能更好，空间可以复用    &quot;&quot;&quot;    def __init__(self, n):        &quot;&quot;&quot;        初始化栈        参数: n - 同时在栈里的元素个数上限        &quot;&quot;&quot;        self.stack = [0] * n  # 固定大小数组        self.size_ = 0  # 当前栈元素个数    def is_empty(self):        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return self.size_ == 0    def push(self, num):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.stack[self.size_] = num  # 在当前size位置插入        self.size_ += 1  # 元素个数+1    def pop(self):        &quot;&quot;&quot;弹栈操作&quot;&quot;&quot;        self.size_ -= 1  # 元素个数-1，先减后取值        return self.stack[self.size_]  # 返回弹出的元素    def peek(self):        &quot;&quot;&quot;返回栈顶元素但不弹出&quot;&quot;&quot;        return self.stack[self.size_ - 1]    def size(self):        &quot;&quot;&quot;返回栈大小&quot;&quot;&quot;        return self.size_\n\n循环队列循环队列是队列的一种特殊实现，通过循环使用固定大小的数组来避免空间浪费。\nclass MyCircularQueue:    &quot;&quot;&quot;    循环队列实现    测试链接: https://leetcode.cn/problems/design-circular-queue/    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.queue = [0] * k  # 固定大小数组        self.l = 0  # 队首指针        self.r = 0  # 队尾指针        self.size = 0  # 当前元素个数        self.limit = k  # 容量上限    def enQueue(self, value):        &quot;&quot;&quot;        入队操作        返回: 成功返回True，队列满返回False        &quot;&quot;&quot;        if self.isFull():            return False  # 队列已满        else:            self.queue[self.r] = value  # 队尾插入元素            # 队尾指针循环移动            self.r = 0 if self.r == self.limit - 1 else self.r + 1            self.size += 1  # 元素个数+1            return True    def deQueue(self):        &quot;&quot;&quot;        出队操作        返回: 成功返回True，队列空返回False        &quot;&quot;&quot;        if self.isEmpty():            return False  # 队列为空        else:            # 队首指针循环移动            self.l = 0 if self.l == self.limit - 1 else self.l + 1            self.size -= 1  # 元素个数-1            return True    def Front(self):        &quot;&quot;&quot;返回队首元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.queue[self.l]    def Rear(self):        &quot;&quot;&quot;返回队尾元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            # 计算队尾指针的实际位置            last = self.limit - 1 if self.r == 0 else self.r - 1            return self.queue[last]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n\n014【入门】队列和栈入门题目-栈和队列相互实现用栈实现队列队列是先进先出（FIFO），而栈是后进先出（LIFO）。要用栈实现队列，需要使用两个栈来模拟队列的行为。\n算法思想使用两个栈：\n\n输入栈（in_stack）：负责接收新元素的push操作\n输出栈（out_stack）：负责输出元素的pop和peek操作\n\n关键规则\n倒数据条件：只有当输出栈为空时，才能从输入栈倒数据\n倒数据原则：如果要倒数据，必须将输入栈的数据全部倒完\n时间复杂度：虽然单次操作可能是O(n)，但均摊时间复杂度是O(1)\n\nclass MyQueue:    &quot;&quot;&quot;    用栈实现队列    测试链接: https://leetcode.cn/problems/implement-queue-using-stacks/    时间复杂度: 均摊O(1)    &quot;&quot;&quot;    def __init__(self):        self.in_stack = []     # 输入栈，负责push        self.out_stack = []    # 输出栈，负责pop/peek    def inToOut(self):        &quot;&quot;&quot;        倒数据操作：从输入栈将数据倒入输出栈        核心规则：        1) 输出栈空了，才能倒数据        2) 如果倒数据，输入栈必须倒完        &quot;&quot;&quot;        if not self.out_stack:                     # 只有输出栈为空才能倒            while self.in_stack:                   # 输入栈必须倒完                self.out_stack.append(self.in_stack.pop())    def push(self, x: int):        &quot;&quot;&quot;入队操作：新元素加入输入栈&quot;&quot;&quot;        self.in_stack.append(x)                    # 新元素压入输入栈        self.inToOut()                             # 检查是否需要倒数据    def pop(self) -&gt; int:        &quot;&quot;&quot;出队操作：从输出栈弹出元素&quot;&quot;&quot;        self.inToOut()                             # 确保输出栈有数据        return self.out_stack.pop()                # 弹出队首元素    def peek(self) -&gt; int:        &quot;&quot;&quot;查看队首元素：不移除，只查看&quot;&quot;&quot;        self.inToOut()                             # 确保输出栈有数据        return self.out_stack[-1]                  # 返回栈顶即队首    def empty(self) -&gt; bool:        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return not self.in_stack and not self.out_stack  # 两个栈都空才是空队列\n\n时间复杂度分析虽然inToOut()操作在最坏情况下需要O(n)时间，但通过均摊分析：\n\n每个元素最多被移动两次（输入栈→输出栈→出队列）\nn次操作的总时间复杂度为O(n)\n均摊时间复杂度为O(1)\n\n用队列实现栈栈是后进先出（LIFO），队列是先进先出（FIFO）。要用队列实现栈，需要在每次push操作后重新排列队列中的元素。\n算法思想使用一个双端队列（deque），在每次push新元素后，将队列中原有的元素依次移动到新元素后面，确保新元素总是在队首位置。\nfrom collections import dequeclass MyStack:    &quot;&quot;&quot;    用双端队列实现栈    测试链接: https://leetcode.cn/problems/implement-stack-using-queues/    &quot;&quot;&quot;    def __init__(self):        self.queue = deque()                       # 用deque实现队列    def push(self, x: int):        &quot;&quot;&quot;        压栈操作        时间复杂度: O(n)        核心思想: 新元素入队后，将前面所有元素重新排列到新元素后面        &quot;&quot;&quot;        n = len(self.queue)                        # 记录当前队列长度        self.queue.append(x)                       # 新元素加入队尾                # 将前面的n个元素依次移动到队尾        for _ in range(n):            self.queue.append(self.queue.popleft())    def pop(self) -&gt; int:        &quot;&quot;&quot;弹栈操作：弹出队首元素，即栈顶元素&quot;&quot;&quot;        return self.queue.popleft()    def top(self) -&gt; int:        &quot;&quot;&quot;查看栈顶元素：返回队首元素&quot;&quot;&quot;        return self.queue[0]    def empty(self) -&gt; bool:        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;        return not self.queue\n\n操作示例假设依次push元素1, 2, 3：\n初始状态: []push(1): [1]push(2): [2] -&gt; [2,1] (将1移动到2后面)push(3): [3,2,1] -&gt; [3,2,1] (将2,1依次移动到3后面)\n\n最终队列状态为[3,2,1]，队首元素3就是栈顶元素，符合LIFO特性。\n\n015【入门】栈的入门题目-最小栈最小栈问题最小栈要求实现一个栈，除了基本的栈操作外，还要能够在O(1)时间内获取栈中的最小元素。\n问题分析核心挑战是如何在保持基本栈操作O(1)时间复杂度的同时，追踪当前栈中的最小值。当栈顶元素（恰好是最小值）被弹出时，需要快速知道剩余元素中的最小值。\n解决方案：辅助栈法使用两个栈：\n\n数据栈（data）：存储实际数据\n最小值栈（min）：存储对应位置的最小值\n\n实现方法一：基于列表class MinStack1:    &quot;&quot;&quot;    最小栈实现方法一：使用Python列表    测试链接: https://leetcode.cn/problems/min-stack/    时间复杂度: 所有操作均为O(1)    &quot;&quot;&quot;    def __init__(self):        self.data = []  # 数据栈，存储实际元素        self.min = []   # 最小值栈，存储对应位置的最小值    def push(self, val):        &quot;&quot;&quot;        压栈操作        核心思想: 每次压栈时，同时在最小值栈中记录当前的最小值        &quot;&quot;&quot;        self.data.append(val)  # 将val压入数据栈                if not self.min or val &lt;= self.min[-1]:  # 如果最小栈为空或val是新的最小值            self.min.append(val)  # 将val压入最小栈        else:  # 否则val不是最小值            self.min.append(self.min[-1])  # 将当前最小值再次压入最小栈    def pop(self):        &quot;&quot;&quot;弹栈操作：同时弹出两个栈的栈顶元素&quot;&quot;&quot;        self.data.pop()  # 弹出数据栈栈顶        self.min.pop()   # 弹出最小栈栈顶    def top(self):        &quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;        return self.data[-1]  # 返回数据栈栈顶元素    def getMin(self):        &quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;        return self.min[-1]   # 返回最小栈栈顶元素\n\n工作原理示例假设依次压入元素：5, 2, 7, 1, 3\n\n\n\n操作\n数据栈\n最小栈\n说明\n\n\n\npush(5)\n[5]\n[5]\n5是第一个元素，也是最小值\n\n\npush(2)\n[5,2]\n[5,2]\n2比5小，成为新的最小值\n\n\npush(7)\n[5,2,7]\n[5,2,2]\n7比2大，最小值仍是2\n\n\npush(1)\n[5,2,7,1]\n[5,2,2,1]\n1比2小，成为新的最小值\n\n\npush(3)\n[5,2,7,1,3]\n[5,2,2,1,1]\n3比1大，最小值仍是1\n\n\n实现方法二：基于固定数组class MinStack2:    &quot;&quot;&quot;    最小栈实现方法二：使用固定大小数组    适用于已知最大容量的场景，常数时间性能更好    &quot;&quot;&quot;    def __init__(self):        # 根据leetcode测试数据实验得出的容量上限        # 如果测试数据增加导致溢出，需要调大此值        self.MAXN = 8001        self.data = [0] * self.MAXN  # 数据数组        self.min = [0] * self.MAXN   # 最小值数组        self.size = 0  # 当前栈大小    def push(self, val):        &quot;&quot;&quot;压栈操作&quot;&quot;&quot;        self.data[self.size] = val  # 在size位置存储val                if self.size == 0 or val &lt;= self.min[self.size - 1]:  # 第一个元素或新的最小值            self.min[self.size] = val  # 存储val作为最小值        else:  # val不是最小值            self.min[self.size] = self.min[self.size - 1]  # 复制前一个最小值                self.size += 1  # 栈大小加1    def pop(self):        &quot;&quot;&quot;弹栈操作：只需将size减1，不需要实际删除数据&quot;&quot;&quot;        self.size -= 1    def top(self):        &quot;&quot;&quot;获取栈顶元素&quot;&quot;&quot;        return self.data[self.size - 1]    def getMin(self):        &quot;&quot;&quot;获取栈中最小元素&quot;&quot;&quot;        return self.min[self.size - 1]\n\n复杂度分析时间复杂度\npush操作：O(1) - 只需要常数次比较和赋值\npop操作：O(1) - 只需要移动指针或减少计数\ntop操作：O(1) - 直接访问数组元素\ngetMin操作：O(1) - 直接访问最小值栈顶\n\n空间复杂度\n总空间复杂度：O(n) - 需要两个栈存储数据\n额外空间：O(n) - 最小值栈的空间开销\n\n优化思考虽然辅助栈法简单易懂，但存在空间冗余。可以考虑以下优化：\n\n稀疏存储：最小值栈只在最小值更新时才压入新值\n差值存储：存储与最小值的差值而非绝对值\n链表实现：在节点中直接存储当前最小值\n\n\n数据结构选择指南性能对比\n\n\n实现方式\n时间复杂度\n空间复杂度\n常数因子\n适用场景\n\n\n\nPython内置容器\nO(1)均摊\nO(n)\n较大\n快速原型，不追求极致性能\n\n\n固定数组\nO(1)\nO(n)\n较小\n已知容量上限，追求性能\n\n\n双栈&#x2F;双队列\nO(1)均摊\nO(n)\n中等\n功能转换，教学示例\n\n\n016【入门】双端队列-双链表和固定数组实现双端队列的基本概念双端队列（Deque，Double-ended Queue）是一种特殊的线性数据结构，允许在队列的两端进行插入和删除操作。与普通队列只能在一端插入、另一端删除不同，双端队列提供了更大的灵活性。\n双端队列的基本操作\ninsertFront: 在队首插入元素\ninsertLast: 在队尾插入元素  \ndeleteFront: 删除队首元素\ndeleteLast: 删除队尾元素\ngetFront: 获取队首元素\ngetRear: 获取队尾元素\nisEmpty: 判断队列是否为空\nisFull: 判断队列是否已满\n\n循环双端队列的实现循环双端队列是双端队列的一种特殊实现，使用固定大小的数组并通过循环索引来管理队列的边界。\n实现方式一：基于Python列表class MyCircularDeque1:    &quot;&quot;&quot;    基于Python列表实现的循环双端队列    内部使用动态数组，操作简单但常数时间较慢    测试链接: https://leetcode.cn/problems/design-circular-deque/    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环双端队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.deque = []  # 用列表模拟双端队列        self.size = 0    # 当前队列大小        self.limit = k   # 队列容量    def insertFront(self, value):        &quot;&quot;&quot;        在队首插入元素        时间复杂度: O(n) - 需要移动所有现有元素        &quot;&quot;&quot;        if self.isFull():            return False        else:            self.deque.insert(0, value)  # 在索引0位置插入，其他元素后移            self.size += 1            return True    def insertLast(self, value):        &quot;&quot;&quot;        在队尾插入元素        时间复杂度: O(1)均摊        &quot;&quot;&quot;        if self.isFull():            return False        else:            self.deque.append(value)  # 直接添加到列表末尾            self.size += 1            return True    def deleteFront(self):        &quot;&quot;&quot;        删除队首元素        时间复杂度: O(n) - 需要移动所有剩余元素        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            self.size -= 1            self.deque.pop(0)  # 删除索引0的元素，其他元素前移            return True    def deleteLast(self):        &quot;&quot;&quot;        删除队尾元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            self.size -= 1            self.deque.pop()  # 删除列表末尾元素            return True    def getFront(self):        &quot;&quot;&quot;获取队首元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[0]    def getRear(self):        &quot;&quot;&quot;获取队尾元素，队列为空返回-1&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[-1]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n实现方式二：基于固定数组class MyCircularDeque2:    &quot;&quot;&quot;    基于固定数组实现的循环双端队列    使用循环索引管理队列边界，常数时间性能更好    适用于已知容量上限的场景    &quot;&quot;&quot;    def __init__(self, k):        &quot;&quot;&quot;        初始化循环双端队列        参数: k - 队列容量上限        &quot;&quot;&quot;        self.deque = [0] * k  # 固定长度数组        self.l = 0            # 队首指针        self.r = 0            # 队尾指针        self.size = 0         # 当前队列大小        self.limit = k        # 队列容量    def insertFront(self, value):        &quot;&quot;&quot;        在队首插入元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isFull():            return False        else:            if self.isEmpty():                # 空队列情况，队首和队尾指针都指向同一位置                self.l = self.r = 0                self.deque[0] = value            else:                # 队首指针向前移动（循环）                self.l = self.l - 1 if self.l != 0 else self.limit - 1                self.deque[self.l] = value            self.size += 1            return True    def insertLast(self, value):        &quot;&quot;&quot;        在队尾插入元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isFull():            return False        else:            if self.isEmpty():                # 空队列情况                self.l = self.r = 0                self.deque[0] = value            else:                # 队尾指针向后移动（循环）                self.r = 0 if self.r == self.limit - 1 else self.r + 1                self.deque[self.r] = value            self.size += 1            return True    def deleteFront(self):        &quot;&quot;&quot;        删除队首元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            if self.size == 1:                # 删除后队列变空，可选择重置指针                pass  # 这里不重置l和r，因为逻辑上没有影响            # 队首指针向后移动（循环）            self.l = 0 if self.l == self.limit - 1 else self.l + 1            self.size -= 1            return True    def deleteLast(self):        &quot;&quot;&quot;        删除队尾元素        时间复杂度: O(1)        &quot;&quot;&quot;        if self.isEmpty():            return False        else:            if self.size == 1:                # 删除后队列变空                pass  # 不重置指针            # 队尾指针向前移动（循环）            self.r = self.limit - 1 if self.r == 0 else self.r - 1            self.size -= 1            return True    def getFront(self):        &quot;&quot;&quot;获取队首元素&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[self.l]    def getRear(self):        &quot;&quot;&quot;获取队尾元素&quot;&quot;&quot;        if self.isEmpty():            return -1        else:            return self.deque[self.r]    def isEmpty(self):        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;        return self.size == 0    def isFull(self):        &quot;&quot;&quot;判断队列是否已满&quot;&quot;&quot;        return self.size == self.limit\n\n循环索引的关键理解指针移动规律在固定数组实现中，关键是理解循环索引的移动：\n# 向后移动（队尾插入，队首删除）next_index = 0 if current_index == limit - 1 else current_index + 1# 向前移动（队首插入，队尾删除）  prev_index = limit - 1 if current_index == 0 else current_index - 1\n\n边界情况处理\n空队列插入：第一个元素插入时，队首和队尾指针都指向同一位置\n单元素删除：删除唯一元素后队列变空，但指针位置不需要重置\n满队列检测：通过size变量而非指针位置来判断队列是否已满\n\n性能分析时间复杂度对比\n\n\n操作\n列表实现\n数组实现\n说明\n\n\n\ninsertFront\nO(n)\nO(1)\n列表需要移动所有元素\n\n\ninsertLast\nO(1)均摊\nO(1)\n列表可能需要扩容\n\n\ndeleteFront\nO(n)\nO(1)\n列表需要移动所有元素\n\n\ndeleteLast\nO(1)\nO(1)\n两种实现都是常数时间\n\n\ngetFront&#x2F;getRear\nO(1)\nO(1)\n直接索引访问\n\n\n空间复杂度\n列表实现：O(k)，但可能因为动态扩容导致额外开销\n数组实现：O(k)，固定空间，无额外开销\n\n应用场景双端队列的典型应用\n滑动窗口问题：需要在窗口两端进行操作\n回文检测：从两端向中间检查字符\n撤销&#x2F;重做功能：需要在两端添加和删除操作记录\n广度优先搜索变种：某些图算法需要双向扩展\n\n与其他数据结构的对比\n\n\n数据结构\n队首操作\n队尾操作\n适用场景\n\n\n\n普通队列\n删除O(1)\n插入O(1)\nFIFO场景\n\n\n栈\n插入&#x2F;删除O(1)\n无操作\nLIFO场景\n\n\n双端队列\n插入&#x2F;删除O(1)\n插入&#x2F;删除O(1)\n需要两端操作\n\n\n动态数组\n插入O(n)，删除O(n)\n插入O(1)均摊，删除O(1)\n随机访问\n\n\n双端队列提供了比普通队列和栈更大的灵活性，在需要两端操作的算法中具有重要作用。固定数组的循环实现虽然代码复杂度稍高，但提供了最优的时间和空间性能。刷题中优先选择固定数组实现，性能更好，实际工程中如果容量不确定，可以考虑列表实现或者动态扩容的数组；此外，固定数据能使得内存使用更可控。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","节点遍历","队列","栈","列表","数组"]},{"title":"数据结构与算法自学笔记（4）- 二叉树相关","url":"/2025/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了二叉树的基础概念、三种遍历方式的递归实现和非递归实现，涵盖了先序、中序、后序遍历的原理与代码实现，包括了class017 -&gt; class018的内容\n017【入门】二叉树及其三种序的递归实现二叉树的基本概念二叉树是一种重要的树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树是许多高级数据结构和算法的基础。\n二叉树节点定义class TreeNode:    def __init__(self, v):        self.val = v         # 节点的值        self.left = None     # 左子节点        self.right = None    # 右子节点\n\n递归序的概念递归序是理解二叉树遍历的关键概念。对于任意二叉树节点，递归过程会经过该节点三次：\ndef f(head):    if head is None:        return    # 第1次到达该节点 - 刚进入该节点    f(head.left)   # 递归处理左子树    # 第2次到达该节点 - 左子树处理完毕    f(head.right)  # 递归处理右子树    # 第3次到达该节点 - 右子树处理完毕\n\n根据在这三个时机中选择处理节点的时机不同，就形成了三种不同的遍历方式。\n二叉树的三种递归遍历先序遍历（Pre-order Traversal）先序遍历的顺序是：根节点 → 左子树 → 右子树\n@staticmethoddef preOrder(head):    &quot;&quot;&quot;    先序遍历：在第1次到达节点时处理    应用场景：复制二叉树、表达式树求值、目录树打印    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/    &quot;&quot;&quot;    if head is None:        return    print(head.val, end=&quot; &quot;)  # 先处理当前节点    BinaryTreeTraversalRecursion.preOrder(head.left)   # 再遍历左子树    BinaryTreeTraversalRecursion.preOrder(head.right)  # 最后遍历右子树\n\n中序遍历（In-order Traversal）中序遍历的顺序是：左子树 → 根节点 → 右子树\n@staticmethoddef inOrder(head):    &quot;&quot;&quot;    中序遍历：在第2次到达节点时处理    应用场景：二叉搜索树排序（得到有序序列）、表达式树转中缀表达式    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/    &quot;&quot;&quot;    if head is None:        return    BinaryTreeTraversalRecursion.inOrder(head.left)   # 先遍历左子树    print(head.val, end=&quot; &quot;)  # 再处理当前节点    BinaryTreeTraversalRecursion.inOrder(head.right)  # 最后遍历右子树\n\n后序遍历（Post-order Traversal）后序遍历的顺序是：左子树 → 右子树 → 根节点\n@staticmethoddef posOrder(head):    &quot;&quot;&quot;    后序遍历：在第3次到达节点时处理    应用场景：计算目录大小、删除二叉树、表达式树计算    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if head is None:        return    BinaryTreeTraversalRecursion.posOrder(head.left)   # 先遍历左子树    BinaryTreeTraversalRecursion.posOrder(head.right)  # 再遍历右子树    print(head.val, end=&quot; &quot;)  # 最后处理当前节点\n\n递归遍历的示例执行以下面的二叉树为例：\n    1   / \\  2   3 / \\ / \\4  5 6  7\n\n执行结果对比\n先序遍历结果：1 2 4 5 3 6 7\n中序遍历结果：4 2 5 1 6 3 7  \n后序遍历结果：4 5 2 6 7 3 1\n\n递归调用过程分析以先序遍历为例，递归调用的过程：\n\n访问节点1，打印1\n递归进入左子树（节点2）\n访问节点2，打印2\n递归进入左子树（节点4）\n访问节点4，打印4\n左右子树为空，返回\n\n\n递归进入右子树（节点5）\n访问节点5，打印5\n左右子树为空，返回\n\n\n\n\n递归进入右子树（节点3）\n类似过程…\n\n\n\n复杂度分析时间复杂度所有递归遍历算法的时间复杂度都是 O(n)，其中n是二叉树的节点数。每个节点都会被访问恰好一次。\n空间复杂度额外空间复杂度：O(h)，其中h是树的高度。\n\n最好情况（完全平衡的二叉树）：h &#x3D; ⌊log₂n⌋，空间复杂度为O(log n)\n最坏情况（完全不平衡的树，退化为链表）：h &#x3D; n，空间复杂度为O(n)\n平均情况：对于随机二叉树，h &#x3D; O(log n)\n\n空间消耗主要来自递归调用栈，栈的最大深度等于树的高度。\n三种遍历方式的应用场景先序遍历的典型应用\n复制二叉树：先创建根节点，再递归复制左右子树\n表达式树求值：先处理操作符，再处理操作数\n目录树打印：先打印目录名，再打印子目录内容\n序列化二叉树：将树结构转换为字符串格式\n\n# 复制二叉树示例def copyTree(root):    if root is None:        return None    # 先创建新节点（先序特点）    newNode = TreeNode(root.val)    newNode.left = copyTree(root.left)    # 递归复制左子树    newNode.right = copyTree(root.right)  # 递归复制右子树    return newNode\n\n中序遍历的典型应用\n二叉搜索树排序：中序遍历BST得到有序序列\n表达式树转中缀表达式：按照运算符优先级添加括号\n验证二叉搜索树：检查中序遍历结果是否为递增序列\n\n# 验证二叉搜索树示例def isValidBST(root):    def inorder(node, values):        if node is None:            return        inorder(node.left, values)        values.append(node.val)  # 中序收集值        inorder(node.right, values)        values = []    inorder(root, values)    # 检查是否严格递增    return all(values[i] &lt; values[i+1] for i in range(len(values)-1))\n\n后序遍历的典型应用\n计算目录大小：先计算子目录大小，再计算当前目录\n删除二叉树：先删除子节点，再删除父节点\n表达式树计算：先计算子表达式，再计算根表达式\n计算树的高度：先计算子树高度，再计算当前树高度\n\n# 计算二叉树高度示例def maxDepth(root):    if root is None:        return 0    # 先计算左右子树高度（后序特点）    leftHeight = maxDepth(root.left)    rightHeight = maxDepth(root.right)    # 再计算当前树高度    return max(leftHeight, rightHeight) + 1\n\n遍历方式选择指南\n\n\n需求场景\n推荐遍历方式\n理由\n\n\n\n复制&#x2F;构建树结构\n先序遍历\n需要先创建根节点\n\n\n获取有序数据\n中序遍历\nBST的中序遍历有序\n\n\n释放&#x2F;计算资源\n后序遍历\n需要先处理子节点\n\n\n树的序列化\n先序遍历\n便于重建树结构\n\n\n表达式求值\n后序遍历\n需要先计算子表达式\n\n\n递归实现的优缺点优点\n代码简洁：逻辑清晰，易于理解和实现\n自然表达：完美匹配树的递归定义\n易于扩展：容易添加额外的处理逻辑\n\n缺点\n栈溢出风险：深度递归可能导致栈溢出\n性能开销：函数调用的开销相对较大\n难以控制：无法方便地暂停或恢复遍历过程\n\n在实际应用中，对于一般规模的二叉树，递归实现是首选方案。当树的深度可能很大时，需要考虑使用非递归实现来避免栈溢出问题。\n\n018【入门】二叉树遍历的非递归实现和复杂度分析非递归实现的必要性递归实现虽然简洁易懂，但在处理大型树时可能导致栈溢出。非递归实现使用显式栈来模拟递归过程，提供了更好的控制性和避免栈溢出的优势。\n核心思想用显式的栈数据结构来模拟系统递归调用栈的行为，手动管理遍历过程中的状态信息。\n先序遍历的非递归实现实现原理先序遍历要求”根-左-右”的访问顺序。使用栈时，由于栈是LIFO（后进先出）结构，需要先压入右子节点，再压入左子节点，这样弹栈时就是先处理左子树。\n@staticmethoddef preOrder(head):    &quot;&quot;&quot;    先序遍历非递归实现    核心思路：使用一个栈。每次先访问节点本身，再依次压入右、左子节点（注意顺序，先右后左），这样弹栈时总是优先处理左子树，实现“中-左-右”顺序    时间复杂度：O(n)，每个节点进栈出栈各一次    空间复杂度：O(h)，h为树的高度    测试链接LeetCode 144. 二叉树的前序遍历https://leetcode.cn/problems/binary-tree-preorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []        stack.append(head)        while stack:            head = stack.pop()        # 弹出栈顶节点            print(head.val, end=&quot; &quot;)  # 立即打印（先序特点）            # 关键：先压右子节点，再压左子节点            # 这样弹栈时就是先处理左子树，再处理右子树            if head.right is not None:                stack.append(head.right)            if head.left is not None:                stack.append(head.left)        print()\n\n执行过程示例以树 1(2(4,5),3(6,7)) 为例：\n\n\n\n步骤\n栈状态\n弹出节点\n打印\n压入节点\n\n\n\n初始\n[1]\n-\n-\n-\n\n\n1\n[3,2]\n1\n1\n3,2\n\n\n2\n[3,5,4]\n2\n2\n5,4\n\n\n3\n[3,5]\n4\n4\n-\n\n\n4\n[3]\n5\n5\n-\n\n\n5\n[7,6]\n3\n3\n7,6\n\n\n6\n[7]\n6\n6\n-\n\n\n7\n[]\n7\n7\n-\n\n\n输出结果：1 2 4 5 3 6 7\n中序遍历的非递归实现实现原理中序遍历要求”左-根-右”的访问顺序。需要先沿着左子树走到底，将路径上的所有节点压栈，然后开始弹栈处理节点，并转向右子树。\n@staticmethoddef inOrder(head):    &quot;&quot;&quot;    中序遍历非递归实现    核心思路：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。    测试链接LeetCode 94. 二叉树的中序遍历：https://leetcode.cn/problems/binary-tree-inorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []        while stack or head is not None:            if head is not None:                # 当前节点不为空，压栈并继续向左                stack.append(head)                head = head.left            else:                # 当前节点为空，说明左子树遍历完毕                head = stack.pop()        # 弹出栈顶节点                print(head.val, end=&quot; &quot;)  # 打印节点值（中序特点）                head = head.right         # 转向右子树        print()\n\n算法状态分析中序遍历的非递归实现有两种状态：\n\n下降状态：head != None，沿左子树向下走并压栈\n上升状态：head == None，弹栈处理节点并转向右子树\n\n\n执行过程示例以树 1(2(4,5),3(6,7)) 为例：\n\n\n\n步骤\nhead\n栈状态\n操作\n打印\n\n\n\n初始\n1\n[]\n-\n-\n\n\n1\n2\n[1]\n压栈1，左移\n-\n\n\n2\n4\n[1,2]\n压栈2，左移\n-\n\n\n3\nNone\n[1,2,4]\n压栈4，左移\n-\n\n\n4\n4\n[1,2]\n弹栈4\n4\n\n\n5\nNone\n[1,2]\n4右移(None)\n-\n\n\n6\n2\n[1]\n弹栈2\n2\n\n\n7\n5\n[1]\n2右移到5\n-\n\n\n8\nNone\n[1,5]\n压栈5，左移\n-\n\n\n…\n…\n…\n…\n…\n\n\n输出结果：4 2 5 1 6 3 7\n后序遍历的非递归实现后序遍历是最复杂的，因为需要确保在访问根节点之前，左右子树都已经被完全访问。提供两种实现方法：\n方法一：使用两个栈@staticmethoddef posOrderTwoStacks(head):    &quot;&quot;&quot;    后序遍历非递归实现 - 双栈法    核心思路：第一个栈实现&quot;中-右-左&quot;遍历，结果压入第二个栈    最后弹出第二个栈得到&quot;左-右-中&quot;的后序遍历结果    即：用一个栈模拟递归。每次不断沿左子树走到底，并将沿途所有节点入栈；遇到空节点就弹出栈顶节点，访问它，然后转向其右子树。如此反复，完整地实现“左-中-右”顺序。    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if head is not None:        stack = []      # 主栈：用于遍历        collect = []    # 收集栈：用于收集结果        stack.append(head)                while stack:            head = stack.pop()            collect.append(head)      # 收集节点到第二个栈            # 注意：这里先压左子节点，再压右子节点            # 这样遍历顺序就是&quot;中-右-左&quot;            if head.left is not None:                stack.append(head.left)            if head.right is not None:                stack.append(head.right)                # 反向弹出收集栈，得到&quot;左-右-中&quot;顺序        while collect:            print(collect.pop().val, end=&quot; &quot;)        print()\n\n双栈法原理解析\n第一阶段：用第一个栈实现”中-右-左”遍历，类似先序遍历但左右子节点入栈顺序相反\n第二阶段：将第一阶段的结果压入第二个栈\n第三阶段：弹出第二个栈，得到”左-右-中”的后序遍历结果\n\n关键洞察：”中-右-左”的逆序正好是”左-右-中”\n方法二：使用一个栈@staticmethoddef posOrderOneStack(h):    &quot;&quot;&quot;    后序遍历非递归实现 - 单栈法    核心思路：通过记录最近访问的节点，确保每个节点在其左右子树都被访问后才访问自己，从而严格实现“左-右-中”的后序遍历。    每个节点最多入栈两次，效率更高    测试链接LeetCode 145. 二叉树的后序遍历：https://leetcode.cn/problems/binary-tree-postorder-traversal/    &quot;&quot;&quot;    if h is not None:        stack = []        stack.append(h)        # h的含义：最近一次处理（打印）的节点                while stack:            cur = stack[-1]  # 查看栈顶元素但不弹出                        # 情况1：有左子树且左子树未被处理过            if cur.left is not None and h != cur.left and h != cur.right:                stack.append(cur.left)            # 情况2：有右子树且右子树未被处理过            elif cur.right is not None and h != cur.right:                stack.append(cur.right)            # 情况3：左右子树都没有或都已处理完毕            else:                print(cur.val, end=&quot; &quot;)                h = stack.pop()  # 更新h为刚刚处理的节点        print()\n\n单栈法状态管理核心变量h的含义变化：\n\n初始时：h指向根节点（但实际表示”还没有处理过任何节点”）\n处理过程中：h始终指向最近一次处理（打印）的节点\n判断逻辑：通过比较当前节点的子节点与h的关系，判断子树是否已被处理\n\n三种处理情况：\n\n有左子树且未处理：cur.left != None and h != cur.left and h != cur.right\n有右子树且未处理：cur.right != None and h != cur.right\n可以处理当前节点：左右子树都不存在或都已处理完毕\n\n复杂度分析对比时间复杂度所有非递归遍历算法的时间复杂度都是 O(n)：\n\n先序和中序：每个节点进栈出栈各一次\n后序双栈法：每个节点进栈出栈总共两次（每个栈一次）\n后序单栈法：每个节点最多进栈两次，出栈一次\n\n空间复杂度额外空间复杂度对比：\n\n\n\n实现方法\n空间复杂度\n说明\n\n\n\n先序非递归\nO(h)\n一个栈，最大深度为树高\n\n\n中序非递归\nO(h)\n一个栈，最大深度为树高\n\n\n后序双栈法\nO(n)\n收集栈最坏情况存储所有节点\n\n\n后序单栈法\nO(h)\n一个栈，最大深度为树高\n\n\n递归实现\nO(h)\n系统调用栈，深度为树高\n\n\n其中h为树的高度：\n\n最好情况：h &#x3D; O(log n)（平衡树）\n最坏情况：h &#x3D; O(n)（退化为链表）\n\n实现方法选择建议性能对比\n\n\n方法\n时间复杂度\n空间复杂度\n实现难度\n推荐场景\n\n\n\n先序非递归\nO(n)\nO(h)\n简单\n通用推荐\n\n\n中序非递归\nO(n)\nO(h)\n中等\nBST相关问题\n\n\n后序双栈法\nO(n)\nO(n)\n简单\n理解后序遍历逻辑\n\n\n后序单栈法\nO(n)\nO(h)\n困难\n空间要求严格的场景\n\n\n选择建议\n实际应用：根据具体需求选择，一般情况下递归实现更简洁\n性能要求高：选择非递归实现，避免函数调用开销\n内存受限：后序遍历优选单栈法，其他遍历方式空间复杂度相当\n\n非递归实现的优势\n避免栈溢出：可以处理任意深度的树\n更好控制：可以方便地暂停、恢复遍历过程\n性能优化：减少函数调用开销\n状态保存：便于在遍历过程中保存额外信息\n\n非递归实现虽然代码复杂度较高，但在处理大规模数据或有特殊要求的场景中具有重要意义。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","递归","二叉树","节点遍历","迭代"]},{"title":"数据结构与算法自学笔记（7）- 随机排序&随机选择算法","url":"/2025/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89-%20%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F&%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series本笔记包括了随机快速排序和随机选择算法的原理与实现，涵盖了荷兰国旗问题优化、时间复杂度分析等内容，包括了class023 -&gt; class024的内容\n023【必备】随机快速排序快速排序的基本思想快速排序是一种高效的分治排序算法，其核心思想是：\n\n选择基准元素（pivot）：从数组中选择一个元素作为基准值pivot\n数组划分：将数组重新排列，使得所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值后面\n递归排序：对基准值两侧的子数组递归地应用快速排序\n\n随机化的重要性为什么需要随机化？\n\n普通快速排序：固定选择位置（如最右元素）作为基准，最坏情况时间复杂度为O(n²)\n随机快速排序：随机选择基准元素，期望时间复杂度为O(n log n)\n\n# 随机选择基准元素是关键x = arr[random.randint(l, r)]  # 在[l,r]范围内随机选择\n\n\n 测试链接 ：https://www.luogu.com.cn/problem/P1177\n经典快速排序实现（不推荐）def quickSort1(l, r):    # l == r，只有一个数    # l &gt; r，范围不存在，不用管    if l &gt;= r:        return    # 随机这一下，常数时间比较大    # 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)    # l......r 随机选一个位置，x这个值，做划分    x = arr[random.randint(l, r)]    mid = partition1(l, r, x) #会返回x的下标即index    quickSort1(l, mid - 1)    quickSort1(mid + 1, r)# 已知arr[l....r]范围上一定有x这个值# 划分数组 &lt;=x放左边，&gt;x放右边# 并且确保划分完成后&lt;=x区域的最后一个数字是xdef partition1(l, r, x):    # a : arr[l....a-1]范围是&lt;=x的区域    # xi : 记录在&lt;=x的区域上任何一个x的位置，哪一个都可以    a = l            # 初始化指针a，表示&lt;=x区域的右边界，初值为l    xi = 0           # 初始化xi，用于记录&lt;=x区域内某一个x的位置（后面需要与a-1交换）    for i in range(l, r + 1):   # 从l遍历到r，依次考察每个元素，每一步都会i++（重要，所以这里的代码没有显式写i++）        if arr[i] &lt;= x:         # 如果当前元素小于等于x            swap(a, i)          # 把当前元素交换到a位置（即&lt;=x区的后面）            if arr[a] == x:     # 如果新放到a位置的元素等于x                xi = a          # 记录下这个位置为xi            a += 1              # &lt;=x区往右扩展一位    swap(xi, a - 1)             # 把&lt;=x区域里某个x与区域最后一个元素交换，保证x落在最后    return a - 1                # 返回&lt;=x区域的最后一个下标（即x最终所在的位置）def swap(i, j):    tmp = arr[i]        # 先把arr[i]暂存到tmp    arr[i] = arr[j]     # arr[i]赋值为arr[j]    arr[j] = tmp        # arr[j]赋值为tmp，实现arr[i]和arr[j]交换\n\n经典版本的问题：\n\n经典快排每次只排掉一个等于pivot的元素，重复元素多时递归深度大，容易爆栈突变为，pivot 只确定了它自己的最终位置，如果有很多元素等于 pivot，只有一个会归位，剩下的还在“乱序”的子区间里。\n\n\n荷兰国旗问题优化版（推荐）荷兰国旗问题是快速排序的重要优化，将数组分为三个区域：\n[小于x的区域] [等于x的区域] [大于x的区域]\n能够一次处理所有等于pivot的元素，递归层数大大降低，所以不会爆栈，每次把所有等于pivot的数都一次性放到中间，只对小于和大于pivot的区间递归\n核心优势\n一次性处理所有相等元素：将所有等于pivot的元素都放到正确位置\n减少递归层数：只需要对小于和大于pivot的区域递归\n避免栈溢出：特别适合处理有大量重复元素的数组\n\n实现代码def quickSort2(l, r):    if l &gt;= r:        return    # 随机这一下，常数时间比较大    # 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)    x = arr[random.randint(l, r)]    partition2(l, r, x)    # 为了防止底层的递归过程覆盖全局变量    # 这里用临时变量记录first、last    left = first[0]    right = last[0]    quickSort2(l, left - 1)    quickSort2(right + 1, r)# 荷兰国旗问题first = [0]  # 用list模拟全局变量last = [0]# 已知arr[l....r]范围上一定有x这个值# 划分数组 &lt;x放左边，==x放中间，&gt;x放右边# 把全局变量first, last，更新成==x区域的左右边界def partition2(l, r, x):    first[0] = l    last[0] = r    i = l    while i &lt;= last[0]:        if arr[i] == x:            i += 1        elif arr[i] &lt; x:            swap(first[0], i)            first[0] += 1            i += 1        else:            swap(i, last[0])            last[0] -= 1 #i不变的原因是交换后 i 位置上的新元素还没考察过#前两种情况i++的原因是x作为基准，在i位置上，顶着左边区域向右推进，此外快速排序算法不需要随机元素的index\n\n荷兰国旗问题详细演示以数组 [7, 2, 6, 3, 1, 5, 4]，pivot&#x3D;3 为例：\n初始状态：\narr = [7, 2, 6, 3, 1, 5, 4]first = 0, last = 6, i = 0\n\nStep 1：arr[0] = 7 &gt; 3\n\n与 arr[6] 交换：[4, 2, 6, 3, 1, 5, 7]\nlast = 5，i 不变\n\nStep 2：arr[0] = 4 &gt; 3\n\n与 arr[5] 交换：[5, 2, 6, 3, 1, 4, 7]\nlast = 4，i 不变\n\nStep 3：arr[0] = 5 &gt; 3\n\n与 arr[4] 交换：[1, 2, 6, 3, 5, 4, 7]\nlast = 3，i 不变\n\nStep 4：arr[0] = 1 &lt; 3\n\n与 arr[0] 交换（自己）：不变\nfirst = 1，i = 1\n\nStep 5：arr[1] = 2 &lt; 3\n\n与 arr[1] 交换（自己）：不变\nfirst = 2，i = 2\n\nStep 6：arr[2] = 6 &gt; 3\n\n与 arr[3] 交换：[1, 2, 3, 6, 5, 4, 7]\nlast = 2，i 不变\n\nStep 7：arr[2] = 3 == 3\n\ni = 3，此时 i &gt; last，循环结束\n\n最终结果：\narr = [1, 2, 3, 6, 5, 4, 7][0, 1]: 小于3的区域 [1, 2][2, 2]: 等于3的区域 [3][3, 6]: 大于3的区域 [6, 5, 4, 7]\n\n时间复杂度分析随机快速排序的复杂度时间复杂度：O(n log n) （期望）\n\n每层的划分操作需要O(n)时间\n随机选择使得平均递归深度为O(log n)\n总时间复杂度：O(n) × O(log n) &#x3D; O(n log n)\n\n空间复杂度：O(log n) （期望）\n\n来自递归调用栈的深度\n最好情况：每次平分，深度为O(log n)\n最坏情况：退化为链式递归，深度为O(n)\n\n与普通快速排序对比普通快速排序\n\n普通快速排序的时间复杂度O(n^2)：固定流程考虑最坏情况（极端不平衡，每次都选到最小或最大元素为主元），每次只能划分出一个元素，剩下的 n-1 继续递归；额外空间复杂度O(n)取得是最坏情况递归的栈的深度。\n最好情况：T(n) &#x3D; 2 * T(n&#x2F;2) + O(n) &#x3D; O(n * logn),空间是O(logn)取得是递归的栈的深度。\n因为固定流程的话，可以构造出特定的数据，导致每次固定取最右最左的元素都是最差情况。\n\n随机快速排序\n\n随机快速排序，时间复杂度O(n * logn)随机取得是期望理论上每次能比较均匀划分为两半，递归深度约为 log𝑛，每一层的划分操作需要 O(n) 时间。额外空间复杂度O(logn)取得是递归的栈的深度，运气好每次都是区间二分，参考中序二叉树\n取期望，每个位置取1&#x2F;N的权重，最后能证明期望时间复杂度是O(n * logn)，额外空间复杂度O(logn)\n关于复杂度的分析，进行定性的说明，定量证明略，因为证明较为复杂，算法导论-7.4.2有详细证明\n\n\n\n\n算法类型\n时间复杂度（平均）\n时间复杂度（最坏）\n空间复杂度（平均）\n空间复杂度（最坏）\n\n\n\n普通快排\nO(n log n)\nO(n²)\nO(log n)\nO(n)\n\n\n随机快排\nO(n log n)\nO(n log n)*\nO(log n)\nO(log n)*\n\n\n*期望意义下\n024【必备】随机选择算法问题描述无序数组中第K大的元素问题：\n\n给定整数数组 nums 和整数 k\n返回数组中第 k 个最大的元素\n要求时间复杂度为 O(n)\n\n关键转换：第K大 &#x3D; 第(len-k)小（python中）。事实上，若下标从0开始时，第K大等于第(len-k)小（即下标为len-k的元素）；如果下标从1开始，则用len+1-k\n随机选择算法原理随机选择算法是快速排序的变种，核心思想：\n\n只关心目标位置：不需要完全排序，只需要找到第K大的元素\n单侧递归：每次只需要在包含目标位置的一侧继续查找\n随机化优化：通过随机选择pivot避免最坏情况\n\n 测试链接 ：https://leetcode.cn/problems/kth-largest-element-in-an-array/\n实现代码class RandomizedSelect:    first = 0  # 等于区域的左边界    last = 0   # 等于区域的右边界    @staticmethod    def findKthLargest(nums, k):        &quot;&quot;&quot;找第K大元素&quot;&quot;&quot;        # 转换为找第(len-k)小的元素        return RandomizedSelect.randomizedSelect(nums, len(nums) - k)    @staticmethod    def randomizedSelect(arr, i):        &quot;&quot;&quot;        连递归都没用，所以时间复杂度是O(n)左右的量级        在数组中找到如果排序后在位置i的元素        时间复杂度：O(n)        &quot;&quot;&quot;        ans = 0        l = 0        r = len(arr) - 1                while l &lt;= r:#不断二分的过程中，l和r上是仍然有范围的，直到没有范围才终止            # 随机这一下，常数时间比较大            # 但只有这一下随机，才能在概率上把时间复杂度收敛到O(n)            pivot = arr[l + int(random.random() * (r - l + 1))]                        # 使用荷兰国旗问题进行划分            RandomizedSelect.partition(arr, l, r, pivot)                        # 因为左右两侧只需要走一侧            # 所以不需要临时变量记录全局的first、last，直接用即可            # 等于的区域即first，last包住的位置，i小于first则去左侧，i大于last则去右侧            if i &lt; RandomizedSelect.first:                r = RandomizedSelect.first - 1  # 目标在左侧，pivot左边变成r            elif i &gt; RandomizedSelect.last:                l = RandomizedSelect.last + 1   # 目标在右侧，pivot右边变成l            else:                ans = arr[i]  # 找到目标                break                        return ans    @staticmethod    def partition(arr, l, r, x):        &quot;&quot;&quot;荷兰国旗问题划分&quot;&quot;&quot;        RandomizedSelect.first = l        RandomizedSelect.last = r        i = l                while i &lt;= RandomizedSelect.last:            if arr[i] == x:                i += 1            elif arr[i] &lt; x:                RandomizedSelect.swap(arr, RandomizedSelect.first, i)                RandomizedSelect.first += 1                i += 1            else:                RandomizedSelect.swap(arr, i, RandomizedSelect.last)                RandomizedSelect.last -= 1    @staticmethod    def swap(arr, i, j):        &quot;&quot;&quot;交换数组元素&quot;&quot;&quot;        arr[i], arr[j] = arr[j], arr[i]\n\n算法执行示例以数组 [7, 2, 6, 3, 1, 5, 4]，查找第4小元素（下标为3）为例：\n第一轮：\n\n随机选择 pivot = 3\n划分后：[1, 2, 3, 6, 5, 4, 7]\n等于区域：first = 2, last = 2\n目标下标3 &gt; last&#x3D;2，继续在右侧 [6, 5, 4, 7] 查找\n\n第二轮：\n\n在右侧区域随机选择 pivot = 4\n划分后相对位置：[4, 5, 6, 7]（实际在原数组的3,4,5,6位置）\n等于区域：first = 3, last = 3\n目标下标3 &#x3D;&#x3D; first &#x3D;&#x3D; last，找到答案 arr[3] = 4\n\n时间复杂度证明（定性分析）为什么是O(n)？\n每次划分后，下一次只需要处理一侧的数据：\n\n第一次处理：n个元素\n第二次处理：n&#x2F;2个元素（期望）\n第三次处理：n&#x2F;4个元素（期望）\n…\n\n总时间：n + n/2 + n/4 + n/8 + ... ≈ 2n\n因此期望时间复杂度为 O(n)。\n与其他算法的比较\n\n\n算法\n时间复杂度\n空间复杂度\n特点\n\n\n\n完全排序\nO(n log n)\nO(1)\n简单但过度\n\n\n堆排序K次\nO(n + k log n)\nO(1)\n适合K很小的情况\n\n\n随机选择\nO(n)\nO(1)\n最优解\n\n\nBFPRT算法\nO(n)\nO(log n)\n理论最优但常数大\n\n\n实际应用场景\nTop-K问题：找出数组中最大&#x2F;最小的K个元素\n中位数查找：快速找到数组的中位数\n分位数计算：统计学中的百分位数计算\n数据分析：快速找到数据集中的特定排名元素\n\n关键要点总结\n随机化的重要性：\n\n避免最坏情况的发生\n使算法在期望意义下达到最优复杂度\n\n\n荷兰国旗问题的优势：\n\n一次性处理所有相等元素\n减少递归&#x2F;迭代次数\n提高算法稳定性\n\n\n单侧处理的效率：\n\n与完全排序不同，只需要处理包含目标的一侧\n大大减少了计算量\n\n\n工程实践建议：\n\n对于一般规模的数据，随机选择算法是首选\n当需要多次查询不同K值时，可以考虑先排序\n在对稳定性要求极高的场合，可以考虑BFPRT算法\n\n\n\n这两个算法（随机快速排序和随机选择）是分治算法的经典应用，展示了随机化在算法设计中的重要作用。掌握这些算法不仅有助于解决实际问题，也为理解更复杂的分治算法奠定了基础。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","排序算法","分治算法","随机算法","荷兰国旗问题"]},{"title":"数据结构与算法自学笔记（5）- 算法笔试中处理输入和输出","url":"/2025/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%20%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E4%B8%AD%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/","content":"引言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n是class019的内容，本笔记重点介绍Python在算法竞赛和笔试中的高效输入输出处理技巧，包含子矩阵最大累加和问题的完整实现，以及与Java的性能对比分析。\n019【必备】算法笔试中处理输入和输出概述在算法竞赛和大厂笔试中，输入输出的处理效率往往是程序性能的关键瓶颈。Python虽然在执行速度上不如C++和Java，但通过合理的IO优化技巧，同样可以在大多数场景下取得良好的性能表现。\nPython vs Java IO性能对比\n\n\n特性\nPython\nJava\n\n\n\n默认IO\ninput()、print() 较慢\nScanner、System.out 较慢\n\n\n高效IO\nsys.stdin.read()、批量输出\nBufferedReader、PrintWriter\n\n\n内存管理\n自动垃圾回收，相对简单\n需要考虑静态空间分配\n\n\n大整数\n原生支持任意精度\n需要BigInteger类\n\n\n编程复杂度\n语法简洁，容易上手\n类型安全，但代码较长\n\n\nPython编程风格选择填函数风格（OJ平台推荐）适用于LeetCode、牛客网等在线判题平台，平台会自动处理输入输出。\nclass Solution:    def sumOfSubMatrix(self, mat, n):        &quot;&quot;&quot;        只需实现核心算法逻辑        平台自动调用并验证结果        &quot;&quot;&quot;        return self.maxSumSubmatrix(mat, n, n)        def maxSumSubmatrix(self, mat, rows, cols):        max_sum = float(&#x27;-inf&#x27;)        for i in range(rows):            arr = [0] * cols  # 辅助数组            for j in range(i, rows):                for k in range(cols):                    arr[k] += mat[j][k]                max_sum = max(max_sum, self.maxSumSubarray(arr))        return max_sum        def maxSumSubarray(self, arr):        max_sum = float(&#x27;-inf&#x27;)        cur = 0        for num in arr:            cur += num            max_sum = max(max_sum, cur)            cur = max(cur, 0)  # 负数时重置为0        return max_sum\n\nACM风格（竞赛笔试推荐）适用于ACM竞赛、大厂笔试等需要自己处理输入输出的场景。\nimport sysdef main():    &quot;&quot;&quot;    完整的输入输出处理    需要自己解析数据格式    &quot;&quot;&quot;    lines = sys.stdin.read().split()    ptr = 0    output = []        while ptr &lt; len(lines):        n = int(lines[ptr])        ptr += 1        m = int(lines[ptr])        ptr += 1                # 构建矩阵        mat = []        for i in range(n):            row = []            for j in range(m):                row.append(int(lines[ptr]))                ptr += 1            mat.append(row)                # 计算结果        result = maxSumSubmatrix(mat, n, m)        output.append(str(result))        # 批量输出    print(&#x27;\\n&#x27;.join(output))if __name__ == &#x27;__main__&#x27;:    main()\n\n高效输入输出技巧输入优化策略推荐：一次性读取大数据import sys# 最高效：适用于已知数据量的场景lines = sys.stdin.read().split()ptr = 0# 逐个解析数据while ptr &lt; len(lines):    n = int(lines[ptr])    ptr += 1    # 处理数据...\n\n优点：\n\nIO次数最少，效率最高\n相当于Java的BufferedReader一次性读取\n适合大数据量场景\n\n可选：按行读取# 适用：需要按行处理不同格式数据for line in sys.stdin:    parts = line.strip().split()    total = sum(int(num) for num in parts)    print(total)\n\n适用场景：\n\n每行数据格式不同\n无法提前确定数据量\n相当于Java的逐行readLine()\n\n不推荐：频繁调用input()# 效率低：类似Java的Scannern = int(input())  # 大数据时很慢for i in range(n):    x = int(input())  # 每次都要系统调用\n\n输出优化策略推荐：批量输出# 收集所有结果，最后一次性输出output = []for i in range(n):    result = solve(data[i])    output.append(str(result))print(&#x27;\\n&#x27;.join(output))  # 一次性输出\n\n不推荐：频繁print()# 每次print都会刷新缓冲区，效率低for i in range(n):    print(solve(data[i]))  # 大数据时很慢\n\n内存优化：静态空间vs动态空间推荐：静态空间分配# 全局预分配，避免频繁内存分配MAXN = 201MAXM = 201mat = [[0] * MAXM for _ in range(MAXN)]  # 静态矩阵arr = [0] * MAXM  # 静态辅助数组def solve():    global n, m    # 复用已分配的空间    for i in range(n):        for j in range(m):            mat[i][j] = read_next_int()        # 使用前先清空    for i in range(m):        arr[i] = 0\n\n不推荐：频繁动态分配def solve():    # 每次都重新分配内存    mat = []  # 动态创建    for i in range(n):        row = []  # 每行都新建        for j in range(m):            row.append(read_next_int())        mat.append(row)\n\n子矩阵最大累加和问题详解问题描述与算法思路问题：给定包含正数、负数、零的矩阵，求累加和最大的子矩阵。\n核心思想：将二维问题转化为一维最大子数组和问题\n\n枚举子矩阵的上下边界（第i行到第j行）\n将每列在这个范围内的元素累加，得到一维数组\n对一维数组使用Kadane算法求最大子数组和\n\n完整实现（填函数风格）class Code01_FillFunction:    def sumOfSubMatrix(self, mat, n):        &quot;&quot;&quot;主方法，求n×n矩阵的最大子矩阵和&quot;&quot;&quot;        return self.maxSumSubmatrix(mat, n, n)    @staticmethod    def maxSumSubmatrix(mat, n, m):        &quot;&quot;&quot;求子矩阵的最大累加和&quot;&quot;&quot;        max_sum = float(&#x27;-inf&#x27;)                # 枚举上边界        for i in range(n):            arr = [0] * m  # 辅助数组，每次重置                        # 枚举下边界（从i到n-1）            for j in range(i, n):                # 将第j行累加到辅助数组                for k in range(m):                    arr[k] += mat[j][k]                                # 求当前辅助数组的最大子数组和                max_sum = max(max_sum, Code01_FillFunction.maxSumSubarray(arr, m))                return max_sum    @staticmethod    def maxSumSubarray(arr, m):        &quot;&quot;&quot;Kadane算法求最大子数组和&quot;&quot;&quot;        max_sum = float(&#x27;-inf&#x27;)        cur = 0                for i in range(m):            cur += arr[i]            max_sum = max(max_sum, cur)            cur = 0 if cur &lt; 0 else cur  # 负数时重置                return max_sum\n\n算法复杂度：\n\n时间复杂度：O(n² × m)\n空间复杂度：O(m)\n\nACM风格实现（静态空间优化）import sys# 静态空间分配，避免频繁内存分配MAXN = 201MAXM = 201mat = [[0] * MAXM for _ in range(MAXN)]arr = [0] * MAXMn = m = 0def main():    global n, m    tokens = sys.stdin.read().split()    idx = 0    output = []        while idx &lt; len(tokens):        n = int(tokens[idx])        idx += 1        m = int(tokens[idx])        idx += 1                # 读取矩阵数据到静态空间        for i in range(n):            for j in range(m):                mat[i][j] = int(tokens[idx])                idx += 1                # 计算结果并收集输出        output.append(str(maxSumSubmatrix()))        # 批量输出所有结果    print(&#x27;\\n&#x27;.join(output))def maxSumSubmatrix():    &quot;&quot;&quot;使用静态空间的子矩阵最大和算法&quot;&quot;&quot;    max_sum = float(&#x27;-inf&#x27;)        for i in range(n):        # 清空辅助数组（复用静态空间）        for x in range(m):            arr[x] = 0                    for j in range(i, n):            # 累加第j行到辅助数组            for k in range(m):                arr[k] += mat[j][k]            max_sum = max(max_sum, maxSumSubarray())        return max_sumdef maxSumSubarray():    &quot;&quot;&quot;一维最大子数组和&quot;&quot;&quot;    max_sum = float(&#x27;-inf&#x27;)    cur = 0        for i in range(m):        cur += arr[i]        max_sum = max(max_sum, cur)        cur = 0 if cur &lt; 0 else cur        return max_sumif __name__ == &#x27;__main__&#x27;:    main()\n\n执行过程示例以矩阵为例：\n[[-90, 48, 78], [ 64,-40, 64],  [-81, -7, 66]]\n\n枚举过程：\n\ni&#x3D;0, j&#x3D;0（第0行）：arr&#x3D;[-90, 48, 78] → 最大子数组和&#x3D;126\ni&#x3D;0, j&#x3D;1（第0-1行）：arr&#x3D;[-26, 8, 142] → 最大子数组和&#x3D;150  \ni&#x3D;0, j&#x3D;2（第0-2行）：arr&#x3D;[-107, 1, 208] → 最大子数组和&#x3D;209\ni&#x3D;1, j&#x3D;1（第1行）：arr&#x3D;[64, -40, 64] → 最大子数组和&#x3D;88\ni&#x3D;1, j&#x3D;2（第1-2行）：arr&#x3D;[-17, -47, 130] → 最大子数组和&#x3D;130\ni&#x3D;2, j&#x3D;2（第2行）：arr&#x3D;[-81, -7, 66] → 最大子数组和&#x3D;66\n\n最终结果：209（来自第0-2行，第2-2列的子矩阵）\nPython高级IO优化FastReader快读类FastReader 是一个极致追求输入速度的工具，适用于数据量极大的算法竞赛场景。\n主要作用\n\n极速读取输入，尤其是大量数字（如百万级数据）。\n通过 一次性读取大块数据（8KB） 到内存，减少系统I&#x2F;O调用次数。\n按字节处理并手动解析数字，比标准 input() 或 sys.stdin.readline() 更快。\n\n工作原理\n\n缓冲区：用 self.buffer 存储从输入流一次性读取的大块数据。\n按字节解析：用 readByte 方法逐字节读取，跳过非数字字符，自己实现整数解析（包括负数）。\n高效：只处理数字和符号，省略 split、strip 等高层方法，极致优化输入。\n\n典型用法适合极端大数据输入、对时间卡得很紧的OJ平台。\nimport sysclass FastReader:    def __init__(self, file=sys.stdin):        self.file = file        self.buffer = &quot;&quot;        self.idx = 0    def _read(self):        &quot;&quot;&quot;一次性读取8KB数据到缓冲区&quot;&quot;&quot;        self.buffer = self.file.read(8192)        self.idx = 0    def readByte(self):        &quot;&quot;&quot;读取下一个字节&quot;&quot;&quot;        if self.idx &gt;= len(self.buffer):            self._read()            if self.buffer == &quot;&quot;:                return -1        byte = self.buffer[self.idx]        self.idx += 1        return ord(byte)    def readInt(self):        &quot;&quot;&quot;快速读取整数&quot;&quot;&quot;        num = 0        minus = False        b = self.readByte()                # 跳过非数字字符        while b != -1 and (b &lt; ord(&#x27;0&#x27;) or b &gt; ord(&#x27;9&#x27;)) and b != ord(&#x27;-&#x27;):            b = self.readByte()                    if b == ord(&#x27;-&#x27;):            minus = True            b = self.readByte()                    # 读取数字        while b != -1 and (ord(&#x27;0&#x27;) &lt;= b &lt;= ord(&#x27;9&#x27;)):            num = num * 10 + (b - ord(&#x27;0&#x27;))            b = self.readByte()                    return -num if minus else num    def readLong(self):        &quot;&quot;&quot;读取长整数（Python中与int相同）&quot;&quot;&quot;        return self.readInt()\n\nFastWriter快写类FastWriter 是一个高效输出工具，适用于需要频繁输出、输出量大的场合。\n主要作用\n\n减少输出次数：把所有输出内容先缓存在内存里，最后统一输出，减少系统调用。\n链式调用和兼容Java风格，用起来很方便。\n\n工作原理\n\n缓冲区：所有待输出内容先存入 self.buffer 列表。\n批量输出：调用 flush() 时，一次性将所有内容写入输出流。\n兼容性：支持 write（写字符串）、writeln&#x2F;println（写一行），用法灵活。\n\n典型用法\n适合数据量大、频繁输出的算法题&#x2F;竞赛场景，防止 print() 太慢导致超时。\nimport sysclass FastWriter:    def __init__(self, file=sys.stdout):        self.file = file        self.buffer = []    def write(self, s):        &quot;&quot;&quot;写入字符串到缓冲区&quot;&quot;&quot;        self.buffer.append(str(s))        return self  # 支持链式调用    def writeln(self, s=&quot;&quot;):        &quot;&quot;&quot;写入一行&quot;&quot;&quot;        self.buffer.append(str(s) + &quot;\\n&quot;)        return self    def println(self, s=&quot;&quot;):        &quot;&quot;&quot;兼容Java习惯的方法名&quot;&quot;&quot;        return self.writeln(s)    def flush(self):        &quot;&quot;&quot;刷新缓冲区，实际写入文件&quot;&quot;&quot;        if self.buffer:            self.file.write(&quot;&quot;.join(self.buffer))            self.file.flush()            self.buffer = []    def close(self):        &quot;&quot;&quot;关闭写入器&quot;&quot;&quot;        self.flush()        if self.file != sys.stdout:            self.file.close()\n\nKattio类（Python版）Kattio 类是一个高效的输入输出（I&#x2F;O）工具类，最初流行于 Java 的竞赛编程圈。它的 Python 版本（如你上面给出的代码）主要是用来简化和加快处理标准输入输出，尤其适合数据量较大、输入格式“特殊”或需要频繁读取单个数据的场景，比如各类算法竞赛、OJ（Online Judge）平台等。\n主要作用\n\n高效读取输入：普通的 input() 在数据量大时会变慢，Kattio 通过缓冲和一次性读取一行数据，提升了读取效率。\n简化输入格式处理：常见的输入格式如多行多列、混合类型（int、float、str）都能方便读取，不用每次都写 split、map 一大堆。\n输出简便：带有封装的 println 方法，输出不再需要手动 print(…, file&#x3D;…)。\n\n工作原理\n\n维护一个缓冲区（self.buffer），每次读取一整行并分割成单词。\n提供 next() 方法按顺序读取下一个字符串，nextInt() 读取下一个整数，nextDouble() 读取下一个浮点数等。\n适配输入和输出流（默认为标准输入输出，但也可以重定向到文件），并提供 close 方法在需要时关闭流。\n\n参考Java版Kattio的Python实现，处理特殊输入格式：\nimport sysfrom typing import Optionalclass Kattio:    &quot;&quot;&quot;    高效IO类，适用于特殊格式输入    效率略低于FastReader，但兼容性更好    &quot;&quot;&quot;    def __init__(self, input_stream=sys.stdin, output_stream=sys.stdout):        self.input = input_stream        self.output = output_stream        self.buffer = []        self.idx = 0    def _fill_buffer(self):        &quot;&quot;&quot;填充缓冲区&quot;&quot;&quot;        line = self.input.readline()        if line == &#x27;&#x27;:            return        self.buffer = line.strip().split()        self.idx = 0    def next(self) -&gt; Optional[str]:        &quot;&quot;&quot;读取下一个字符串&quot;&quot;&quot;        while self.idx &gt;= len(self.buffer):            self._fill_buffer()            if not self.buffer:                return None        result = self.buffer[self.idx]        self.idx += 1        return result    def nextInt(self) -&gt; int:        &quot;&quot;&quot;读取下一个整数&quot;&quot;&quot;        return int(self.next())    def nextLong(self) -&gt; int:        &quot;&quot;&quot;读取下一个长整数&quot;&quot;&quot;        return int(self.next())    def nextDouble(self) -&gt; float:        &quot;&quot;&quot;读取下一个浮点数&quot;&quot;&quot;        return float(self.next())    def println(self, s):        &quot;&quot;&quot;输出一行&quot;&quot;&quot;        print(s, file=self.output)    def close(self):        &quot;&quot;&quot;关闭IO流&quot;&quot;&quot;        if self.input != sys.stdin:            self.input.close()        if self.output != sys.stdout:            self.output.close()\n\nPython常用数据结构快速参考基础容器操作from collections import deque, defaultdictimport bisect# 列表（动态数组）arr = [1, 2, 3]arr.append(4)              # O(1) 尾部添加arr.insert(0, 0)           # O(n) 头部插入arr.pop()                  # O(1) 尾部删除arr.pop(0)                 # O(n) 头部删除print(arr[1])              # O(1) 随机访问# 双端队列（可当栈或队列）dq = deque()dq.append(1)               # 队尾入队dq.appendleft(2)           # 队首入队dq.pop()                   # 队尾出队dq.popleft()               # 队首出队# 集合操作s1 = &#123;1, 2, 3&#125;s2 = &#123;2, 3, 4&#125;print(s1 | s2)             # 并集print(s1 &amp; s2)             # 交集print(s1 - s2)             # 差集# 字典操作d = defaultdict(int)       # 默认值为0d[&quot;key&quot;] += 1              # 自动初始化并自增\n\n排序与查找# 排序arr = [3, 1, 4, 1, 5]arr.sort()                           # 原地升序排序arr.sort(reverse=True)               # 原地降序排序sorted_arr = sorted(arr)             # 返回新的排序数组custom_sorted = sorted(arr, key=lambda x: -x)  # 自定义排序# 二分查找arr = [1, 2, 4, 7, 9]  # 必须有序idx = bisect.bisect_left(arr, 4)     # 查找插入位置idx = bisect.bisect_right(arr, 4)    # 查找插入位置（右侧）\n\n大整数与高精度# Python原生支持任意精度整数big_num = 10**100                    # 10的100次方result = big_num * big_num           # 自动处理大整数运算# 高精度除法import decimaldecimal.getcontext().prec = 50       # 设置精度a = decimal.Decimal(&#x27;1&#x27;) / decimal.Decimal(&#x27;3&#x27;)\n\n实战技巧与注意事项性能优化技巧# 1. 避免在循环中重复计算# 错误写法for i in range(n):    for j in range(len(arr)):  # 每次都计算len(arr)        pass# 正确写法  arr_len = len(arr)for i in range(n):    for j in range(arr_len):        pass# 2. 使用局部变量访问全局数据# 错误写法def process():    for i in range(n):        result += global_data[i]  # 每次都查找全局变量# 正确写法def process():    local_data = global_data  # 本地化全局变量    for i in range(n):        result += local_data[i]# 3. 字符串拼接优化# 错误写法s = &quot;&quot;for i in range(n):    s += str(i)  # 每次都创建新字符串# 正确写法parts = []for i in range(n):    parts.append(str(i))s = &quot;&quot;.join(parts)\n\n常见陷阱与解决方案# 1. 递归深度限制import syssys.setrecursionlimit(10000)  # 设置递归深度限制# 2. 浮点数精度问题import mathdef is_equal(a, b, eps=1e-9):    return abs(a - b) &lt; eps# 3. 列表初始化陷阱# 错误：所有行共享同一个列表matrix = [[0] * m] * n# 正确：每行都是独立的列表matrix = [[0] * m for _ in range(n)]# 4. 字典默认值from collections import defaultdict# 使用defaultdict避免KeyErrorcount = defaultdict(int)count[key] += 1  # 自动初始化为0\n\n调试技巧# 条件编译式调试DEBUG = Falsedef debug_print(*args):    if DEBUG:        print(&quot;DEBUG:&quot;, *args)# 输入输出重定向（本地测试）import sysif DEBUG:    sys.stdin = open(&#x27;input.txt&#x27;, &#x27;r&#x27;)    sys.stdout = open(&#x27;output.txt&#x27;, &#x27;w&#x27;)# 计时器import timestart_time = time.time()# ... 算法代码 ...print(f&quot;执行时间: &#123;time.time() - start_time:.3f&#125;秒&quot;)\n\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","输入输出(IO)","高效编程","子矩阵问题"]},{"title":"数据结构与算法自学笔记（8）- 堆结构&哈希表&堆结构相关习题","url":"/2025/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89-%20%E5%A0%86%E7%BB%93%E6%9E%84&%E5%93%88%E5%B8%8C%E8%A1%A8&%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98/","content":"前言参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series\n本笔记涵盖了堆的基本概念与堆排序、哈希表的实现以及堆结构的一些相关习题，包括了class025→027的内容。\n025【必备】堆结构和堆排序堆的基本概念什么是堆堆是一种特殊的完全二叉树结构，通常用数组来实现存储。堆有以下特性：\n\n结构性质：堆是完全二叉树，即除了最后一层，其他层都是满的，最后一层从左到右连续填充\n堆序性质：\n大根堆：任何一个子树内部的最大值一定在顶部（父节点 ≥ 子节点）\n小根堆：任何一个子树内部的最小值一定在顶部（父节点 ≤ 子节点）\n\n\n\n堆的数组表示堆使用数组实现，通过下标关系来表示父子关系：\n# 对于下标为 i 的节点：parent = (i - 1) // 2    # 父节点下标left_child = i * 2 + 1   # 左孩子下标  right_child = i * 2 + 2  # 右孩子下标# 判断是否有孩子节点：# 如果 left_child &gt;= size，则没有左孩子# 如果 right_child &gt;= size，则没有右孩子\n\n堆的核心操作堆有两个核心调整操作，时间复杂度都是 O(log n)：\n\nheapInsert（向上调整）：新元素插入后向上调整维持堆性质\nheapify（向下调整）：删除堆顶后向下调整维持堆性质\n\n堆的核心算法实现heapInsert - 向上调整当在堆的末尾插入新元素时，需要向上调整以维持堆的性质：\ndef heapInsert(i):    &quot;&quot;&quot;    i位置的数，向上调整大根堆    时间复杂度：O(logn)    &quot;&quot;&quot;    while arr[i] &gt; arr[(i - 1) // 2]:  # 当前节点大于父节点时        swap(i, (i - 1) // 2)          # 与父节点交换        i = (i - 1) // 2               # 更新当前位置为父节点位置\n\n算法流程：\n\n比较当前节点与其父节点的值\n如果当前节点更大（大根堆），则交换\n向上移动到父节点位置，重复过程\n直到满足堆性质或到达根节点\n\n测试链接：https://www.luogu.com.cn/problem/P1177\n\nheapify - 向下调整当删除堆顶元素后，需要向下调整以维持堆的性质：\ndef heapify(i, size):    &quot;&quot;&quot;    i位置的数，向下调整大根堆    当前堆的大小为size    时间复杂度：O(logn)    &quot;&quot;&quot;    l = i * 2 + 1  # 左孩子    while l &lt; size:  # 如果左孩子存在        # 选出左右孩子中更大的那个        best = l + 1 if (l + 1 &lt; size and arr[l + 1] &gt; arr[l]) else l        # 当前节点和最强孩子之间，选出最强的        best = best if arr[best] &gt; arr[i] else i        if best == i:  # 如果当前节点最大，调整完成            break        swap(best, i)  # 交换        i = best       # 移动到交换后的位置        l = i * 2 + 1  # 更新左孩子# 1.找到更大的子节点：比较左右子节点，选出值更大的那个# 2.与父节点比较：将较大的子节点与当前父节点比较# 3.决定是否交换：如果子节点更大就交换，否则停止调整# 4.继续向下：交换后继续对新位置进行同样的操作\n\n算法流程：\n\n找到更大的子节点：比较左右子节点，选出值更大的那个\n与父节点比较：将较大的子节点与当前父节点比较\n决定是否交换：如果子节点更大就交换，否则停止调整\n继续向下：交换后继续对新位置进行同样的操作\n\n堆排序的两种实现方法一：从顶到底建堆（经典版本）def heapSort1():    &quot;&quot;&quot;    完全二叉树的节点为N的话，高度是log_2(N)的水平    从顶到底建立大根堆，从顶到底建立大根堆，O(n * logn)，每次排好一个数，排n个数要n次，每排一个数时间复杂度是logn，排n个数当然是nlogn    依次弹出堆内最大值并排好序，O(n * logn)    整体时间复杂度O(n * logn)    &quot;&quot;&quot;    # 建堆阶段：从第一个元素开始，依次插入    for i in range(n):        heapInsert(i)  # 每个元素向上调整        # 排序阶段：不断取出最大值    size = n    while size &gt; 1:        swap(0, size - 1)  # 将最大值（堆顶）放到数组末尾        size -= 1          # 减少堆的大小        heapify(0, size)   # 对新的堆顶进行向下调整\n\n时间复杂度分析：\n\n建堆阶段：log₁ + log₂ + log₃ + ... + logₙ =（收敛于） O(n logn)\n排序阶段：每次调整 O(log n)，共 n-1 次，总计 O(n logn)\n总时间复杂度：O(n logn)\n\n\n方法二：从底到顶建堆（优化版本）def heapSort2():    &quot;&quot;&quot;    从底到顶建立大根堆，O(n)     依次弹出堆内最大值并排好序，O(n * logn)    整体时间复杂度O(n * logn)    &quot;&quot;&quot;    # 建堆阶段：从最后一个非叶子节点开始，向前调整    for i in range(n - 1, -1, -1):        heapify(i, n)        # 排序阶段：与方法一相同    size = n    while size &gt; 1:        swap(0, size - 1)        size -= 1        heapify(0, size)# 这种方法更像修理一栋破房子，从最下面的楼层开始修。建堆阶段只需要O(n)时间，具体是从最后一个非叶子节点开始逐个向前调整，每个节点只需要&quot;向下看&quot;把不合格的子节点换上来，由于采用从底向上的策略效率更高。# 排序阶段的做法与方法1相同，先取堆顶元素放到合适位置，然后重新调整剩余元素成堆并重复进行。整体而言方法2更优，因为它的建堆过程比方法1快了一个数量级，从O(n logn)优化到了O(n)\n为什么从底到顶建堆更快？\n从底到顶建堆的时间复杂度是 O(n)，这是因为：\n\n叶子节点无需调整：完全二叉树中约有 n&#x2F;2 个叶子节点，它们天然满足堆性质\n调整距离递减：越靠近叶子的节点，需要向下调整的最大距离越小\n数学分析：可以证明总的调整代价是一个等比数列，收敛到 O(n)\n\n两种方法的对比：\n\n\n\n建堆方法\n建堆复杂度\n排序复杂度\n总复杂度\n特点\n\n\n\n从顶到底\nO(n logn)\nO(n logn)\nO(n logn)\n逐个插入元素”爬楼梯”\n\n\n从底到顶\nO(n)\nO(n logn)\nO(n logn)\n从下往上”修房子”\n\n\n完整代码实现import sysimport randomMAXN = 100001arr = [0] * MAXNn = 0def main():    global n    data = sys.stdin.read().split()    n = int(data[0])    for i in range(n):        arr[i] = int(data[i + 1])        heapSort2()  # 使用优化版本        # 高效输出    sys.stdout.write(&#x27; &#x27;.join(str(arr[i]) for i in range(n - 1)))    sys.stdout.write(&#x27; &#x27; + str(arr[n - 1]) + &#x27;\\n&#x27;)def heapInsert(i):    while arr[i] &gt; arr[(i - 1) // 2]:        swap(i, (i - 1) // 2)        i = (i - 1) // 2def heapify(i, size):    l = i * 2 + 1    while l &lt; size:        best = l + 1 if (l + 1 &lt; size and arr[l + 1] &gt; arr[l]) else l        best = best if arr[best] &gt; arr[i] else i        if best == i:            break        swap(best, i)        i = best        l = i * 2 + 1def swap(i, j):    arr[i], arr[j] = arr[j], arr[i]def heapSort1():    for i in range(n):        heapInsert(i)    size = n    while size &gt; 1:        swap(0, size - 1)        size -= 1        heapify(0, size)def heapSort2():    for i in range(n - 1, -1, -1):        heapify(i, n)    size = n    while size &gt; 1:        swap(0, size - 1)        size -= 1        heapify(0, size)if __name__ == &quot;__main__&quot;:    main()\n\n堆排序的特点总结优点\n时间复杂度稳定：无论什么数据，时间复杂度都是 O(n logn)\n原地排序：额外空间复杂度 O(1)，直接在原数组上建堆\n不稳定但可预测：虽然不是稳定排序，但性能可预测\n\n缺点\n不稳定：相同元素的相对位置可能改变\n常数因子较大：虽然渐进复杂度优秀，但实际运行时常数因子比快排大\n缓存友好性差：堆调整过程中的访问模式对CPU缓存不太友好\n\n应用场景\n优先队列：堆是实现优先队列的最佳数据结构\nTop-K 问题：找出最大或最小的K个元素\n实时数据流：需要实时维护最值的场景\n任务调度：按优先级处理任务\n\n重要提示堆结构比堆排序有用得多，尤其是和比较器结合之后。堆排序只是堆数据结构的一个应用，堆在实际开发中更多用于实现优先队列、解决Top-K问题等场景。\n026【必备】哈希表、有序表和比较器的用法哈希表（Hash Table）的基本概念什么是哈希表？哈希表是一种数据结构，它通过键（key）来直接访问存储在值（value）中的数据，实现快速查找、插入和删除操作。\n大概约等于python中的字典啦\n核心思想\n将数据存储在数组中\n通过哈希函数将key转换为数组索引\n理想情况下，查找、插入、删除的时间复杂度都是O(1)\n\n工作原理Key → 哈希函数 → 数组索引 → 存储位置\n\n哈希表的特点\n时间复杂度：增、删、改、查时间为O(1)，但是大常数\n空间换时间：用额外的空间来换取时间效率\n两种形式：\nHashSet：只存储键，用于判断元素是否存在\nHashMap：存储键值对，根据键快速找到对应的值\n\n\n\nPython中的哈希表实现字符串的比较机制Python中字符串有特殊的驻留机制，需要注意is和==的区别：\n# 字符串比较str1 = str(&quot;Hello&quot;) str2 = str(&quot;Hello&quot;)  # 不同内存地址，但是内容都是Hello# 比较对象身份（内存地址）print(str1 is str2)   # 可能是True（驻留机制）# 比较值（内容）print(str1 == str2)   # True，内容一样# 动态生成的字符串s3 = &#x27;&#x27;.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])print(s1 == s3)  # Trueprint(s1 is s3)  # False，复杂或动态生成的字符串，is一般是False\n\n重要概念：\n\n字符串驻留：Python对于短小、常用的字符串可能会优化，放到同一个内存地址\n内容比较 vs 身份比较：==比较内容，is比较内存地址\n\nset操作（HashSet）# set判断元素是否相等靠内容，不看对象idstr1 = str(&quot;Hello&quot;) str2 = str(&quot;Hello&quot;)  # 不同内存地址，但是内容都是Hellos = set()s.add(str1)print(&quot;Hello&quot; in s)     # Trueprint(str2 in s)        # Trues.add(str2)print(len(s))           # 1，因为set里不会存储重复元素s.discard(str1)         # 删除等价元素（内容相等的字符串都会被删掉）s.clear()               # 清空所有元素print(len(s) == 0)      # True\n\ndict操作（HashMap）# dict操作map1 = dict()map1[str1] = &quot;World&quot;    # str1是key，&quot;World&quot;是valueprint(&quot;Hello&quot; in map1)  # Trueprint(str2 in map1)     # Trueprint(map1.get(str2))   # Worldprint(map1.get(&quot;你好&quot;) is None)  # Trueif &quot;Hello&quot; in map1:    del map1[&quot;Hello&quot;]print(len(map1))        # 0map1.clear()print(len(map1) == 0)   # True\n\n哈希表的优化策略数组替代哈希表当key的范围是固定的、可控的情况下，可以用数组结构替代哈希表结构：\n# 哈希表实现map2 = dict()map2[56] = 7285map2[34] = 3671263map2[17] = 716311map2[24] = 1263161# 数组替代实现（速度更快）arr = [0] * 100arr[56] = 7285arr[34] = 3671263arr[17] = 716311arr[24] = 1263161\n\n优势：\n\n速度更快：直接数组访问，无需哈希计算\n空间可控：预知范围，精确分配空间\n无哈希冲突：避免了哈希表的冲突处理\n\n自定义对象作为Keyclass Student:    def __init__(self, age, name):        self.age = age        self.name = names1 = Student(17, &quot;张三&quot;)s2 = Student(17, &quot;张三&quot;)map3 = dict()map3[s1] = &quot;这是张三&quot;print(s1 in map3)  # Trueprint(s2 in map3)  # False，Python默认不同对象hash不同map3[s2] = &quot;这是另一个张三&quot;print(len(map3))   # 2，s1和s2是不同的对象，字典中有两个键值对\n\n重要提示：Python自定义对象没有实现__eq__和__hash__时，默认按对象id判定。\n有序表（TreeMap&#x2F;TreeSet）Python中的有序表模拟Python没有内置的TreeMap，需要用其他方式模拟：\nimport heapq# 用dict+排序模拟TreeMaptree_map = dict()tree_map[5] = &quot;这是5&quot;tree_map[7] = &quot;这是7&quot;tree_map[1] = &quot;这是1&quot;tree_map[2] = &quot;这是2&quot;tree_map[3] = &quot;这是3&quot;tree_map[4] = &quot;这是4&quot;tree_map[8] = &quot;这是8&quot;print(1 in tree_map)        # Trueprint(10 in tree_map)       # Falseprint(tree_map.get(4))      # 这是4tree_map[4] = &quot;张三是4&quot;print(tree_map.get(4))      # 张三是4tree_map.pop(4, None)       # 删除key为4的键值对print(tree_map.get(4) is None)  # True\n\n有序表的特殊操作# firstKey 和 lastKey 需要排序keys = sorted(tree_map.keys())print(keys[0])      # firstKey: 1print(keys[-1])     # lastKey: 8# floorKey: 所有的key，&lt;= 4且最近的key是什么def floor_key(k):    return max([x for x in tree_map if x &lt;= k], default=None)# ceilingKey: 所有的key，&gt;= 4且最近的key是什么def ceiling_key(k):    return min([x for x in tree_map if x &gt;= k], default=None)print(floor_key(4))    # 3print(ceiling_key(4))  # 5\n\n操作解释：\n\n删除前：1, 2, 3, [4], 5, 7, 8\n删除后：1, 2, 3, 5, 7, 8\nfloor_key(4)：找到 ≤ 4 的最大值，可选值：[1, 2, 3]，最大值：3\nceiling_key(4)：找到 ≥ 4 的最小值，可选值：[5, 7, 8]，最小值：5\n\nTreeSet模拟# TreeSet模拟：用set+排序（去重且有序）s = set()s.add(3)s.add(3)s.add(4)s.add(4)print(&quot;有序表大小:&quot;, len(s))  # 2，因为set里不会存储重复元素# 以有序弹出for item in sorted(s):    print(item)  # 3 4\n\n优先队列（堆）小根堆# 小根堆heap1 = []heapq.heappush(heap1, 3)heapq.heappush(heap1, 3)heapq.heappush(heap1, 4)heapq.heappush(heap1, 4)print(&quot;堆大小:&quot;, len(heap1))  # 4while heap1:    print(heapq.heappop(heap1))  # 3 3 4 4\n\n大根堆实现技巧# 大根堆trick：使用负数heap2 = []for x in [3, 3, 4, 4]:    heapq.heappush(heap2, -x)print(&quot;堆大小:&quot;, len(heap2))  # 4while heap2:    print(-heapq.heappop(heap2))  # 4 4 3 3\n\n核心技巧：Python的heapq只提供小根堆，要实现大根堆可以将所有元素取负数。\n比较器的使用基本比较器概念任何比较器都有统一的规则：\n\n返回负数：认为第一个对象优先级更高\n返回正数：认为第二个对象优先级更高\n返回0：两个对象优先级相等\n\n员工类的排序示例from functools import cmp_to_keyclass Employee:    def __init__(self, company, age):        self.company = company        self.age = age    def __repr__(self):        return f&quot;Employee(&#123;self.company&#125;, &#123;self.age&#125;)&quot;# 员工比较器，按年龄升序def employee_comparator(o1, o2):    return o1.age - o2.age# 创建员工对象s1 = Employee(2, 27)s2 = Employee(1, 60)s3 = Employee(4, 19)s4 = Employee(3, 23)s5 = Employee(1, 35)s6 = Employee(3, 55)arr = [s1, s2, s3, s4, s5, s6]# 按年龄升序排序arr.sort(key=cmp_to_key(employee_comparator))for e in arr:    print(f&quot;&#123;e.company&#125;, &#123;e.age&#125;&quot;)\n\n多种排序方式# 按年龄降序排序（lambda表达式）arr.sort(key=lambda x: -x.age)for e in arr:    print(f&quot;&#123;e.company&#125;, &#123;e.age&#125;&quot;)# 多级排序：先按公司编号，再按年龄arr.sort(key=lambda x: (x.company, x.age))for e in arr:    print(f&quot;&#123;e.company&#125;, &#123;e.age&#125;&quot;)\n\n自定义对象的去重策略按年龄去重class EmployeeByAge(Employee):    def __eq__(self, other):        return self.age == other.age  # 只看年龄        def __hash__(self):        return hash(self.age)treeSet1 = set()for e in arr:    treeSet1.add(EmployeeByAge(e.company, e.age))print(len(treeSet1))  # 6# 会去重，因为age一样的员工被认为是同一个treeSet1.add(EmployeeByAge(2, 27))print(len(treeSet1))  # 6\n\n按多个属性去重class EmployeeByAll(Employee):    def __eq__(self, other):        if not isinstance(other, EmployeeByAll):            return False        return (self.company == other.company and                 self.age == other.age and                 repr(self) == repr(other))        def __hash__(self):        return hash((self.company, self.age, repr(self)))treeSet2 = set()for e in arr:    treeSet2.add(EmployeeByAll(e.company, e.age))print(len(treeSet2))  # 6# 不会去重，因为repr不同（内存地址不同）treeSet2.add(EmployeeByAll(2, 27))print(len(treeSet2))  # 7\n\n重要概念：\n\n__eq__方法：定义对象间的相等性比较，当使用==操作符时调用\n__hash__方法：定义对象的哈希值，用于在集合和字典中作为键\n\n字符串的字典序比较# 字典序比较str1 = &quot;abcde&quot;str2 = &quot;ks&quot;print(str1.__lt__(str2) - str1.__gt__(str2))  # -1print(str2.__lt__(str1) - str2.__gt__(str1))  # 1# 或者直接用比较运算符print((str1 &gt; str2) - (str1 &lt; str2))  # -1print((str2 &gt; str1) - (str2 &lt; str1))  # 1\n\n字典序规则：按字符的ASCII码逐位比较，先遇到不同字符的位置决定大小关系。\n数据结构选择指南性能对比表\n\n\n数据结构\n查找\n插入\n删除\n有序性\n去重\n适用场景\n\n\n\nset\nO(1)\nO(1)\nO(1)\n❌\n✅\n快速查重、集合运算\n\n\ndict\nO(1)\nO(1)\nO(1)\n❌\n✅\n键值映射、缓存\n\n\n数组\nO(1)\nO(1)\nO(1)\n❌\n❌\nkey范围可控时替代哈希表\n\n\n排序列表\nO(log n)\nO(n)\nO(n)\n✅\n❌\n需要有序且查找频繁\n\n\nheapq\nO(1)\nO(log n)\nO(log n)\n部分\n❌\n优先队列、Top-K问题\n\n\n使用建议\n快速查找、去重：使用set\n键值映射：使用dict\nkey范围固定：考虑数组替代哈希表\n需要有序：使用排序+二分查找或第三方库\n优先队列：使用heapq\n自定义排序：实现比较器或使用key参数\n\n实际应用场景场景1：统计词频# 使用dict统计text = &quot;hello world hello python&quot;word_count = &#123;&#125;for word in text.split():    word_count[word] = word_count.get(word, 0) + 1print(word_count)  # &#123;&#x27;hello&#x27;: 2, &#x27;world&#x27;: 1, &#x27;python&#x27;: 1&#125;\n\n场景2：去重并保持顺序# 使用dict保持插入顺序的去重def dedupe_keep_order(items):    seen = &#123;&#125;    result = []    for item in items:        if item not in seen:            seen[item] = True            result.append(item)    return resultitems = [1, 2, 3, 2, 4, 1, 5]print(dedupe_keep_order(items))  # [1, 2, 3, 4, 5]\n\n场景3：Top-K问题import heapqdef find_top_k(nums, k):    # 使用小根堆，维护k个最大元素    heap = []    for num in nums:        if len(heap) &lt; k:            heapq.heappush(heap, num)        elif num &gt; heap[0]:            heapq.heapreplace(heap, num)    return sorted(heap, reverse=True)nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]print(find_top_k(nums, 3))  # [9, 6, 5]\n\n总结\n哈希表：提供O(1)的查找、插入、删除，但有较大常数因子\n有序表：在Python中需要模拟实现，适合需要有序性的场景\n比较器：统一的优先级比较规则，负数表示第一个对象优先级更高\n优化策略：key范围可控时用数组替代哈希表，性能更好\n实际应用：根据具体需求选择合适的数据结构，考虑时间复杂度和空间复杂度的权衡\n\n027【必备】堆结构常见题Python heapq 模块详解heapq 基本概念heapq 是 Python 标准库提供的”二叉堆”实现工具，基于列表实现的最小堆（min-heap）。它能在 O(log n) 时间内插入与弹出最小元素，heap[0] 永远是当前最小值。\n常用 APIimport heapq# 基本操作heapq.heappush(heap, item)      # 压入元素，O(log n)heapq.heappop(heap)             # 弹出最小元素，O(log n)heapq.heapify(lst)              # 原地把列表转成堆，O(n)# 高效组合操作heapq.heappushpop(heap, item)   # 先推入再弹出（更高效的一步）heapq.heapreplace(heap, item)   # 先弹出最小再推入# 实用函数heapq.nsmallest(n, iterable)    # 返回n个最小元素heapq.nlargest(n, iterable)     # 返回n个最大元素heapq.merge(*iterables)         # 合并多个已排序可迭代对象（惰性生成）\n\n大根堆实现技巧由于 Python 的 heapq 只提供小根堆，实现大根堆需要使用负数技巧：\n# 大根堆实现heap = []for x in [3, 1, 4, 1, 5]:    heapq.heappush(heap, -x)    # 插入负数max_val = -heapq.heappop(heap)  # 弹出并转回正数\n\n问题一：合并K个有序链表测试链接：https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6\n问题描述给定K个有序链表，将它们合并成一个有序链表。\n算法思路使用小根堆维护所有链表的当前头节点，每次取出值最小的节点：\n\n初始化：将所有链表的头节点放入堆中\n合并过程：\n弹出堆顶最小节点，连接到结果链表\n如果该节点有下一个节点，将下一个节点入堆\n重复直到堆为空\n\n\n\n\n核心实现import heapqfrom typing import List, Optionalclass ListNode:    def __init__(self, val=0, next=None):        self.val = val        self.next = nextdef mergeKLists(arr: List[Optional[ListNode]]) -&gt; Optional[ListNode]:    # 小根堆，存储节点及其值，用堆结构的话时间复杂度会比O(NlogN)更小    # Optional[T] 等价于 Union[T, None]    # 表示这个值可能是 T 类型，也可能是 None    heap = []        # 将所有链表头节点入堆    for h in arr:        if h is not None:            # Python的heapq不能直接比较对象，需包装            heapq.heappush(heap, (h.val, id(h), h))            # heapq 比较规则：它按元组字典序比较。你放入 (val, something, node) 时，先比 val，相等就比第二个元素；如果第二个也相等，就会去比第三个元素（即 ListNode 实例）。            # 问题：ListNode 没有定义大小比较，直接比较会抛出 TypeError: &#x27;&lt;&#x27; not supported...            # 加入 id(node)：id 是对象在该进程生命周期内的唯一“身份值”（可比较），作为“决胜键”保证元组能比较出大小，从而避免直接比较 ListNode。     if not heap:        return None        # 弹出一个节点作为总头部    _, _, h = heapq.heappop(heap)    pre = h        # 将该节点的下一个节点入堆    if pre.next is not None:        heapq.heappush(heap, (pre.next.val, id(pre.next), pre.next))        # 继续合并过程    while heap:        _, _, cur = heapq.heappop(heap)        pre.next = cur      # 连接链表        pre = cur          # pre后移        if cur.next is not None:            heapq.heappush(heap, (cur.next.val, id(cur.next), cur.next))        return h    # 对 heapq 来说，一个 item 就是一个可比较的对象。这里把一个三元组 (pre.next.val, id(pre.next), pre.next) 当作 item 放入堆。    # 比较顺序（字典序）：    # 先比第 1 位 pre.next.val（值越小，优先级越高）    # 若相等，再比第 2 位 id(pre.next)（保证能比较出大小，避免去比较 ListNode 本身）    # 只在前两位都相等时，才会看第 3 位 pre.next（但通常不会用到，因为 id 已经唯一）\n\n关键技术点元组比较机制：\n\nheapq 按元组字典序比较：(val, something, node)\n先比较 val，相等时比较第二个元素\n加入 id(node) 作为”决胜键”，避免直接比较 ListNode 对象\n\n为什么需要 id(node)：\n\nListNode 没有定义大小比较，直接比较会抛出 TypeError\nid() 返回对象的唯一标识符，可以进行比较\n保证元组能比较出大小，避免直接比较 ListNode\n\n复杂度分析\n时间复杂度：O(N log K)，其中 N 是所有节点总数，K 是链表个数\n空间复杂度：O(K)，堆中最多存储 K 个节点\n\n问题二：最多线段重合问题测试链接：\n\nhttps://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37\nhttps://leetcode.cn/problems/meeting-rooms-ii/\n\n问题描述给定n条线段，每条线段有起点和终点，求最多同时重合的线段数量。\n算法思路使用扫描线算法 + 小根堆：\n\n排序：将所有线段按起点排序\n扫描：从左到右处理每条线段\n维护堆：堆中存储当前重合线段的结束时间\n清理：移除已结束的线段（结束点 ≤ 当前起点）\n更新：添加当前线段，更新最大重合数\n\n\n核心实现\n想象每条线段根据开始和结束位置，放在x轴上，然后有一根竖线，从左到右划过x轴，竖线压中的线段上的点，就需要把当前点放入到某个组里。\n\n请问，从左到右划的过程，你最多需要准备几个组？最多重合几条线段，就需要几个组。这些组不断复用空间，放入不同的点。但是最大重合了多少，你就需要准备几个组。\n\n重要：我之前一直在纠结为什么不要考虑后面重复合并， 但是我们这个代码已经考虑了后面重复合并，因为我们是把结束点加入到堆里，而不是把线段加入到堆里。因此即便这条线段的结束点和后面的线段的开始点重合，我们也会把这条线段的结束点加入到堆里，则以这个为标准对数轴进行扫描，又因为小根堆是根据开始点进行从小大排序的，所以能够保证后面的线段初始点严格小于当前线段的初始点，不会忽略到后面的线段重合，这个是个离散的逐点扫描的过程。\n\n\nimport heapqdef compute():    &quot;&quot;&quot;    # 时间复杂度：O(NlogN) ，n条线段，平均比较次数是logN，所以是O(NlogN)    # 空间复杂度：O(N)，因为需要存储每条线段的结束点&quot;&quot;&quot;    global size    size = 0  # 堆的清空        # 所有线段根据开始位置排序    sorted_lines = sorted(line[:n], key=lambda x: x[0])        ans = 0  # 最大重合数    for i in range(n):        # 步骤1：清理已结束的线段        while size &gt; 0 and heap[0] &lt;= sorted_lines[i][0]:            # 堆顶是最早结束的线段            # 如果它的结束点 ≤ 当前线段的起点，说明已经不重合了            pop()  # 移除这个已结束的线段                # 步骤2：加入当前线段        add(sorted_lines[i][1])  # 把当前线段的结束点加入堆                # 步骤3：更新答案        ans = max(ans, size)  # 当前堆的大小 = 当前重合的线段数        return ans\n\n算法可视化想象一根竖线从左到右扫过数轴：\n线段1: |-------|线段2:    |-----|线段3:      |---|线段4:        |-----|扫描过程：时刻1: |          重合数 = 1时刻2:   |        重合数 = 2  时刻3:     |      重合数 = 3 (最大值)时刻4:       |    重合数 = 2\n\n手写堆实现为了提高效率，使用数组实现小根堆：\nMAXN = 10001heap = [0] * MAXN  # 存储结束点size = 0def add(x):    global size    heap[size] = x    i = size    size += 1    # 上浮调整    while i &gt; 0 and heap[i] &lt; heap[(i - 1) // 2]:        swap(i, (i - 1) // 2)        i = (i - 1) // 2def pop():    global size    swap(0, size - 1)    size -= 1    i = 0    l = 1    # 下沉调整    while l &lt; size:        best = l + 1 if l + 1 &lt; size and heap[l + 1] &lt; heap[l] else l        best = best if heap[best] &lt; heap[i] else i        if best == i:            break        swap(i, best)        i = best        l = i * 2 + 1def swap(i, j):    heap[i], heap[j] = heap[j], heap[i]\n\n变种问题会议室问题def minMeetingRooms(meeting):    n = len(meeting)    meeting.sort(key=lambda x: x[0])  # 按起始时间排序    heap = []  # 小根堆，会议的结束时间    ans = 0        for i in range(n):        while heap and heap[0] &lt;= meeting[i][0]:  # 堆顶会议已结束            heapq.heappop(heap)        heapq.heappush(heap, meeting[i][1])      # 当前会议结束时间入堆        ans = max(ans, len(heap))                # 记录最大会议室数量        return ans\n\n分组问题def minGroups(meeting):    n = len(meeting)    meeting.sort(key=lambda x: x[0])    heap = []    ans = 0        for i in range(n):        while heap and heap[0] &lt; meeting[i][0]:  # 注意此处是 &lt;，题意不同            heapq.heappop(heap)        heapq.heappush(heap, meeting[i][1])        ans = max(ans, len(heap))        return ans\n\n关键区别：会议室问题用 &lt;=（会议可以无缝衔接），分组问题用 &lt;（需要间隔）。\n复杂度分析\n时间复杂度：O(N log N)，排序 + 每个元素平均 log N 次堆操作\n空间复杂度：O(N)，存储线段结束点的堆\n\n问题三：将数组和减半的最少操作次数测试链接：https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/\n问题描述给定一个数组，每次操作可以将任意一个元素减半，求使数组总和减少到原来一半所需的最少操作次数。\n算法思路使用贪心策略 + 大根堆：\n\n贪心原理：每次选择当前最大的元素进行减半，减少量最大\n堆维护：用大根堆维护当前所有元素\n操作过程：不断取出最大元素减半，直到总减少量达到目标\n\n方法一：基于 heapqimport heapqdef halveArray1(nums):    # 大根堆（用负数模拟）    heap = []    sum_val = 0        for num in nums:        heapq.heappush(heap, -float(num))  # 负数模拟大根堆        sum_val += num        sum_val /= 2  # 要减少到总和一半    ans = 0       # 操作次数    minus = 0     # 已减少的和        while minus &lt; sum_val:        cur = -heapq.heappop(heap) / 2  # 取出最大数、减半        heapq.heappush(heap, -cur)      # 新值放回堆        minus += cur                    # 记录减少量        ans += 1                        # 操作次数加1        return ans\n\n方法二：手写堆 + 精度优化MAXN = 100001heap_arr = [0] * MAXNsize = 0def halveArray2(nums):    global size    size = len(nums)    sum_val = 0        # 初始化大根堆，左移20位保证精度    for i in range(size - 1, -1, -1):        heap_arr[i] = int(nums[i]) &lt;&lt; 20  # 左移20位放大        sum_val += heap_arr[i]        heapify(i)  # 调整堆        sum_val //= 2  # 目标减少量    ans = 0    minus = 0        while minus &lt; sum_val:        heap_arr[0] //= 2    # 堆顶减半        minus += heap_arr[0]        heapify(0)        ans += 1        return ansdef heapify(i):    global size    l = i * 2 + 1    while l &lt; size:        best = l + 1 if l + 1 &lt; size and heap_arr[l + 1] &gt; heap_arr[l] else l        best = best if heap_arr[best] &gt; heap_arr[i] else i        if best == i:            break        swap(best, i)        i = best        l = i * 2 + 1def swap(i, j):    heap_arr[i], heap_arr[j] = heap_arr[j], heap_arr[i]\n\n关键优化技术精度处理问题：浮点数运算有精度损失，可能导致结果错误\n解决方案：\n\n将所有数左移20位（乘以 2²⁰）\n用整数运算模拟浮点数运算\nint(32位) × 2²⁰ &lt; long(64位)，不会溢出\n\n性能优化手写堆 vs heapq：\n\nheapq 基于 Python 列表，有额外开销\n手写数组堆效率更高，常数因子更小\n\n算法正确性证明贪心策略的正确性：\n\n每次选择最大元素减半，获得的减少量最大\n假设最优解不是每次选最大元素，可以证明交换操作不会使结果变差\n因此贪心策略能得到最优解\n\n复杂度分析\n时间复杂度：O(N log N)，每个元素最多被操作 log(max_value) 次。若傻傻地每个元素都缩1&#x2F;2，一定能达成目标；显然操作的元素个数一定小于n\n空间复杂度：O(N)，存储堆的空间\n\n堆结构应用总结适用场景\n\n\n问题类型\n堆类型\n核心思想\n典型例题\n\n\n\n合并有序序列\n小根堆\n维护多个序列的当前最小值\n合并K个有序链表\n\n\n区间重合问题\n小根堆\n扫描线 + 维护结束时间\n最多线段重合\n\n\n贪心选择\n大根堆\n每次选择当前最值进行操作\n数组和减半\n\n\nTop-K问题\n小根堆\n维护K个最大值\n第K大元素\n\n\n任务调度\n小根堆\n按优先级处理任务\nCPU任务调度\n\n\n实现选择\n\n\n情况\n推荐实现\n原因\n\n\n\n原型开发\nheapq\n简单易用，标准库\n\n\n性能要求高\n手写堆\n效率更高，常数因子小\n\n\n需要大根堆\n负数技巧\nPython只有小根堆\n\n\n精度要求高\n整数模拟\n避免浮点数误差\n\n\n常见陷阱\n对象比较问题：自定义对象作为堆元素时，需要实现比较方法或使用包装\n精度问题：浮点数运算可能有误差，关键场合使用整数\n堆类型混淆：Python默认小根堆，大根堆需要取负数\n边界条件：空堆操作、单元素情况需要特殊处理\n\n性能优化技巧\n预分配空间：手写堆时预分配数组空间\n避免频繁内存操作：使用数组而非动态列表\n批量操作：heapify 比逐个插入效率高\n精度与性能平衡：根据需求选择合适的数据类型\n\n堆结构是解决很多算法问题的重要工具，在实际使用中，要根据具体问题选择合适的实现方式和优化策略。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","哈希表","排序算法","堆结构","比较器","heapq模块"]},{"title":"数据结构与算法自学笔记（6）- 递归、归并排序与归并分治","url":"/2025/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-%20%E9%80%92%E5%BD%92%E4%B8%8Emaster%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3/","content":"参照的是左程云的课程：https://space.bilibili.com/8888480/lists/3509640?type=series  \n记录的是class020→class022，包括了递归的本质理解、Master公式的应用、归并排序的递归与非递归实现，以及归并分治思想在解决小和问题和翻转对问题中的应用。\n020【必备】递归和Master公式递归的本质理解思想层面的递归递归不是玄学，它是一种**”大事化小”**的思维方式。对于新手来说，画调用图是理解递归的关键。\ndef max_value(arr):    &#x27;&#x27;&#x27;给定一个数组，在arr[l...r]范围上，返回最大值&#x27;&#x27;&#x27;    return f(arr, 0, len(arr) - 1)def f(arr, l, r):    # arr[l...r] 范围上的最大值    if l == r:        # 递归基：当左右下标相等时，区间只有一个数，直接返回        return arr[l]    m = (l + r) // 2  # 找到中点    lmax = f(arr, l, m)        # 递归求左半部分最大值    rmax = f(arr, m + 1, r)    # 递归求右半部分最大值    return max(lmax, rmax)     # 返回左右部分的最大值\n\n递归的三个关键点：\n\n明确递归要干什么：这里是”返回 arr[l…r] 的最大值”\n找递归的终止条件：这里是”l &#x3D;&#x3D; r”，即区间只有一个数  \n思考如何缩小规模：这里是分别递归处理左区间和右区间\n\n实际层面的递归递归底层利用系统栈来实现：\n\n当函数调用发生时，系统会将函数的状态（参数、局部变量、返回地址）压入栈中\n当函数返回时，系统从栈中弹出状态，恢复到调用点继续执行\n这个过程是可视化的，所以所有递归函数都可以改成非递归\n\n递归改非递归的必要性：\n\n工程实践：几乎一定要改，除非确定递归深度不会太大\n算法竞赛：能通过就不改，时间紧迫时优先保证正确性\n\n形象比喻：\n\n迭代像是擂台赛：一个个来，逐步解决\n递归像是季后赛：分组对战，逐层淘汰\n\nMaster公式详解Master公式用于分析分治算法的时间复杂度，适用于所有子问题规模相同的递归。\n公式形式$$T(n) &#x3D; a \\times T(\\frac{n}{b}) + O(n^c)$$\n其中：\n\na：子问题被调用的次数\nb：子问题规模（数据量变为原来的1&#x2F;b）  \nc：除去子问题之外的时间复杂度指数\n\n判断标准设 $\\log_b(a) &#x3D; d$，则：\n\n\n\n条件\n时间复杂度\n说明\n\n\n\n$d &lt; c$\n$O(n^c)$\n合并工作量占主导\n\n\n$d &gt; c$\n$O(n^d)$\n递归调用占主导\n\n\n$d &#x3D; c$\n$O(n^c \\log n)$\n两者平衡\n\n\n经典例子分析# 归并排序：T(n) = 2*T(n/2) + O(n)# a=2, b=2, c=1# log₂(2) = 1 = c，所以复杂度为 O(n*logn)# 二分查找：T(n) = 1*T(n/2) + O(1)  # a=1, b=2, c=0# log₂(1) = 0 = c，所以复杂度为 O(logn)# 快速排序最好情况：T(n) = 2*T(n/2) + O(n)# 结果同归并排序：O(n*logn)\n\n特殊情况对于 $T(n) &#x3D; 2 \\times T(\\frac{n}{2}) + O(n \\log n)$：\n\n这不符合标准Master公式形式，结果是 $O(n \\times (\\log n)^2)$，需要特殊记忆，证明过程较复杂，这种递归式常见于“分治 + 合并时需要二分&#x2F;复杂统计”的问题，比如“翻转对”、“区间对统计”，主定理告知其复杂度为 $O(n \\log^2 n)$\n\n021【必备】归并排序归并排序原理核心思想\n左部分排好序、右部分排好序\n利用merge过程让左右整体有序\nmerge过程：谁小拷贝谁，直到左右两部分数字耗尽，拷贝回原数组\n\n为什么归并排序比O(n²)排序快？比较行为没有浪费！\n对比三种原始排序（选择、冒泡、插入）：\n\n每次1到N-1次比较只能确定一个位置\n大量比较工作被浪费，效率低下\n\n归并排序中：\n\n每次比较都有意义，用于合并两个有序序列\n比较结果被充分利用，没有浪费\n系统栈不会太深\n\n\n 测试链接 ：https://www.luogu.com.cn/problem/P1177\n递归实现MAXN = 100001arr = [0] * MAXN      # 原数组help_arr = [0] * MAXN # 辅助数组n = 0                 # 数组长度def mergeSort1(l, r):    &quot;&quot;&quot;    归并排序递归版    T(n) = 2 * T(n/2) + O(n)    根据master公式，时间复杂度O(n * logn)    空间复杂度O(n)    &quot;&quot;&quot;    if l == r:  # 递归终止条件：只剩一个元素        return    m = (l + r) // 2  # 计算中点    mergeSort1(l, m)      # 递归排序左半部分    mergeSort1(m + 1, r)  # 递归排序右半部分    merge(l, m, r)        # 合并def merge(l, m, r):    &quot;&quot;&quot;    合并两个有序区间 arr[l...m] 和 arr[m+1...r]    时间复杂度O(n)，其中n = r - l + 1    &quot;&quot;&quot;    i = l      # help数组写指针    a = l      # 左侧起始指针    b = m + 1  # 右侧起始指针        # 双指针合并过程    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]             b += 1        i += 1        # 处理剩余元素    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1            # 写回原数组    for i in range(l, r + 1):        arr[i] = help_arr[i]\n\n非递归实现def mergeSort2():    &quot;&quot;&quot;    归并排序非递归版    时间复杂度O(n * logn)：外层循环O(logn)，内层归并O(n)    空间复杂度O(n)    &quot;&quot;&quot;    global n    step = 1  # 步长初始化为1        while step &lt; n:  # 外层控制步长，共O(logn)次        l = 0  # 每轮从左端开始                while l &lt; n:  # 内层处理每一组            m = l + step - 1      # 计算中点            if m + 1 &gt;= n:        # 右半部分越界，跳出                break            r = min(l + (step &lt;&lt; 1) - 1, n - 1)  # 计算右边界            merge(l, m, r)        # 合并            l = r + 1             # 移动到下一组                    step &lt;&lt;= 1  # 步长翻倍\n\n非递归实现的核心思路\nstep表示每次要合并的有序段长度，初始为1（每个元素自己是有序段）\n每一轮成对合并长度为step的有序段，合并成长度为2*step的有序段\n下一轮step翻倍，继续两两合并\n重复直到step &gt;&#x3D; n，整个数组有序\n\n过程示例：\n原数组: [3, 8, 7, 6, 4, 5, 1, 2]step=1: [3,8] [6,7] [4,5] [1,2] → [3,8,6,7,4,5,1,2]step=2: [3,6,7,8] [1,2,4,5] → [3,6,7,8,1,2,4,5] step=4: [1,2,3,4,5,6,7,8] → [1,2,3,4,5,6,7,8]\n\nmerge过程详解双指针合并策略def merge(l, m, r):    &quot;&quot;&quot;    合并过程详解：    1. 双指针扫描：a指向左部分，b指向右部分    2. 比较合并：较小值写入help_arr，对应指针右移    3. 剩余处理：一边扫完后，另一边直接复制    4. 写回原数组：完成排序合并    &quot;&quot;&quot;    i = l      # help_arr写入位置    a = l      # 左部分起点    b = m + 1  # 右部分起点        # 两两比较，选择较小值    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]            b += 1        i += 1        # 处理剩余元素（必有一边先结束）    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1        # 拷贝回原数组    for idx in range(l, r + 1):        arr[idx] = help_arr[idx]\n\n复杂度分析时间复杂度：O(n log n)\n递归层数：log₂(n)层，每次将问题规模减半\n每层工作量：O(n)，所有元素都要参与一次合并\n总复杂度：O(n) × O(log n) &#x3D; O(n log n)\n\n空间复杂度：O(n)\n辅助数组：需要与原数组等长的help_arr\n递归栈：最大深度O(log n)，但主要空间开销是辅助数组\n原地归并：理论上可以做到O(1)空间，但时间复杂度会退化到O(n²)\n\n022【必备】归并分治归并分治的核心思想归并分治是在归并排序基础上的拓展，用来解决更复杂的问题。\n应用条件判断一个问题能用归并分治解决，需要满足：\n\n大范围答案 &#x3D; 左部分答案 + 右部分答案 + 跨越左右产生的答案\n计算”跨越左右产生的答案”时，左右各自有序能带来计算便利性\n如果以上两点成立，该问题很可能被归并分治解决\n\n求解过程：在归并排序过程中加入统计逻辑，利用左右有序的特性获得计算便利性。\n小和问题问题描述给定数组arr，对于每个位置i，求出其左边所有小于等于arr[i]的数的累加和，所有位置的累加和即为数组的”小和”。\n例子：\n数组: [1, 3, 5, 2, 4, 6]位置0(1): 左边小于等于1的数 → 0位置1(3): 左边小于等于3的数 → 1  位置2(5): 左边小于等于5的数 → 1+3 = 4位置3(2): 左边小于等于2的数 → 1位置4(4): 左边小于等于4的数 → 1+3+2 = 6位置5(6): 左边小于等于6的数 → 1+3+5+2+4 = 15小和 = 0+1+4+1+6+15 = 27\n\n\n\n 测试链接 ：https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469\n归并分治解法def smallSum(l, r):    &quot;&quot;&quot;    返回arr[l...r]范围上小和的累加和，同时让arr[l..r]变有序    时间复杂度O(n * logn)    &quot;&quot;&quot;    if l == r:        return 0    m = (l + r) // 2    # 递归统计左右部分和跨区部分的小和    return smallSum(l, m) + smallSum(m + 1, r) + merge(l, m, r)def merge(l, m, r):    &quot;&quot;&quot;    统计跨左右产生的小和，同时完成合并    &quot;&quot;&quot;    ans = 0        # 累计小和    i = l          # 左侧指针    sum_left = 0   # 累计左侧小于等于当前右侧元素的和        # 统计跨区贡献：对每个右侧元素，统计左侧贡献    for j in range(m + 1, r + 1):        # 左侧所有 &lt;= arr[j] 的元素都对arr[j]有贡献        while i &lt;= m and arr[i] &lt;= arr[j]:            sum_left += arr[i]  # 累加左侧贡献            i += 1        ans += sum_left  # arr[j]的左侧贡献总和        # 正常归并过程    i = l    a = l    b = m + 1    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]            b += 1        i += 1    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1    for idx in range(l, r + 1):        arr[idx] = help_arr[idx]        return ans\n\n算法关键思路为什么要在merge过程中统计？\n\n左右有序的便利性：因为左右都有序，可以用双指针线性扫描\n避免重复计算：每个跨区的小和贡献只需要计算一次\n时间复杂度优势：总体保持O(n log n)，而暴力解法是O(n²)\n\n核心技巧：\n\n对于右半部分的每个元素arr[j]，左半部分所有 ≤ arr[j] 的元素都会对小和产生贡献\n由于左半部分有序，可以用指针i从左向右扫描，累加贡献值\n指针i只会前进不会后退，总的扫描时间为O(n)\n\n翻转对问题问题描述给定数组nums，如果i&lt;j且nums[i]&gt;2*nums[j]，我们就将(i,j)称作一个重要翻转对。求数组中翻转对的总数量。\n例子：\n数组: [1,3,2,3,1]翻转对: (1,4)→3&gt;2*1, (3,4)→3&gt;2*1答案: 2\n 测试链接 ：https://leetcode.cn/problems/reverse-pairs/\n归并分治解法def reversePairs(arr):    &quot;&quot;&quot;统计翻转对的主函数&quot;&quot;&quot;    return counts(arr, 0, len(arr) - 1)def counts(arr, l, r):    &quot;&quot;&quot;    统计l...r范围上翻转对的数量，同时让l...r范围变有序    时间复杂度O(n * logn)    &quot;&quot;&quot;    if l == r:        return 0    m = (l + r) // 2    # 递归统计左右两边和跨区部分的翻转对数量    return counts(arr, l, m) + counts(arr, m + 1, r) + merge(arr, l, m, r)def merge(arr, l, m, r):    &quot;&quot;&quot;统计跨区翻转对并完成合并&quot;&quot;&quot;    ans = 0  # 翻转对计数    j = m + 1  # 右边数组起点        # 统计跨区翻转对    for i in range(l, m + 1):        # 找到右侧第一个不满足 arr[i] &gt; 2*arr[j] 的位置        while j &lt;= r and arr[i] &gt; 2 * arr[j]:            j += 1        # 当前i能形成的翻转对数量 = j - (m+1)        ans += j - m - 1        # 正常merge过程（与归并排序相同）    i = l    a = l    b = m + 1    while a &lt;= m and b &lt;= r:        if arr[a] &lt;= arr[b]:            help_arr[i] = arr[a]            a += 1        else:            help_arr[i] = arr[b]            b += 1        i += 1    while a &lt;= m:        help_arr[i] = arr[a]        a += 1        i += 1    while b &lt;= r:        help_arr[i] = arr[b]        b += 1        i += 1    for idx in range(l, r + 1):        arr[idx] = help_arr[idx]        return ans\n\n算法关键思路统计策略：\n\n利用左右部分独立有序：对于左半部分的每个元素arr[i]，在右半部分找到满足arr[i] &gt; 2*arr[j]的所有j\n指针单向移动：左右部分都是有序的，指针j只需要前进，不需要回退  \n计数技巧：当找到第一个不满足条件的j时，说明j前面的所有元素都满足条件\n\n时间复杂度分析：\n\n每个元素只会被访问一次，总的统计时间：O(n)，符合归并分治的要求\n\n归并分治总结适用问题特征\n可分解性：问题可以分解为左部分 + 右部分 + 跨区部分\n有序性便利：跨区部分的计算在左右有序时能够优化\n线性合并：跨区计算的时间复杂度为O(n)\n\n解题模板def divide_conquer(l, r):    if l == r:        return base_case        m = (l + r) // 2    left_ans = divide_conquer(l, m)    right_ans = divide_conquer(m + 1, r)    cross_ans = merge_and_count(l, m, r)  # 关键：统计跨区答案        return left_ans + right_ans + cross_ansdef merge_and_count(l, m, r):    # 1. 利用左右有序性，统计跨区答案    cross_count = 0    # ... 统计逻辑        # 2. 正常的归并排序merge过程    # ... 合并逻辑        return cross_count\n\n常见应用\n小和问题：统计左侧小于等于当前元素的累加和\n翻转对问题：统计满足特定大小关系的数对\n最近点对问题：二维空间中最近两点距离（高难度）\n逆序对问题：统计数组中的逆序对数量\n\n与其他算法的关系\n线段树：也可以解决类似问题，但常数因子可能更大\n树状数组：适合在线查询修改，离线场景下归并分治更简洁\n分块算法：另一种分治思想，将在后续课程中介绍\n\n归并分治是一种优雅而强大的算法思想，它将复杂问题通过分治和有序性的结合，优雅地降低了时间复杂度。掌握这种思想对于解决许多看似困难的问题都有很大帮助。\n","categories":["Notes","Algorithm"],"tags":["数据结构","Python","归并排序","递归","分治算法","Master公式"]},{"title":"25 Spring - 模式识别笔记(1)","url":"/2025/03/07/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/","content":"引言Word2Vec Embedding 技术Word2Vec 是一种用于将单词映射到向量空间的技术，通过训练语料库来学习单词的语义关系。核心思想是将单词转换为一个高维向量，使得语义相近的单词在向量空间中距离较近。\nWord2Vec 过程\n输入文本（例如：”我”、”是”、”中国”、”人民”）\n嵌入层（Embedding）：将单词转换为向量表示\n训练：使用 Skip-gram 或 CBOW 模型进行训练\n输出向量：得到语义空间中的词向量表示\n\n在黑板上的示例中，展示了单词如何通过 Word2Vec 进行向量化，并且最终映射到一个 n 维向量空间中。\n\nK-Means 聚类算法K-Means 是一种常见的无监督学习算法，主要用于数据聚类。其基本思想是：\n\n给定样本集合 $S$，包含样本 $S_1, S_2, \\dots, S_k$。\n设定 $k$ 个聚类中心 $C_1, C_2, \\dots, C_k$。\n将样本 $f$ 分配给最近的聚类中心 $C_k$。\n\n数学定义定义样本 $f$ 归属于最接近的簇：\n$$U_k^* &#x3D;\\begin{cases}1, &amp; f \\in S_k \\0, &amp; \\text{otherwise}\\end{cases}$$\n其中，样本 $f$ 的归属取决于其与聚类中心 $C_k$ 的欧式距离：\n$$| f - C_k |^2$$\n因此，每个样本都会归属于离它最近的簇。\nK-Means 迭代步骤\n随机初始化 $k$ 个聚类中心 $C_1, C_2, \\dots, C_k$。\n计算每个样本到聚类中心的距离，并将其分配到最近的簇。\n更新聚类中心，使其成为簇中所有样本的平均值。\n重复步骤 2 和 3，直到聚类中心不再发生变化或达到迭代次数上限。\n\n\n总结\nWord2Vec 将单词映射到向量空间，使语义相似的单词在向量空间中更接近。  \nK-Means 通过反复迭代，将数据点划分到不同的簇中进行聚类分析。\n\n这两者结合在自然语言处理 (NLP) 中可用于 文本分类、聚类分析 等任务。例如，先用 Word2Vec 将文本转换为向量，然后使用 K-Means 进行文本聚类。\nkmeans算法的定义独热编码（One-Hot Encoding）在 K-Means 聚类算法中，我们使用独热编码（One-Hot Encoding）来表示样本所属的类别：\n\n若样本 $f$ 属于第 $k$ 个簇，则其独热编码表示为\n$$\\mathbf{U}^* &#x3D; (0, 0, \\dots, 1, \\dots, 0)$$\n其中只有第 $k$ 维的值为 1，其余维度为 0。\n\n例如：\n\n若 $f \\in S_1$：$$\\mathbf{U}^* &#x3D; (1, 0, 0, \\dots, 0)$$\n若 $f \\in S_k$：$$\\mathbf{U}^* &#x3D; (0, 0, \\dots, 1, \\dots, 0)$$\n\n\n\n\nK-Means 目标函数在 K-Means 算法中，我们的目标是最小化样本点到其分配的聚类中心的距离平方和：\n$$\\mathbf{U}^* &#x3D; \\arg\\min_{\\mathbf{U} \\in \\mathcal{U}} \\sum_{k&#x3D;1}^{K}U_k (f - C_k)^2$$\n其中：\n\n$\\mathcal{U}$ 是所有可能的独热编码集合：\n\n  \n  $$\\mathcal{U} = \\left\\{ \\mathbf{u} = (U_1, U_2, \\dots, U_K) \\,\\middle|\\, \\sum_{k=1}^{K} U_k = 1, \\quad 0 \\leq U_k \\leq 1 \\right\\}$$\n\n  表示每个样本点只能属于一个簇。\n\n定理及其证明定理（Thm）对于任意样本 $f$ 和聚类中心 $C_1, C_2, \\dots, C_K$，定义：\n\n$$\nU_k^* =\n\\begin{cases} \n1, & k = \\arg\\min\\limits_{R=1,2,\\dots,K} (f - C_R)^2 \\\\\n0, & \\text{else}\n\\end{cases}\n$$\n\n\n即，样本 $f$ 应该被分配到使得 $(f - C_k)^2$（最小值唯一） 最小的簇 $C_k$。\n证明（Proof）\n定义\n$$m &#x3D; \\min_{k \\in {1,2,\\dots,K}} {(f - C_k)^2}$$\n由于 $U_k$ 是独热编码，所有可能的 $U_k$ 满足\n$$\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$$\n\n目标函数展开：\n$$\\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \\geq\\ \\sum_{k&#x3D;1}^{K} U_k \\cdot m$$\n由于 $\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1,$ 代入可得：\n$$\\sum_{k&#x3D;1}^{K} U_k (f - C_k)^2 \\geq m$$\n\n取 $U_k^*$ 使得 $k$ 取最小距离的索引，则：\n$$\\sum_{k&#x3D;1}^{K} U_k^* (f - C_k)^2 &#x3D; m.$$\n这说明只有当 $U_k^$ 取最优独热编码时，目标函数才能取到最小值 $m$ ，从而证明了 $U_k^$ 具有唯一最优解。\n\n\n\n结论\n独热编码 用于表示样本所属的类别，每个样本只能属于一个簇。  \n目标函数 通过最小化样本到其最近聚类中心的距离平方和，确定最优分类。  \n定理证明 说明了最佳分配方案是将样本分配到使得 $(f - C_k)^2$ 最小的簇。\n\n这一定理是 K-Means 算法的核心之一，保证了算法在每一步迭代中都能使目标函数收敛到一个局部最优解。\n–\n连续情况下的 K-Means 聚类定义在离散情况下，我们用有限个样本点 $f$ 进行聚类，而在连续情况下，需要对整个定义域 $\\Omega$ 进行考虑。\n目标函数扩展到连续情况\n设函数 $f: \\Omega \\to \\mathbb{R}$，其中 $\\Omega$ 是定义域，$f(x)$ 是定义在 $\\Omega$ 上的连续函数。  \n\n目标是在整个 $\\Omega$ 上最小化聚类误差：\n$$\\min_{\\mathbf{U}(x) \\in \\mathcal{U}} \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} U_k(x) (f(x) - C_k)^2$$\n其中：\n\n$C_1, C_2, \\dots, C_K$ 为 $K$ 个聚类中心。  \n$U_k(x)$ 表示位置 $x$ 归属于第 $k$ 个聚类中心的程度。\n\n\n\n\n约束条件为了保证每个点 $x$ 仅归属于一个聚类簇，引入约束：\n\n$$\n\\mathcal{U} = \\left\\{ \\mathbf{U}(x) = (U_1(x), U_2(x), \\dots, U_K(x)) \\,\\middle|\\, \\sum_{k=1}^{K} U_k(x) = 1, \\quad 0 \\leq U_k(x) \\leq 1, \\quad \\forall x \\in \\Omega \\right\\}\n$$\n\n\n\n这意味着：\n\n每个 $x$ 只能属于一个簇（即某个 $U_k(x)$ 取 1，其余取 0）。\n$U_k(x)$ 的取值范围在 $[0,1]$ 之间。\n\n\n直观解释从黑板上的示意图可以看出：\n\n$x \\in \\Omega$ 表示数据点在连续空间中的分布。\n$f(x)$ 代表数据点的特征值。\n目标是将这些数据点划分到不同的簇 $C_1, C_2, \\dots, C_K$ 中，使得同一簇中的点具有较小的方差。\n\n\n结论\n在连续情况下，K-Means 的目标函数和约束条件从离散样本点扩展到了整个定义域 $\\Omega$。  \n目标仍然是最小化数据点到聚类中心的平方误差。  \n约束条件确保每个点 $x$ 只能归属于一个簇。  \n这种扩展形式在实际应用中可用于处理连续空间中的数据，如图像分割或概率密度估计。\n\n\nK-Means 迭代优化过程K-Means 算法的目标是最小化聚类误差 $E(\\mathbf{U}, \\mathbf{C})$，即样本点到其聚类中心的平方误差和。它采用 迭代优化 的方式，在每次迭代中交替更新 簇分配 和 聚类中心，直到收敛。\n定义\n聚类中心向量：\n$$\\mathbf{C} &#x3D; (C_1, C_2, \\dots, C_K)^T.$$\n\nK-Means 的优化目标：\n$$\\min_{\\mathbf{U} \\in \\mathcal{U}, \\mathbf{C}} E(\\mathbf{U}, \\mathbf{C}).$$\n\n\nStep 1：更新簇分配 $\\mathbf{U}$$$\\mathbf{U}^{t+1} &#x3D; \\arg\\min_{\\mathbf{U} \\in \\mathcal{U}} E(\\mathbf{U}, \\mathbf{C}^t).$$\n其中，$U_k^{t+1}(x)$ 按照最近邻准则更新：\n\n$$\nU_k^{t+1}(x) =\n\\begin{cases}\n1, & k = \\arg\\min\\limits_{\\,k' \\in \\{1,2,\\dots,K\\}} \\bigl(f(x) - C_{k'}^t\\bigr)^2 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n\n\n即，将样本 $x$ 归到当前最近的聚类中心 $C_k^t$。\nStep 2：更新聚类中心 $\\mathbf{C}$$$\\mathbf{C}^{t+1} &#x3D; \\arg\\min_{\\mathbf{C}} E(\\mathbf{U}^{t+1}, \\mathbf{C}).$$\n聚类中心的更新公式：\n$$C_k &#x3D; \\frac{\\sum\\limits_{x \\in \\Omega} U_k^{t+1}(x) , f(x)}{|\\Omega_k|},$$\n其中：\n\n$\\Omega_k$ 是当前属于第 $k$ 个簇的所有样本点集合。\n上式表示：新的聚类中心是该簇内所有样本的加权平均值。\n也可以把$\\Omega_k$替换成$\\sum_{x \\in \\Omega} U_k^{t+1} (x) :&#x3D; \\Omega^{t+1}_{k}$\n\n总结\nStep 1：更新簇分配，使得每个点归属于与其最近的聚类中心。  \nStep 2：更新聚类中心，使其为簇内所有点的均值。  \n这两步交替进行，直到聚类中心不再变化，算法收敛。\n\n\n目标函数关于聚类中心的推导以下演示 Step 2（更新聚类中心）中，如何对目标函数关于聚类中心 $C_k$ 求导并得到更新公式。为简化，只对离散情形展示，连续情形可将求和替换为积分，思路相同。\n目标函数拆分K-Means 的目标函数（离散情形）：\n$$E(\\mathbf{U}, \\mathbf{C})&#x3D; \\sum_{k&#x3D;1}^{K} \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n我们先单独关注属于簇 $k$ 的部分：\n$$E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n在更新 $C_k$ 时，$U_k(x)$ 固定，只需对 $C_k$ 进行最优化。\n对 $C_k$ 求偏导令\n$$E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n对 $C_k$ 求导并令其为 0：\n$$\\frac{\\partial}{\\partial C_k} E_k(\\mathbf{U}, C_k)&#x3D; \\sum_{x \\in \\Omega} 2 U_k(x)  \\bigl(C_k - f(x)\\bigr).$$\n令其为 0，可得：\n$$\\sum_{x \\in \\Omega} U_k(x)\\bigl(C_k - f(x)\\bigr) &#x3D; 0$$\n解方程，得到更新公式整理可得：\n$$C_k \\sum_{x \\in \\Omega} U_k(x)&#x3D; \\sum_{x \\in \\Omega} U_k(x)f(x)$$\n若分母不为 0（该簇有样本），则\n$$C_k &#x3D; \\frac{\\sum\\limits_{x \\in \\Omega} U_k(x) f(x)}{\\sum\\limits_{x \\in \\Omega} U_k(x)}$$\n这就是 K-Means 中聚类中心的更新公式。在常见的离散数据立场下，上式意味着“该簇内所有样本特征的加权平均值”，权值由 $U_k(x)$ 决定。若 $U_k(x)$ 只取 0 或 1（硬划分），则退化为简单的算术平均。\n\n注：\n\n在连续情况下，将“求和”换为对 $\\Omega$ 的积分即可：\n$$C_k &#x3D; \\frac{\\int_{\\Omega} U_k(x)f(x)\\mathrm{d}x}{\\int_{\\Omega} U_k(x)\\mathrm{d}x}$$\n\n当 $U_k(x)$ 只取 0 或 1，即标准 K-Means，公式变为簇内样本的算术平均。\n\n\n\n\nK-Means 能量单调下降（不增）性以下笔记基于课堂板书，展示 K-Means 迭代过程中目标函数（也称“能量”或“误差”）如何在每一步都单调下降（或不增），从而收敛到局部最优解。\n引理 &#x2F; 定理描述\n定理：由 K-Means 算法产生的迭代序列 $(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)})$ 满足\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr),$$\n即每次迭代更新后，目标函数 $E(\\cdot)$ 不会增大，从而保证了算法的单调收敛性。\n\n目标函数回顾离散情形下的 K-Means 目标函数：\n$$E\\bigl(\\mathbf{u}, \\mathbf{c}\\bigr)&#x3D; \\sum_{k&#x3D;1}^{K} \\sum_{x \\in \\Omega}U_k(x)\\bigl(f(x) - C_k\\bigr)^2$$\n迭代过程（两步更新）\nStep 1：更新 $\\mathbf{u}^{(t+1)}$固定 $\\mathbf{c}^{(t)}$，令\n$$\\mathbf{u}^{(t+1)}&#x3D; \\arg\\min_{\\mathbf{u} \\in \\mathcal{U}}  E\\bigl(\\mathbf{u}, \\mathbf{c}^{(t)}\\bigr)$$\n由于独热编码的性质，每个样本 $x$ 归于距离最近的中心 $C_k^{(t)}$。这样得到\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr)$$\n\nStep 2：更新 $\\mathbf{c}^{(t+1)}$固定 $\\mathbf{u}^{(t+1)}$，令\n$$\\mathbf{c}^{(t+1)}&#x3D; \\arg\\min_{\\mathbf{c}}  E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}\\bigr).$$\n对每个 $C_k$ 求导并令其为 0，得到聚类中心是该簇内样本的加权平均。于是\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t)}\\bigr)$$\n\n\n能量严格下降的证明思路上两步结合，可得：\n$$E\\bigl(\\mathbf{u}^{(t+1)}, \\mathbf{c}^{(t+1)}\\bigr)\\leE\\bigl(\\mathbf{u}^{(t)}, \\mathbf{c}^{(t)}\\bigr)$$\n这说明每一轮迭代后，目标函数都会朝着不增的方向变化，从而收敛到某个局部最优或鞍点。\n结论\nK-Means 通过交替最小化簇分配 $\\mathbf{u}$ 和聚类中心 $\\mathbf{c}$，使目标函数在每次迭代中不增。  \n因此，算法单调地收敛到一个局部最优解（或鞍点）。\n\n这便是 K-Means 能量单调下降 的主要证明思路，也是该算法能保证在有限步内收敛的关键原因。\n","categories":["Notes","Course"],"tags":["机器学习","模式识别","K-Means聚类"]},{"title":"25 Spring - 模式识别笔记(2)","url":"/2025/05/10/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/","content":"模式识别笔记汇总本次笔记主要关于K-Means 及其变分问题、熵不等式、Softmax&#x2F;Softmin 函数、数值稳定化、以及泛函与方向导数等内容。\n\nK-Means 基本原理与能量函数K-Means 能量函数的定义K-Means 算法的能量函数（目标函数）定义如下：\n$$E(\\vec{U}, \\vec{C})&#x3D; \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} \\bigl(f(x) - C_k\\bigr)^2  U_k(x)$$\n其中：\n\n$ f(x) $ 表示数据点 $ x $ 的特征值；\n$ C_k $ 表示第 $ k $ 个聚类中心；\n$ U_k(x) $ 为归属矩阵的元素，表示数据点 $ x $ 是否属于第 $ k $ 个簇（在硬分类中，取值为 0 或 1）。\n\n然后定义\n$$\\langle \\overrightarrow{O}, \\overrightarrow{u} \\rangle &#x3D; \\sum_{x \\in \\Omega} \\sum_{k&#x3D;1}^{K} O_k(x) \\cdot u_k(x)$$\n其中误差函数为：\n$$O_k(x) &#x3D; \\bigl(f(x) - C_k\\bigr)^2$$\n该能量函数也可用内积的形式表示：\n$$E(\\vec{U}, \\vec{C}) &#x3D; \\langle \\vec{O}, \\vec{U} \\rangle$$\n其中 $\\vec{O}$ 为一个误差向量。\n\nK-Means 算法的迭代更新规则K-Means 算法通过两步交替迭代来最小化能量函数 $E(\\vec{U}, \\vec{C})$：\n\n更新归属矩阵 $\\vec{U}^{t+1}$：\n$$\\vec{U}^{t+1} &#x3D; \\arg \\min_{\\vec{U}}  E(\\vec{U}, \\vec{C}^t)$$\n具体到每个样本点 $x$ 的更新规则为：\n  \n   $$\n   U_k^{t+1}(x)= \n   \\begin{cases}\n   1, & \\text{if} k = \\arg \\min_{k \\in \\{1, \\dots, K\\}} (f(x) - C_k^t)^2 \\\\\n   0, & \\text{otherwise}\n   \\end{cases}\n   $$\n     \n\n即将每个数据点分配给距离其最近的簇中心。\n\n更新聚类中心 $\\vec{C}^{t+1}$：\n$$\\vec{C}^{t+1} &#x3D; \\arg \\min_{\\vec{C}}  E\\bigl(\\vec{U}^{t+1}, \\vec{C}\\bigr)$$\n即对每个簇的样本求均值，作为新的聚类中心。\n\n\n\n误差函数与误差向量定义误差函数：\n$$O_k(x) &#x3D; \\bigl(f(x) - C_k\\bigr)^2$$\n令\n$$\\vec{O}(x) &#x3D; \\bigl(O_1(x), O_2(x), \\dots, O_K(x)\\bigr)^\\mathsf{T},$$\n则 $\\vec{O}$ 是一个向量值函数，映射\n$$\\vec{O}: \\Omega \\subseteq \\mathbb{R}^2 \\to \\mathbb{R}^K.$$\n\n备注\nK-Means 采用硬聚类方式，每个数据点只能属于一个簇，$U_k(x) \\in {0,1}$。\n优化目标：在每次迭代中，先更新 $\\vec{U}$，再更新 $\\vec{C}$，直至收敛。\n计算复杂度：主要与数据点数 $N$ 和簇数 $K$ 有关，通常为 $O(NKT)$（$T$ 为迭代次数）。\n\n\nK-Means 的变分问题与熵的性质K-Means 变分问题我们希望最小化下述能量函数：\n$$\\min_{\\vec{U}, \\vec{C}} E(\\vec{U}, \\vec{C})$$\n其中 $\\vec{U}$ 为归属矩阵，$\\vec{C}$ 为聚类中心。\n除硬划分之外，还可使用许多优化或正则化技巧，例如引入软分类思想（softmax &#x2F; softmin）的方法。\n\n熵的性质在分析 K-Means 变分问题时，引入熵的一条不等式，用于约束归属矩阵的对数项：\n$$-\\ln K\\le \\langle \\vec{U}, \\ln \\vec{U} \\rangle\\le 0$$\n其中：\n\n$U_k$ 表示数据点对第 $k$ 个簇的归属概率（软分类时可在 $[0,1]$ 之间）；\n$\\langle \\vec{U}, \\ln \\vec{U}\\rangle &#x3D; \\sum_{k&#x3D;1}^{K} U_k \\ln U_k$ 是熵相关的项。\n\n该不等式可以用 Jensen 不等式等方法证明。等号成立的两种情况为：\n\n左边等号：所有 $U_k &#x3D; \\frac{1}{K}$，即均匀分布；\n右边等号：某一个 $U_k&#x3D;1$，其它为 0，即完全硬分类。\n\n\n变分方法的直观解释\n最优化角度：寻找最优的 $\\vec{U}, \\vec{C}$ 使得数据点与簇中心的总体误差最小；\n信息论角度：考虑信息熵约束，避免过度偏向某一簇，从而获得更合理的簇划分。\n\n\n备注\n熵的约束：对归属矩阵 $ \\vec{U} $ 提供了额外的正则约束。\n与 EM（期望最大化）算法中的软聚类思想存在对应关系。\n\n\n熵不等式的证明这里给出熵不等式：\n$$-\\ln K\\leq \\langle \\vec{U}, \\ln \\vec{U} \\rangle\\leq 0$$\n的推导思路详述如下：\n证明 $f(u)&#x3D;-\\ln u$ 是凸函数：函数 $f(u) &#x3D; -\\ln u$ 的一阶导数和二阶导数分别为：\n$$f’(u) &#x3D; -\\frac{1}{u},\\quadf’’(u) &#x3D; \\frac{1}{u^2} &gt; 0 \\quad (u&gt;0)$$\n由于 $f’’(u) &gt; 0$，可知 $f(u)$ 是凸函数。\n计算极限 $\\lim\\limits_{u\\to0^+} u \\ln u$：令 $g(u) &#x3D; -u \\ln u$，求其极限：\n$$\\lim_{u\\to0^+} u \\ln u &#x3D; \\lim_{u\\to0^+} \\frac{\\ln u}{1&#x2F;u}$$\n利用洛必达法则，分子求导得$1&#x2F;u$，分母求导得 $-1&#x2F;u^2$，因此：\n$$\\lim_{u\\to0^+} \\frac{\\ln u}{1&#x2F;u} &#x3D; \\lim_{u\\to0^+} \\frac{1&#x2F;u}{-1&#x2F;u^2} &#x3D; \\lim_{u\\to0^+} -u &#x3D; 0$$\n所以：\n$$\\lim_{u\\to0^+} u \\ln u &#x3D; 0.$$\n这表明当 $u \\to 0$ 时，$u \\ln u$ 趋于 0。\n用 Jensen 不等式推导熵不等式：由于 $f(x)&#x3D;-\\ln x$ 是凸函数，因此对于满足 $\\sum_{k&#x3D;1}^{K} \\alpha_k &#x3D; 1$ 且 $ 0 \\leq \\alpha_k \\leq 1$ 的权重  $\\alpha_{k} $ ，有：\n$$\\left( \\sum_{k&#x3D;1}^{K} \\alpha_k x_k \\right) \\leq \\sum_{k&#x3D;1}^{K} \\alpha_k f(x_k)$$\n取 $\\alpha_k &#x3D; U_k$，$x_k &#x3D; \\frac{1}{U_k}$，则：\n$$-ln \\left( \\sum_{k&#x3D;1}^{K} U_k \\cdot \\frac{1}{U_k} \\right) \\leq \\sum_{k&#x3D;1}^{K} U_k (-\\ln \\frac{1}{U_k})$$\n由于 $\\sum_{k&#x3D;1}^{K} U_k &#x3D; 1$，所以：\n$$-ln K \\leq \\sum_{k&#x3D;1}^{K} U_k \\ln U_k \\leq 0$$\n即\n$$ln K \\geq -\\langle \\vec{U}, \\ln \\vec{U} \\rangle$$\n等号成立的条件：\n左边等号成立条件：当所有 $U_k$ 相等，即 $U_k &#x3D; 1&#x2F;K$ 时，左侧等号成立。\n右边等号成立条件：当仅有一个 $U_k&#x3D;1$，其余 $U_k&#x3D;0$ 时，右侧等号成立。\n\n熵不等式在 K-Means 变分问题中的作用：该不等式用于限制聚类的过度集中，即防止所有数据点都归属于同一簇。同时，它也鼓励一定程度的分散度，使簇划分更加均匀，从而优化聚类效果。\n\nK-Means 的变分问题扩展在传统 K-Means 的能量函数 $E(\\vec{U}, \\vec{C})$ 基础上，引入一项基于熵的正则化：\n$$\\min_{\\vec{u}\\in U}\\Bigl[E(\\vec{u}, \\vec{C})+\\varepsilon \\langle \\vec{u}, \\ln \\vec{u}\\rangle\\Bigr]$$\n其中 $\\varepsilon &gt; 0$ 为权衡系数（正则化参数）。当 $\\varepsilon \\to 0$ 时，该模型接近传统 K-Means 硬分类；当 $\\varepsilon$ 较大时，模型更倾向于软聚类。\n更新过程：\n\n$\\vec{u}^{t+1} &#x3D; \\arg \\min_{\\vec{u}} \\bigl[E(\\vec{u}, \\vec{C}^t) - \\varepsilon H(\\vec{u})\\bigr]$ (变成了严格凸)\n$\\vec{C}^{t+1} &#x3D; \\arg \\min_{\\vec{C}} \\bigl[E(\\vec{u}^{t+1}, \\vec{C})\\bigr]$  （与传统 K-Means 相同）\n\n这里的熵项\n$$H(\\vec{u})&#x3D; - \\sum_{k&#x3D;1}^{K} \\sum_{x\\in \\Omega} u_k(x)\\ln u_k(x)$$\n作为“软化”或正则化手段，避免完全的 0-1 硬分类。\n偏导数计算熵项 $H(\\vec{u})$ 可重写为\n$$ -H(\\vec{u}) &#x3D; \\langle \\vec{u}, \\ln \\vec{u} \\rangle.$$\n对于目标函数 $E(\\vec{u}, \\vec{C}) - \\varepsilon H(\\vec{u})$，计算其关于 $u_k$ 的偏导数：\n\n设 $E(\\vec{u}, \\vec{C})$ 关于 $u_k$ 的偏导数为：\n$$\\frac{\\delta E}{\\delta u_k} &#x3D; O_k$$\n\n对于熵项：\n$$\\frac{\\delta (-H)}{\\delta u_k} &#x3D; \\ln u_k + 1$$\n\n结合上述结果，求解极值条件：\n$$O_k - \\varepsilon (\\ln u_k + 1) &#x3D; 0$$\n\n化简得：\n$$u_k &#x3D; \\exp\\left(-\\frac{O_k}{\\varepsilon} - 1\\right)$$\n\n\n这表明更新 $u_k$ 时，其值受 $\\varepsilon$ 控制，较大的 $\\varepsilon$ 使得 $u_k$ 更加平滑，有助于软聚类。\n\n拉格朗日函数与 Softmax 分析拉格朗日函数定义拉格朗日函数：\n$$\\mathcal{L}(\\vec{u}, \\lambda)&#x3D; E(\\vec{u}, \\vec{c})-\\varepsilon H(\\vec{u})+\\sum_{x \\in \\Omega} \\lambda(x)\\Bigl(\\sum_{k&#x3D;1}^{K} u_k(x)-1\\Bigr)$$\n其中：\n\n$H(\\vec{u})$ 是熵项；\n$\\lambda(x)$ 为拉格朗日乘子，用于保证 $\\sum_{k&#x3D;1}^{K} u_k(x)&#x3D;1$。\n\n软分类 (Softmin &#x2F; Softmax) 的推导对 $\\mathcal{L}(\\vec{u}, \\lambda)$ 关于 $u_k$ 取偏导为 0，可得到：\n$$\\ln u_k(x)&#x3D; -\\frac{O_k(x) +\\lambda(x)}{\\varepsilon}$$\n其中 $O_k$ 是某类损失（例如 $(f(x)-C_k)^2$ ）或能量。\n结合约束 $\\sum_{k&#x3D;1}^K u_k(x)&#x3D;1$，可得Softmin形式：\n$$u_k^{t+1}(x)&#x3D; \\frac{\\exp\\Bigl(\\dfrac{-O_k(x)}{\\varepsilon}\\Bigr)}{\\sum_{j&#x3D;1}^{K} \\exp\\Bigl(\\dfrac{-O_j(x)}{\\varepsilon}\\Bigr)}$$\n也可写成softmax形式：\n  \n$$\n\\text{Softmax}_{\\varepsilon}(-\\vec{O}) =\n\\left[\\text{Softmin}_{\\varepsilon}(\\vec{O})\\right]_k\n$$\n  \n\n\n极限问题与分母拆分k-means 硬分类更新公式当不考虑熵正则化时，k-means 的硬分类可写为：\n$$u_k^{t+1}(x) &#x3D;\\begin{cases}    1, &amp; \\text{if } k &#x3D; \\arg \\min_{k \\in {1, \\dots, K}} O_k, \\    0, &amp; \\text{otherwise}.\\end{cases}$$\nSoftmin 的极限考虑\n\n$$\n\\lim_{\\varepsilon \\to 0^+}\n\\frac{\\exp\\bigl(-O_k(x)/\\varepsilon\\bigr)}{\\sum_{j=1}^K \\exp\\bigl(-O_j(x)/\\varepsilon\\bigr)}\n=\\lim_{\\varepsilon \\to 0^+}\\frac{\\exp\\bigl(-O_k(x)+m(x)/\\varepsilon\\bigr)}{\\sum_{j\\in M} \\exp\\bigl(-O_j(x)+m(x)/\\varepsilon\\bigr)+\\sum_{j\\notin M} \\exp\\bigl(-O_j(x)+m(x)/\\varepsilon\\bigr)}\n$$\n\n\n令 $m = \\min \\bigl\\{ O_1(x), O_2(x), \\dots, O_K(x) \\bigr\\}, \\quad M = \\arg\\min_{k \\in \\bigl\\{ 1, \\dots, K \\bigr\\}} O_k(x)$。当 $\\varepsilon \\to 0^+$，对于属于最优集 $M$ 的索引 $k$，$\\exp(-O_k&#x2F;\\varepsilon)$ 主导；而不是最优集的 $\\exp(-O_k&#x2F;\\varepsilon)$ 迅速衰减为 0。因此极限结果为：\n\n$$\n\\lim_{\\varepsilon \\to 0^+}\n\\text{Softmin}_{\\varepsilon}(\\vec{O})\n=\n\\begin{cases}\n1, & \\text{if } k \\in M \\\\\n0, & \\text{if } k \\notin M\n\\end{cases}\n\\quad \\text{where } M = \\left\\{ k \\mid O_k = \\min_j O_j \\right\\}\n$$\n\n\n这与 k-means 硬分类（一次只属于距离最近的簇）相一致。称   $\\min_{\\vec{u}\\in U，\\vec{C}}\\Bigl[E(\\vec{u}, \\vec{C})-\\varepsilon H(u)\\Bigr]$   为softmin&#x2F;softmax的分类的变分优化问题k-means 的光滑化与 Softmax 溢出问题k-means 的光滑化通过在 k-means 能量函数中加入熵项并令 $\\varepsilon&gt;0$，可以将硬分类变为软分类，使其输出变得连续可导。\n\n当 $\\varepsilon \\to 0$，Softmin 退化为 k-means 硬分类；\n当 $\\varepsilon$ 较大时，软分类更加显著。\n\nSoftmax 的数值溢出问题Softmax 标准形式：\n  \n$$\n\\text{Softmax}\\bigl(\\vec{O}\\bigr)_k\n=\n\\frac{e^{O_k}}{\\sum_{j=1}^K e^{O_j}}.\n$$\n  \n\n若 $O_k$ 值过大，$e^{O_k}$ 可能数值溢出。\n解决方案：数值稳定化取   $\\displaystyle M = \\max\\{O_1, O_2, \\dots, O_K\\}$  ，将所有项减去 $M$：\n  \n$$\n\\text{Softmax}(\\vec{O})_k\n=\n\\frac{e^{O_k - M}}{\\sum_{j=1}^K e^{O_j - M}}\n$$\n\n\n这样可防止溢出，保持结果不变。\n\n泛函分析与方向导数泛函与方向导数基本概念在更高层次，令\n  \n$$\nJ: \\mathcal{F} \\to \\mathbb{R}\n$$\n  \n\n是作用于函数空间 $\\mathcal{F}$ 的一个泛函（functional）。对于 $u(x)$ 的变化，可以定义方向导数：\n  \n$$\n\\lim_{h \\to 0}\n\\frac{J\\bigl(x + hv\\bigr) - J(x)}{h}\n=\n\\left.\n\\frac{d}{dh} \nJ\\bigl(x + hv\\bigr)\n\\right|_{h=0}\n$$\n  \n\n方向导数与梯度存在对应关系：若把 $\\nabla J&#x3D;(\\tfrac{\\delta J}{\\delta x_1}，\\tfrac{\\delta J}{\\delta x_2} \\cdot \\cdot \\cdot \\tfrac{\\delta J}{\\delta x_n})$ 类比于有限维中的梯度，则方向导数可理解为梯度在 $v$ 方向的投影。\n\n方向导数与梯度的关系对 $J(U_k)$ 做微分：\n  \n$$\n\\langle \\tfrac{\\delta J}{\\delta U_k},  V_k \\rangle\n=\n\\left.\n\\tfrac{d}{dh}\nJ\\bigl(U_k + hV_k\\bigr)\n\\right|_{h=0}.\n$$\n  \n\n例如，若\n  \n$$\nJ(U_k)\n=\n\\sum_{x\\in \\Omega}\nO_k(x)\\ln U_k(x),\n$$\n  \n\n则\n  \n$$\nJ(U_k + hV_k)\n=\n\\sum_{x\\in \\Omega}\nO_k(x)\\ln\\bigl(U_k(x) + hV_k(x)\\bigr)\n$$\n  \n\n对其在 $h&#x3D;0$ 处求导，可得到对应的偏导，从而确定梯度形式。\n\n九、总结与要点\nK-Means 算法\n\n能量函数：数据点到簇中心的平方误差和；\n经典迭代：硬分类与均值更新交替进行。\n\n\nK-Means 的变分扩展\n\n通过引入熵（软分类），可得到 Softmin &#x2F; Softmax 形式；\n当正则系数 $\\varepsilon \\to 0$ 时，又可退化到原始硬划分结果。\n\n\n熵不等式与数值稳定\n\n熵提供了在聚类中的分布约束；\nSoftmax 需用数值移位避免溢出。\n\n\n泛函与方向导数\n\n在更高阶场景中，可将 K-Means 问题放到泛函分析框架下；\n方向导数、梯度概念可帮助理解对函数空间的优化。\n\n\n\n","categories":["Notes","Course"],"tags":["模式识别","K-Means聚类","熵不等式","变分法"]},{"title":"25 Spring - 模式识别笔记(3)","url":"/2025/06/16/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲前三个part，符号源于课程讲义，整理了关于K-means 聚类及其变分表达、熵正则与空间正则的相关笔记。用markdown在网页上做笔记还是太费劲了，回归latex！\nPDF file","categories":["Notes","Course"],"tags":["模式识别","K-Means聚类","变分法","熵正则","空间正则"]},{"title":"25 Spring - 模式识别笔记(4)","url":"/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲第四个和第五个part，符号源于课程讲义，整理了关于混合模型分类（GMM），EM算法及其变分表示以及MM算法的相关笔记。\nPDF file","categories":["Notes","Course"],"tags":["模式识别","变分法","GMM算法","MM算法"]},{"title":"25 Spring - 模式识别笔记(5)","url":"/2025/06/17/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/","content":"模式识别期末笔记基于模式识别期末考纲最后一个part，符号源于课程讲义，整理了关于MLP及其网络训练、反向传播算法的相关笔记。\nPDF file","categories":["Notes","Course"],"tags":["模式识别","神经网络","MLP","反向传播算法"]}]